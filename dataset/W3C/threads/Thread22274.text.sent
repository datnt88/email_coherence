I don't know how to subscribe to this mailing list. 
But I have a comment to DOM Level 1. 
I think that the interface DocumentType should have a method which returns default value of a attribute, like DOMString getDefaultAttribute(in DOMString element_name, in DOMString attribute_name); "Fundamental Interfaces" does not include DocumentType. 
But the method getAttribute of Element should search DTD for default value. 
Implementators of Fundamental Interfaces who don't care about the structure of DocumentType could call such method if doctype of Document is not null. 
I am developping my own DOM in Perl, then I noticed it. 
// (UENO Kojun) / k.ueno@psynet.net, 
kojun@ann.ne.jp / I posted the following on the DOM IG's mailing list a while back. 
I think it covers most of the things that the DocumentType has to tell us. 
I've tried to generalize from DTDs so it can also support DCD, and maybe other schema proposals. 
I haven't yet compared it to the draft that Arnaud has made available, and it may be missing needed features; if you see a mistake, please say so! DocumentType has to be able to tell us: a) The type(s) of the acceptable Root element(s). 
Some of the schema designs allow more than one valid choice (to avoid the need for a functionless wrapper element). 
b) The type(s) and sequence(s) of children that each kind of element will permit. 
To insulate us from possible variation in how these rules are expressed in the schema langauges, I'd suggest making this a query that asks "If I was to do nodeX.insertBefore(nodeY,nodeZ), where X and Z are known, what types of nodes would be permitted as Y?" Note that I'm only suggesting checking the structure upward and backward from this point, not the following nodes, since a legal may require insertion of several nodes before Z rather than just one. 
c) The type(s) of attributes that each type of element will permit/require, together with acceptable values and default and so on. 
Note that in some schema languages, this depends on the context in which the element appears, so we may have to pass in a specific element, in context, rather than just an element's nodename. 
d) Whether a node's contents are valid, given the rules used above. 
This could be more tightly optimized than checking the single-node calls repeatedly. 
This is the real validation test; the preceeding two are primarily provided for directed editing. 
The application would decide whether it wants to check each node as it's built or defer that to a go/no-go test on larger chunks of the document; this may mean the validate call should be able to operate either as a shallow check (if the tree is being checked bottom-up) or as a deep tree-walk (if an entire subtree is to be validated at once). 
Failure might return the first node that isn't acceptable where it stands. 
That isn't necessarily the point of error, but it's probably the best we can do to help the user find the problem. 
e) Entity and Notation information is already covered by the Level 1 API. 
I'm not wild about the way in which they're handled -- I'd rather have a get-by-name query against the DocumentType itself rather than retrieving the NamedNodeMap and then querying that, especially since some schema proposals may have to gather data from several document descriptions -- but it's workable. 
There may be some details that have to be filled in; I haven't used either Entities or Notations enough to be sure about that. 
Joe Kesselman / IBM Research Unless stated otherwise, all opinions are solely those of the author. 
This is a very interesting document indeed! 
One simplification: It's not clear that such a list is easy to compute. 
I would rather make the legal element types known, and then simply ask: is this type a legal predecessor of existing node Z? (X is just Z.getParent()). 
John Cowanhttp://www.ccil.org/~cowancowan@ccil.org 
You tollerday donsk? 
N. 
You tolkatiff scowegian? 
Nn. 
You spigotty anglease? 
Nnn. 
You phonio saxo? 
Nnnn. 
Clear all so! 'Tis a Jute.... (Finnegans Wake 16.5) Now I am a member of this list. 
Supporting query method is kind to the users, but a burden to the implementation. 
Exposing attributes, the opposite, in some sense. 
I don't know which is important. 
But in case of fetching default value from DTD, a query procedure must be written AFTER ALL for Element- getAtribute. 
DocumentType, Attr or Element should contain such procedure. 
I think DocumentType is most reasonable. 
// UENO Kojun / k.ueno@psynet.net, 
kojun@ann.ne.jp / wouldn't the follow-on states be easier to compute and just as useful? 
i would not expect, in the context of editing, to need an interface which allowed more specificity than "shallow" v/s "entire document". 
since the context models are context-free, only a shallow test on the immediate content set is strictly necessary to edit. 
were one to wished to defer validation, i'd be surprised if the editing user were able to control more than three modes: the element i just edited, all changed elements, the entire document. 
an option such as "the trees (with depth n) starting from all changed elements" would be seldom used and produce results which would be hard to use. 
will I think my version is essentially your two stages combined, with the second used to filter the first. 
That filtered list is a good basis for content-directed editing. 
Of course, the filtering could be done in user code rather than the DOM, but I think moving it into the DOM would generally produce a significantly more efficient implementation. 
Joe Kesselman / IBM Research Unless stated otherwise, all opinions are solely those of the author. 
