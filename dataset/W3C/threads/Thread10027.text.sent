I indicated last week my intention that the WG should decide on the semantics of non-datatyped, i.e. old style, literals, at this weeks telecon. 
I ask for the WG's support in keeping to that schedule. 
The decision we have to make is to choose whether literals of the form: have tidy or untidy semantics, or indeed whether we are not saying one way or the other. 
Note: I like the terms introduced by Patrick, "value based semantics" and "string based semantics". 
This debate has raged for many months, with committed proponents of each position arguing at length and failing to convince each other. 
After all this, I think we have to conclude that we have failed to find a decisive flaw or advantage in either approach. 
We have, in fact, to assume that we have two self consistent positions and we must make a choice between them, or choose not to decide. 
I think it is the role of the chair to assist the WG to reach a decision. 
We have been stuck on this for ages. 
In the light of this, I am going to introduce a bias in the way I frame the decision. 
I note that all of the implementations of RDF with which I am familiar have implemented M&amp;S with the assumption that literals have string semantics, i.e. literal("foo").equals(literal("foo")). 
Our charter is to clarify M&amp;S, not to go rewriting it. 
We have in the past allowed ourselves some leeway in this regard, but we have set the bar higher for justifying a "change" than for more straight forward clarifications. 
If we are going to ask implementations to change to remain conformant, I suggest the WG has a duty to justify that decision. 
There must be a strong and clear benefit from such a change and it must be one we can clearly articulate to the developer community and expect them to support. 
The issue here is not whether the developer community is willing to change. 
I expect the Jena team will implement what the WG decides as no doubt will others. 
But if the WG are going to ask folks to spend time and money making these changes, it ought to have a good reason for doing so. 
I am suggesting therefore that the default decision is that non-datatyped literals have string based semantics (tidy) unless there is good reason to change. 
I invite those who advocate value based semantics (untidy) to advance a rationale for such a change and we will determine at Fridays telecon whether this convinces the WG. 
I suggest that we have debated this issue to death and that further debate is pointless. 
We are at the stage where we need to summarize the argument and have the WG decide whether it finds it convincing. 
As chair, I could try that summary myself, but I have decided that it would be best done by the advocates themselves, though I'll try to help out if it looks like that would be useful. 
Brian ps: summaries are short and clear I read M&amp;S as merely articulating syntactic facts, and hence reflecting a syntactically tidy graph; this does not preclude semantic untidiness. 
I prefer the option of "not deciding". 
I could live with any of the options. 
Syntactically tidy, (possibly) value based semantics, and valentines day MT. For details see below. 
(Or, PROS: - does not require changes to preexisting implementations: equals is taken as syntactic - does not preclude the "10" in Jenny age "10" from meaning the integer ten. 
- could support rdfs:range="xsd:int" construction - could support tidiness - does not fly in the face of the community feedback. 
CONS: - somewhat contorted (the divergence between syntax and semantics may confuse) - stresses further the separation of the abstract graph syntax (the Model in M&amp;S) and the interpretation (the Model in the MT) [we already have this with our decision on datatypes of last Friday, see below for example] Specifically: - the graph is syntactically tidy - the interpretation of a typed literal is given by its datatype - the interpretation of a triple with an untyped literal has an extra level of indirection (semantically untidy, the interpretation of the literal in the triple depends on the property, and maybe the subject too) - otherwise, and in general terms, the model thoery follows the valentines day approach, which does not permit bnodes to match literals in entailments, and hence the decisive questions cannot be asked. 
As an implementator I would expect to implement two equivalence relationships over graph nodes. 
equals() would reflect syntactic equality, and sameValueAs() would reflect semantic equality: e.g. not equals( literal(" xsd:int 010"), literal(" xsd:decimal 10.0") ) but sameValueAs( literal(" xsd:int 010"), literal(" xsd:decimal 10.0") ) and n = literal("untyped") equals( n, n ) but not sameValueAs( n, n ) (I might prefer not to have sameValueAs defined over literal nodes, but only over triples). 
This does not require implementations to change; clarifies how to implement RDFS; is somewhat contorted; and is a bit of a fudge. 
A modification to this, would be to explicitly support [p rdfs:range datatype ] in it, in which case it is untidy. 
My weak preference is to not require that there are any literals which do not have tidy semantics. 
(i.e. exactly the valentines day mt position; the machinery of untidiness is presented, but no commitment to actually use it!) Jeremy PS: At the Bristol F2F Guha talked about the mapping of the literal node depending on either: - only the literal - the literal and the property - the literal, the property and the subject I can't remember whether any crucial showstoppers were identified to any of these. 
I remember that rdf:object was a little disappointing with the middle one. 
(And I think only the last made me feel alright about dc:Creator, but then I'm out on limb with dc). 
My perception is this: M&amp;S is not clear, so neither choice is a *change* to M&amp;S. 
Value based semantics: corresponds to the readings of M&amp;S by those doing "information design" (e.g. CC/PP, DC, etc.) String based semantics: corresponds to the readings of M&amp;S by those doing software implementations (e.g. cwm, Jena, etc.) Thus, whatever choice me make, it will break *someone's* code and/or data. 
I favour value-based semantics, because I think this more closely matches the intuitions that are invoked when populating the semantic web, which I think will, in the longer run, be the biggest task. 
But (given datatyped literals) I think either approach can work. 
#g Graham Klyne 
