DOM XPath module last call issue b5 was about the descrepancy between DOM ownerElement and XPath parent attributes in the new XPathNamespace node. 
The resolution of this issue is that the new DOM interface is being consistent with existing DOM interfaces as well as the infoset, which does not provide a parent of the XPathNamespace node. 
The writers of the XPath spec forced this incompatibility, producing a parent of a node of which the node was not a child. 
No change is desired in the DOM data structures, because it would be inconsistent with other DOM interfaces and the mapping of the infoset to those interfaces. 
See the issues list for more complete information at Please let us know if you are, or are not, satisfied with this resolution. 
Ray Whitmer W3C DOM WG Chair rayw@netscape.com 
Alternative suggestion: There had been discussion of moving the ownerElement attribute back into Node, to make it a general equivalent of XPath's concept of parent, saving them the coding hassle of (node.getType()==Node.ATTR_NODE) ? 
node.getOwnerElement() : node.getParent() and making the relationship between the DOM and XPath views somewhat more straightforward. 
This would also have to skip past EntityReference nodes, since those don't exist in the XPath model; I don't remember any other complications but it's been a while since I've looked at it. 
Relatively simple architectural change, non-breaking, should be low impact on implementers and it'd close this issue in a manner which (I think) the XPath folks would actually be happy with rather than tolerant of. 
Has this been considered and voted down, or did it simply fall through the cracks? 
Joe Kesselman / IBM Research 
I do not recall such a discussion. 
This would be a core issue. 
In practice, it doesn't seem to me to be a big hassle anyway, since most 
normal applications know if they have an attribute node to start with before asking for the parent or owner element, and it is no problem for 
the XPath implementation to do the above a few times and heavy XPath users can just use expressions to get the behavior. 
In DOM, there are additional cases, such as attributes which have text nodes underneath them. 
The parent of the text node is clearly the 
attribute so the model breaks down even though an XPath user would probably never get to that particular text node. 
As this was not the only comment we got suggesting that Node attributes should match XPath instead of the established DOM- infoset mapping (for example prefix, namespaceURI, etc.), the impression I get from this sort 
of thing is that they think that the parent attribute of an attribute should be the element, even though it is not a child of element and they 
consider it a matter of using the "right" names to avoid confusion for XPath users. 
It will obviously not solve the fact that we do not consider the element the parent of it's attributes or call it that, which was established in DOM Level 1 long before XPath. 
Can you perhaps make a stronger argument? 
I am not well-enough convinced that this proposal significantly helps anyone. 
Perhaps if it solved more problems... entity reference skipping seems like another side benefit. 
The root node would have to have no owner 
element, etc. as this would be the closest ancestor that was an element... Ray Whitmer rayw@netscape.com 
On Thursday, 09/05/2002 at 12:45 MST, rayw@netscape.com (Ray Whitmer) 
If I'm not dreaming, this was brought up fairly early in DOM L3 discussions as a "did we miss an obvious opportunity by being overspecific" question. 
Feel free to blame me for the fact that it isn't in the Open Issues List. 
Or someone may have come up with a killer objection -- but I honestly don't remember hearing one. 
(Might be time to check the archives/minutes for past discussion; searching for ownerElement ought to find it...) 
Granted, but it would be intended to ease XPath/XSLT/XQuery implementation. 
It isn't _big_. 
But it also isn't hard, and it would help address the ongoing accusations I hear that the W3C seems to be scattering away from the Infoset rather than finding ways to come back to it. 
Call it a convenience function if you like, but one which does permit some optimization of that operation... which is a category the DOM has been willing to consider in the past. 
As you said: Most. 
Some don't. 
XPath is an example of one that may not, except by explicitly testing the node type. 
Yes, they can do so. 
Is there a Good Reason we shouldn't reduce the need to do so? 
Remember that I suggested only generalizing ownerElement. 
If that's defined as "move up to the nearest enclosing element", it works fine for XPath and may be useful for others. 
That would also address the case of a Text node within an EntityReference within an Element -- skipping the EntRef and going to the Element would match XPath's desired behavior. 
(And illustrates another place where this convenience would add value.) 
The parent of the text node is clearly the attribute 
Not in the XPath view. 
There, attrs don't have children; they carry text directly. 
Hence, in that environment going from the text (which is "part of the attr") to the Element is entirely reasonable. 
Again, remember that I specifically suggested moving getOwnerElement back to Node. 
That's a clearly defined behavior. 
If it isn't one _you_ want to use in your apps, that's fine... but I think it really would be a step back toward making these two views of the Infoset consistant, and thus is a Good Thing for the W3C architecturally. 
It doesn't address the terminology problem, but at least it provides a very direct mapping. 
I'm trying to take us a step away from arguing about the use of the specific term "parent" -- which is now unchangable, as are some of our own past mistakes -- and focus on functionality, as I now wish we had when this issue first came up. 
(Hindsight is always 20:20...) If they can say "what we call parent, the DOM calls ownerElement" for all of their nodes, the fact that they use a different term for the same concept is annoying but reduced to the level of a documentation problem rather than persisting as a genuine architectural divergence. 
Sorry; that was my intent, as mentioned above. 
I should have stated that more explicitly. 
The root node would have to have no owner element 
Agreed. Joe Kesselman / IBM Research 
I am certainly happy to discuss this and see where it goes. 
I see merit in it. 
I suspect, as I said previously, that it will not answer the question being asked in B5 or others who think it should be called parent. 
One problem that limits the usefulness is the lack of a similar accessor in the Traversal module on the Treewalker interface, which may be used 
to process the result of the XPath query, especially where a EntityReferences may be present. 
Ray Whitmer rayw@netscape.com 
Granted, unless we want to add getOwnerElement there as well. 
BUT: I'm not convinced that this is a killer. 
We aren't claiming that the Traverser presents the XPath view, right? 
Note that you said 
especially where a EntityReferences may be present 
which is something the traverser could support trivially by setting whatToShow to exclude EntRef nodes. 
If we haven't already made that effort (not to mention filtering text-node-not-first-in-sequence), then Traverser.getOwnerElement by itself isn't a make-or-break issue. 
Note that folks could still use the traverser to find the matching nodes, then switch to normal DOM operations -- including the generalized ownerElement attribute -- to navigate from those nodes. 
And in fact that's what I'd generally expect them to do, since they'd generally want to leave this traverser primed to look for the next node found by the XPath. 
Pure brainstorming: It is almost possible to create a Traverser which encapsulates the XPath view of the document, by setting appropriate filters... and I think it actually would be possible if Traverser added a getOwnerElement method. 
The filtering to handle text wouldn't be very efficient ... but it Could Be Done. 
(And it might be more efficient in an implementation designed to use internal information to optimize this case. 
We always did have the idea that some traversers, particularly those returned from queries, might be specially coded for better performance....) Joe Kesselman / IBM Research 
