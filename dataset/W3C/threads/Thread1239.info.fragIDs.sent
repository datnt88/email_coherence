Charset aliases: NONE Suitability for use in MIME text: YES 
Published specification(s): ISO 10646 equivalency table: Also in http://www.unicode.org/unicode/reports/tr19/ 
Additional information: Mark Davis 2509 Alpine Road, Menlo Park, CA 94025 mark@unicode.org 
Intended usage: LIMITED USE (This template was taken from http://www.normos.org/ietf/bcp/bcp19.txt. 
If 
any additional information needs to be supplied, please let me know.) 
Sorry, I missed that. 
Do you want me to resubmit, or could you just make that change? 
Mark Mark Davis, IBM GCoC, Cupertino ned.freed@mrochek.com 
on 05-09-2001 09:54:09 Subject: Re: Registration of new charsets UTF-32, UTF-32BE, UTF32LE 
Sorry. UTF-32, like UTF-16 is NOT suitable for use in MIME text. 
In particular, it uses octets with a value of 0. Additionally, CR and LF aren't represented in the same way as in ASCII. 
The answer to this question is therefore NO, not YES. 
If 
Resubmit. note: each charset should have its own registration form. 
BTW, TR19 is technically broken in its definition of UTF-32: it specifies that an UTF-8 character stream MAY OR MAY NOT begin with a Byte Order Mark, 
and that octets can be in any order. 
D36c (a) UTF-32 is the Unicode Transformation Format that serializes a Unicode code point as a sequence of four bytes, in either big-endian or little-endian format. 
An initial sequence corresponding to U+FEFF is interpreted as a byte order mark: it is used to distinguish between the two byte orders. 
The byte order mark is not considered part of the content of the text. 
A serialization of Unicode code points into UTF-32 may or may not begin with a byte order mark. 
This allows (when taking exquisite care - you only have 4.1 bits that are valid in both upper and lower halves of the 32-bit word) the construction of octet sequences that are ambiguous. 
If either the specification or the registration had said "A serialization of Unicode code points into UTF-32 that does not begin with a byte order mark MUST be in Big Endian", I would not have protested. 
But this is, IMHO, 
just too broken to be registered as a charset. 
As written, I OPPOSE the registration of UTF-32. 
(Apologies for having missed it at Unicode standardization time - we saw it 
coming, and did not catch it in time) Harald 
Thanks for your feedback. 
I will resubmit them. 
Comments: A. If each charset needs to be in a separate message, then you really ought to fix http://www.normos.org/ietf/bcp/bcp19.txt. 
It says: "5. 
Charset Registration Template Subject: Registration of new charset [names]" with the word "names" in plural. 
This is misleading. 
B. UTF-32 in Unicode, as with UTF-16, could be BOM-less, with the orientation being determined by a higher-level protocol. 
The IETF registration (with good reason!) can impose a further restriction, as it does with UTF-16, that BOM-less UTF-16 must be BE. 
I will put such a clause in the registration. 
Mark 
Mark, 
D36c (a) UTF-32 is the Unicode Transformation Format that serializes a Unicode code point as a sequence of four bytes, in either big-endian or little-endian format. 
An initial sequence corresponding to U+FEFF is interpreted as a byte order mark: it is used to distinguish between the two byte orders. 
The byte order mark is not considered part of the content of the text. 
A serialization of Unicode code points into UTF-32 may or may not begin with a byte order mark. 
IMHO, 
it 
It really comes down to having unique names for unique formats. 
After all, if I am going to serial LE into fields in a database, I can simply make it clear that that is "UTF-16LE", not "UTF-16". 
It is then clearly identified exactly what the format is, and does not require a BOM. 
Mark Mark Davis, IBM GCoC, Cupertino Patrik F?ltstr?m paf@cisco.com 
on 05-12-2001 03:48:58 Davis/Cupertino/IBM@IBMUS, ned.freed@mrochek.com, 
ietf-charsets@iana.org 
Subject: Re: Registration of new charsets UTF-32, UTF-32BE, UTF32LE 
However, if the IETF liaison wants to present a proposal to restrict UTF-16 and UTF-32 -- when used as a serialization into bytes, to being only BE if there is no BOM, I believe that the UTC would certainly take that into consideration. 
The next meeting is happening very soon... 
We have had such discussions, or rather, asked what IETF can/should do to make sure that we don't get different byte orders inside protocols and at the same time not override what UTC does. 
As you say, UTC definitions are not only used in protocols but also stored data on disk, and that is for historical reasons in different byte orders. 
Going away from that fact is difficult -- even though it would be nice. 
Can IETF do something which might help you think? 
Patrik, Liason from IETF to Unicode Consortium 
