Eve Maler's note with questions about the equivalence of SGML and XML raises serious questions, but before I try to answer them I want to pose even more questions. 
I apologize for the length of this posting, but I'm just working out these ideas and I don't understand them well enough to summarize them crisply. 
We say that XML and SGML should have 'essentially the same expressive power', and my own attempt to answer Eve's questions depends on clarifying what that means. 
First, let's distinguish equivalence among document instances from equivalence among DTDs. 
I Instance equivalence Instances can be: - byte-equivalent, if each octet of each entity in the document is the same - character-equivalent, if each 'character' in each entity is the same, but the encoding of the character may differ: a document in Ascii and the same document after translation into Ebcdic is a common-place and old-fashioned example; the same document in ISO 8859-1 and its equivalent in UCS-2 or UTF-8 is a similar and forward-looking example. 
- external-entity-equivalent, if each character in each *external* entity is the same (after resolving references to internal entities and character references) - ESIS-equivalent, if their document elements are E-equivalent, where elements are E-equivalent if and only if: * they have the same generic identifier * they have the same set of attributes * corresponding attributes have the same values (after expansion of entity references) * they have the same number of children, and all pairs of corresponding children are E-equivalent and character data chunks are E-equivalent if they consist of the same sequence of 'characters' (which does not mean they are in the same encoding). 
This may differ slightly in detail from the definition of ESIS in the Corrigendum, but not intentionally. 
- EE-ESIS-equivalent, if they are ESIS equivalent and the beginnings and endings of external entities occur at the same places in the ESIS. 
(This isn't well phrased; I hope it's reasonably clear what I mean: ESIS equivalent, plus division into external entities is preserved.) 
I need some examples: 1 p Hello, world! 
/p is byte equivalent to p Hello, world! 
/p and to the equivalent in EBCDIC (or in ASCII, I should say, because as I write this, it *is* in EBCDIC. 2 If we have !ENTITY greet 'Hello' and !ENTITY someone 'world' then p Hello, world! 
/p is ESIS-equivalent, but not character equivalent, to p  &amp;greet;, &amp;someone;! 
/ 3 A document divided into one file per chapter is ESIS-equivalent, but not EE-ESIS-equivalent, with the same document in a single file (i.e. with all references to external entities resolved). 
If two instances have the same DTD and are byte- or character-equivalent, they are guaranteed ESIS-equivalent, but not vice versa. 
If they are external-entity equivalent and have the same DTD, they are ESIS-equivalent; I can't think of a way to preserve entity equivalence as defined here without preserving ESIS equivalence. 
II DTD equivalence Now for DTD equivalence. 
Normally we think of this in terms of the set of effective declarations, after resolution of entity references and marked sections, etc. 
Here, though, I think we should focus on the languages defined by two DTDs. 
We need to clarify what we mean by 'equivalent expressive power'. 
In general (the computer scientists among us may correct me freely) I think grammars are equivalent if they define the same languages, i.e. if they accept the same strings as members of the language and reject the same non-members. 
One formalism F has the same power as another formalism G if for each grammar written using F, an equivalent grammar may be written using G, and vice versa. 
F is more powerful than G if the set of languages definable by F's grammars is a proper superset of the set of languages definable by G's grammars. 
Now, if XML's DTDs are to be 'as powerful' as SGML's, they have to be able to define the same set of languages: for every SGML DTD there must be an equivalent XML DTD accepting and rejecting exactly the same set of valid and invalid document instances. 
This, we cannot do, if we are set on doing without CDATA and RCDATA elements. 
(Or even DATATAG and RANK!) On the other hand, we can say that for our purposes XML DTDs and SGML DTDs have 'essentially' the same expressive power if for any SGML DTD, there is an XML DTD such that: - for every document instance accepted by the SGML DTD, the XML DTD accepts a document which is 'equivalent' - for every document instance accepted by the XML DTD, the SGML DTD accepts a document which is 'equivalent'. 
We can choose, I think, to require that the documents be ESIS- or EE-ESIS-equivalent, or apply some other test, depending on how strict we want to be. 
We could also insist on byte-equivalence or character-equivalence, but if we do so we can't make any real changes to DTDs. 
Dropping DATACHAR and RANK and SHORTREF don't bother people, I think, because we're all used the notion of normalizing SGML documents, and the normalized forms of documents share ESIS with their originals, but aren't byte-equivalent. 
If we drop CDATA and RCDATA elements, we can meet the same standard: any CDATA element in an accepted SGML instance can be replaced, in XML, with the same thing, but with  and &amp; escaped using any of the various possibilities discussed earlier. 
If we drop the &amp; connector from the content model syntax, as I suspect some people would like to do, then we haven't changed the expressive power of the language because (in theory) it is always possible to replace a content model using &amp; with an equivalent one not using &amp;. 
It may be ugly and very very long -- and for these reasons no one is likely to do it -- but it's *possible*. 
Dropping EMPTY, on the other hand, would seriously affect the expressive power of XML DTDs, since we could not guarantee the second DTD-equivalence clause above. 
III What is needed? 
I think we should shoot for the following: - any existing SGML document can be translated into an EE-ESIS equivalent document (i.e. same ESIS, same gross entity structure, but there may be more, or fewer, internal entities and references) - any existing SGML DTD can be translated into an XML DTD which recognizes a set of documents EE-ESIS-equivalent to the original DTD. - a document translated from SGML into XML into SGML should be EE-ESIS-equivalent to the original; same for one that goes X-S-X. 
I don't think we should shoot for more than EE-ESIS equivalence after round-trip transmission. 
Bytes will change. 
References to internal entities will be resolved, or introduced. 
That means there may be additional entity declarations in the DTD, and thus we can't even guarantee that the document will parse with the same DTD. 
I think we can guarantee that it will parse with the same set of effective element, attlist, and notation declarations. 
-C. 
M. Sperberg-McQueen [Thanks, Charles, for correcting me on the ESIS/EMPTY issue...] Michael -- compared to my poor attempt, your mail seemed crystal clear to me! 
You've explained why EMPTY isn't just another random kind of declared content. 
I could easily agree to cut out *multiple* ways of expressing the same markup language without getting down to *zero* ways, which meets our principle of having only one way to do things. 
If we agreed to go by this rule, mixed content would have to stay in... Of course, we could still decide that some things have to go, but I think the criteria should be much more stringent. 
(Hmm, could RANK be simulated for all practical purposes by GIs that have the number in them?) Eve This was an excellent summary of the types of equivalence between the documents translated from their original un-XML-fettered SGML representation to XML and back. 
I agree that EE-ESIS is an appropriate level. 
There is another type of equivalance I think I've heard some posters in this forum hint at: I don't know what to call it but "identity". 
There is some set of SGML documents existing today, which will need no translation to XML, XML will be defined such that these documents already will be valid XML. 
Is it a design goal to ensure that some percentage of today's SGML documents are "grandfathered" in, or is it enough that the EE-ESIS translation is available? 
If it is the former case, how do we decide which class(es) of documents shall be supported? 
-Bill William D. Lindsey blindsey@bdmtech.com 
My pleasure ... now I'll try to show why that means that EMPTY is unnecessary. 
He's tried to, but I think he is wrong. 
I don't think so. 
The effective normalized (i.e., ESIS or semantic grove form) of all empty elements, whether declared or spontaneously empty, is: tag /tag " Therefore, a content model of (#PCDATA) is equivalent to a declared value of EMPTY. 
(There is a difference in validatability by an SGML parser, but that is not an issue here ... and isn't much of an issue anywhere.) Eliminating declared content (including EMPTY) and mixed content is all that is needed to accomplish this goal. 
Translating from the SGML instance with declared and mixed content to the XML without those things is trivial and is reversible without information loss. 
The resulting XML can be parsed (but not validated, of course) without reference to a DTD. 
This solution does not in any way dictate the syntax of XML DTDs. 
What it does do is remove the need for new markup conventions or syntax in XML instances, or the need to require XML applications to enforce conventions for RE handling. 
This solution also has the significant advantage, described by Paul Grosso, in that existing SGML tools could easily create and receive XML documents, and that essentially all existing document types could easily be used for XML. 
And yes, Eve, I think you are right in thinking this technique would work for RANK, and possibly even DATATAG as well. 
Best regards, Charles Charles F. Goldfarb * Information Management Consulting * +1(408)867-5553 13075 Paramount Drive * Saratoga CA 95070 * USA International Standards Editor * ISO 8879 SGML * ISO/IEC 10744 HyTime Prentice-Hall Series Editor * CFG Series on Open Information Management The set of documents I would like to see "grandfathered in" is that set defined in (valid) HTML. 
If an XML browser cannot read that set of raw HTML documents that are valid according to the 2.0 DTD (or later versions) then it will not be of much practical use, and will be ignored by the majority of potential users. 
(We would still have the problem of the 60% of invalid documents, but hopefully this situation will get better once standard WP tools start offering automatic conversion to HTML.) Martin Bryan Martin Bryan, The SGML Centre, Churchdown, Glos. 
GL3 2PU, UK I just don't think this is practical. 
HTML relies OMITTAG (notably for P, LI, DT, DD). 
I don't see how we can possibly achieve our ease of implementation goals if we support OMITTAG in XML. 
I don't need to use an XML browser to browse HTML; I've already got plenty of HTML browsers that do that just fine. 
James This sounds like a reasonable goal. 
We should also be able to build EE-ESIS based test suites for parsers then too (perhaps have a parser verification suite and testing framework). 
We can't support all of them, of course. 
A lot of use of the *exotic* features of SGML has been made. 
This is one issue where filtering is an acceptable solution. 
I think we have to do as James Clark has suggested and be very stingy with the features we include. 
Otherwise, we will be debating based on the size of the legacy. 
While I understand the realities of legacy, my experience has been that this argument has the effect of making one choose politics of investment and buttered bread. 
This is slippery ground and one of the places where the *use real SGML* argument applies. 
len bullard lockheed martin Respectfully, Martin, I disagree. 
We would already be starting to determine XML's design by constituency. 
If we start that, then I have to point to the enormous amount of material in the CALS and AECMA worlds which also has a substantial investment, and might even be said to be *more valuable* information. 
I wish to avoid that kind of argument here but I would have to make it. 
Don't grandfather documents. 
Look strictly at features right now and the technical problems for capabilities. 
I too wish to field existing information without the need to do expensive conversions, but I accept the necessity of minor ones if for no other reason than a lot of the legacy is overbuilt and uses overdesigned DTDs. 
But to make XML contingent on grandfathering what is in many many cases, poor SGML (try to build a tag scanner for the legacy out there and keep it current) instances is not a good design criterion, IMHO. 
They will not accept the *valid HTML* argument and will insist that all of their invalid HTML should also work. 
This looks to me like a bad situation to even attempt to rectify. 
Let HTML and other existing DTDs take care of making the transition to XML. Make XML an attractive target because it does NOT have the foibles of these apps. 
len bullard lockheed martin James said: I can certainly see how we could make HoTMetaL Pro have an option to save HTML files in XML. 
It isn't that easy to suggest a general converter using SGML tools, since most HTML documents are not valid according to any particular HTML DTD. 
But I can imagine public domain conversion utilities that could be fairly painless. 
Would that be too much of a compromise? 
With no SHORTTAG and no OMITTAG and no EMPTY elements and no MIXED content, XML is becoming about as far from HTML as HTML is from RTF :-) It seems to me that limited versions of some of these things could usefully be retained: * allow an omitted end tag immediately before an end tag: P em stuff /P (is this worth it? 
it's easy to parse) * allow / (easy to parse, and safer than NET) * allow mixed content with | but not with ",", so as to avoid the difficulties associated with whitespace in element context in a mixed content model being taken as PCDATA. 
It is a mistake to think that using pseudo-elements solves very much, I think. 
Consider: where in fact the newlines should be inside the text elements, not between text and em . 
This is hard to explain. 
If comments and processing instructions make this complex, delete them and use elements instead. 
Heck, you can use elements instead of marked sections and attributes and entities and get a much cleaner syntax! 
Think of combining the wonderful work done by Tommie and Debbie on Pinnacles Reflections with the careful TEI WSD spec... entities as they could have been :-) -- as elements, using ID/IDREF to `insert' them. 
* consider a naming convention for EMPTY elements, if they are allowed at all -- e.g. E.BR , E.HR etc. -- if SGML is to be modified to allow end tags on EMPTY elements, this is probably irrelevant. 
* allow default attributes to be omitted, so that arch forms can be used (HTML IMG has 22 attributes according to HoTMetaL Pro 3.0, and almost all of them have defailt values. 
(a few are actually #IMPLIED I think). 
Having to put DIR="ltr" on eery element would be a pain, for example... Lee As currently discussed it would not be possible with XML - this gives me a problem. 
Yes, but if its a choice between viewing a few documents on XML, a huge number on HTML and even more on SGML I'm going to stick with HTML/SGML and forget all about XML. 
Unless XML browsers can reference and display HTML documents they are not going to form worthwhile information management tools! 
What I want XML to do is to provide me with all the good stuff (and none of the sloppy stuff) that HTML provides while allowing me to extend the basic concepts beyond the limits currently set by W3C. Martin Bryan, The SGML Centre, Churchdown, Glos. 
GL3 2PU, UK That may be biting off more than we wish to chew... HTML 2.0 makes liberal use of end-tag omission, a couple cases of start-tag omission, contains elements with CDATA, RCDATA, and EMPTY declared content, uses inclusion exceptions, and encourages omitted attribute name minimization. 
It does disallow most other forms of SHORTTAG minimization by application convention, and in "Strict" or "Recommended" mode HTML 2.0 does not use CDATA or RCDATA declared content (though HTML 3.2 does), but still... (FWIW, I agree with you that XML should be able to handle HTML -- not necessarily HTML 2.0, but possibly a similar, slightly stricter DTD -- but the general consensus seems to be that the cost of supporting the necessary features is too high.) 
More like 96% invalid from what I've seen... --Joe English jenglish@crl.com 
A while ago I asked Tim Bray to check for me with the Open Text index... and a little under 5% of HTML documents had a DOCTYPE line. 
That doesn't mean that they were valid, and there may be documents that are otherwise valid but don't have DOCTYPE, but it's unlikely that the overall figure is much higher. 
So I'd say that 90% to 95% invalid is a good guess. 
I'd be interested to run the same test again now a few million more copies of HoTMetaL have shipped... 
The conversions we've seen do not generally attempt to create valid SGML. 
I think there isn't enough encuragement. 
This is an aspect of the demise of the IETF HTML WG that is unfortunate, I think -- there are things that are easier for that sort of very approachable standards body. 
However that may be, I think it's reasonable to expect to have to run sme sort of transformation from arbitrary/normal/typical HTML into XML. 
Most HTML documents won't go automatically. 
In addition, it's very common for HTML documents to be different on the server than when they are delivered-- * processing instructions and significant comments are used by some servers: ?dvi 
filename to replace the PI with a DVI image on the fly !--#include filename to do server-side inclusion (like entities, but without the indirection -- much more natural for a C programmer) !--#exec date -- inserts today's date, more often used for generating those this-page-visited-00000026-times-most-of-them-by-my-mum counters * database servers often use their own elements (or perhaps I shouldn't elevate them thta high, their own _tags_), e.g. stuff like where the SQL query is executed before the document is shipped, and the content of the tags need not be stuff that would be valid within the HTML document. 
* some servers asemble fragments (not in the SGML OPEN fragment sense) on the fly -- should the inividual fragments be valid, or only the result? 
(rhetorical question!) It's interesting that HTML serves as a low-level portable document formatting language, sort of like a new troff that's a little easier to parse. 
Perhaps if XML had been around some 7 years ago, so that you could write an XML parser in C in a day or two, even as an undergraduate, Tim and later Marc and Eric &amp; friends would have used it. 
If HTML 4 is based on XML, it will get widely deployed if it is not too much harder than HTML 3 to type in NOTEPAD or to parse. 
You don't need to declare that Hey Presto! 
all HTML documents are XML! -- far from it, it is better not to. 
If there is no need to improve HTML documents to make them XML, what have we accomplished? 
Sorry for a long mesage -- I think it's important to agrewe on this, though. 
Lee Liam Quin, SoftQuad Inc | lq-text freely available Unix text retrieval lee@sq.com 
+1 416 544-9000 | FAQs: Metafont fonts, OPEN LOOK UI, OpenWindows SGML: http://www.sq.com/ | We've moved; new 'phone number &amp; postal address! 
The barefoot programmer | `who is my neighbour?' 
