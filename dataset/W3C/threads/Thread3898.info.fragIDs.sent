Hi Joseph, Referring to the document at http://www.w3.org/P3P/2003/04-beyond-http.html and your message posted on Mar 29, here are some comments. 
The most interesting/difficult requirement is with respect to delegation 
and 
propagation. 
The Web Services Architecture Usage Scenarios has a Third Party Intermediary scenario [4] that is perhaps closes to what we would want to do? 
[4] http://www.w3.org/TR/2002/WD-ws-arch-scenarios-20020730/#S030 
While I've looked at the WS-Policy specifications [5] I think it's perhaps best to play with this scenario in the context of a SOAP message header 
[6] 
or a WSDL definition [7] for the time being. 
[5] 
ry/en-us/dnglobspec/html/wspolicyspecindex.asp 
[6] http://www.w3.org/TR/soap12-part1/#muprocessing [7] http://www.w3.org/TR/2001/NOTE-wsdl-20010315#A3 
I have done a bit about WS-Policy and also the delegation issues of Web services for a health informatics project by using Web services technologies. 
If you are interested in it, you can check some relevant information at: 
In fact, I have been thinking whether it is feasible and appropriate to implement/apply P3P into WS-Policy for the project. 
Anyway, the first job for me is to "modify/change/re-create" the PURPOSE elements (Section 3.3.4 
from The P3P1.0 Specification) for this project. 
Thus, I have to define the purposes/ of collecting/processing the health data as some specific purposes in the context of health data and epidemiological statistics, such as " vital-statistics/ ," 
morbidity-statistics/ ," and etc. Anyway, I am still studying on it. 
I haven't made an attempt at it yet -- has anyone else? -- but I hope to soon. 
However, even without doing so, I ask myself if: 1. 
Does the privacy statement belong at the SOAP level, or HTTP? 
In the majority of cases SOAP will be transported over HTTP, what happens if both of a HTTP statement? 
As HTTP is a carrier for SOAP messages, I don't really get what you mean here. 
Do you mean that what happens if both "Web service requestor" and "Web service provider" using HTTP and no SOAP message? 
An application specification MUST specify where relevant P3P statements 
can be found. 
We recommend 
that a higher/abstract layer MAY include the privacy policy of layers it 
is dependent upon, but that lower 
layers SHOULD NOT represent the policies of higher layers. 
For example, an 
application that transfers data 
with SOAP over HTTP that uses cookies, MUST specify: 1. the P3P policy associated with SOAP is normative and includes the HTTP 
policy, or 
2. there are distinct P3P policies associated with the SOAP and HTTP 
layers. 
By "my understanding," it should not be possible for a Web service requestor (i.e., Web service) to set 
cookies at the side of Web service requestor (e.g., an application program or even another Web service), except the Web services requestor's interface resides in a browser. 
The Web service provider always resides in a Web server. 
2. Does the privacy statement belong at the WSDL level? 
Not every service must have a service description. 
And if they did for the purposes of privacy then *have* to fetch the WSDL before proceeding with the interaction? 
My sense here is that SOAP would trump the OPTIONAL WSDL definition. 
Referring to the first question, do we need separate P3P (privacy) policies for each operation (web method) in a Web service? 
Then, for the second question, it may be closely related to the matchmaking process between Web service requestors and providers. 
In the 
workflow environment, the service locators (i.e., matchmakers) may have to deal with the P3P policies from 
both tasks and Web services by using APPEL. 
Please correct me if I misunderstood anything. 
Thanks, Patrick C. K. Hung Research Scientist, Security and Privacy Group Commonwealth Scientific &amp; Industrial Research Organisation (CSIRO) CSIRO Mathematical and Information Sciences (CMIS) GPO Box 664, Canberra, ACT 2601, Australia URL: www.cmis.csiro.au/Patrick.Hung 
Thank you for the comments Patrick. 
morbidity-statistics/ ," and etc. Anyway, I am still studying on it. 
I'll note this as more evidence that p3p:PURPOSE is likely to be a part of the vocabularly most likely to change. 
However, I'm thinking it will be useful to distinguish the meta "purpose" of "current" and "other" from the other terms. 
I expect you'd want to user both of those terms independent of the others...? 
No, what happens if the HTTP header has a P3P statement, and the SOAP message has one too, and they don't agree, or they do in parts but not in others? 
This is an interesting point, if the web service client isn't a web browser, it might not support cookies anyway. 
However, I don't think we can presume this just yet. 
Might be worth a few setences on the point. 
2. Does the privacy statement belong at the WSDL level? 
Not every service must have a service description. 
And if they did for the purposes of privacy then *have* to fetch the WSDL before proceeding with the interaction? 
My sense here is that SOAP would trump the OPTIONAL WSDL definition. 
Oh, good point. 
I'll add this as an issue to the outline I'm working on. 
Hi, 
Here are notes and files I promised on XML Schema for BSD. 
Rigo, perhaps you could post the files on a server somewhere as promised. 
The XSLT works with msxml but can easily be adapted for others (see notes below). 
Note that this is an investigation of how to express the existing schema as XSD, not an investigation of alternatives. 
I do think that we should eventually make a switch to a more interoperable and efficient format but I don't think this would be a good idea at present. 
bsd.xsd is the (formatted) result of a transformation on the P3P1.0 BSD 
bsdtransform.xml is the xml of the p3p1.0 BSD 
bsdtransform.xsl is the xslt bsdtransform.html is the client side code for executing the transform and outputting as HTML. 
The notes below are also attached as a word document. 
P3P Base Data Schema as XML Schema 
Giles Hogben JRC Aims The aims of this first pass solution were 1. 
To allow a simple 1 to 1 transformation between policies expressed in the old format and policies which conform to the XML schema. 
2. To allow a simple 1 to 1 transformation between any custom built data schemas and the new format. 
For this purpose I have provided an xslt. 
Although I have provided an XML version of the transformed schema, it is necessarily complex and this document explains how it is structured. 
These aims led to the following Requirements for the base data schema XML schema: 1. 
The schema must express classes of data and their allowed relationships in terms of sub and superclasses. 
In the old format this led to expressions like Which I take to mean - the information the statement is about is an instance in the class home-info, in the class user. 
OR Which I take to mean - the information the statement is about is an instance in the class uri, in the class online etc?. 2. These classes (called structures in the old format) are reused at different levels of the hierarchy and therefore must be declared by reference within the schema hierarchy. 
For example the class denoted by the structure "contact" may be used by both business-info and home-info. 
3. The XML language can assume a semantic such that nested elements imply subclassing. 
Although there is no formally defined semantics for P3P, by inspecting the use of elements such as purpose, one can gather that use of a sub-element in P3P may be equated to the semantic "is a subclass of?" 
For example: Means something like: "The data this statement is about has purpose of type (subclass of purpose) current " 4. An overall set of "categories" is assumed within any DS from which are derived subsets of categories for any class. 
These categories do not have the same semantic as classes. 
They superclass any classes used but only a certain subset of all the categories may superclass a given class. 
This superclassing is inherited within the DS but it follows a reverse inheritance rule because superclasses of the standard classes inherit the categories of their subclasses. 
For this reason it has to be declared at each level and cannot use standard inheritance syntax using the XML tree. 
For example in the BSD, May be given the additional semantic of "this data type is in the online category" These requirements are satisfied by the following Informal specification This informal specification is formally specified in the attached XML Schema. 
Data types are expressed as subclasses of a root "Datatype" element. 
The subclass semantic is expressed by making an element a child of another element. 
For example appear ONLY AS LEAVES. 
This mimics the previous syntax where the classes were specified up to a certain granularity which was then given a category. 
For example: P3P1.0: data ref="user.home-info" 
CATEGORIES online/ demographic / /CATEGORIES /data P3P 1.1. 
XML Schema Compliant P3P 1.0 data ref="user.home-info.online.email" 
CATEGORIES online/ /CATEGORIES /data P3P 1.1. 
XML Schema Compliant Notice that the names of the "structures" are not specified in the XSD as a formal naming of a group of subelements is no longer necessary. 
An informal description of the structure of the BSD should however be given within the specification document, allowing users to know how to use the classes without reading the XSD (Maybe it's even possible to write an XSLT for the specification document J ). Notes for Transform files: 1. 
The XSLT is general and will transform any data schema, which is syntactically correct according to P3P 1.0. 
2. The files provided are everything you need to transform a data schema using client side transformation in MS IE. bsdtransform.xml is the xml of the p3p1.0 BSD bsdtransform.xsl is the xslt bsdtransform.html is the client side code for executing the transform and outputting as HTML. 
bsd.xsd is the (formatted) result of a transformation on the P3P1.0 BSD 4. You can use the stylesheet with other xsl processors but you need to change the node-set extension. 
To transform a different DS, just change the xml input document in bsdtransform.html 5. The mechanism of the transform of the old BSD to XSD is extremely complex but is explained in the comments of the XSLT. 
The transform uses a multipass transform which uses the node-set xslt extension so it is specific to msxml. 
It can be used with SAXON with a very minor change which is written in the xslt. 
Explanation of Schema Syntax Used: The schema is contained in bsd.xsd. 
The schema starts with a definition of all the categories from which the allowed categories are derived. 
Starting with a definition of the root datatype element, it then uses the choice element to specify the subelements of this recursively. 
For each subelement, there is then a further choice which specifies the use of categories. 
It says that category elements used must be a leaf by saying making their usage mutually exclusive wrt any subelements (using xs:choice ). 
Hi Giles, good stuff! 
Some comments below: 
I presume I should be able to run this against a P3P instance? 
But one of the annoyances of Schema is not being able to clearly distinguish the root element, and in this case I don't think there is any? 
So which subset of a P3P XML instance is this schema file supposed to validate against? 
(Not against the root POLICIES ... ENTITY? 
DATA-GROUP?) Why is there a seven after the schema element? 
schema targetNamespace="http://www.w3.org/2002/01/P3Pv1" 7 
That's on line 44 now, the documentation says 42. Might include the following URI so folks can read about it: "xx" is an unbound prefix. 
Why not include: xmlns:xx="http://exslt.org/common" in your xslt. 
Even if it's not used, it won't hurt anything would it? 
(Found that namespace in: I haven't been able to confirm the transform yet. 
I'm not a big fan of java -- never got saxon to run -- I don't think sablotron supports that function and xsltproc gives me odd results: 
xsltproc bsdtransforms.xsl bsd.xml 
schema xmlns:xx="http://exslt.org/common" targetNamespace="http://www.w3.org/2002/01/P3Pv1" 7 simpleType @br/~ enumeration value="uniqueid" @br/~ /enumeration @br/~ enumeration value="demographic" @br/~ /enumeration @br/~ enumeration value="physical" @br/~ /enumeration @br/~ enumeration value="online" @br/~ /enumeration @br/~ enumeration value="computer" @br/~ /enumeration @br/~ enumeration value="navigation" @br/~ /enumeration @br/~ enumeration value="interactive" @br/~ /enumeration /restriction /simpleType /schema 
Here are some more files on this issue I have corrected some small errors in the schema transform (e.g. it was outputting category element and attribute element definitions with global scope where it shouldn't have been). 
I have also included a 2 stage transform which avoids using extensions (you 
do transform 1 and then transform2 on the results of transform1 to eliminate 
duplicates) and, for the benefit of other members of list the files for the 
policy transform I sent earlier. 
Apologies for confusing the acronyms BDS and BSD... BDS means the base data 
schema and BSD is an OS... 
For those who don't want to get bogged down in nasty amounts of complexity, 
just look at the file bdsfinal.xsd 
which is the final result schema, or try 
the policy transformer on a policy (e.g. the one included). 
Hope the directory and file names are relatively self explanatory Regards 
Giles 
Yeah - sorry - it was the quickest and easiest way to get it to work at the time - will try to send a self executing .jar 
file at some point - maybe that'll help. 
I'm still not following, keep in mind I know nothing about MS IE and very little about Java (I'm more of a XML and Python person) smile/ . 
I was expecting to do something like: xsltproc bsdtransform.xsl 
p3p1_0.xml  
converted_p3p_1_0.xsd then I can check a P3P instance against that schema: xsv p3p.xml converted_p3p_1_0.xsd 
What is "BSD" btw? 
P3Pers, apologies for having missed the call today, XQuery is swamping me these days. 
Anyway, some quick words on the "P3P data schema in XML Schema". 
This issue had already been tackled quite some time ago in the P3P spec group (you might have wondered if somebody hadn't thought about it before... right? 
;) In fact, this has at a time been discussed as an alternate proposal, and finally rejected. 
I'll state the reasons and some comments here, because these still apply (which means, reopening this issue in P3P1.1 should then again mean challenge again the "con" of the solution). 
First big motivation: who needs it? 
What are the real advantages? 
Implementers, at the time, let us know they didn't like the "xml-schema way" (let's call it this way), because a) it makes parsing heavier b) it makes simple data declaration too verbose (as you have to duplicate each subpart of a data element in begin and end tags) This was the main objection at the time. 
Now, we are no more in the designing phase (1.0), so tackling this issue again in 1.1 has to face the new, crucial, additional problem: c) what are the costs of adding an alternate format to the spec? 
There was also other considerations that led not to consider that design, that I'll recap here too: d) splitting data elements (etc) in separate tags, apparently leads to the loss of the "reference with a URI" property: you'd still need to recombine the info in a single-line canonicalization to get this property back (so, essentially going back to the status quo). 
e) makes DTD support more difficult Ok, enough with historical motivations for today ;) So all in all, the above considerations just apply if this proposal is going to end in 1.1 (i.e., it's reopening the issue). 
If it's instead a translation-only thing (like the RDFization note of P3P), likely to end as a Note or so, then of course all the above is moot ;) -M 
Yeah - sorry - it was the quickest and easiest way to get it to work at the time - will try to send a self executing .jar 
file at some point - maybe that'll help. 
(Do the BSD files only work on that OS then???) 
FYI I've attached the result of running: 
xsltproc p3ptransform.xsl 
p3ptransform.xml  
out.xml 
Note I first had to remove the commented section (lines 57-78) from p3ptransform.xsl in order to get it to work (otherwise my XML tools complain it isn't well formed: comments don't nest). 
My thoughts on this as an implementer. 
It would be good to have other people's feedback: 1. 
As far as making custom schemas is concerned, the current version (let's call it BDS and the new one XSD) is a complete non-starter. 
The syntax is so unintuitive that no-one can make head or tail of it and the only custom data schema I've seen had completely misunderstood it. 
The whole thing of having DEF's, ref's and structrefs and matching using the first half of the ref element is really a mess! 
Just take a look at the code I had to write in the xsl files to get an XSD that makes sense. 
2. From the same point of view, validating any new schemas is a nightmare. 
Having built a (the only) system for parsing and validating generalised DS's in our implementation, I can tell you that it was a horrible, horrible job. 
3. I don't agree that this version makes it heavier. 
It means that any APPEL like engine can just carry on doing sub-tree matching instead of going into another regular expression based mode which we found added weight. 
You're right that it will be slightly more verbose. 
Could you explain why you'd want it "reference with a URI". 
Surely this could be solved - maybe by referring to a particular element in the XSD - they are unique. 
4. The format is so non-intuitive that it is very difficult to make sense of it. 5. XSD does not have a formal semantics, but its informal semantics is a lot easier to make sense of than BDS. 
I think the RDFS attempt at codifying the BDS shows both how impossible it is for people to understand the BDS format and how confused the semantics are (vide our discussion about a year ago on this subject) - the RDFS schema has a uri for EVERY possible combination of allowed structures - I think it ends up being about 5000 lines because of this! 6. 
What I am suggesting here has a 1-1 mapping to the old version with an xslt so it's quite legacy-friendly isn't it. 
I don't think it should just end up with a note that nobody is going to read. 
Thoughts? 
[mailto:public-p3p-spec-request@w3.org]On 
Behalf Of Massimo Marchiori P3Pers, apologies for having missed the call today, XQuery is swamping me these days. 
Anyway, some quick words on the "P3P data schema in XML Schema". 
This issue had already been tackled quite some time ago in the P3P spec group (you might have wondered if somebody hadn't thought about it before... right? 
;) In fact, this has at a time been discussed as an alternate proposal, and finally rejected. 
I'll state the reasons and some comments here, because these still apply (which means, reopening this issue in P3P1.1 should then again mean challenge again the "con" of the solution). 
First big motivation: who needs it? 
What are the real advantages? 
Implementers, at the time, let us know they didn't like the "xml-schema way" (let's call it this way), because a) it makes parsing heavier b) it makes simple data declaration too verbose (as you have to duplicate each subpart of a data element in begin and end tags) This was the main objection at the time. 
Now, we are no more in the designing phase (1.0), so tackling this issue again in 1.1 has to face the new, crucial, additional problem: c) what are the costs of adding an alternate format to the spec? 
There was also other considerations that led not to consider that design, that I'll recap here too: d) splitting data elements (etc) in separate tags, apparently leads to the loss of the "reference with a URI" property: you'd still need to recombine the info in a single-line canonicalization to get this property back (so, essentially going back to the status quo). 
e) makes DTD support more difficult Ok, enough with historical motivations for today ;) So all in all, the above considerations just apply if this proposal is going to end in 1.1 (i.e., it's reopening the issue). 
If it's instead a translation-only thing (like the RDFization note of P3P), likely to end as a Note or so, then of course all the above is moot ;) -M 
(you 
eliminate 
the 
data 
complexity, 
try 
Yeah - sorry - it was the quickest and easiest way to get it to work at the time - will try to send a self executing .jar 
file at some point - maybe that'll help. 
