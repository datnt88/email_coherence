I'd like to double check my interpretations of the ECMAScript binding's expectations for caller provided object. 
From binding.html: 
Object EventListener This is an ECMAScript function reference. 
This method has no return value. 
The parameter is a Event object. 
function clickHandler(evt) // Function contents // The following line will add a non-capturing 'click' listener // to 'exampleNode'. 
exampleNode.addEventListener("click", 
clickHandler, false); From ecma-script-binding.html Object NodeFilter This is an ECMAScript function reference. 
This method returns a Number. 
The parameter is a Node object. 
From L3 Events: binding.html 
EventListener function: This function has no return value. 
The parameter is an object that implements the Event interface. 
From binding.html 
Objects that implement the DOMErrorHandler interface: Functions of objects that implement the DOMErrorHandler interface: handleError(error) This function returns a Boolean. 
The error parameter is an object that implements the DOMError interface. 
Objects that implement the UserDataHandler interface: Functions of objects that implement the UserDataHandler interface: handle(operation, key, data, src, dst) This function has no return value. 
The operation parameter is a Number. 
The key parameter is a String. 
The data parameter is an object that implements the any type interface. 
The src parameter is an object that implements the Node interface. 
The dst parameter is an object that implements the Node interface. 
From binding.html 
Objects that implement the LSParserFilter interface: Properties of objects that implement the LSParserFilter interface: whatToShow This read-only property is a Number. 
Functions of objects that implement the LSParserFilter interface: startElement(elementArg) This function returns a Number. 
The elementArg parameter is an object that implements the Element interface. 
acceptNode(nodeArg) This function returns a Number. 
The nodeArg parameter is an object that implements the Node interface. 
Objects that implement the LSResourceResolver interface: Functions of objects that implement the LSResourceResolver interface: resolveResource(type, namespaceURI, publicId, systemId, baseURI) This function returns an object that implements the LSInput interface. 
The type parameter is a String. 
The namespaceURI parameter is a String. 
The publicId parameter is a String. 
The systemId parameter is a String. 
The baseURI parameter is a String. 
Objects that implement the LSSerializerFilter interface: Objects that implement the LSSerializerFilter interface have all properties and functions of the NodeFilter interface as well as the properties and functions defined below. 
Properties of objects that implement the LSSerializerFilter interface: whatToShow This read-only property is a Number. 
It is pretty explicit that a function object is used for EventListeners and NodeFilters. 
Am I right in interpreting that the DOMErrorHandler, UserDataHandler, LSSerializerFilter, LSParserFilter and ResourceResolver are passed as objects, something like: function MyDOMErrorHandler() { MyDOMErrorHander.prototype.handleError = function(err) { var errorHandler = new MyDOMErrorHandler(); document.domConfig.setParameter('error-handler', 
errorHandler); This description of LSSerializerFilter could use some clarification since it says the object has all the properties NodeFilter, but NodeFilter is a function object. 
I would argue that it should be able to pass a JS function as any callback interfaces that contain only one method (i.e. one method, no attributes, but constants are ok). 
That would mean that one can pass a JS function as a DOMErrorHandler, UserDataHandler, or LSResourceResolver, but not as a LSSerializerFilter nor as a LSParserFilter. 
jst Being able to pass in either a JS function or an object sounds desirable in those instances sounds desirable, but I don't see justification for it in the current ecmascript binding description. 
I assume that you do not anticipate any implementation difficulties if it took either form. 
I don't see any technical problems either way, but not allowing functions to be passed would be an inconsistency with the handling of existing callback-like interfaces. 
I strongly encourage a change to the ecmascript bindings to reflect this. 
jst 
