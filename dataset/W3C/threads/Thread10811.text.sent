The point... does concern whether an entity referenced by a syntactic entity reference must be accessed and parsed. 
According to 8879, it must... 
The only way to avoid this required access and parsing is to use an entity attribute. 
Hence the [entirely valid] concern on the WG &amp; ERB about the use of external text entities in XML. 
They are highly useful for authoring, but given the requirements of 8879, if we include them we are in danger of requiring that, to be "XML compliant", any browser, no matter how lightweight, be required to pull in &amp; interpolate text entities from all over creation. 
Which is kind of silly since it is clear that doing this is hard in modern browser architectures, and it is far from clear that this is the right semantic for providing access to distributed modular documents, and it is *extremely* clear that we'd like to make it easy for browsers to achieve XML compliance. 
And since the real reason for having external text entities is to support authoring anyhow. 
The first-cut solution was to make them optional, which carries its own set of costs. 
*BUT*, I think there's another way to avoid this required access. 
This tactic, independently proposed by several people, is to zero in on the word "parse" and say that an XML Processor is, in 8879 terms, a "parser" only when it's trying to validate against a real DTD. 
In which case, of course, it has to go pull in the entities. 
When it's just reading a document and checking for well-formedness not validity (the natural behavior of a client browser), we can say that it's not, in 8879 terms, "parsing", and is thus not required to interpolate external text entities. 
Authors will quickly learn to resolve external text entities before sending instances down network pipes. 
This works well in XML because the presence or absence of a text entity can never affect well-formedness - we've already decided they have to be element-synchronous. 
I see this as a solution that allows XML to standardize on SGML's management architecture at the authoring end, bless browsers as compliant without placing unreasonable demands on their authors, and remove optional features from XML. 
Also, it's easy to document in the spec. 
Cheers, Tim Bray tbray@textuality.com 
http://www.textuality.com/ 
+1-604-488-1167 The only way to avoid this required access and parsing is to use an entity attribute. 
Can someone please prove that this is so? 
The distinction between an "SGML comformant parser" and an "XML parser" might be a good one to make. 
For the sake of argument, let's say we have an XML parser that parses entity references. 
Can anyone show me a case where it is absolutely necessary to resolve the entity before parsing can continue (especially considering that replacement text would become psuedo-elements and thereby not affect the structure much at all). 
The case I have in mind is one, for a valid XML document, where an external text entity contains markup that would change the content model of the document instance based on parse-time inclusion versus use-time inclusion. 
I'm not a parser expert but suspect that we may have a problem with delayed parsing of external text entities in valid XML even if we preclude asynchronous entities. 
I cannot see any cases (with the API's I have in my head) when an application could ever even know if the entity occurred (ie. the tree the application accessed would be identical for all practical purposes). 
I could see some differences in RE/RS recognition if we follow SGML's recognition rules, which would lead to some differences in tree structure, and this is another reason why I prefer the "no such thing as RE/RS" approach... 
