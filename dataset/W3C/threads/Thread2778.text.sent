The current wording in section 14.20 is nonsense as it renders all existing HTTP/1.1 servers not compliant: The Expect request-header field is used to indicate that particular server behaviors are required by the client. 
A server that does not understand or is unable to comply with any of the expectation values in the Expect field of a request MUST respond with appropriate error status. 
People not having read the spec before or not knowing about HTTP implementations will get very surprised if they expect this behavior. 
The MUST MUST be changed to something like this: The Expect request-header field can be used to indicate that particular server behaviors are preferred by the client. 
The client is not guaranteed that the server recognizes the information in an Expect request header field. 
The stronger semantics of a MUST is captured by the Mandatory proposal which is under way on the HTTP-EXT mailing list. 
Henrik Henrik Frystyk Nielsen, World Wide Web Consortium In what sense, Henrik? 
My server responds with Expectation Failed if you send a token in Expect: that it doesn't recognize... Yes, this was not in 2068, but this is not the only thing we've added. 
I believe that the MUST should stand; making it a SHOULD renders the Expect feature almost useless. 
Scott Lawrence Consulting Engineer lawrence@agranat.com 
Agranat Systems, Inc. Embedded Web Technology http://www.agranat.com/ 
I agree, but isn't this in fact the case in practice? 
Wouldn't it be better to let Mandatory handle this as it has a stronger mechanism for enforcing client based requirements based on the M- method name prefix? 
Henrik Henrik Frystyk Nielsen, World Wide Web Consortium Henrik Frystyk Nielsen replied: ... but have you tested what happens with old servers (and CGI programs) if you send them new methods? 
At least in the case of CGIs they often ignore the method - in short, you have exactly the same situation faced by Expect, but more complex. 
Don't get me wrong - I like the Mandatory mechanism because it is so much more descriptive, but I don't think that it is any better from a backward compatibility point of view (and cannot be made any better). 
Scott Lawrence Consulting Engineer lawrence@agranat.com 
Agranat Systems, Inc. Embedded Web Technology http://www.agranat.com/ 
We cannot do that and still call it HTTP/1.1. 
The protocol versioning rules exist to prevent the HTTP-WG from screwing over early implementers of the protocol, such that the protocol can be deployed and remain interoperable even though some definitions and requirements will, by necessity, change over time. 
....Roy Does the server ignore them as well and just hands off the script regardless? 
I don't have an exhaustive list - do you have some data? 
Is so then I can try and check around to see about other servers as well. 
Thanks, Henrik Henrik Frystyk Nielsen, World Wide Web Consortium The CGI spec (either the existing 1.1 spec or the new 1.2) just makes the method available to the program - if the program doesn't look, it doesn't. 
Some of the CGI libraries make this easy to do as well - parameters are parsed by the library from a GET query string or a POST body transparently, for example. 
I've tried bouncing TRACE and OPTIONS requests off various URLs that were obviously scripts and many respond as though the request were a GET. 
I just took a (very) quick peek at the Apache documentation for adding modules, and found a similar API - the method is passed by the server to the module, so the core server itself doesn't even appear to have a way to know what methods might be handled or not. 
Pretty good design if you are optimizing for flexibility. 
Scott Lawrence Consulting Engineer lawrence@agranat.com 
Agranat Systems, Inc. Embedded Web Technology http://www.agranat.com/ 
You are right - they indeed seem to be largely indifferent except that I see an added 100 code on PUTs and HEAD responses don't include a body. 
Sure if you have a way of describing what you mean by a new method and that you have a mechanism for ensuring that it is handled probably. 
The current situation is just a recipe for evolutional disaster in HTTP/1.x and it indeed breaks HTTP/1.1 for any method (including unknown ones) except GET, HEAD and POST. 
Henrik Henrik Frystyk Nielsen, World Wide Web Consortium The problem starts with the fact we've carefully never acknowledged the CGI interface as being part of HTTP. 
What I think is needed is a MUST requirement that a HTTP server never delegate handling of any method other then GET, HEAD, or POST to any part of the server which isn't known to understand / properly handle the unknown method. 
I think this requirement is implicit in the spec in any case so it isn't a protocol change. 
It does mean that a conforming HTTP/1.1 server can't handoff an unknown method to a CGI (or *API) program if there isn't some kind of configuration switch to prevent handing such requests to an old CGI program. 
With a server having the ability to distinguish 'old' methods from new methods and controlling which application code each will be sent to, the server can't even fix a failure by disabling the new methods from the old CGI. 
Dave Morris I think that crosses the line from being a protocol spec to being a functional spec for a server, which it should not try to be. 
There are few cases where we have put in requirements outside the wire protocol, but they are mostly governing caching to preserve correctness, or are related to the security behaviours. 
rom the point of view of this spec, "the server" is whatever is generating the response to a request - it encompasses the CGI or *API program, and those components are as much bound by its requirements as any other part. 
Yes, I understand the real world implications of this - and I believe that those working on a new CGI spec do too. 
Scott Lawrence Consulting Engineer lawrence@agranat.com 
Agranat Systems, Inc. Embedded Web Technology http://www.agranat.com/ 
OK, then lets stop worrying about the fact that servers invoke brain dead cgi programs. 
In any case, the requirement I suggested is there to insure correct behavior. 
I tried to use very general language as to the requirement that base servers take responsibility for what they deliver on the wire. 
It is easy enough to expect the base server to enforce protocol when invoking API programs. 
The new CGI spec. is only intended to be an informational RFC. 
Whether or not a server implements the new CGI specification, it must ensure that what it returns as an HTTP/1.1 response is infact a HTTP/1.1 response. 
Dave Morris And the spec does that now - it does not make any special allowance for responses that originate with some other component or gatewayed system - if the response is labelled HTTP/1.1 then the spec makes certain requirements of it. 
What more is needed than that? 
When we say MUST, we don't need to then provide a list of circumstances under which the MUST still applies - unless we allow for exceptions, there are none. 
Scott Lawrence Consulting Engineer lawrence@agranat.com 
Agranat Systems, Inc. Embedded Web Technology http://www.agranat.com/ 
If Expect continues in the spec then there can be only two reasonable options: 1. Require the client to perform discovery on the resource (by asking for OPTIONS and looking for a particular header, for example) before using Expect with that resource. 
2. Change the version number to HTTP/1.2. Yaron From: Scott Lawrence [mailto:lawrence@agranat.com] Sent: Tuesday, July 28, 1998 12:21 PM Subject: Re: ISSUE: Expect Header Field Problem in the Expect field of a request MUST respond with 
