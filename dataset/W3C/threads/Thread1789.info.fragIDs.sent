Hi, Lets say I have a working collection wcoll. 
Now, I need to place a file, file1, into this working collection. 
And to update the content in the next call. 
I am assuming that NO auto-version policies are used. 
The sequence of operations would typically be: 1. PUT /wcoll/file1 //created the file here. 
2. PUT /wcoll/file1 //updated the content here. 
My doubt is whether a first version (and version history and version-controlled resources) are created in step (1). 
If so, then the sequence of operations required would be: 1. PUT /wcoll/file1 //created the file here - and placed it into version control 2. CHECKOUT /wcoll/file1 //create a working resource of the file 3. PUT /wcoll/file1 //updated the content here. 
Is this what RFC3253 specifies? 
If so, can somebody point out to me where in the spec this is specified. 
Section 14.10 of RFC3253 says that at the time of checkin of a working collection, all non-version-controlled members of the working collection have to be placed under version control. 
If this is understood, then at step (1) above, the server need not place the file under version control and can wait until the time of checkin of wcoll1. 
So the checkout in step (2) above would not be required. 
Am I getting the specifications correctly here? 
If I am getting it right, then if I want to add a new collection coll2 under wcoll, and a file file1 under coll2, then the sequence of operations would be: 1. MKCOL /wcoll/coll2 //created the collection here. 
2. PUT /wcoll/coll2/file1 //created a file under coll1. 
No checkout of coll1 is required. 
So, when wcoll is checkedin, coll2 and its members are placed under version control. 
Is this right? 
Girish 
From: B H, Girish [mailto:g.b.h@sap.com] 
Lets say I have a working collection wcoll. 
Now, I need to place a file, file1, into this working collection. 
And to update the content in the next call. 
I am assuming that NO auto-version policies are used. 
The sequence of operations would typically be: 1. PUT /wcoll/file1 //created the file here. 
2. PUT /wcoll/file1 //updated the content here. 
My doubt is whether a first version (and version history and version-controlled resources) are created in step (1). 
That is correct, no new version-controlled resources (or version histories) are created until /wcoll is checked in. 
Note that a more realistic working collection URL would be something like /repo/wcoll/16734. 
If so, then the sequence of operations required would be: 1. PUT /wcoll/file1 //created the file here - and placed it into version control No, the PUT does not put it under version control. 
A CHECKIN of /wcoll is required. 
2. CHECKOUT /wcoll/file1 //create a working resource of the file Since /wcoll/file1 is not under version control, the CHECKOUT would fail. 
3. PUT /wcoll/file1 //updated the content here. 
Is this what RFC3253 specifies? 
If so, can somebody point out to me where in the spec this is specified. 
It doesn't, so nobody can (:-). 
Section 14.10 of RFC3253 says that at the time of checkin of a working collection, all non-version-controlled members of the working collection have to be placed under version control. 
If this is understood, then at step (1) above, the server need not place the file under version control and can wait until the time of checkin of wcoll1. 
So the checkout in step (2) above would not be required. 
Am I getting the specifications correctly here? 
Yes, that is right. 
In particular, section 14.0 states: "a working collection contains bindings to version history resources and non-version-controlled resources". 
So a server is not even allowed to place a member of a working collection under version control (until that working collection is checked in, at which time the working collection is deleted, so the working collection never actually contains a version-controlled resource). 
If I am getting it right, then if I want to add a new collection coll2 under wcoll, and a file file1 under coll2, then the sequence of operations would be: 1. MKCOL /wcoll/coll2 //created the collection here. 
2. PUT /wcoll/coll2/file1 //created a file under coll1. 
No checkout of coll1 is required. 
So, when wcoll is checkedin, coll2 and its members are placed under version control. 
Is this right? 
Yes, that is right. 
Cheers, Geoff 
From the abstract: "In many cases, a versioning-aware client might want to display/include the URI of the version it's editing while it's being edited. 
For instance, an editor might include this as meta information, or the author of a document might want to know the URI of the version before it's checked in. 
A well-known example is the W3C way of referring to document versions in recommendations: it contains references to "the current version", to "this version" and to the "previous version". 
Something like this is currently impossible with WebDAV deltaV [RFC3253], as the version URI is determined at the time of CHECKIN." 
From the change log: Made the document element for responses upon failed CHECKIN DAV:error rather than DAV:checkin-response. Updated reference to [RFC3253]. 
Moved extension elements out of DAV: namespace. 
Changed examples to explicitly use utf-8 encoding for HTTP content type and XML encoding. 
Globally replaced the term "CHECKIN URI" by "version URI" Added note about how to discover whether the server actually applied the expected version URI. 
Made sure artwork (figures) fits into 72 columns. 
Links: Submitted version in HTML format: http://greenbytes.de/tech/webdav/draft-reschke-deltav-compute-checkin-uri-0 
1.html Current version: http://greenbytes.de/tech/webdav/draft-reschke-deltav-compute-checkin-uri-l 
atest.html 
