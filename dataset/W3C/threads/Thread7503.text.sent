Collections 1. State explicitly that a WebDAV server must treat its HTTP URL hierarchy as collections, whether or not they were created with WebDAV's MKCOL. 
So they must have resourcetype = collection, etc. 2. I'm going to raise the issue of ordered collections again, because this version of the specification explicitly states that collections are not ordered. 
I have been arguing for some time that standardizing ordering for collections would be very useful, and I believe that others on the list share my view. 
Of course, Jim has the last word on whether we have reached consensus, and I bow to his judgment. 
Ellis also pointed out that if we do have ordering for collections, it is sometimes useful to allow a resource to be a member of the same collection more than once. 
3. Semantics of external members There are several points in the specification where I think the semantics of external collection members is mistaken. 
I think that the reason for all of the anomalies is that you have decided to implement external members as a property of the collection resource. 
This implementation choice does not force us to have the mistaken semantics, but it makes it more difficult to get the semantics right. 
I would argue that the semantics should drive the implementation (and in fact we don't have to tell servers how to implement external members at all). 
So here are the problems: Getting a listing of the members of a collection should result in a list that includes both internal and external members, but according to 7.1 the list will include internal members only. 
A Depth = 0 COPY operation should not copy any members, internal or external. 
The new collection should not have any members. 
But according to section 7.10.3, the new collection will have external members copied from the old collection. 
The Depth header should define the behavior of a method for both internal and external children, but according to 8.3 it affects only the behavior for internal children. 
4. (A minor point) DELETE for Non-Collection Resources (7.8.1): Actually, everything you say here applies to all resources, whether they are collections or not. 
Then 7.8.2 goes on to discuss DELETE behavior that applies only to collections. 
Links I think it would be worth introducing the notion of links somewhere in section 2. Section 3.4 refers to them without having introduced them at all, and support for links between resources of arbitrary media types is really a significant contribution of WebDAV. 
Here's some text, if you like: "Although HTML resources support links to other resources, the Web needs more general support for links between resources of any media types. 
WebDAV provides such links. 
A WebDAV link is a special type of property, formally defined in section 11.4, that allows typed connections to be established between resources of any media types. 
The property value consists of a source URL and a destination URL, and the property name identifies the link type." 
I also wonder if the formal definition of link is right. 
It says: But the accompanying text says you are trying to allow for multiple links of the same type on the same resource, so do you really mean: Or are you trying to allow a single link to have multiple sources or multiple destinations? 
Or both, perhaps: Typos 7.9.1 "...are not otherwise effected." 
Should be "affected". 
11 "(i.e., to further restrict . 
. 
.)" should be "(e.g., to further restrict . 
. 
.)" Name:Judith A. Slein E-Mail:slein@wrc.xerox.com 
Xerox Corporation Mail Stop 105-50C 800 Phillips Road Webster, NY 14580 [Dylan Barrell] Comments Below 3. Semantics of external members There are several points in the specification where I think the semantics of external collection members is mistaken. 
I think that the reason for all of the anomalies is that you have decided to implement external members as a property of the collection resource. 
This implementation choice does not force us to have the mistaken semantics, but it makes it more difficult to get the semantics right. 
I would argue that the semantics should drive the implementation (and in fact we don't have to tell servers how to implement external members at all). 
So here are the problems: Getting a listing of the members of a collection should result in a list that includes both internal and external members, but according to 7.1 the list will include internal members only. 
A Depth = 0 COPY operation should not copy any members, internal or external. 
The new collection should not have any members. 
But according to section 7.10.3, the new collection will have external members copied from the old collection. 
The Depth header should define the behavior of a method for both internal and external children, but according to 8.3 it affects only the behavior for internal children. 
[Dylan Barrell] I Agree absolutely with Judith. 
The external memebers should not differ from internal members in anything other than a property defining whether they are external or internal. 
The content of the external member should then simply be the URI to the external reference. 
This would result in a much cleaner implementation. 
Cheers Dylan See my comments below: Collections 1. State explicitly that a WebDAV server must treat its HTTP URL hierarchy as collections, whether or not they were created with WebDAV's MKCOL. 
So they must have resourcetype = collection, etc. [SKREDDY] Yes. 
Also, what about the backward compatibility. 
What happens if WEBDAV clients are trying to retrive properies of URL hierarchy created outside this protocol? 
What is acceptable in this scenario? 
2. I'm going to raise the issue of ordered collections again, because this version of the specification explicitly states that collections are not ordered. 
I have been arguing for some time that standardizing ordering for collections would be very useful, and I believe that others on the list share my view. 
Of course, Jim has the last word on whether we have reached consensus, and I bow to his judgment. 
Ellis also pointed out that if we do have ordering for collections, it is sometimes useful to allow a resource to be a member of the same collection more than once. 
[ SKREDDY] I agree with Judith and Ellis on this. 
May be we can do some more discussion on this issue and come to some consensus on this. 3. Semantics of external members There are several points in the specification where I think the semantics of external collection members is mistaken. 
I think that the reason for all of the anomalies is that you have decided to implement external members as a property of the collection resource. 
This implementation choice does not force us to have the mistaken semantics, but it makes it more difficult to get the semantics right. 
I would argue that the semantics should drive the implementation (and in fact we don't have to tell servers how to implement external members at all). 
So here are the problems: Getting a listing of the members of a collection should result in a list that includes both internal and external members, but according to 7.1 the list will include internal members only. 
A Depth = 0 COPY operation should not copy any members, internal or external. 
The new collection should not have any members. 
But according to section 7.10.3, the new collection will have external members copied from the old collection. 
The Depth header should define the behavior of a method for both internal and external children, but according to 8.3 it affects only the behavior for internal children. 
[SKREDDY] Why should external members different from internal memebers. 
We should treat internal and external members same this would lead to much better and cleaner implementation. 
Regards, -Surendra Email.skreddy@us.oracle.com 
"It is unwise to be too sure of one's own wisdom. 
It is healthy to be reminded that the strongest might weaken and the wisest might err." 
Warning: Statements and opinions stated herein may not be those of Oracle Corp. Collections 1. State explicitly that a WebDAV server must treat its HTTP URL hierarchy as collections, whether or not they were created with WebDAV's MKCOL. 
So they must have resourcetype = collection, etc. 2. I'm going to raise the issue of ordered collections again, because this version of the specification explicitly states that collections are not ordered. 
I have been arguing for some time that standardizing ordering for collections would be very useful, and I believe that others on the list share my view. 
Of course, Jim has the last word on whether we have reached consensus, and I bow to his judgment. 
Ellis also pointed out that if we do have ordering for collections, it is sometimes useful to allow a resource to be a member of the same collection more than once. 
3. Semantics of external members There are several points in the specification where I think the semantics of external collection members is mistaken. 
I think that the reason for all of the anomalies is that you have decided to implement external members as a property of the collection resource. 
This implementation choice does not force us to have the mistaken semantics, but it makes it more difficult to get the semantics right. 
I would argue that the semantics should drive the implementation (and in fact we don't have to tell servers how to implement external members at all). 
So here are the problems: Getting a listing of the members of a collection should result in a list that includes both internal and external members, but according to 7.1 the list will include internal members only. 
A Depth = 0 COPY operation should not copy any members, internal or external. 
The new collection should not have any members. 
But according to section 7.10.3, the new collection will have external members copied from the old collection. 
The Depth header should define the behavior of a method for both internal and external children, but according to 8.3 it affects only the behavior for internal children. 
4. (A minor point) DELETE for Non-Collection Resources (7.8.1): Actually, everything you say here applies to all resources, whether they are collections or not. 
Then 7.8.2 goes on to discuss DELETE behavior that applies only to collections. 
Links I think it would be worth introducing the notion of links somewhere in section 2. Section 3.4 refers to them without having introduced them at all, and support for links between resources of arbitrary media types is really a significant contribution of WebDAV. 
Here's some text, if you like: "Although HTML resources support links to other resources, the Web needs more general support for links between resources of any media types. 
WebDAV provides such links. 
A WebDAV link is a special type of property, formally defined in section 11.4, that allows typed connections to be established between resources of any media types. 
The property value consists of a source URL and a destination URL, and the property name identifies the link type." 
I also wonder if the formal definition of link is right. 
It says: But the accompanying text says you are trying to allow for multiple links of the same type on the same resource, so do you really mean: Or are you trying to allow a single link to have multiple sources or multiple destinations? 
Or both, perhaps: Typos 7.9.1 "...are not otherwise effected." 
Should be "affected". 
11 "(i.e., to further restrict . 
. 
.)" should be "(e.g., to further restrict . 
. 
.)" Name:Judith A. Slein E-Mail:slein@wrc.xerox.com 
Xerox Corporation Mail Stop 105-50C 800 Phillips Road Webster, NY 14580 Comments below: On Thursday, January 22, 1998 2:00 PM, Judith Slein hierarchy I agree. 
As I recall, you made this comment when you reviewed the spec. 
right before it was released. 
I'm not sure why it wasn't addressed then, but language to this effect will be added to the next draft. 
like: I agree. 
Hmm. 
Right now we use the link element in the source property, which is defined: Combined with the definition of link: This allows the source property to contain multiple links, each of which can have multiple sources and multiple destinations, as is shown in the example in Section 12.11.1. 
It seems that there is a slight advantage to keeping the definition of link singular (i.e., only one single link) since this way you can specify a property to only include a single link. 
If link was defined like: It would be impossible to specify only a single link without creating a new production. 
So, my inclination is to leave the specification as-is. 
Do you agree? 
Agreed. 
This one is moot. 
I think that i.e. is OK here, but the best solution is to rewrite the sentence so i.e. isn't needed. 
- Jim Yes, you are right about the definition of link. 
Keep it the way it is. 
Jim/Judith, I am little bit confused with COPY, MOVE and DELETE operations. 
I have gone through the scenarios document, and protocol document. 
I would appreciate if someone can explain to me how the following scenarios are handled using the current protocol spec. 
I am not trying to take whole group back to use case analysis stage, but, my objective here is to make sure that current protocol has all definitions and explanations to have a clean implementation. 
Otherwise, to overcome some of the limitation each implementor will choose their own way of interpretion and which lead to interoperability issues. 
Scenario A:Jane directs that the page P and all subordinate objects be deleted from the web W. Joe directs his web browser to retrieve page P from the web W. Issue here is: If deletion of page P and associated subordinate objects from the Web W takes sometime to process, then Joe requests this page and by that time some references to that page might have deleted already and hence joe sees broken links on page P. This throws an integrity issue. 
Or in other case, assume joe had already started editing this page P. Jane deleted this and when joe gets into publishing stage there is no matching properties associated with the same document. 
Scenario B: Jane directs that collection C be moved to collection D. While this move operation in progress. 
joe directs his editor to take a write(exclusive) lock on Collection D. This request will succeed as MOVE operation hasn't taken any explicit lock on Collection D. If this assumption is right, then, rest of the move operation will fail as EXCLUSIVE WRITE lock has acquired by joe on collection D and jane cannot be completed either server will be WAITING for lock release on collection D. I think, to make the spec more clearer, good add some more explanation on COPY, MOVE and DELETE methods, how locks are issued on source and target resources for these operations and impact of this on relevant methods. 
Regards, -Surendra Email.skreddy@us.oracle.com 
"It is unwise to be too sure of one's own wisdom. 
It is healthy to be reminded that the strongest might weaken and the wisest might err." 
Warning: Statements and opinions stated herein may not be those of Oracle Corp. Yes, you are right about the definition of link. 
Keep it the way it is. 
objects be web W. subordinate objects and by that time sees broken links on already started editing matching Maybe I am assuming too much, but if I was a user of a commercial-grade WebDAV system, I would just assume that appropriate locks were taken out automatically on the subordinate objects, so that Joe could not access P or its subordinate objects once Jane had set the deletion in motion. 
I would assume this without it being in the spec, as this has been standard practice in the relational DB world for a number of years, and this problem is nearly (maybe exactly) isomorphic to the "SQL DELETE on related tables" problem. 
(For a non-DBA, it seems like I've spent a lot of time on DB-related issues...) However, other users might make a different assumption. 
(For a freeware WebDAV system, it might be acceptable to let Joe look at a page with broken links while a deletion was in progress. 
One of the major strengths of Tim BL's approach to hypertext was breaking out of the Dexter hypertext model, where every link was guaranteed to work -- Dexter-based hypertext would never have worked over the Internet, which is never all working at the same time.) Mark Leighton Fisher Thomson Consumer Electronics fisherm@indy.tce.com 
Indianapolis, IN "Browser Torture Specialist, First Class" This assumption is false. 
The spec says explicitly that GET is unaffected by locks. 
Perhaps this indicates the need for a sentence or two in the spec to explicitly call out this possibility for integrity violations. 
I acknowledge in advance the need for a balance between tutorial/cautionary material and straightforward exposition, but if this is a plausible misunderstanding then perhaps it is good to try a little harder to fend it off. 
Surendra, On Friday, January 23, 1998 3:01 PM, Surendra Reddy spec. 
sure some issues. 
Judging by the discussion this has started, this is a worthwhile activity. 
be on There are at least two possible ways of handling this situation, and both are completely acceptable (intentionally so) according to the current language in the -06 spec. 
These two situations correspond to the two different types of servers in Mark Fisher's post (database and "freeware") a) ("freeware") The server happily returns page P to Joe, and page P may very well contain broken links. 
As both Jim Davis and Mark fisher have pointed out, the web is optimized for distribution and availability, so this choice is consistent with the design principles of the web. 
b) (database) A smarter web server might note that P's namespace is being deleted, and prevent accesses to this namespace while the operation is taking place. 
Again, both are legal. 
The advantage of this is that a DAV server implemented on a file system doesn't have to use an internal transaction manager, while a DAV server implemented on a database or a document management system can be much more intelligent by making use of its native capabilities. 
If Joe is editing page P without having first taken out a lock, then it is acceptable to Joe to have P change while he is editing it. 
If it is unacceptable to Joe that P change while he is editing it, then Joe must take out a write lock prior to starting his edit session. 
D. write(exclusive) lock as be There are many cases here: 1) If Joe's lock on D is processed before Jane's MOVE operation, the MOVE will fail. 
2) One server strategy is to pause operations on D while the MOVE was taking place. 
In this case, the MOVE would finish, then the lock operation would be performed. 
3) Another strategy is to allow the operations to interleave, allowing the MOVE to start, and then, while the MOVE is underway, start performing the LOCK. 
Even if the MOVE does not MOVE all members of the source collection to the destination, the semantics of MOVE are such that a partial failure does not result in a rollback on failure, so it is OK to interleave without knowing the final outcome. 
on and I agree, a small section on the integrity concerns is probably worthwhile. 
On the other hand, describing all of the possible interactions between all methods is a combinatoric nightmare, and I think this isn't a good idea. 
- Jim Hold it, the spec does not state that GETs are unaffected by locks. 
It states that GETs are unaffected by WRITE locks. 
This is only one kind of lock. 
I know that a read lock spec will be released in the near future (mostly because I have to write it). 
Additionally our syntax allows for one to request multiple lock types simultaneous so one could, for example, ask for a read/write exclusive lock. 
This would create the sort of atomicity that has been asked for. 
Yaron From:Jim Davis [SMTP:jdavis@parc.xerox.com] 
Sent:Monday, January 26, 1998 10:42 AM Subject:RE: Comments on 06 spec on and I agree, a small section on the integrity concerns is probably worthwhile. 
On the other hand, describing all of the possible interactions between all methods is a combinatoric nightmare, and I think this isn't a good idea. 
- Jim [Dylan Barrell] I agree. 
Add to the above examples the fact that a user may have a lock on a resource which is part of a large tree which is being operated-on (e.g. DELETED) and there is no good solution for all cases (with the current spec). 
It doesn't deal with the case where a whole subtree should be deleted where one or more resources are already locked (because DELETE is not atomic and can be partially successful). 
I think we should be explicitly optimistic in the spec as it will cause little problems in practice because if the user noticed the inconsistency and performed a reload it is very likely that the resource being accessed will have been deleted, moved, copied too. 
I originally made a reference to this problem about six months ago when I asked for publishing methods to be included in WebDAV. 
This would allow the principle manipulating the namespace to "unpublish" the effected namespaces (an atomic operation), perform the operation and the "publish" the results (another atomic operation). 
Nobody took much notice of this at the time. 
I suppose that your server could perform implicit "publish" and "unpublish" operations when the namespace is manipulated (although this is likely to lead to performance problems) Cheers Dylan Hold it, the spec does not state that GETs are unaffected by locks. 
It states that GETs are unaffected by WRITE locks. 
This is only one kind of lock. 
I know that a read lock spec will be released in the near future (mostly because I have to write it). 
Additionally our syntax allows for one to request multiple lock types simultaneous so one could, for example, ask for a read/write exclusive lock. 
This would create the sort of atomicity that has been asked for. 
Yaron -----Original Message----- From:Jim Davis [SMTP:jdavis@parc.xerox.com] 
Sent:Monday, January 26, 1998 10:42 AM Subject:RE: Comments on 06 spec The word for "publish" and "unpublish" is transactioning. 
The TIP group has a nifty protocol which does this and I even wrote a spec for them on how to use it with HTTP. 
It will provide you with what you require. 
Yaron -----Original Message----- From:Jim Davis [SMTP:jdavis@parc.xerox.com] 
Sent:Monday, January 26, 1998 10:42 AM Subject:RE: Comments on 06 spec 
