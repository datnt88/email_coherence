On a slightly different topic: why is a refresh done using locktokens gathered from the If: header, rather than the more obvious Lock-Token: header? 
I can't recall our original rationale. 
We might have been thinking that, since the lock had to exist for the request to be honored, this effectively made the locks existence a precondition, and preconditions are expressed using the If header. 
So do we need to define server behavior if more than one lock is specified in the If header? 
fyi: mod_dav refreshes all of them. 
Interesting. 
And what type of body do you use for success? 
Do you only support it if the locks are on the same resource? 
And how do you respond if some of the refreshes failed? 
So do we need to define server behavior if more than one lock is in the If header? 
fyi: mod_dav refreshes all of them. 
We return a DAV:lockdiscovery element (as defined) which contains multiple DAV:activelock elements (as defined). 
We refresh any locks that are extent on that resource and that we find in the If: header. 
In other words, we'll refresh direct locks and those inherited from Depth:infinity locks further up in the namespace. 
On error, we return a single status code (not a multistatus). 
That's because a refresh is not being applied to multiple resources -- just multiple locks on *one* resource. 
Cheers, -g Greg Stein, http://www.lyra.org/ 
We return a DAV:lockdiscovery element (as defined) which contains multiple DAV:activelock elements (as defined). 
We refresh any locks that are extent on that resource and that we find in the If: header. 
In other words, we'll refresh direct locks and those inherited from Depth:infinity locks further up in the namespace. 
On error, we return a single status code (not a multistatus). 
That's because a refresh is not being applied to multiple resources -- just multiple locks on *one* resource. 
And what about if the if header references several locks on different resources? 
A = the set of locktokens found in the If: header B = the set of locktokens found on the resource (directly and/or through inherited locks) mod_dav refreshes the intersection. 
By "on different resources", if you mean the Request-URI and the resource locked with a Depth:infinity lock (implied by the inherited lock on the Request-URI), then yes. 
If you mean locks implied by a Tagged-List in the If: header, then that just doesn't make sense :-) Happy Thanksgiving, -g Greg Stein, http://www.lyra.org/ 
If you mean locks implied by a Tagged-List in the If: header, then that just doesn't make sense :-) That's what I meant. 
I don't know if it makes sense or not, but I'm perfectly willing to say that "it" is not supported. 
And I agree that it seems somewhat odd that we use the IF header to determine what locks are to be refreshed. 
I would think this should work just as UNLOCK does. 
That's not to say people can't use an IF header, but that's not how they specify which of the locks is to be refreshed. 
The IF header would only be for consistancy checking if the client wanted the refresh to be contingent on the presence of a specified lock on some specified resource. 
Now I also recognize that changing this might break some clients/servers. 
Before we could change this, we'd have to come to a consensus that we're willing to change our implementations. 
J. Hrm; I guess it could make some sense to impute the URIs in a tagged-list as some kind of input parameter. 
We do with the locktokens, after all :-) IMO, this would have been the clearest way to do this. 
It's that pedantic trap again. 
As JimW explained "well, we saw it as a precondition, and preconditions are specified with the If: header, and ..." Well, Office 2000 uses LOCKs and could be argued as one of the more popular clients :-). 
If it doesn't send a Lock-Token header, then we're out of luck. 
The spec would then need to specify behavior in the absence of the Lock-Token header. 
Anybody know if it sends a Lock-Token header when it refreshes its lock? 
Personally: I'd be fine changing mod_dav. 
Simply a lot of stuff, and I really think its the clearest mechanism for the protocol. 
Cheers, -g Greg Stein, http://www.lyra.org/ 
From: ccjason@us.ibm.com 
UNLOCK only contingent I agree with Jason (and others) that this would be the preferable way for a lock refresh to work. 
Cheers, Geoff Anyone that has a locking server or locking client (or knows of one) that would be significantly affected by this alteration or by any other locking changes, please send me a note or post it to this list. 
I'll add you to the locking mailing list. 
I just like to make sure I have a complete list of servers/clients (with email addresses) that are resistant to changes to locking due to 2518 compatibility issues and client base. 
--- note from Geoff Clemm follows ----- From: ccjason@us.ibm.com 
UNLOCK how only contingent I agree with Jason (and others) that this would be the preferable way for a lock refresh to work. 
Cheers, Geoff Anyone that has a locking server or locking client (or knows of one) that would be significantly affected by this alteration or by any other locking changes, please send me a note or post it to this list. 
I'll add you to the locking mailing list. 
I just like to make sure I have a complete list of servers/clients (with email addresses) that are resistant to changes to locking due to 2518 compatibility issues and client base. 
Just in reply to my note above and something Kevin said subsequently about compatibility with clients. 
The transition path could be... Clients use both IF and token header for a while until servers have drifted to the new convention. 
After that, just token headers are used. 
Servers accept token header. 
If not there, they use the if header. 
Eventually the servers would just accept token headers. 
Noone would need to break. 
But I'd like to know if there is even a need for a transition strategy. 
This change would not affect the Python WebDAV server, because it does not implement lock refreshing at all. 
