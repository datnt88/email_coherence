Except when there is need for that extra bit of range, it seems undesirable to make integer arguments or writable attributes that are not enumerations "unsigned". 
It doesn't matter in Java or JavaScript, since neither supports the concept of unsigned numbers. 
It does, however, make implementations in other language either fail differently or incorrectly succeed, since C and C++ will transparently convert a negative signed number into a large positive number. 
Obviously, it is too late to change the existing L2 and below methods, but we should avoid adding any more problems. 
There did not seem to be any examples in Core, Load/Save. 
In ASLS: minOccurs and maxOccurs in ASModel.createASContentModel() ASObjectList.length ASObjectList.item(index) ASNamedObjectMap.length ASNamedObjectMap.item(index) ASContentModel.minOccurs 
ASContentModel.maxOccurs 
CharacterDataEditAS.*(offset,count) In Xpath: XPathResult.snapshotItem(index) XPathResult.snapshotLength not really necessary since it is read-only, but for consistency In none of these cases does it appear that range is an issue. 
Java and Javascript implementions will have to raise an appropriate exception when negative values are passed. 
Encouraging other bindings that support unsigned numbers to silently treat negative values are large positive values isn't beneficial. 
Using signed values for maxOccurs would have the benefit of allowing the more accessible -1 to be used for "unbounded" instead of Integer.MAX_VALUE. 
Actually in C at least I believe most users would prefer 'int' because it's much easier to type and on most systems INT_MAX is 2GB whereas UINT_MAX is 4GB which means using unsigned is only (maybe) useful for marking stream positions and file sizes. 
The use of unsigned long in methods like: void deleteData(in unsigned long offset, in unsigned long count) raises(DOMException); is obviously not necessary. 
On systems where int is 16 bits or less a dom should probably not be manipulating continuous strings of 32K considering the machine probably wouldn't have much more main memory than that. 
Mike 
Can't go back and undo the past. 
However, I'd strongly encourage C++ DOM's to also expose signed variants of methods that take unsigned args. 
The signed methods would check for negatives and throw an exception (behaving like the Java/JavaScript implementations) and then delegate to the unsigned implementation. 
Then the caller can then control whether the checking or unchecking implementation is used by selecting to do the string math using either signed or unsigned ints and avoid the transparent promotion to unsigned. 
However, for new stuff there is no reason to continue doing the same old thing. 
