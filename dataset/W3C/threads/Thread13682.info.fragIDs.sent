I'm proposing a number of good changes, that will let us be much clearer about threading (state) and some of the other issues raised, as discussed in the following IRC log:- 02:55:04 sbp * sbp cleans up the EARL 1.0 test specification 02:55:21 sbp I'm wondering how to capture threading in EARL; if it's even necessary, etc. 02:55:48 sbp also, we need to be able to point to very discrete things... precision is critical 02:56:12 AaronSw threading? 
02:56:39 sbp yes: how to say that you're evaluating the "same thing" 02:56:48 AaronSw sbp, equivalentTo? 
02:57:11 sbp no, it's not equivalentTo, because the content has changed... that's the point 02:57:21 sbp for example you might say "this was broken, now it's fixed" 02:57:39 sbp those are two different resources (one is a :Broken, the other is a :Fixed) 02:57:47 sbp but the author may regard them as not being so 02:57:54 sbp The basic model is: :Assertor earl:asserts { :SomeResource earl:passes :SomeTest } . 
02:58:21 sbp let's say that the Assertor is the author of :SomeResource, and it doesn't comply to WCAG 1.0 02:58:26 sbp it'd be... 02:58:42 sbp :Assertor earl:asserts { :SomeResource earl:fails :WCAG10 } . 
02:58:49 sbp then he fixes the page 02:58:59 sbp :Assertor earl:asserts { :SomeNewResource earl:passes :WCAG10 } . 
02:59:09 AaronSw Aha. 
02:59:25 AaronSw :SomeNewResource :previousVersion :SomeResource . 
02:59:25 sbp now, he wants to say, the "general thing" identified in :SomeResource is the same as in :SomeNewResource 02:59:37 sbp well, that was one of quite a few suggestions, yes 03:00:01 sbp I also suggested a DAML List: (:SomeResource :SomeNewResource) a earl:Thread . 
03:00:11 sbp but now I think that's unecessary 03:01:05 sbp because an EARL TestSubject (the subject in the formula) is actually comprised (as per your suggestion!) of a resource, and a date or some other disambiguating property 03:01:16 AaronSw :-) 03:01:23 AaronSw I don't like the list idea. 
03:01:28 sbp so it's quite easy to do the logic on the following:- 03:01:57 sbp :SomeResource :resource http://example.org/ 
; :date "2001-10" . 
:SomeNewResource :resource http://example.org/ 
; :date "2001-11" . 
03:02:24 sbp list idea: well, you're probably right 03:02:41 AaronSw Yeah, doing inferences on the dates would be even better: 03:02:45 sbp it's difficult to construct a list automatically 03:03:57 AaronSw { ?x 
:resource ?uri ; :date ?date . 
?y :resource ?uri ; :date ?date2 . 
?date :laterThan ?date2 
.} 
= { ?x 
:previousVersion ?y 
} . 
03:04:09 AaronSw and make laterThan a cwm builtin 03:07:01 sbp well, you want to *filter* out all of the previous versions. 
{ ?x 
:resource ?u; 
:date :d2 . 
?y :resource ?u; 
:date ?d2 . 
?d1 :laterThan ?d2 
} log:implies { ?y 
:resource ?u; 
:date ?d2 
} . 
03:07:49 sbp that'd only work for two things, though... not sure how you'd get the "latest" property 03:07:49 sbp s/property/value/ 03:08:16 sbp er the first d2:- 03:08:16 sbp s/d2/d1/ 03:08:28 sbp oh, let me do that again 03:08:41 sbp { ?x 
:resource ?u; 
:date :d1 . 
?y :resource ?u; 
:date ?d2 . 
?d1 :laterThan ?d2 
} log:implies { ?y 
:resource ?u; 
:date ?d1 
} 03:09:32 sbp note that we use "testSubject" at the moment instead of resource. 
I'm thinking of calling it resource... but actually, that's wrong 03:10:04 sbp the resource at time a should be the same as at time a' 03:10:04 sbp it really means the representation of 03:10:04 sbp :reprOf 03:10:32 sbp ah, that's perfect! 
03:10:47 sbp :MyPageInOct earl:reprOf http://example.org/ 
; earl:date "2001-10" . 
03:11:12 sbp then you can add additional facets such as content negotiation, and so on 03:11:13 sbp :MyPageInOct earl:reprOf http://example.org/ 
; earl:date "2001-10"; dc:format "text/html"; :language "en" . 
03:12:21 sbp the problem then is that: earl:reprOf rdfs:domain :WebContent . 
03:12:52 sbp it's a physical bag of bytes (well, I should go through the UAAG terminology for that) 03:13:34 sbp but in EARL, we want to be able to assess tools as well. 
Ah, then you just leave the earl:reprOf bit out 03:13:59 sbp we can set a cardinality restriction on the earl:WebContent class so that it must have exactly one "reprOf" arc coming off of it. 
That makes a lot of sense 03:15:24 sbp O.K., so, changes:- 
03:15:33 sbp * Remove testSubject 03:15:40 sbp * Add reprOf 
03:16:07 sbp * Set cardinality restriction on WebContent to have 1 and only 1 reprOf 03:16:52 sbp * Add conneg and langneg (?) 03:16:52 sbp * Add isDefinedBy arcs 03:20:08 sbp Now, do we want to give an arc for earl:Tool/earl:UA etc. that gives more information/download etc.? 03:20:16 sbp s/an arc/some arcs/ 03:21:32 AaronSw Hmm. 
]]] - http://blogspace.com/swhack/chatlogs/2001-12-09.txt 
I need to go through UAAG carefully, and I'm still hacking on stuff, but it's getting quite neat now. 
Cheers, Kindest Regards, Sean B. Palmer @prefix : http://purl.org/net/swn# . 
:Sean :homepage http://purl.org/net/sbp/ . 
Couple of thoughts: One is that a set of evaluations might not completely overlap - I do one lot of tests on day 1, and I do half of those again plus some new test on day 3, and Sean does half of the overlapping ones plus half of each lot of others plus a new set on day 5. Is threading the right way to go about this? 
I ahve been thinking for a whie about using annotea as one model of storing assertions - we should look at the way it threads annotations. 
Also, is there any reason why CC/PP isn't sufficient for providing "context" - language and content negotiation information that was used? 
Cheers Charles I'm proposing a number of good changes, that will let us be much clearer about threading (state) and some of the other issues raised, as discussed in the following IRC log:- 02:55:04 sbp * sbp cleans up the EARL 1.0 test specification 02:55:21 sbp I'm wondering how to capture threading in EARL; if it's even necessary, etc. 02:55:48 sbp also, we need to be able to point to very discrete things... precision is critical 02:56:12 AaronSw threading? 
02:56:39 sbp yes: how to say that you're evaluating the "same thing" 02:56:48 AaronSw sbp, equivalentTo? 
02:57:11 sbp no, it's not equivalentTo, because the content has changed... that's the point 02:57:21 sbp for example you might say "this was broken, now it's fixed" 02:57:39 sbp those are two different resources (one is a :Broken, the other is a :Fixed) 02:57:47 sbp but the author may regard them as not being so 02:57:54 sbp The basic model is: :Assertor earl:asserts { :SomeResource earl:passes :SomeTest } . 
02:58:21 sbp let's say that the Assertor is the author of :SomeResource, and it doesn't comply to WCAG 1.0 02:58:26 sbp it'd be... 02:58:42 sbp :Assertor earl:asserts { :SomeResource earl:fails :WCAG10 } . 
02:58:49 sbp then he fixes the page 02:58:59 sbp :Assertor earl:asserts { :SomeNewResource earl:passes :WCAG10 } . 
02:59:09 AaronSw Aha. 
02:59:25 AaronSw :SomeNewResource :previousVersion :SomeResource . 
02:59:25 sbp now, he wants to say, the "general thing" identified in :SomeResource is the same as in :SomeNewResource 02:59:37 sbp well, that was one of quite a few suggestions, yes 03:00:01 sbp I also suggested a DAML List: (:SomeResource :SomeNewResource) a earl:Thread . 
03:00:11 sbp but now I think that's unecessary 03:01:05 sbp because an EARL TestSubject (the subject in the formula) is actually comprised (as per your suggestion!) of a resource, and a date or some other disambiguating property 03:01:16 AaronSw :-) 03:01:23 AaronSw I don't like the list idea. 
03:01:28 sbp so it's quite easy to do the logic on the following:- 03:01:57 sbp :SomeResource :resource http://example.org/ 
; :date "2001-10" . 
:SomeNewResource :resource http://example.org/ 
; :date "2001-11" . 
03:02:24 sbp list idea: well, you're probably right 03:02:41 AaronSw Yeah, doing inferences on the dates would be even better: 03:02:45 sbp it's difficult to construct a list automatically 03:03:57 AaronSw { ?x 
:resource ?uri ; :date ?date . 
?y :resource ?uri ; :date ?date2 . 
?date :laterThan ?date2 
.} 
= { ?x 
:previousVersion ?y 
} . 
03:04:09 AaronSw and make laterThan a cwm builtin 03:07:01 sbp well, you want to *filter* out all of the previous versions. 
{ ?x 
:resource ?u; 
:date :d2 . 
?y :resource ?u; 
:date ?d2 . 
?d1 :laterThan ?d2 
} log:implies { ?y 
:resource ?u; 
:date ?d2 
} . 
03:07:49 sbp that'd only work for two things, though... not sure how you'd get the "latest" property 03:07:49 sbp s/property/value/ 03:08:16 sbp er the first d2:- 03:08:16 sbp s/d2/d1/ 03:08:28 sbp oh, let me do that again 03:08:41 sbp { ?x 
:resource ?u; 
:date :d1 . 
?y :resource ?u; 
:date ?d2 . 
?d1 :laterThan ?d2 
} log:implies { ?y 
:resource ?u; 
:date ?d1 
} 03:09:32 sbp note that we use "testSubject" at the moment instead of resource. 
I'm thinking of calling it resource... but actually, that's wrong 03:10:04 sbp the resource at time a should be the same as at time a' 03:10:04 sbp it really means the representation of 03:10:04 sbp :reprOf 03:10:32 sbp ah, that's perfect! 
03:10:47 sbp :MyPageInOct earl:reprOf http://example.org/ 
; earl:date "2001-10" . 
03:11:12 sbp then you can add additional facets such as content negotiation, and so on 03:11:13 sbp :MyPageInOct earl:reprOf http://example.org/ 
; earl:date "2001-10"; dc:format "text/html"; :language "en" . 
03:12:21 sbp the problem then is that: earl:reprOf rdfs:domain :WebContent . 
03:12:52 sbp it's a physical bag of bytes (well, I should go through the UAAG terminology for that) 03:13:34 sbp but in EARL, we want to be able to assess tools as well. 
Ah, then you just leave the earl:reprOf bit out 03:13:59 sbp we can set a cardinality restriction on the earl:WebContent class so that it must have exactly one "reprOf" arc coming off of it. 
That makes a lot of sense 03:15:24 sbp O.K., so, changes:- 
03:15:33 sbp * Remove testSubject 03:15:40 sbp * Add reprOf 
03:16:07 sbp * Set cardinality restriction on WebContent to have 1 and only 1 reprOf 03:16:52 sbp * Add conneg and langneg (?) 03:16:52 sbp * Add isDefinedBy arcs 03:20:08 sbp Now, do we want to give an arc for earl:Tool/earl:UA etc. that gives more information/download etc.? 03:20:16 sbp s/an arc/some arcs/ 03:21:32 AaronSw Hmm. 
]]] - http://blogspace.com/swhack/chatlogs/2001-12-09.txt 
I need to go through UAAG carefully, and I'm still hacking on stuff, but it's getting quite neat now. 
Cheers, Kindest Regards, Sean B. Palmer @prefix : http://purl.org/net/swn# . 
:Sean :homepage http://purl.org/net/sbp/ . 
Location: 21 Mitchell street FOOTSCRAY Vic 3011, Australia (or W3C INRIA, Route des Lucioles, BP 93, 06902 Sophia Antipolis Cedex, France) 
"Sean B. Palmer" 
I'm concerned this moves away from EARL as being general purpose evaluate/report on anything language, to a language for reporting on webpages (with different "EARL"s for UA's etc.) I'm also concerned that by introducing threading it complicates evaluations which should be unthreaded, which as I see the uses is more common (multiple tools/people make evaluations but testSubjects change infrequently.) Threading only seems to be of value within a single evaluator, ie I only believe we can trust Tool says resource fails, Tool later says resource passes - unless my particular EARL tool has defined some sort of trust relationship between tools. 
I can't see how EARL could define how Tool1 says resource fails, Tool2 later saying resource passes as we don't know if it's a defective tool, or a change of resource, or some "unknown" content negotiation. 
(As to why CC/PP is not sufficient, is it's got no support, and the current proposals make no sense so I can't see it having any support for many years - content negotiation based on browser is a very bad idea.) Jim. 
(cc'd to Aaron as the original was...) 
