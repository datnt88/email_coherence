Jeremy and I talked about the resolution of rdfms-not-id-and-resource-attr after chatting about the syntax WD in general and agree that we both see the two alternatives as 1) rdf:ID is always allowed and reifys the 1 statement parent node URI propertyElt URI rdf:resource URI . 
2) rdf:ID is never allowed. 
If you want to reify that statement, use the expanded form rather than this abbreviation. 
Jeremy slightly prefers #1 but could live with #2 ("I could 'concur' with such a position"). 
I don't really care as long as we pick one only way, thus I propose #1. 
Both of these answers changes what the existing M&amp;S says but it is something that hardly anyone used/uses. 
For the latter reason, I did suggest deleting it in my original text but I'm happy with #1, #2 above. 
I propose to close this issue by making the appropriate change to the syntax grammar in production from [attributes]=set((idAttr | resourceAttr)?, bagIdAttr?, propertyAttr*) to [attributes]=set(idAttr?, resourceAttr?, bagIdAttr?, propertyAttr*) [ WAS 4th clause of ' ' propName idRefAttr? 
bagIdAttr? 
propAttr* '/ ' Plus more words to say what the combinations of these do when I write the mappings. 
Dave Thanks for calling this out Dave. 
I'd like to see a general policy that proposals that change what M&amp;S says, or the common interpretation of what it says, are specifically highlighted. 
It would be easier to just say, we are not changing the current spec, but we already have precedent, aboutEachPrefix, that we will change something if we feel there are very strong reasons to do so. 
I haven't seen any such case made for this change. 
The barrier for making changes is set very much higher than for 'clarifications'. 
A strong case must be made that the change is necessary. 
There must be a strong call from the community to make the change. 
And we must be sure we have evidence of how existing code and data and will be affected. 
And there must be good reason why it cannot wait till we have a more relaxed charter. 
We should resist the temptation to fix things that we don't like but are not really broken. 
Lets save those for rdf 2. Brian Brian McBride said: I've no particular strong reason for making this change, rather than just neatness or consistency and as issue owner, I want to get it closed. 
In this case it seems like even if it was not used much, we can keep it around in the syntax without too much trouble - solving it with better wording and specification. 
Anyone who has a very good reason for a requirement to change this, please can you give evidence, as Brian asks. 
Dave Brain: Dave: WARNING WARNING JEREMY IS EXPLODING ... :) I feel strongly about this. 
The 'common interpretation' is not defensible. 
The two resolutions Dave proposed are defensible. 
here goes .... [This concerns exclusively the interpretation of rdf:ID on propertyELt productions]. 
*strong reasons* 1: The current spec is self contradictory. 
2: The 'common interpretation' (by a few members of this WG) of this differs from any plausible reading of the spec. 
3: The current spec or the common interpretation both present considerable burden to understanding the reification rules in RDF/XML, and hence fundamentally limit the take-up of the use of reification. 
4: The current spec is how it is because of an editorial oversight. 
This is an honest-to-goodness error, and should be corrected. 
5: There are a number of cases in the mail archives of both novices and experts being confused by this issue (including DanC, and myself). 
6: There is no record of any argument for it being like this. 
No one, who has been aware of the contradiction between: [[[ (Para 232) r2 is the resource named by the resource attribute if present or a new resource. 
If the ID attribute is given it is the identifier of this new resource. 
and: [[[ (Para 214) The value of the ID attribute, if specified, is the identifier for the resource that represents the reification of the statement. 
has ever articulated reasons for para 232, the best is the "backwards compatibility" argument. 
7: Whenever this is discussed in any mailing list no-one actually says they use para 232; it is only a few parser writer (almost all represented in the WG) who have any legacy to be backwardly compatible about. 
I will, in follow up messages, expand many of these points. 
This is wrong. 
It was always a mistake. 
It was not the intent of M&amp;S. 
It has never been implemented. 
There is no legacy. 
It is a burden to implementators. 
It is a burden to document writers (if any of them wish to use the facilities provided?) To remove Para 232 (by not creating text that repeats it) will be a genuine clarification that comes about as part of our task of rearticulating M&amp;S. 
It will be in keeping with the intent of the previous WG much more so than the necessary clarification concerning unqualified attributes. 
From our charter: We should make limited fixes, clarifications and improvements to the specification of RDF's abstract model and XML syntax. 
and it is the responsibility of this group to not let near-term deployment considerations grossly increase the future costs (to implementors, authors, users, etc.) of new features. 
Introspective use of metadata requires use of reification, this was a core issue for the old WG and one they ensured was handled in the syntax. 
They had one or two aborted attempts at articulating reification, and by editorial accident, some text from one of these (para 232) ended up in the final spec. 
As it is, RDF applications to date have made less use of reification than the original WG hoped for. 
If we wish to continue that hope then we should clarify their intent: make reification easy, rather than leave this horrendous corner case in. 
This argues in favour of consistently reading rdf:ID as reification rather than disallowing it in one case for spurious historical reasons. 
Lance the boil. 
Jeremy PS: I am taking some risks in overstating my case - like asserting para 232 has never been used by a document writer in anger. 
Later, I will assert that para 229 has never been implemented, I might be wrong, but it will more fun if I stick my neck out. 
Brian: I suspect most of the members of the community who understand this issue are in the WG. Brian: Agreed. 
This is really broken. 
Argued elsewhere. 
It acts as a significant barrier to the use of the RDF/XML reification syntax, and hence as a barrier to the use of reification. 
If reification is a good thing (which is moot, but I think we should assume) then this needs fixing. 
Jeremy Jeremy: Here is a (biased) guide to the current spec: In section 6, where the style of the spec is precise and rigorous, as opposed to the chatty introductory materal earlier Para 214: Within propertyElt (production [6.12]), the URI used in a resource attribute identifies (after resolution) the resource that is the object of the statement (i.e., the value of this property). 
The value of the ID attribute, if specified, is the identifier for the resource that represents the reification of the statement. 
There is no indication that this is restricted to only some of the expansions of production 6.12. 
Significantly later, after a number of unrelated issues have been discussed (namespaces, unicode, string equality, xml:lang), we arrive at para 229 Properties and values expressed in XML attribute form within an empty XML element E by productions [6.10] and [6.12] are equivalent to the same properties and values expressed as XML content of a single Description element D which would become the content of E. The referent of D is the value of the property identified by the XML element name of E according to productions [6.17], [6.2], and [6.3]. 
Specifically; each propertyElt start tag containing attribute specifications other than ID, resource, bagID, xml:lang, or any attribute starting with the characters xmlns results in the creation of the triples {p,r1,r2}, {pa1,r2,va1}, ..., {pan,r2,van} where 1. [...snip...] 2. [...snip...] [[[ para 232 3. r2 is the resource named by the resource attribute if present or a new resource. 
If the ID attribute is given it is the identifier of this new resource. 
4. [...snip...] 5. [...snip...] The 'common interpretation' goes + para 232 and para 214 contradict one another, + para 232 specifically applies when the condition specified in para 229 is true + thus para 229 implies that para 214 doesn't hold in certain cases. 
This interpretation of self-contradictory text is appropriate reasoning when reading introductory material, when the technique of leaving some complexity to later is often found; it is also appropriate when the proximity of the paragraphs and the overall textual structure makes it clear that an "if then else" structure is intended. 
Neither of these is present here, and we are faced with a contradiction, a mistake, an erratum. 
It is the job of this WG to fix errata. 
The 'common interpretation' also links in with production 6.12. 
viz: [6.12] propertyElt ::= ' ' propName idAttr? 
' ' value ' /' propName ' ' ' ' propName idAttr? 
parseLiteral ' ' literal ' /' propName ' ' ' ' propName idAttr? 
parseResource ' ' propertyElt* ' /' propName ' ' '/ ' The common interpretation is that para 214 picks out the final expansion in this production, and in that case para 232 applies. 
That is not what it says. 
Consider the following rdf document: With the common interpretation this becomes: #BAG rdf:type rdf:Bag . 
http://example.org/ rdf:value #id . 
The text of para 229 does not say the fourth expansion of 6.12 but it says "each propertyElt start tag containing attribute specifications other than ID, resource, bagID, xml:lang" The rdf:value in this example is not such a case and hence para 232 does not apply on any reading of M&amp;S. 
Therefore the only possible reading of this particular rdf:ID attribute is that given by para 214, i.e. reification. 
Thus M&amp;S without doubt specifies the following triples for the example: #BAG rdf:type rdf:Bag . 
http://example.org/ rdf:value _:a . 
#id rdf:type rdf:Statement . 
#id rdf:subject http://example.org/ . 
#id rdf:predicate rdf:value . 
#id rdf:object _:a . 
OK, I suspect I am being disingenuous here. 
The following paragaph, the last in section 6 is The value of the bagID attribute, if specified, is the identifier for the Bag corresponding to the Description D; else the Bag is anonymous. 
I don't believe there are any implementations of this last phrase either, the writers of this spec had run out of steam by this point, and were making mistakes. 
The text in this part of the spec does not have a meaning, and we should not give it a false loyalty. 
Earlier Dave articulated two options: Dave: Brian implicitly suggests two other options: 3) re-articulate what M&amp;S says by taking para 232 which is guarded by para 229 as taking precedence in that case over paragraph 214. 
4) articualte, for the first time ever, the 'common interpretation' of what M&amp;S says i.e. using the fourth production of 6.12 as the guard for text like para 232. 
I point out that none of these is backwardly compatible. 
All readings of the spec, the 'common interpretation' in parsers, and any artiuclatable approach, all differ. 
Whichever of these four choices we make we break 'backward compatibility' with something. 
Fortunately there are no users of this construction. 
(I wonder why?) Thus the backward compatibility argument is spurious, and we should ask why there are no users of this construction. 
Two reasons spring to my mind: + maybe reification is less useful than was thought + the lack of clarity about how to use reification effectively, and overly confusing syntactic rules act as obstacles to users, implementators, document writers, documentation writers at all levels. 
Brian said: We don't have a choice but to do something along the lines of (1), (2) (3) or (4) and the argument is not about not fixing things, but about what does the least damage to M&amp;S and rearticulates M&amp;S most faithfully. 
I believe that (1) is that choice. 
Jeremy You know Pearl Jam wrote a song about a Jeremy getting out of control: Art-not-to-old-to-R&amp;R-B P.S. It's hard to believe Ten was released 10 years ago ... Sorry, I'm guilty of using this corner of the spec... 
I read it as saying: rdf:ID on a propElt gives a way to refer to the reified version of a statement. 
I gather that's (1), the choice you're advocating, Jeremy. 
I implemented it that way in some code to conver rules from SHOE to RDF (and to KIF); here's an example from the documentation of that code... Example busy(?who, ?t) 
:- member(?who, 
?group), 
meets(?group, 
?t) -- Inference Rules, an RDF Schema Tue, 01 Aug 2000 20:00:42 GMT Actually, this use of reification doesn't really work they way I was trying to make it work... but that's due to the use/mention bugs I've pointed out elsewhere. 
I agree. 
Meanwhile, the use/mention problems make rdf:subject/predicate/object worthless for the use cases I'm interested in, so my argument for agreeing with Jeremy comes down to aesthetics, not an existing application of RDF 1.0 that I want to support. 
Dan Connolly, W3C http://www.w3.org/People/Connolly/ 
This is apparently in reply to a message from Jeremy. 
Am I the only one who did Brian I think I was mistaken thinking the following ... Jeremy: [meaning a 'drafting' error rather than a 'design' or 'review' error] I now believe that it is probable that when the first versions of the critical paragraphs were drafted the intent was an exclusive reading. 
On a re-examination of the archive I think I have understood the original motivation. 
Summary: In early WDs the serialization syntax and the abbreviated syntax were separate, with only the new productions in the abbreviated syntax. 
These new productions introduced property attributes; they all permitted identical attributes; hence the semantics of these attributes were made uniform accross the three productions (desciption with propAttrs, typedNode with propAttrs and propertyElt with propAttrs). 
The reification reading of rdf:ID, and early versions of para 214, were in the description of the serialization syntax (a distinct subsection from the abbreviated syntax); while the descriptions of all the attributes in the abbreviated form were largely identical across the different productions in the abbreviated form. 
Sources: The following draft introduced the abbreviated syntax but does not describe what an id attribute on any property element means. 
The first text describing what the id attribute on property elements mean is found in This crucially introduces early versions of all critical paragraphs in distinct sections of the document. 
In its discussion of the serialization syntax (section 3.1) The value of the ID attribute, if specified, is the identifier for the node that represents the reification of the property. 
In the discussion of the abbreviated syntax we have: ... else if ID is specified R is a new node whose identifier is the value of the attribute, ... At the same time the group were making major advances in their understanding of reification and how to serialize it. 
bagID is introduced in: Ralph Swick (Dec 8 1997) (The issue list is: Prior to bagID the same concept was represented by id. 
Hence, it remains plausible (but not probable) that this use of id on propertyElt's with propAttr's was some sort of left-over from the older notation. 
I may still explore what happened when the text for the serialized syntax and the abbreviated syntax got merged; and when RDF:href got split into rdf:about on descriptions and rdf:resource on propertyElt's. 
The latter removes the regularity of the treatment of *all* attributes accross the abbreviated syntax productions; and hence makes it difficult to sustain any non-historical motivation for a non-reifying reading of rdf:ID. 
Jeremy Jeremy: Searching in the mail archive the earliest reference to the contradiction I could find was: which was written a couple of weeks after M&amp;S became a recommendation. 
I can't locate a reply to Kajiyama'san. 
Anyone know if there was one? 
I would suggest updating the issue list with this mail URL. 
He states the problem very clearly. 
Jeremy Jeremy: I The author, Tamito Kajiyama, has confirmed to me that he has not yet received any reply to his comment. 
I have indicated to him that I believe we are currently considering this comment under Jeremy Well, I wonder if before deciding one way or the other about the merits of reification, could we first decide what reification actually is? 
I thought I knew, but at the F2F the model theory I gave for reification (which I honestly thought was the blandest and least controversial interpretation one could wish for, and to directly follow the M&amp;S) seemed to cause a firestorm. 
We havn't discussed reification since then, but if we are going to start, then please lets first define what we are talking about. 
Pat IHMC(850)434 8903 home 40 South Alcaniz St.(850)202 4416 office phayes@ai.uwf.edu 
I would appreciate any remarks from anyone on what the intended uses of reification were. 
What would it be to 'use reification effectively' ? 
Use it for what? 
Part of my problem with reification has always been that I am unable to see a single effective use for in it RDF; every suggested use I have seen has seemed to involve a logical or conceptual error of some kind. 
Pat IHMC(850)434 8903 home 40 South Alcaniz St.(850)202 4416 office phayes@ai.uwf.edu 
Here is a challenge ;) What is an adequate way of representing aggregation and order in RDF? 
Aggregation: I want to be able to identify a set of statements as "belonging together", e.g. describing a certain self-contained thing. 
For example, consider several sets of statements gathered from different RDF/XML pages. 
How do I "mark" the statements within a single graph? 
Order: I want to establish an order between the authors of a book: isbn001 dc:creator author1 isbn001 dc:creator author2 How to add ordering without destroying the semantics of dc:creator? 
You won't tell me that the solution is to use a container like rdf:Bag, right? 
;) Sergey My view of reification is that it can serve a "use without assertion" role; I understand that this is not exactly the same as conventional use of the term in logic, so it may be mis-named.. 
I have found (at least) the situations in which I have wanted a construct that serves this purpose: (1) encoding rules in RDF for an RDF-driven expert system shell. 
The antecedents and consequences of any rule must be clearly distinguishable from the facts that may be tested/asserted when the rule is triggered. 
(2) designing a program that will use RDF to drive a user interface for creation, editing and display of arbitrary RDF. 
The RDF-encoded information that is accepted/returned by the UI components needs to be in the form of a uniformly structured description of the statements, rather than the statements themselves. 
(3) in contemplation of trust modelling in RDF, using a framework drawing from the ideas of contexts. 
(I think McCarthy mentions somewhere that contexts must deal with reifications of statements.) In this case, a description of some statements is required which quite explicitly may or may not be regarded as true, depending upon the available provenance information. 
In each case, I have found that reification (as I understand it) *might* be used, but that it has also been possible to define new RDF classes and properties that achieve the desired effect in a specific scenario, and which I am confident could be used by a software system to achieve the desired effect. 
I think I'm starting to see (based on RDFS "closures") how this also might work at a model theoretic level. 
#g Graham Klyne MIMEsweeper Group Strategic Research http://www.mimesweeper.com 
OK, though I reserve the right to conclude that there isn't one. 
:-) Well, if you want to identify a set of *statements* then indeed you need some way to refer to statements, which I guess could be called 'reification'. 
But you just need a way to *refer* to the statements, not to *describe* them. 
With RDF reification you have the ability to describe the subject, object and property of each triple in the set of statements you wish to describe. 
That doesn't help you do such aggregation. 
On the other hand, you do need a way to identify the particular statements that are also being asserted. 
What part of the RDF reification machinery establishes a connection between an asserted triple and the entity which is called its reification? 
Note, it is not sufficient simply to *describe* the triples in a reified language. 
That only establishes that some such triple exists; it does not establish that the particular triple in your set is the one being described. 
This example actually illustrates one of the fundamental problems with RDF, ie its limitation to binary relations. 
The ordering of two authors of a book is a nice example of an essentially three-way relation that is not reducible to a simple conjunction of binaries. 
There is of course a uniform reduction to the binary case that is available in RDF, but that wouldn't use the relation dc:creator between book and author, but would have to 'split' that meaning between two auxiliary relations. 
So by insisting on the use of dc:creator you have neatly provided an example that cannot in fact be represented in RDF without some kind of hackery. 
I would use rdf:Seq, myself; but I will also claim that reification does not provide ANY way to do this ordering. 
How could it? 
Reification isn't about authors or books, it is about triples. 
The ordering of triples says nothing about any kind of ordering of the things named by the terms used in the triples. 
Pat IHMC(850)434 8903 home 40 South Alcaniz St.(850)202 4416 office phayes@ai.uwf.edu 
