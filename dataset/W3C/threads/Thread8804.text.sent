Hi Joseph, hi all, I know that we shouldn't apply big changes to the XML Signature spec to get it come fast through the standards process. 
But I think there's a sentence in the spec that probably adds confusion. 
The thread [1] also shows this. 
In section 3.2.1 Reference Validation, the first bulleted item says: "Canonicalize the SignedInfo element based on the CanonicalizationMethod in SignedInfo." 
After that, we don't say anything about what appens with these octets. 
Then we process the references. 
I think that we should delete this sentence, because 1: we don't give a guideline what to do with the bytes 2: AFAIK it does not make sense at this place 3: c14n of ds:SignedInfo is done in 3.2.2 Signature Validation, second step. 
In my implementation, I tried to interpret the sentence in question the following way: When I am asked to verify a ds:Signature, I work on a DOM structure. 
I canonicalize ds:SignedInfo, reparse it into a new document and replace the original not-canonicalized ds:SignedInfo by the re-parsed canonicalized one. 
From implementations point of view, this is complicated and error-prone and did not word very safe _AND_ I didn't heard that any of the other implementations makes something like this. 
So why do we have such a sentence of canonicalizing prior ro reference validation? 
The only reason that would make sense would be a security problem that would arise if I process an not-c14nized SignedInfo, e.g. if an attacker can modify the AlgorithmURI of a Signature method or other things that would semantically change the SignedInfo. 
But I don't see changes would make sense and would not break the reference processing. 
So my vote is: could we please delete this sentence and change the section to: 3.2.1 Reference Validation 1: For each Reference in SignedInfo: 2. Obtain the data object to be digested. 
(For example, the signature application may dereference the URI and execute Transforms provided ....... Christian [1] Hi, I forgot something that supports this (I love to reply to my own e-mails In Section 5.1 The Manifest Element, we son't say how to verify a ds:Manifest, but I think it's abvious that the reference validation processing has to be applied to ds:Manifest as well. 
But this is not possible cause there's no CanonicalizationMethod inside a Manifest. 
One reason more to omit the misleading sentence from 3.2.1. 
Best regards, Christian --On Dienstag, 16. Oktober 2001 08:39 +0200 Christian Geuer-Pollmann Well, you only process a Manifest if it is pointed at by a Reference in a SignedInfo or in a Manifest you are already processing (and if your application provides for Manifest processing). 
In fact, the Manifest you process should, it seems to me, be precisely what results from the URI dereference and possible Transform processing in the Reference that refers to this Manifest. 
There could even be cases where the data pointed at by the URI is just some control information which an XSLT transform uses to construct a Manifest. 
So you don't need a CanonnicalizationMethod. 
You have a whole Transforms element in the Reference to the Manifest which can provide canonicalization and more. 
The only reason SignedInfo needs a CanonicalizationMethod is that there isn't a higher level super Reference to point to it and provide Transforms. 
Donald From: Christian Geuer-Pollmann geuer-pollmann@nue.et-inf.uni-siegen.de 
Date: Tue, 16 Oct 2001 08:56:51 +0200 In-reply-to: 2494201376.1003221581@pinkpanther 
Message-id: 2495231627.1003222611@pinkpanther 
That is correct. 
If you will only support canonicalization methods that are known to be safe in this capacity (of not re-writing the Reference URIs or DigestValues) you can "optimize" by not having to implement. 
Otherwise this is an important statement for the reasons stated: NOTE: The signature application must exercise great care in accepting and executing an arbitrary CanonicalizationMethod. 
For example, the canonicalization method could rewrite the URIs of the References being validated. 
Or, the method could massively transform SignedInfo so that validation would always succeed (i.e., converting it to a trivial signature with a known key over trivial data). 
Since CanonicalizationMethod is inside SignedInfo, in the resulting canonical form it could erase itself from SignedInfo or modify the SignedInfo element so that it appears that a different canonicalization function was used! 
Thus a Signature which appears to authenticate the desired data with the desired key, DigestMethod, and SignatureMethod, can be meaningless if a capricious CanonicalizationMethod is used. 
Canonical XML and Exclusive Canonical XML do not rewrite URIs. 
In fact, I don't think any C14N or transform should be used that isn't standardized and reviewed. 
And any C14N that rewrote these URIs should have a stake driven through their hearts. 
But it's hard for us to specify the requirements of externally specified extensible algorithms (e.g., key size). 
So we have to specify our spec as securely as possible, even if it is a little akward. 
1. Evil Eve creates statement G saying she "will pay Joseph $10" and a statement B, "ha-ha". 
2. She creates a signature with a reference to G, but a digest of B and signs it using the Evil-C14N. 
3. When I go to validate the signature (which appears to point to statement G) Evil-C14N rewrites the URI to B and the digest checks. 
Joseph Reagle Jr. http://www.w3.org/People/Reagle/ W3C Policy Analyst mailto:reagle@w3.org 
IETF/W3C XML-Signature Co-Chair http://www.w3.org/Signature W3C XML Encryption Chair http://www.w3.org/Encryption/2001/ Hi Joseph, OK, this all means that I have to do it "the hard way" ;-)). 
I understood the points you mentioned and agree. 
Thanks, Christian Mit freundlichen Gr??en, Christian Geuer-Pollmann Institute for Data Communications Systems University of Siegen Hoelderlinstrasse 3 D-57068 Siegen Germany mail: mailto:geuer-pollmann@nue.et-inf.uni-siegen.de 
web: http://www.nue.et-inf.uni-siegen.de/~geuer-pollmann/ 
[To continue the time honored tradition of responding to one's self smile/ ] As an aside, the likelihood of C14N re-writing URIs is not all that unlikely We considered it (in general) with respect to relative URI for namespaces before they were "deprecated" by XML Core, and others might for any sort of relative URI (this might help isolate the context). 
So I don't mean to dismiss them as something no one would ever consider, people might consider it, but they'll have to be *very* careful. 
If you did have a C14N that absolutized relative URIs given a base URI, then you would still need to ensure *both* the signer and verifier c14n SignedInfo prior to Reference Validation. 
Joseph Reagle Jr. http://www.w3.org/People/Reagle/ W3C Policy Analyst mailto:reagle@w3.org 
IETF/W3C XML-Signature Co-Chair http://www.w3.org/Signature/ W3C XML Encryption Chair http://www.w3.org/Encryption/2001/ 
