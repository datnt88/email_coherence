This contains a contentious suggestion and I apologise if I have missed something obvious - I am not an expert in the management of existing SGML systems and I simply post the concerns of a typical webhacker. 
I have spent the last 12 hours trying to get EXISTING SGML files to work with XML and am now deeply worried that the syntax of XML Phase I is seriously flawed and it will be very difficult to market. 
(The good news is that I think it's *technically* very easy to mend.) [Please forgive the loose terminology in contrasting 'SGML' with 'XML'] 
If you install Panorama there is a directory called catalog, with about 35 files which are a mixture of popular *.dtd and *.ent. 
EVERY SINGLE FILE WILL BREAK XML UNLESS THE SYNTAX IS CHANGED. 
(I can think of no simple kludge for this problem.) If XML goes ahead with 961114, then the only solution is to have a modified 
version of every file which works with XML. (This file will also work with SGML, of course, but it would need the *supplier* to authorise a change.) 
The problem arises from (at least) the following: !-- .* -- is illegal in XML ? 
.*  is illegal in XML (I don't know whether there are any PIs in the distribution, but there could be. 
!ENTITY % Foo "-//FOO//ENTITIES//EN" %Foo; is not supported XML must be able to interoperate with these files UNCHANGED The good news is that all these files are easy to parse (i.e. *I* can do it, I think). 
They all have identifiable tokens and (although I haven't tried to parse DTDs - I only do documents at present - it looks 'trivial'). 
Why was !--* .* 
*-- introduced? 
Presumably it is possible for someone 
to write something with embedded '--' that is difficult to parse. 
I doubt very much if this happens in any of the DTDs or entity sets. 
If it *does* we have to write better parsers, or put pressure on the 0.1% of people who write poor DTDs. 
I assume ? 
... ? 
was introduced for the same reason. 
That someone might write or something like that. 
This is still easy to parse if the rules say that the quotes are required. 
I am sure that it is *possible* to create some monster that breaks our syntax, but in practice it won't be a problem. 
I don't understand the forbidding of PUBLIC ENTITYs at all. 
I found it a non-issue until this debate started. 
You get a DTD from (say) Panorama which requires an EntitySet. 
It is *identified* by an FPI. 
Panorama even send you this file *in the same directory*. 
The catalog tells what its name is. 
Even I have managed to write code that resolves this. 
My simple understanding is that FPIs identify the document just like an ISBN identifies a book. 
Up until now it has been *my* responsibility to get the document. 
Panorama helps me by downloading lots of them. 
I assume that most of you in practice have a directory full of commonly used DTDs and Entity Sets which you use every day. 
[The problem only arises when someone MODIFIES a document which purports to be the true document with a given FPI. 
I assume that not only is this bad practice, it may also break copyright, particularly if it is retransmitted]. 
The result of this is that EVERY file I have been working with up to now (document instances, DTDs, catalogs, EntitySets) are broken w.r.t XML. 
I have to modify them, often by hand. 
The rest of the world is not going to like this 
XML should interoperate with existing DTDs/catalogs/entitySets as far as possible. 
If not possible XML should make accommodation for parsing problems in very commonly-used WELL-FORMED documents. 
(In a very small number of cases there may be grey areas - but you have lots of these with SGML anyway - ambiguous content, whitespace, etc. - these are far more likely to give problems). 
Rescind !--* *-- Rescind ? 
? 
Allow the use of PUBLIC ENTITYs and other similar constructions in DTDs. 
There remain other problems which I am not expert enough to make comments on. 
I flag up two: The '- -', '- o' fields in ELEMENT. 
(I don't know its name). 
You have to be able to skip these if you parse an existing DTD. 
SDATA in entitySets. 
I don't know what it does, but it should be kludgeable. 
One point to bear in mind is that unless you constantly think about implementation, you are going to run into problems. 
I have seen several languages die because no one bothered to think of implementation - it was assumed to be easy. 
It is always harder than you think, which is why I urge caution on Phase II. 
I know that it is very antisocial to suggest major revisions at a late stage and I am a believer in communal discipline. 
If I have missed something obvious please forgive this posting. 
P. Peter Murray-Rust, domestic net connection Virtual School of Molecular Sciences 
It's hard enough to get Panorama to work with normal SGML :-) But this is very useful information, Peter, thanks for identifying it. 
I have a sneaking suspicion it was introduced because C programmers can't get a handle on comments /* unless they have an asterisk */, and as they are the target audience for implementations, this was done to persuade them that XML is not as hard as SGML :-) 
I think the intention was (?is?) that XML can be parsed by SGML parsers, but there was no intention that it should go the other way round. 
///Peter 
On Thu, 20 Feb 1997 06:35:10 -0500 Peter Murray-Rust said: 
I'm sorry to see members of the WG taken by surprise on this topic. 
I for one thought it was obvious long ago, and never hidden or disguised, that the restrictions on comments, entity types, content models, and attribute declarations would require the preparation of XML-compatible versions of standard entity sets from ISO and elsewhere, 
as well as of XML-compatible versions of standard DTDs like Docbook, TEI, and HTML. 
So I'm neither surprised nor shocked by Peter Murray-Rust's discovery, though I am alarmed to see that some members of the WG seem surprised by it. 
The preparation of XML-compatible versions of these files is (a) not hard, and (b) something that need be done only once. 
It seems to me a very small price indeed to pay for the simplifications we get in declaration syntax and entity handling. 
So, with respect, I suggest that any proposals to - start allowing comments in arbitrary SGML declarations - return to the use of -- -- com delimiters - remove the restrictions on content models which will make many existing DTDs break with XML parsers - restore the SDATA entity type need some further motivation before we reopen these questions. 
We knew 
when we made the original decision that existing SGML DTDs and entity sets use these constructs. 
We knew that eliminating the constructs would mean making new XML-compatible versions of the files we all use. 
Nothing has changed. 
Is there a reason to revisit the decisions? 
-C. M. Sperberg-McQueen University of Illinois at Chicago 
Those will have to be explained to an existing user base who possess some rather expensive tools and substantial SGML legacy. 
All they actually want is an SGML browser and database tools for the Internet. 
It is a sideways compatibility issue. 
Moving to XML is not an upgrade to SGML. 
It is a crab walk into a different standard, language and system. 
So, deciding to do it raises serious issue of maintenance and tools. 
These changes, unless explained with hefty benefits, will result in the rejection of XML by some users. 
The problem is that the early adopters of XML will likely come from the SGML community who have an immediate need. 
Typically, I've seen this problem met by freeware for conversion. 
From VRML 1.0 to 2.0, many syntax changes occurred that looked 
gratuitous. 
SGI, Sony, and some editor vendors responded with automatic conversion routines. 
Mileage varies. 
The difference in this situation is the size of the legacy to be considered, and the impact on the existing base of tools. 
I am not surprised. 
But, unless met with explanations that are the changes are practical and beneficial, there will be some serious questions raised by the SGML user community. 
Newbies won't care. 
This will be hard where the nature of the changes or the accruing benefits are either esoteric or so technical the audience gives up and looks for alternatives. 
len bullard 
[... PM-R's material deleted ...] I said that I am prepared to accept communal discipline and I don't intend to post further on this topic unless asked :-) 
I got the impression from 2-3 mails that this had surprised people and I am sorry if I have raised an issue that had been put to bed. 
My reaction is that it will create a lot of work and potentially some confusion. 
Not everyone will initially understand the reason for two sets of entity sets which differ only by asterisks and they may occasionally muddle them up. 
If this is recognised and accepted, that's fine. 
I accept that for large well-financed organisations this isn't a problem. 
Nor is it a problem for people who are developing a complete XML solution without any reference to existing SGML. 
The problem will hit those who (like me) are on the fringes of the SGML community and who have to make do with what bits and pieces they can pick up. 
My own position is that my DTD (CML) is (now) not interoperable with XML. 
The problem is not primarily technical. 
The components that CML interoperates 
with belong to other organisations who own the copyright and for each of which I shall have to get permission to alter and redistribute the material. 
Whilst I am sure this will come in time, it's not something that a single individual is likely to make much headway with. 
Therefore, I cannot legally distribute my material in XML-form (unless I have misunderstood this). 
I will predict that what will happen is that people will develop XML software 
which has switches on the command line, that allow it to read 'SGML' entity sets, rather than the confusion of interoperating with 'SGML' sets and 'XML' sets in neighbouring directories. 
No :-) But it would be a useful thing for those of us who are trying to develop software to have the definitive XML versions of the common DTDs and entity sets. 
At present my XML development is stalled until this happens. 
P. Peter Murray-Rust, domestic net connection Virtual School of Molecular Sciences 
I concur completely with Michael. 
No-one has ever said that existing legacy SGML (or HTML) files will be valid XML files. 
They won't. 
The conversion is automatic and trivial. 
The !--* comment syntax *-- came from me, and is a sort of 
transition syntax: you can use this in SGML today, as any SGML parser will accept it as a comment that just happens to contain the stars. 
If'when SGML is enhanced to allow different start and end comment delimiters, this comment syntax lets you include -- in comments. 
Also, yes, it looks familiar to C programmers, and there are a lot of us. 
No, none of these files will break. 
They are all SGML files, and are not for use with XML. 
I expect that a future Panorama may well handle both XML and SGML... 
I agree. 
All the changes were made for good reason. 
XML is a subset of SGML, but that doesn't mean that a subset of existing SGML files are XML files. 
No. Lee 
I aggree. 
But I *do* wish we could stop referring to SGML files as "legacy". 
Surely SGML- XML is a "down-translation" not an "up-translation". 
Sean 
[ent sets] 
I just hadn't gotten round to thinking about it. 
I knew my DTDs would need editing, but as you say, you only need do it once. 
No, but it should remain true to say that a carefully-edited set of ent files and dtds will remain usable with standard SGML tools. 
///Peter 
to discover 1000s of internal "homepages" that grew overnight like magic mushrooms on a rich motherlode of corporate horseshit. 
Copyright 1996, IBM. 
All Rights Reserved 
So what? 
And the language in fact obscures what the most likely application of XML is: a delivery format on the Web for SGML. 
len bullard 
Afraid not. 
You lose no information in going from SGML to XML, unless you 
have somehow managed to come up with a way to use SHORTREF that could not be equivalently expressed with tags. 
It is a cross-translation, since any SGML DTD and any XML DTD should be able to operate at the same level of abstraction. 
Actaully, there are a few exceptions: as far as I can tell, the only 
place where we lose information with the current draft is in some rare 
content model with mixed content, in SDATA, where a meaningful string must be hand-translated to a numeric code, and separately documented, and (hopefully not for long), with PUBLIC, where a location independent perpetually valid identifier must be replaced with a method that depends on a particular technical infrastructure for resolution. 
As this is a follow on to the previous thread and SDATA was raised by someone else, I will repeat my plea that we allow a way to use strings for 
undefined characters instead of undefined code points. 
In the absence of a resolution mechanism, they are equivalent, but SDATA has key advantages: compatible with established SGML practice (CoST and SP for instance), and potentially provide supereior information to a user. 
SDATA also extends easily and obviously to implementation of a registration mechanism in the future -- Private use characters do not. 
I am not a number, I am an undefined character! 
-- David David Durand dgd@cs.bu.edu \ david@dynamicDiagrams.com 
Boston University Computer Science \ Sr. Analyst --------------------------------------------\ http://dynamicDiagrams.com/ MAPA: mapping for the WWW \__________________________ 
That is right. 
SGML and XML conversions/translations don't lose information except where application restrictions (e.g, linktypes) put restrictions on the developer. 
Those restrictions are necessary to the interoperability of the tools. 
XML is a subset of SGML. 
In fact, it would be a matter of interest to know how the SGML grove plan compares to a grove plan derived for XML. 
I spent some part of the day reading Dan Connoly's architecture papers. 
XML definitions for hyperlinks should be documented in the terms of that glossary if they are not already. 
The current uri.bunyip discussions between TimBL, Dan, Larry Masinter, Martin Duerst, et al are most illuminating. 
This is a quote from Larry Masinter: "This all got better for me when I just admitted that the definitions were circular, and decided that it was OK. 
What's a resource? 
Something that has a URI. 
What's a URL? 
Something that locates a resource. 
What's a URN? 
Something that names a resource. 
If you can name it, it's a resource. 
Different resources have different names. 
A single resource might have multiple names. 
You can't "get" a resource, you can only interact with it. 
One way to interact with a resource is to obtain an entity that is a representation of the resource at a given point in time. 
This isn't smalltalk, it's webtalk. 
"Web" for me is 
defined not by HTTP and HTML, but by this fundamental architectural point, that some entities contain URIs 
that locate/name other entities." 
That's a clear as it gets. 
len 
Which is (surprise!) what we're trying to do here. 
Is it time to point to our activity statement again? 
Jon 
interoperates 
I wouldn't worry too much, yet, Peter. 
I saw long ago that XML would be untenable as a data format for managing source docs and that we would have to adopt on-the-fly conversion if we chose to use it at all for delivering documentation over the net. 
I'm sure that there will be PD tools available to do just that since, so far, it doesn't seem to be too difficult of a transformation. 
bob Robert Streichstreich@slb.com Schlumbergervoice: 1 512 331 3318 
This seems a strange comment coming from you, David. 
Any time you reduce a grammar, you reduce expressibility. 
Any time you reduce expressibility, you lose information. 
bob Robert Streichstreich@slb.com Schlumbergervoice: 1 512 331 3318 
Right. Sort of a Duh, but in the blizzard of alligators, it is good to remember which particular swamp is being drained. 
Sure, but in preparing the FAQ, public announcements, pleas for shareware, the gotchas should be pointed out. 
It looks trivial, but it is quite a bit of work to translate all of this, change the relevant policy documents, etc. 
Then they get to learn about all of the linking features, processing specs. 
Busy two years ahead. 
Peter MR is pointing out something of interest and that is, without tools that do the chores, the concepts are trivial, but the grunt work isn't. 
Two tracks: translation for XML tools of existing SGML, and output from SGML tools where the work continues in SGML, but the delivery format is XML. 
Later, as the WG8 works out the details for the TC and establishes an SGML-Lite built on XML, all of the information about how SGML - XML translations occur should be stated with a minimum of fuss. 
We've taught them so long that the DTD is sacrosanct, PIs are Bad, etc, now we have to be ready to calm the waters. 
Get out the long staff. 
len 
Yes please...if anyone spots pet gotchas for the FAQ, I'd be grateful for them. 
v.3 should be out this weekend at 
///Peter 
I don't think vertical terms are applicable. 
Since the element structures of both forms are the same, I don't think there's vertical motion involved at all. 
It would seem very odd to me to say that global changes of approximately and are "down-translation". 
They seem purely horizontal; certainly none of the real information has changed; only the syntactic details of its representation. 
Certainly we wouldn't call re-vamping an SGML file to use a new delimiter set "down" or "up" translation; and that's all that's really going on here (the only difference being a clearl trivial one, that SGML doesn't presently let us change COMO and COMC separately). 
We should probably define "expressibility" before trying to evaluate these axioms. 
Reducing SGML's grammar to document ::= char* would certainly add to expressibility in one sense, but drastically subtract from it in another. 
so when we say 'expressibility' or 'expressiveness' or 'expressive power', we need to know whether we mean: * maximizing the number of ways i can say the same thing. 
* minimizing the inconsistencies with which the same thing can be said * making the maximum number of strings valid * making the minimum number of strings valid * making the language easiest to use so as to minimize errors * having the most 'custom' settings so everyone can make non-similar- appearing syntaxes that all still conform. 
* maximizing the range of structurally distinct data that can be represented. 
or something else. the last one is the one i'd prefer; I don't consider being able to do the same thing (namely, start a P element) in all these ways "expressiveness", except in the way clothing designers use the term (all are valid SGML given the right context, and I haven't even used variant delimiters): P/ P P / Hello, world &amp;my.starttag.entity; 
&amp;#RE;&amp;#RS; 
Oh, I suppose we should also define "information" before we evaluate whether it's gained or lost. 
In Information Theory (see anything by Claude Shannon), it would be hard to show that any of the above differ in information content, though they might differ in the entropy with which a certain quantitiy of information is being transmitted. 
S 
3.1.a 
Should we have a principle that all linkage information is encoded in GIs and/or attribute values, never in character data? 
No. Unenforceable, and sometimes it's useful anyway, such as for supporting links from every word to dictionaries/glossaries/etc, for links from 'the current selection', etc. 
I THINK if we clarified the question to be "should we provide a mechanism in the minimum supported locator schemes for using link element content as part of a locator" you might agree the answer was 'NO', but that leaves the door open in an unstated way for non-minimum-supported schemes to do so. 
ht 
In the information-theoretical sense this is obviously true, but in terms of the practical problem of preserving information that is usefully used to control processing, the case is less clear. 
I did make a few exceptions, and James pointed out another, data attributes, which I aleways forget because I've never used them... My point was that almost all of the "extra expressivenes" of SGML provides syntactic options for things that can be recorded in other ways. 
From my experience, only Public and SDATA are things that I've ever had occcasion to used. 
Data attributes seem as if they are the kind of thing that doesn't move well across systems, but I may be wrong there -- it seems to me that I can get equivalent effects with NOTATION, though maybe not as elegantly. 
If it's a down-translation, it's not very far down, and I find it hard to imagine an SGML document that could not be converted into an equivalent XML document without losing information. 
So if change the definition of information, and instead ask for an effective information-preserving transformation from SGML- XML, I would say that it always exists. 
So that you need not lose information in moving from SGML to XML. 
The same is not true (in a meaningful sense) for RTF, or Postscript, for instance... -- David David Durand dgd@cs.bu.edu \ david@dynamicDiagrams.com 
Boston University Computer Science \ Sr. Analyst --------------------------------------------\ http://dynamicDiagrams.com/ MAPA: mapping for the WWW \__________________________ 
Just quickly glancing, XML isn't an "application of SGML". 
I think it is a proper subset. 
HTML is an application of SGML, and could be an application of XML. 
That is, perhaps, one way to get the point across. 
len 
Umm... I didn't say that. 
That is Sean's comment. 
I say it is a crab-walk, meaning, same thing, just sideways movement. 
:-) We'll have to be clear about XML and SGML. 
I think subset is the best description although the crabwalk bit has to be explained too. 
Narrowing the features and fixing some holes that open up when one does is about it. 
Also, a few things like minimization were removed because that complicated using XML without a DTD. 
That won't be precise enough. 
I have to review the FAQ in detail. 
I think it necessary to say, "we are not fixing SGML; we are subsetting it to make it easier to apply for those cases where the full requirements of SGML are too burdensome, but otherwise, this is still SGML. 
What we are doing with the linking is a different matter. 
Here we have a subset and/or application of HyTime that is easier to understand and develop and will provide a much more powerful linking capability than is currently in use on the Internet." 
len 
Shannon? Alright, Steve! 
Better than Plato and almost as abstract. 
James made good points though in that he precisely stated what is given up in the crabwalk from SGML to XML. 
Again, a comparison of grove plans would be useful. 
Eliot? 
len 
Why doesn't the same apply to XML itself: "Here we have a subset of SGML that is easier to understand and develop and provides more powerful markup than is currently in use on the Internet." 
This is a positive statement about both XML *and* SGML and is an accurate statement of what has been accomplished. 
Whatever the direction, I do not think the use of the word "legacy" for SGML will help our cause at all and I think we should stop using it. . 
It does not accurately portray the SGML/XML relationship . 
To SGML people, "legacy" is a state your data leaves when you place it in SGML. 
If having got it there is it now "legacy" with respect to XML what happens to all that open systems, future proofing, spiel I swallowed from the salesman? 
I'll buy into "foo"-translation where "foo" is anything other than "up" for describing SGML- XML. 
Sean 
I agree with that. 
len 
There probably are existing SGML files that are XML files. 
Any XML file that includes its DOCTYPE declaration is both. 
We're losing sight of the subset/application spectrum. 
HTML (at least at any point in time) is intended to be a single, nonextendable markup language. 
Nonextendable in the sense that making any additions forms a new markup language, which is only (hopefully closely) related to the old. 
SGML at any point in time is intended to be extensible in certain ways. 
There are specific areas where choices may or must be made. 
These choices partition naturally into three groups: "Semantic" choices, which are generally of interest only to application designers and users; "structure" choices that are specified via a document type declaration, and "lexical" choices that are specified via an SGML declaration. 
At least by tradition you must make the lexical choices before you make the structure choices and semantic choices. 
Making all three is in SGML terms "defining an application". 
Additional restrictions that cannot be specified via the document type declaration or the SGML declaration are "application conventions". 
HTML (at least in some incarnations) is an application of SGML by this definition. 
XML is in the in-between grey area. 
We plan to lock in the SGML declaration; we plan to lock in some semantic roles (e.g., for linking); we plan to add additional restrictions that cannot be specified via the document type declaration or the SGML declaration. 
But we allow users to complete the 
process of making an SGML application. 
It seems to me that "subset" is an appropriate term for such a set of some-but-not-all of the decisions necessary to define an "application". 
According to this definition of "subset", an application is a subset in which all of the available decisions have been made. 
(Or almost all--one could presumably still add more more-restrictive "application conventions".) 
I pose three questions: Is this "subset" a useful concept? 
Is "subset" the right term? 
And is this what you all have meant by "subset" when you've used the term? 
Dave Peterson SGMLWorks! 
davep@acm.org 
Could be. 
To me the boundary is the software that implements it. 
That is where an SGML design becomes a proper application in my book. 
XML retains SGML's meta-language aspects. 
We also design for the software/application boundary the commons data types that make interoperability easy. 
This is done within existing HTTP/URL semantics (sorry loose). 
What HTML demonstrates dramatically is how WELL this idea works when the element types are common. 
Extensions are the province of the DTD writer for their DTDs. 
XML lets them do that so they can use markup as requireed, but it recognizes that where XML must work in application software, the declaration of common data structures makes the software work. 
Not the one's that declare interoperable semantics. 
Those have to be shared. 
But that has always been the case with markup. 
Look at the CALS Table, HTML, etc. Unless XML systems share the application level as well as the subset level, they don't work. 
I see your point. 
The subset is the syntax and feature restrictions. 
Application conventions are the special structures declared to enable interoperable software, eg, linking. 
That leaves the processing specs. 
Same deal: libraries. 
len 
I've used "subset" in the FAQ where I think the word conveys sufficient of what you describe for it to make sense to the reader. 
I also use the phrase "application profile" once where it describes better the "gray area" you mention of XML being neither flesh nor fowl. 
How we describe it here and how we describe it to the world outside may be of importance to the acceptance of XML, so I'd appreciate it if anyone has better phraseology than I have used in the FAQ so far. 
XML's role as "SGML Lite" is currently easiest conveyed by the concept of "subset", I think, but if we can find a less loaded term it might be useful. 
///Peter 
We don't need any more on this subject. 
There are several key questions relating to linking in front of you. 
Given that the ERB will be deciding these questions Wednesday morning and that they probably won't be considering comments made after Tuesday afternoon, you have less than 48 hours to put on record whatever you have to say regarding the matters at hand. 
If you have time to post something to this list, it would be better spent addressing the questions before you than revisiting decisions already made. 
Jon 
