The namespace problem with Attributes grants me no rest. 
Since the new DOM2 draft came up with new conditions for the NAMESPACE_ERR exception on the setAttributeNS method of the Element's interface (which forbids that the qualified name has a prefix and the namespaceURI is null or an empty string) there is hope to get DOM1 and DOM2 namespace methods compatible. 
Therefore, I want to come up with another few suggestions (if those would not convince anybody I must be quiet for the next month for not to become the reputation of a great namespace troublemaker :-). 
So here they are: For Attributes set by the non-namespace method the namespaceURI is supposed to be an empty string or null, and if the Attribute's name is namespace conform it shall be treated as if it were set by the namespace method, e.g. setAttribute('a:b') would have the same result than setAttributeNS('','a:b'), what means that the prefix is 'a' and localName is 'b'. 
If an Attribute is set with no qualified name setAtttributeNS would raise an exception as usual, but e.g. setAttribute('a:b:c') is allowed, whose prefix and localName should then both be an empty string or null. 
Changing the prefix shall be allowed whenever the current nodeName is a qualified name independent from the type of method that created the attribute; if it is not a qualified name as in the case of setAttribute('a:b:c'), an exception shall be raised on trying to modify the prefix. 
The different methods of the NamedNodeMap interface shall behave as follows (the equivalent methods of other interfaces alike): getNamedItem Retrieves a node with the specified name and with a namespaceURI that is an empty string or null. 
If there is a node with the specified name, but a non-empty namespaceURI it returns null. 
getNamedItemNS If the namespaceURI is an empty string or null, this method ignores all nodes that have a prefix which is not an empty string or null. 
If the namespaceURI is not empty it operates as usual. 
removeNamedItem Removes node with the specified name and with a namespaceURI that is an empty string or null. 
If there is a node with the specified name, but a non-empty namespaceURI a NOT_FOUND_ERR is raised. 
removeNamedItemNS If the namespaceURI is an empty string or null, this method ignores all nodes that have a prefix which is not an empty string or null. 
If it finds no node following this strategy a NOT_FOUND_ERR is raised. 
If the namespaceURI is not empty it operates as usual. 
setNamedItem Adds a node with the specified name and with a namespaceURI that is an empty string or null. 
If such a node is already present in this map, it is replaced by the new one. 
setNamedItemNS If the namespaceURI is an empty string or null, this method ignores all nodes that have a prefix which is not an empty string or null. 
If it finds no node following this strategy it adds a node with the specified localName as nodeName and with a namespaceURI that is an empty string or null. 
If such a node is already present in this map, it is replaced by the new one. 
If the namespaceURI is not empty it operates as usual. 
Neither of the namespace methods shall allow the localName attribute being null or an empty string. 
Dieter Koehler, M. A. - dieter.koehler@ppp.uni-bamberg.de 
Mittlere Kaulberg 22, D-96049 Bamberg, +49(0)951-5190726 "http://www.philo.de/Philosophie-Seiten/": 
1000+ Philosophie-Links "http://www.philo.de/VirtualLibrary/14.de.htm": Deutsche Philo-Links "http://www.philo.de/xml/": 
Open XML - XML-Komponenten fuer Delphi This would break backwards compatibility with DOM Level 1. 
Consider the case, where a DOM Level 1 (i.e. namespace unaware) application processes a document with namespaces in it, on top of a DOM Level 2 implementation. 
The implementation namespace aware parser creates all the nodes with their apropriate namespaceURIs. 
All of the application calls to getNamedItem then fail. 
Arnaud Le Hors - IBM Cupertino, XML Technology Group D.K.  getNamedItem D.K.  Retrieves a node with the specified name and with a namespaceURI that D.K.  is an empty string or null. 
If there is a node with the specified D.K.  name, but a non-empty namespaceURI it returns null. 
Good point. 
But here is an example were both suggestions (the DOM2 draft and mine) fail to get complete backwards compatibility. 
Consider the following DOM1 code: for i:= 0 to attributes.length-1 do begin myattr1:= attributes.item(i); 
myattr2:= attributes.getNamedItem(myattr1.NodeName); 
myattr3:= attributes.getNamedItem(myattr2.NodeName); 
end; If we have double localnames with different namespaceURIs in the map myattr1 might be different form myattr2. 
When writing your DOM1 code this was not predictable, since the setAttribute method would have forbidden it. 
So you have no backwards compatibility either. 
Using my strategy myattr2 might be null and therefor raise an exception on the myattr3 line. 
So I am now convinced, that we cannot have an easy compatibility, since the architecture of the map is intransitive with regard to the getNamedItem respectivly getNamedItemNS and the item method. 
So if backwards compatibility at all is an unrealistic goal in this particular case, why not strive for a consistant DOM2, now? 
That means to raise exceptions if namespace and non-namespace methods were used at the same namedNodeMap (a variant of a previous suggestion of mine). 
In the example above using DOM1 together with DOM2 code would result in an exception. 
Pure DOM1 code would still be able to work together with a DOM2 API, but a mixture would be forbidden. 
That is the only amount of backwards compatibility within reach. 
Dieter Koehler, M. A. - dieter.koehler@ppp.uni-bamberg.de 
Mittlere Kaulberg 22, D-96049 Bamberg, +49(0)951-5190726 "http://www.philo.de/Philosophie-Seiten/": 
1000+ Philosophie-Links "http://www.philo.de/VirtualLibrary/14.de.htm": Deutsche Philo-Links "http://www.philo.de/xml/": 
Open XML - XML-Komponenten fuer Delphi Quoth Dieter: The DOM Working Group did consider this alternative, but after debating it the vote was that prefix and localname are not defined for non-namespaced nodes and should not be provided. 
I'm not really delighted with that decision -- it means that code may have to do an "if localname non-null use that, otherwise use node name" test -- but I think I can live with it. 
I think that one's definitely wrong. 
The only reason we permit changing the prefix on a namespaced name is that it "isn't really part of the node's name" -- in the namespace world, the "real" name is the combination of namespace URI and localname. 
For a non-namespaced node, the prefix is an essential part of the node's identity and really should not be mutable. 
As one practical illustration of why: Consider something like the HTML DOM, where different subclasses of element were selected based on the namespaced name. 
If you allow folks to change the prefix -- from postal:address to memory:address -- you may wind up with something that claims to be a memory:address but supports getZipCode() instead of getBytes(). 
Don't worry about it. 
You're asking exactly the same kinds of questions that were most difficult for us during the design process, you're explaining your concerns clearly, and you're suggesting fairly reasonable alternatives. 
We may or may not not agree that the alternatives are better, but having someone read and think about the spec this carefully is very helpful! 
If nothing else, it suggests that we may want to document the rationalle behind the namespace design. 
Joe Kesselman / IBM Research I am getting confused: Isn't your example about a namespace node, where changing the prefix is allowed? 
However: That is a serilization problem for which I would suggest replacing the node instead of only changing the prefix. 
But as my last posting demonstrates, I am not convinced about my own suggestion any longer. 
What I wanted to overcome is the different identity criteria for namespace and non-namespace nodes when using namedNodeMaps. 
Philosophically spoken it is the problem that Leibniz called "principium identitatis indiscernibilium", the sentence of identity of the undistinguishable, or which Quine formulated in the claim "no entity without identity". 
That means, that two objects are two objects if and only if at least one of their essential properties is different, and on the other hand, that you need to compare _all_ essential properties in order to identify an object undoubtedly. 
DOM2 presupposes, that for non-namespace nodes the essential property is the nodename, and for namespace nodes the essential properties are the local name and the URI. 
That would suggest, that a namespace node is a different _type_ of object than a non-namespace node, since there is no way of mapping the essential properties of a nonnamespace node to that of a namespace node, or reverse. 
To demonstrate this on an XML source code example: Is " a:x/ " different from " b:x/ "? -- In a non-namespace view it is definite that it is so. 
In a namespace view it depents on to what URI the prefix is bound. 
Is " a:x/ " different from " a:x/ "? -- In a non-namespace view it is definite that it is not so. 
In a namespace view it depents on to what URI the prefix is bound. 
So mixing the two approaches is insufficiant, since if the one thing is definite the other is contingent, which leads to a loss of information if one proceeds from the one relation to the other: Let '=' be the non-namespace identity relation and '~' be the namespace identity relation, than from "a=b" follows "(a~b) or not (a~b)", and from "(a~b) or not (a~b)" follows "(a=b) or not (a=b)". 
That demonstrats that in moving from one relation to the other information about the object gets lost (in XML documents this is compensated by the fact that the namespace information might be spread over several other tags, so that two documents might be identical as a whole in a namespace view, even if non of their elements are identical in a non-namespace view). 
Therefore it is not by accident, that we get problems if we try to use the same method to identify both types of objects. 
It is only by chance, if we get the object which we set with the one method back with the other. 
Therefore my main goal is to convince you, 1. that the current DOM2 is not backward compatible 2. that the current DOM2 is not in itself coherent 3. that this has to be faced not only in the documentation, but in the API itself. 
The other things are only more or less good proposals to overcome this situation. 
Dieter Koehler, M. A. - dieter.koehler@ppp.uni-bamberg.de 
Mittlere Kaulberg 22, D-96049 Bamberg, +49(0)951-5190726 "http://www.philo.de/Philosophie-Seiten/": 
1000+ Philosophie-Links "http://www.philo.de/VirtualLibrary/14.de.htm": Deutsche Philo-Links "http://www.philo.de/xml/": 
Open XML - XML-Komponenten fuer Delphi There is one important case of level 1 and level 2 mixture that does work in the current spec. 
Consider the supplier of a browser or any other standard framework which parses a document into a DOM without knowing what type of application will operate on it -- level 1 or level 2. A parser is in a superior position to most applications in that it can use level 2 NS methods to easily create a tree that will satisfy either a level 2 or a level 1 application. 
Either will be perfectly happy until post-parser DOM manipulations compromise the dual integrity, and make the model only suitable to level 1 or level 2. Ray Whitmer ray@xmission.com 
