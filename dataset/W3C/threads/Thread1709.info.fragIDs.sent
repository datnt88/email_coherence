All: 
Just as a bit of background, the purpose, especially of mulitpart/interleaved, was for environments (not IPP) where the client CANNOT/DOES NOT have the resources necessary to support a server (e.g. Cell Phone) and this therefore does a BETTER (but not foolproof) job of putting the resources in "proximity" to where it is reference (think printing something like XHTML with images.) 
Also, some of these environments are NOT tcp. 
Don't argue with me about whether or not the Cell Phone can afford to include a server so the printer can get the image as it needs it. 
This is one of the underlying requirements based upon what functions can afford to be included by the manufacturer of these devices. 
The printer guys didn't make up the rules.... we just have to live with them and solve the problems based on them. 
Oh and by the way, we also didn't decide the base protocols either so when the protocols chosen don't do what is necessary, we have to solve the problem with packaging. 
Because of bandwidth issues (again, think non-TCP, non-internet, non-megabit pipes), the 33% inefficiency of base64 encoding with the XHTML/SOAP is also not acceptable. 
* Don Wright don@lexmark.com 
* * Chair, Printer Working Group * * Chair, IEEE MSC * * Director, Alliances &amp; Standards * * Lexmark International * * 740 New Circle Rd * * Lexington, Ky 40550 * Scott Lawrence slawrence%virata.com@interlock.lexmark.com 
on 04/17/2001 01:49:15 PM Subject: Re: Two new drafts: Multipart/Interleaved and Application/BatchBeep 
A better approach would be to use BEEP's multiple session capability -- the client could send the control document over and the server could request things from the client on a different channel. 
The result is a single connection, just in time data delivery, and no need for the client to have to try and predict when the server will need something. 
The disadvantage is that it's a new protocol, but frankly, if this problem is worth solving we should not be afraid of a new protocol to solve it. 
I like this description quite a lot. 
It also sounds like exactly the same task that a Web client has when rendering a web page... 
I agree (as I did in person in Minneapolis) with Ned that the fundamental problem is that of just-in-time delivery, and the sender cannot know what that means. 
For example, in looking at our server logs, we do not find that browsers all request the images for a given HTML document in the same order. 
These drafts were motivated by the buffering problems of an IPP printer, but similar problems would be faced by any device that must combine mulitple components to produce a whole (wireless PDA displaying an alert with a specific font and a graphic). 
Far better is to provide a means of doing bidirectional requests. 
IPP already incorporates print-by-reference, so having the sender incorporate references to objects it is prepared to provide through a special-purpose HTTP server is not much of a stretch - putting the sequencing control of them into the renderer where it belongs. 
The HTTP Upgrade mechanism could be used to switch the HTTP/IPP connection to BEEP/xxx for any value of xxx (including HTTP, even if that would give people alergic reactions). 
Scott Lawrence Architect slawrence@virata.com 
Virata Embedded Web Technology http://www.emweb.com/ 
I don't see how this packaging issue saves resources in the IPP client - it has to muster all the components anyway to send them, regardless of what order they are sent in. 
Indeed, it would be easier for the sender if they were all just sent sequentially without the interleaving. 
The only motivation I could see for the interleaving was solving the problem of not having buffer space in the receiver to buffer the entire composite object. 
Perhaps I misunderstood... Scott Lawrence Architect slawrence@virata.com 
Virata Embedded Web Technology http://www.emweb.com/ 
one reason I didn't suggest the "printer fetches things on demand" model myself was that I didn't know your requirements - other than that you seemed to be assuming that the document would fit into a MIME message. 
there are certainly conditions under which the "on demand" model would not work - among them being long round-trip delay conditions and intermittent connectivity. 
(however I'll confess I'm intrigued - under what conditions does a cell phone need to send a complex document to a printer? 
I can see how a cell phone might want to dump its address book, or forward an incoming documents, they don't seem like complex documents. 
I can also see how I might want to transmit a complex document to a printer from my palm III to a cell phone - but the palm III is quite perfectly of speaking TCP and acting as a server for any document that is already stored in its memory.) 
But I have to wonder about problem definitions that place so many constraints on a solution that no reasonable solution seems possible. 
It's not that such problems don't exist, it's that one gets the impression that the problem definition raises the bar higher than necessary or the solution set is constrained more than necessary. 
In particular "the resources necessary to support a server" basically means the ability to multiplex and demultiplex data over a communications channel, along with (perhaps) the ability to accept unanticipated input. 
I'm not claiming that all cell phones can do this, but a device that cannot do this is limited indeed! 
Surely the processing overhead associated with handling complex documents far exceeds that required to do simple multiplexing and demultiplexing. 
An environment that is so bandwidth constrained that base64 is an onerous amount of overhead probably shouldn't be using either MIME or XML framing either - it should probably be using some binary protocol that does framing, multiplexing, and lossless data compression all at the same time (since they interact with one another). 
And intuitively, trying to make a resource-poor client transmit arbitrarily complex documents to a resource-poor printer sounds like an unrealistically hard problem. 
I'd be looking for ways to place firm limits on the allowable size/complexity of the document. 
Realistically, unless you impose some such constraints, interoperability is just going to be a crap shoot anyway. 
Keitt 
