<s> I've been on vacation and just got back.  </s>
<s> I think the interaction of 'content negotiation' and 'caching' can be limited to acknowledging that: * the value returned by applying a method to a URI depends on many of the other headers in the request (including those supplied during content negotiation, the user agent, etc.) * the originating server needs to indicate which request headers were involved in deciding what content to return, even if those request headers are not replicated in the entity headers of the response * a cache might legitimately keep around several cached values for the same method applied to the same URI, and want to apply a 'get-if-different' validator that would request validation of one of the several cached values.  </s>
<s> The same principle for caching applies for content negotiation, authentication, and state sharing.  </s>
<s> I think there are additional complications which require more attention from the caching subgroup (though it's possible the attention will boil down to dismissing this issue).  </s>
<s> If it is possible for a given object to be returned in response to requests on different URIs, as it would be with content negotiation (among other possibilities), then either that object must be pre-expired, so that it will be validated on every request, or it will be possible for multiple versions of the object to be present in, and servable from, a cache if the object changes at the origin server prior to its stated expiration date.  </s>
<s> The consequence of this is that users might see previous versions of an object, even though they are only using a single cache.  </s>
<s> rom a user's perspective, this is worse than consistently serving a version that lags somewhat behind the "latest &amp; greatest" version from the origin server.  </s>
<s> --Shel  </s>
<s> If it is possible for a given object to be returned in response to requests on different URIs, as it would be with content negotiation (among other possibilities), then either that object must be pre-expired, so that it will be validated on every request, or it will be possible for multiple versions of the object to be present in, and servable from, a cache if the object changes at the origin server prior to its stated expiration date.  </s>
<s> The consequence of this is that users might see previous versions of an object, even though they are only using a single cache.  </s>
<s> There's a false dichotomy here.  </s>
<s> It should be possible to separate the problem of validating a cached response (is this the response that the server would give for this variant) from the problem of determining compatability between a specific response and a set of requests that differ in their Accept headers (is this the variant that the server would return).  </s>
<s> I would agree that one could solve both problems by presenting every request to the server, but I would not agree that this is the only possible solution.  </s>
<s> For example, if the origin server's response contains sufficient information about the existence of other variants, the cache could (in principle) decide that a non-expired ("fresh") cached response obtained with one set of request headers is in fact appropriate to return for a different set of request headers.  </s>
<s> -Jeff  </s>
<s> I see your point, though I wonder how tractable your alternative would be.  </s>
<s> To ensure cache coherency using the method I think you are suggesting, each time a given object is returned in response to any request, the server would have to indicate all the possible request URIs for which that object might be returned (in addition, possibly, to the content-negotiation info by which the object would be selected).  </s>
<s> There is also a spoofing issue, especially in the present design with its Location headers.  </s>
<s> We can't let responses claim anything that would allow the returned objects to be cached under a bogus key that would allow later requests to erroneously return the object.  </s>
<s> This is why people appropriately shot me down some months ago when I suggested that, in order to solve the duplicate object problem as mentioned above, caches replace any objects they contain that used the same Location header.  </s>
<s> So, the only thing I have been able to think of that will work -- by which I mean it will ensure cache coherence and also a reasonable hit rate -- is for the cache to flush any other objects it contains which claimed the same URI as the returned Location header, but only if they do not have the same cache validator.  </s>
<s> --Shel  </s>
