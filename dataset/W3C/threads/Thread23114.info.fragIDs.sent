-----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1 hi all, 
1. Event.preventDefault() vs. preventImmediateDefault() Where exactly is the difference between Event.preventDefault() and Event.preventImmediateDefault()? 
Sorry, I did not understand it - and even why :( some examples would really help, probbably :o) 
2. interface CustomEvent I do not believe that CustomEvent is needed since I even just implemented it after have the main stuff working from the events stuff. 
AFAIK CustomEvent gives just access to some members for at least the EventTarget's dispatching methods. 
While I do not know whether Java does 
support friend classes to access private members I still propose to remove this interface since it is very implementation specific and there is really no need for the application writer to have access to these private members of the Event interface - or give me some reasonable examples :o) 
3. DISPATCH_REQUEST_ERR I do not understand why and when this can happen. 
the spec says "If the Event object is already dispatched in the tree." 
While this may happen in the dispatchEvent method I really have no case for this to be thown. 
Could you give me an example what exactly is meant by the spec? 
4. EventFOO.initFOO[NS](...) Letting all these methods returning the Event that they are (this) would be very helpful for the application programmer since it sometimes makes sense to combine several functionis together. 
There's my C++ use case: dispatchEvent(document- createEvent("Foo")- initFoo("bar")); Although while C++ does not have any GC I assume that the EventTarget.dispatchEvent() method may take ownerchip of its passed event object. 
does this violate the spec to be conform? 
5. XPath result sets Why the hell did you change the return type of all all the query methods from XPathResult to DOMObject? 
Well, this may be straight forward compatible, but I always need to dynamic_casrt here to test whether the result is *really* of type XPathResult. 
This is really everything but performance friendly :( 
That's it so far, Christian. 
15:59:54 up 62 days, 7:08, 0 users, load average: 0.00, 0.00, 0.00 -----BEGIN PGP SIGNATURE----- Version: GnuPG v1.2.2 (GNU/Linux) iD8DBQE/G/bbPpa2GmDVhK0RAuztAJ9BuC2cCW/P7l0P+E/CKHzgtgvHqwCfWt3h vBe8ugKZRVUrtwzSFuPanw0= =G0e5 -----END PGP SIGNATURE----- 
One scenario where this is needed is in mixed language implementations like Mozilla (just to name one). 
There script writer can create custom events in JavaScript (or whatever supported scripting language, at least in theory) and dispatch them, in this case the C++ implementation that does the actual dispatch needs to be able to set the target, and so on. 
In this case it gets really hard if not impossible to do this w/o a well-defined interface on custom events that have setters for those readonly attributes in question. 
This is more a coding style issue than anything else. 
As for the 
ownership issue, the spec doesn't attempt to define that since there's 
no common rules that apply in every case. 
IOW, it's up to the implementation to define the ownership of DOM objects. 
Making the DOM implementation delete events that are dispatched is IMO not a good idea since it limits what type of event objects you can pass in. 
For instance, you can't create a custom event on the stack (i.e. w/o allocating it on the heap) if your dispatch code deletes the events after they're dispatched, and you can't create an array of events and pass in an event in that array (since the array items can't be deleted, all arrays might live in one contigous block of memory). 
And so on. 
jst 
The Event interface never had a preventImmediateDefault. 
You should compare stopImmediatePropagation and stopPropagation. 
Let me know if you're still having problems understanding the diferences. 
I do believe it is clear enough in the current draft. 
The draft is at 
[skipping since Johnny already replied] 
An event listener could certainly try to dispatch the event object it just received: function myListener(e) myOtherTarget.dispatchEvent(e); 
While the event model is reentrant (see section 1.2.2.5), the DOM Event API does not allow the same event object to dispatch in the tree twice at the same time. 
So the event listener above will always raise a DISPATCH_REQUEST_ERR exception. 
[skipping since Johnny already replied] 
XPath 2.0 is the reason. 
The idea is to be able to return XPathResult2 (for XPath 2.0 result objects). 
Noted. 
Not sure if we will do something about it but this is exactly the kind of comments we'd like to hear during the Candidate Recommendation period. 
Philippe 
-----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1 
Yeah, sorry, I meant stop[Intermediate]Propagation. 
It must have been very very late while writing this mail ;) Well, okay, I got some private help by a nearly native speaker ;) *NOW* I believe to understand.... 
Ah, thanks, now I know what's meant ;) If really someone wanna redispatch an event he shall clone this event and dispatch the clone instead of of above case. 
function ilovejs(e) { myOtherTarget.dispatchEvent(e.clone()); 
Yet another thing: Event.eventPhase() vs. Event.type() 
I feel really not very happy about both Event properties. 
I'd either propose to name both as: Event.eventPhase() and Event.eventType() or Event.phase() and Event.type(). 
But having: Event.eventPhase() and Event.type() looks very inconsistent to me :( 
Since no implementation will provide XPath 1.0 *and* XPath 2.0 inclusivily. 
I'd propose to keep that name XPathResult and just extend/modify this interface. 
I really has no need to be backward compatible since we're talking about a big version move (vom 1.0 to 2.0 ;) 
I suggest to provide generic XPathResult interface that provides some kind of read-only property telling me what kind of result I have. 
You may compare this to Node.nodeType() that can be implemented very fast by just returning a member variable inline (in case of C++). 
Greets, Christian Parpart. 
p.s.: now it looks like I've Events module completed before Core... *heh* 21:16:26 up 70 days, 12:22, 0 users, load average: 0.02, 0.03, 0.05 -----BEGIN PGP SIGNATURE----- Version: GnuPG v1.2.2 (GNU/Linux) iD8DBQE/JvHePpa2GmDVhK0RAnSpAJ0ROOIZQe4EX7ummAxORf83nRzt2wCfTx7W 0M2yPAWK7eTQ/vPdstVFpSg= =tgZ9 -----END PGP SIGNATURE----- 
Those names were established in DOM Level 2. It is *MUCH* too late to change them now. 
Sorry. 
inclusivily For what it's worth, Xalan has certainly heard requests that it support both, depending on which level of XSLT we're processing. 
That may or may not have implications for what DOM users will want to do. 
-----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1 
Yes, of course, but EventTarget.dispatchEvent() has direct access to the Event properties (read/write) since the language C++ allows classes to be friends of other classes (EventTarget is a friend of Event, so it can even access private members). 
JavaScript does not need to implement the dispatchEvent algorithm so you don't need this here. 
Furthermore, for creating custom events you don't need the CustomEvent interface to modify the base properties of the Event object since you can initialize it via initEvent[NS] and all remaining properties are related to the EventTarget.dispatchEvent function that means, that this function will write to theses properties itself. 
(Or did I misunderstand something?) Greetings, Christian Parpart. 
00:33:27 up 70 days, 15:39, 0 users, load average: 0.06, 0.07, 0.30 -----BEGIN PGP SIGNATURE----- Version: GnuPG v1.2.2 (GNU/Linux) iD8DBQE/JvjWPpa2GmDVhK0RAon8AJ0etavKNwDCSYMjdKClOBXeFgXgGQCeP0sN HGSGEZT+nwa0Ac8zcALiGHk= =HTaG -----END PGP SIGNATURE----- 
While the implementation will not be required to provide both, I consider it likely for some implementations to provide both. 
This is easy because seperate request codes will be used. 
While the application will choose to use one or the other by choosing the corresponding request codes, the implementor may want to provide both depending upon applications usage. 
Using the hasFeature method, it is possible to test whether the implementation supports the one required. 
It is never necessary to test what type of result is present. 
That is already obvious from the request code. 
This is already very similar to Node.nodeType. 
I hope soon to post a note containing more details. 
Since the result type is sufficiently different for XPath 1.0 and 2.0, a cast is required, but the cast should never fail except in the case of a programming error. 
Ray Whitmer ray@xmission.com 
