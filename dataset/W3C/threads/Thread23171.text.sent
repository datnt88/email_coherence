In the Text Nodes section, I'm a little unsure about how entity references are to be handled. 
The spec says "may have multiple fragmented Text nodes due to cdata sections, entity references, etc.", but does this mean that entity references are treated as text nodes? 
Or when looking for text nodes, should entity references be expanded (or recursively traversed, looking at their content, as if they were expanded)? 
Thanks for pointing me in the right direction. 
The idea is that since you're calling XPath in the DOM world, you get a result in terms of the DOM tree. 
If the XPath returns text, it returns only first Text/CData node in any block of logically-contiguous text. 
(Which may involve multiple nodes, and may cross EntityReference boundaries.) A separate convenience function allows querying all the logically-contiguous text as a single string, ant it's the API user's responsibility to understand that when a Text node is returned they should use this approach rather than just asking that node for its own data/value. 
(Or, of course, the user can set up their own iterator/treewalker to examine the consecutive nodes, if they really care about the structure. 
We might want to include an appropriate NodeFilter in our documentation, though I think that would be considered to be on the wrong side of the declarative/descriptive line.) 
It's a compromise to match impedence between the XPath and DOM data models. 
I consider it a reasonable one, since anyone who wants only the XPath view can fairly easily derive that from these tools,, while those who want the DOM view still have the additional detail available. 
(If XPath and DOM hadn't diverged, this kluge wouldn't be necessary. 
But they did, and we're stuck with trying to come up with a reasonable interpretation and implementation despite that..) Joe Kesselman / IBM Research I'm still a little unclear, say I declare: And then I have the following XML fragment: This is the &amp;middle; part So if I did "/top/text()" what would be returned? 
Would it be: 1) "This is the" 2) "This is the" and "part" 3) "This is the" and "middle bit" and "part" 4) Something else? 
Thanks for the help. 
In your example, "/top/text()" would return a pointer to the Text node containing "This is the " (don't forget the trailing space). 
Your application could (and presumably would, if you aren't interested in the details of the DOM structure) then call that object's wholeText() method rather than retrieving its value/data, which would yield the DOMString "This is the middle bit part". 
(Note that since CDATASection inherits from Text, it too supports the wholeText() operation.) Joe Kesselman / IBM Research ... I presume that any discussions about converging the data models haven't been successful? 
The DOM house has a little too much gingerbread for most purposes I've seen. 
Better defaults would help ... such as saying that boundaries for entity refs and CDATA will be ignored by default when building a DOM tree. 
- Dave On Wednesday, 10/10/2001 at 09:52 MST, David Brownell david-b@pacbell.net 
Since the Infoset has decided that its role is descriptive rather than prescriptive ("if the data happens to exist, this is one way in which it might appear -- but it might not"), I don't expect this to change. 
Some of that's left over from "DOM Level 0" compatability requirements. 
Some is because, as with any committee project, one man's gingerbread is another man's foundation. 
I think the DOM core has actually managed to stay tolerably clean, given the requirements it's had to face and given how many of those (eg namespaces) were afterthoughts. 
The DOM WG has periodically investigated the concept of defining official subsets smaller than Core DOM, but every time we look at that it turns out that there's no clear agreement on what subsets are universal enough to be worth standardizing. 
Before DOM Level 3, we had no API addressing how a DOM tree would be built and thus couldn't specify defaults or how to override them. 
The introduction of the Load/Save chapter gives us a possible handle on that issue... but of course, that still only affects DOMs produced by that API; if the DOM was built by other code, we can make suggestions but really can't enforce them... and generally shouldn't try, since there are legitimate reasons for not doing so. 
The DOM's built-in operations have to be able to deal with any legitimate state of the DOM, and should do so without undue side effects, so our XPath support has to be able to work within that framework. 
This yields a few minor warts, easily hidden from folks who don't care about them. 
(The Namespace Node support may not be such a minor wart, especially as future versions of XPath are likely to redesign how those are handled. 
Oh Well.) Joe Kesselman / IBM Research 
