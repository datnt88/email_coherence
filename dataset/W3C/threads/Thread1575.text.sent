Section 2.2 and Section 2.3: Is it a MUST level requirement that a core versioning server support all of the properties in sections 2.2 and 2.3? 
I.e., MUST a version-controlled resource have all of the Section 2.2 properties defined upon it (well, really, all that are appropriate for its checked out/checked in state), and MUST a version resource have all of the Section 2.3 properties defined on it? 
If so, I couldn't find a place that explicitly states this. 
Section 2.2.3: 
It seems like, most of the time, the server will be setting the value of DAV:predecessor-set, and except for merges, or adding to the server-computed value, the client shouldn't try to write to this property. 
Is this correct? 
If so, it would be nice to capture this in Section 2.2.3, so client writers have a better expectation about how this property works. 
Section 2.2.5: 
This seems underspecified to me. 
There are really two parameters here, resource is write-locked/unlocked, and autoversion status of when-unlocked, and when-locked. 
We can make a table, and indicate areas that are specified in this section write-locked unlocked (non-write-locked) when-unlocked A modification request is automatically ??? preceded by a checkout operation, and (same as unlocked?) automatically followed by a checkin. 
when-locked A modification request is automatically preceded by a checkout operation, and an ??? automatic checkin operation is (same as above? 
(when-unlocked, unlocked)) applied when the applied when the write lock is removed. 
Also, what happens when the resource is write-locked, and the value of DAV:auto-version is changed from when-locked to when-unlocked? 
Is a version automatically created upon successful completion of the PROPPATCH (because there would already be an active CHECKOUT due to the lock, and the when-locked condition)? 
Section 3.2: CHECKIN takes a version-controlled resource, and turns it into a version resource which is a copy of its body and dead properties. 
Properties that must exist on a checked-out version-controlled resource are: DAV:checked-out DAV:predecessor-set DAV:precursor-set DAV:auto-version Which of these properties should be transferred over to the version resource created by CHECKIN? 
My guess is: DAV:checked-out: no DAV:predecessor-set: yes DAV:precursor-set: yes DAV:auto-version: no At the very least, this issue is not currently addressed in the specification (except for DAV:predecessor-set). DAV:precursor-set behavior is described implicitly (by the existence of the property on a version resource) -- I think it should be made more explicit, in the description of CHECKIN. 
The text describing the (DAV:checked-in) postcondition should explicitly note that the properties being discussed are on the version-controlled resource, and not the version resource. 
- Jim Jim Whitehead wrote on Wednesday, January 31, 2001 5:42 PM: I agree that all the combinations need to be covered by the spec. 
Moreover, section 2.1.2 only talks about auto-version being "set" and doesn't differentiate among the possible settings of auto-version. 
Both problems need to be fixed. 
Geoff Clemm's 1/13/01 email sketched out his intent for the semantics of the four possible settings for auto-version: nothing (no auto-versioning) DAV:when-locked (auto-checkout when locked) DAV:when-unlocked (new version when unlocked) DAV:when-locked, DAV:when-unlocked (both) In an attempt to fill in Jim's table, I have tried to expand Geoff's sketch, based on Geoff's other messages around the same time. 
It's useful to recall that if the VCR is checked out at the time of the PUT or PROPPATCH, the auto-version property is ignored, and there is no auto-versioning. 
That leaves the case when the VCR is checked-in at the time of the PUT or PROPPATCH, with the following interpretation of the value of auto-version: nothing - no auto-versioning DAV:when-locked - auto-checkout when write-locked, buffer changes until unlock request, then auto-checkin - error when unlocked (at time of PUT or PROPPATCH) DAV:when-unlocked - create new version; i.e., auto-checkout, modify, auto-checkin (must supply lock header if VCR write-locked) DAV:when-locked, DAV:when-unlocked - auto-checkout when write-locked, buffer changes until unlock request, then auto-checkin - create new version when unlocked; i.e., auto-checkout, modify, auto-checkin Note that when-unlocked does *not* mean auto-version only when the VCR is unlocked, whereas when-locked does in fact mean auto-version only when the VCR is write-locked. 
This inconsistency makes the naming somewhat misleading, but I haven't come up with anything better that also works in combination in the fourth case. 
This interpretation of when-unlocked is critical for versioning systems that require all versionable resources to be under version control, but don't support storing intermediate state on the server between checkout and checkin. 
Such systems cannot support the CHECKOUT option, because it requires storage of intermediate state. 
Nor can they support the when-locked flavor of auto-versioning, for the same reason. 
So they are reduced to depending on the when-unlocked flavor of auto-versioning in core versioning, with the above interpretation covering all VCRs, regardless of lock state. 
--Chuck Fay FileNET Corporation, 3565 Harbor Blvd., Costa Mesa, CA 92626 From: "Jim Whitehead" ejw@cse.ucsc.edu 
Date: Wed, 31 Jan 2001 17:42:14 -0800 Section 2.2 and Section 2.3: Is it a MUST level requirement that a core versioning server support all of the properties in sections 2.2 and 2.3? 
I.e., MUST a version-controlled resource have all of the Section 2.2 properties defined upon it (well, really, all that are appropriate for its checked out/checked in state), and MUST a version resource have all of the Section 2.3 properties defined on it? 
If so, I couldn't find a place that explicitly states this. 
I'll add the statement that the properties defined by core or an option are REQUIRED for core or that option. 
Section 2.2.3: 
It seems like, most of the time, the server will be setting the value of DAV:predecessor-set, and except for merges, or adding to the server-computed value, the client shouldn't try to write to this property. 
Is this correct? 
If so, it would be nice to capture this in Section 2.2.3, so client writers have a better expectation about how this property works. 
There are common cases when branching is disallowed but multiple checkouts are allowed where a client will be updating the predecessor set. 
I believe this is better handled in the scenarios document or FAQ, and not in the protocol document itself. 
Section 2.2.5: 
This seems underspecified to me. 
There are really two parameters here, resource is write-locked/unlocked, and autoversion status of when-unlocked, and when-locked. 
... I'll fix this. 
In particular, there are really only 3 interesting combinations: DAV:always-checkout-always-checkin DAV:always-checkout-when-unlocked-checkin DAV:when-locked-checkout Also, what happens when the resource is write-locked, and the value of DAV:auto-version is changed from when-locked to when-unlocked? 
Is a version automatically created upon successful completion of the PROPPATCH (because there would already be an active CHECKOUT due to the lock, and the when-locked condition)? 
Yes, the postcondition of UNLOCK does not depend on the current state of the DAV:auto-version property. 
Section 3.2: CHECKIN takes a version-controlled resource, and turns it into a version resource which is a copy of its body and dead properties. 
Properties that must exist on a checked-out version-controlled resource are: DAV:checked-out DAV:predecessor-set DAV:precursor-set DAV:auto-version Which of these properties should be transferred over to the version resource created by CHECKIN? 
My guess is: DAV:checked-out: no Yes, properties that are not explicitly stated as being transferred are not transferred. 
DAV:predecessor-set: yes DAV:precursor-set: yes Oops! 
Forgot this one ... will fix. 
DAV:auto-version: no At the very least, this issue is not currently addressed in the specification (except for DAV:predecessor-set). DAV:precursor-set behavior is described implicitly (by the existence of the property on a version resource) -- I think it should be made more explicit, in the description of CHECKIN. 
It is, in the DAV:initialize-version-content-and-properties postcondition. 
The text describing the (DAV:checked-in) postcondition should explicitly note that the properties being discussed are on the version-controlled resource, and not the version resource. 
Will do. 
Cheers, Geoff 
