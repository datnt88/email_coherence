Hi, Wendy 
I think we may not be talking about the same problem. 
I'm looking at the situation where there is a need for pages to be generated 
dynamically. 
There is some aspect of the application which prevents the 
web page from being stored. 
Perhaps, the page content in some way is not static. 
For example, information from two sources being merged together by user request. 
A search engine responding to queries. 
The data from a datasource may not be marked up or the data coming from multiple sources using different mark up formats. 
As a result, the data has to be massaged and converted to a format for presentation. 
My proposal is that there be an ability for the software doing the massaging to produce the information in multiple formats. 
I guess what I'd like to recommend is that if web pages are being generated dynamically for some reason, e.g some aspect of the content is not static from presentation to presentation, I'd like to see that there would be a choice of an accessible version being generated. 
I hope I'm being clearer in my intent. 
Scott 
Scott, In your previous post you suggested that a programmer who had created a dynamic page could more easily write a new subroutine than "dealing with postprocessors." 
Your main concern was that if the data changed, then someone would have to go change the postprocessor. 
If the data and structure of the page is appropriately separated from the presentation, then changes to data can happen independently from changes in presentation. 
In your second post you used the example of a Table as a reason for why someone would want to use dynamically generated pages. 
There are quite a few ways to address this issue either on the client- or the server-side. 
It will depend on how the data or content of the page is marked up, but a client-side tool could more effectively allow the user to interact with the data than a static presentation generated then served (i.e., querying a cell for information about its header(s) or table for a collection of cells). 
There are also several client-side generated schemes that work well. 
I have been working on a client-side script that uses style sheets to show and hide information in a dynamic way that also works when scripts or style sheets are not loaded. 
It is dynamic presentation of content, but because of style sheets and scripting, it can either linearize into a table of contents and text, or be displayed with a "visual imperative." 
I have chosen a blue horizontal menu bar, with orange submenus that pop up, and other text that is shown depending on which submenu is selected. 
in other words, it transforms gracefully because content is separate from presentation. 
I am anxious to investigate how I might use a combination of XML, RDF, and scripting. 
Especially with data tables. 
You are advocating server-side scripting. 
As long as the content is separate from the structure, and the nature of the content is static, I don't think it depends where the generation (or transformation) happens - on the client, the server, or some gateway. 
Until user agents all support scripting consistently and adopt a common object model, some of that generation will more reliably happen on a server, but in the future it's really not going to matter where the presentation comes from: a subroutine, a style sheet, it happens on the fly as the user agent interprets meta information, etc. 
It will depend on what you are doing and what is most effective. 
therefore, your suggestion (if I understand it correctly) follows along quite nicely with the themes of WCAG: graceful transformation and separation of content from structure. 
You are more than welcome to develop server-side strategies for inclusion in the techniques document. 
We are in the process of restructuring it and adding new techniques before the end of the charter (30 Nov), so now is a good time to get something included. 
Particularly, if you have examples for the checkpoints that specifically mention scripting. 
thanks, --wendy 
aloha, scot! 
yes, you are being clearer, and i'm beginning to think that we are talking 
about the same sorts of things, only mine's client side, and it isn't tailored 
for the blind, it's tailored for _me_ and for the system, and user agent from which the request for the content was issued... 
gregory. 
Scott wrote, in reply to Wendy: 
He that lives on Hope, dies farting -- Benjamin Franklin, Poor Richard's Almanack, 1763 Gregory J. Rosmaita unagi69@concentric.net 
WebMaster and Minister of Propaganda, VICUG NYC 
Hi, Nir 
Actually, the issue of specifying the tailoring can be handled in a 
number of different ways depending on the application. 
For example, if the user is accessing a personal portal, when he/she signs up for the portal, there could be an option for blind user customization. 
In a search form, there could be a button requesting output customized for a blind user. 
Cookies are another option. 
Scott 
One issue in generating dynamic pages tailored for the user, is the ability of the server to have useful information on the user's needs. 
It seems to me that the current state of HTTP doesn't allow to get enough information regarding needs of disabled people. 
The mechanisms available now to the server are: 1. 
The client's "accept" "accept-language" and "accept-charset" request headers, 2. The client's "user-agent" request header. 
The accept-language and accept-charset are the most used by clients and servers, but they have no direct relation to accesibility. 
The "accept" header may be of some use for accessibility, but if the server wants to serve only different HTML pages, its use is quite restricted. 
The user-agent request header has two problems. 
One is that using it is not scalable from the server's point of view: the server has to study the particular abilities of a growing and diversified set of user agents. 
The second problem is that even if the server recognizes the user agent, this is insufficient to tell what the user needs: I may very well want a page crowded with images when I am using Lynx as I have configured an external image viewer. 
Style sheets offer a mechanism to discriminate by "medium". 
(Either via the "media" attribute of the link and style HTML elements, or internally in the stylesheet itself) However as Scott suggests, sometimes complicated transformations (not available in CSS but possibly available in XSLT) that are taken on the server side are desireable. 
It seems that a possible solution is to have a "user-agent-media" request HTTP header. 
(or "accept-media" ??) As it has a limited set of values it is much more scalable than user-agent, and is a more natural way to apply style sheets on the server side. 
Seems as an idea that fits the current slogan "CSS on the client and XSLT on the server." 
Regards, Nir. 
Hi, 
In my proposal I'm making the assumption that content can be 
presented in different forms in order to achieve accessibility. 
Here's the mission statement of the working group: 
"This revised charter extends the duration of the Web Content Guidelines Working Group (GL WG) to allow it to complete the Web Content Accessibility Guidelines and to do initial post-Recommendation analysis of implementation issues and appropriate next steps in this area. 
The Web Content Accessibility Guidelines focus on HTML, CSS, and XML, and provide guidance to Web content developers on how to make Web sites accessible to users with disabilities. 
This Working Group was originally chartered and 
a Call for Participation issued in October, 1997, and the group is 
within the duration, scope and resources of the WAI Activity Proposal and announcement. 
The Web Content Accessibility Guidelines Working Draft completed Last Call on March 19, 1999." and the first item in the list of deliverables: "Web Content Accessibility Guidelines: A set of guidelines that clearly outlines the major principles for creating accessible Web content, and includes verifiable checkpoints for each guideline." 
I might be missing something, but I don't quite see any reference to only a single format of content being required for all disabilities. 
Is there a reason why selection of the format has to be via detection? 
If detection were available, the better design would be for the server to take a guess via detection, but allow for the user to over-ride any way. 
The guidelines actually do make decisions already about what is appropriate for individual groups of users, e.g. use of tables, labeling each form component, etc. 
If software can generate web pages which are optimal in accessibility efficiency for a each particular user while conveying the all the information, is there an advantage to the user to cause him/her to use a form of the content which is less in terms of accessibility efficiency? 
My assumption is that in most cases people will much more frequently benefit from greater accessibility efficiency than having the same presentation of their colleagues. 
In the few cases/applications where it is important to see the same exact presentation of content, the web server could create only one form of web page to be used by both sighted and blind users. 
(Though, a question to ask is given the nature of blindess, how similar will be the perception of the presentation for blind people as for sighted people any way?) Scott 
Nir has correctly identified the basic problem of automatically providing different versions - this problem is exactly the same as faced by mobile devices which have an extremely diverse range of capabilities. 
The W3C work on CC/PP is intended to address precisely this question, and hopefull in the near future it will be possible to describe user requirements, preferences and capabilities in terms of media much better, and serve content tailored for that. 
An example from the mobile world is to serve just the outline of a page (perhaps the top couple of header levels, and summaries of multimedia objects) and to serve a single section on request. 
The other problem that has been identified by Gregory and others is the question of what is appropriate for individual groups of users. 
For example, some people who have no vision are not interested in receiving images, and don't care about the colour of text. 
Others have software which allows them to distinguish classes of text in tones, or to render graphics in a tactile or sonic format, or need to know how the content is being presented to their colleagues, in order to talk about the same things. 
As I understand the goal of this group, it is to produce guidelines which enable people to create content once that can be used by people regardless of disability, rather than ot create multiple forms of content for each different set of user needs. 
That approach is necesasry in the case where it isn't possible to create generally accessible content, and may sometimes be an optimisation for reasons of implementation. 
Charles McCN 
I prefer the term content negotioation rather than detection. 
The current 
state of content negotiation (both the standard and even more so the 
implementations) is indeed some sort of detection or guessing. 
In the ideal form of content negotiation users configure their browsers to provide the necessary and sufficient information about their preferences over the form of content, and the server serves them as needed. 
If the server doesn't figure out what is best it gives the client a list of options. 
If the client knows enough it chooses automatically, if it doesn't it asks the user. 
The reasons why content negotiation is preferred than giving the user a list of choices via links or drop down menus are: 1. 
With content negotiation the user configures its browser once and gets the right form of document. 
With lists of choices the user has to manually tell its preference to every website. 
Automation helps the user and saves him nags. 
2. Puting a list of 35 alternatives on every page in a website confuses the users and reduces usability for all users including those who are in their more or less preferred format. 
You should note that alternatives are not only accessibility related but also language and charset (there are many languages less lucky than English where a unique common encoding does not exist.) So if you start multiplying the numbers you'll see that 35 is a rather modest number of alternatives. 
True. But on should strive for automation, and only when the server and client can't figure out what to do, ask the user. 
Nir Dagan 
Assistant Professor of Economics Brown University Providence, RI USA 
Hi, My impression is one reason for using CSS is to be able to create 
different presentations of web pages. 
From the user's point of view, does 
it matter how different presentation forms are created? 
I think the goal is to get the user a presentation of a web page which meets his/her needs and preferences. 
Scott 
Hi, I've done a fair amount on configuration issues over the years. 
One of the challenges can be the difference between general attributes 
and attributes which are specific to such aspects as subject matter or task. 
Setting up a browser for this type of non-general attribute will be interesting. 
An issue is persistence of choices. 
Setting the browser is one approach. 
Unfortunately, the problem with setting the browser is that an 
application may make choices which a user doesn't like. 
The user will need some way to over ride the attributes that the application gets from the browser. 
Two other other problems with browser based attributes is what to do if multiple users share a browser or if a user works with different browsers at different locations. 
Presenting alternatives hopefully will be done in ways to accomodate different types of users, e.g. fewer choices for beginning users, more choices for advanced users, etc. Scott 
aloha, scott! 
you are still, in my opinion, attempting to impose a many-sizes-fits-all policy 
on content delivery -- an approach which is doomed for you cannot possibly predict (nor can you reasonably expect content providers to know) what the 
individual blind user needs in order to make sense of, and interact with, the 
content being delivered... yes, the server should assume half of the burden (which can be done via responsible browser sniffing, so that the stylesheet and inline style declarations delivered with the content, for example, won't crash the requesting UA nor cause the content to be rendered in unexpected and incomprehensible ways), but the client side should handle the quote blind 
tailorization unquote -- particularly if the requester is using an AT that can 
access his or her user agent of choice's DOM... and even if the blind 
individual requesting the content isn't using a user agent that has implemented 
the DOM, or is incapable of supporting it, then an intermediary proxy, of the 
sort that len kasday and i have been talking about in WAI circles since 1997, 
could do the client side work for a client that doesn't have the resources or 
access to the DOM needed by the UA slash A.T. combination described in my 
scenario... of course, the proxy would have to be heuristic, and constantly 
updated, so as to take into account new scenarios and combinations, but gregory. 
He that lives on Hope, dies farting -- Benjamin Franklin, Poor Richard's Almanack, 1763 Gregory J. Rosmaita unagi69@concentric.net 
WebMaster and Minister of Propaganda, VICUG NYC 
Hi, Gregory I'm not sure we are using the same analysis. 
Let's break this up into 
two pieces. 
First there is the selection of what is delivered to the 
browser. 
The server is making the decision here. 
In your model, which is also a version of many-sizes-fits-all approach, the server generates a web page and chooses the style sheets all of which are sent to the browser. 
In my model, the server looks at the information, chooses a format and generates the web page which is then sent to the browser. 
In your model, the server is limited to the style sheets its knows about. 
In my model, the server can use some intelligence in creating the web page. 
As a result, the model I'm talking about for the server side is much more flexible than the server side model your talking about. 
(If your model uses inline style, what is the benefit of you model over my model?) My model has the added benefit of avoiding having to worry about the differences among implementations CSS without losing any flexibility. 
When a server is interacting with information, it has a better understanding about the purposes or concepts which relate to the different aspects of the page. 
For example, the server would better know which links are for advertising and which are for the web site. 
As a result, the server can group links by categories. 
Or, for example, the server could know which functions are probably most likely to be used and could improve blind user's efficiency by letting them be activated by keyboard events. 
When a page is created, these various concepts of relationships on the page disappear. 
The DOM cannot capture them. 
To understand what I'm discussing, you need to understand the "concept-barrier" that is a problem in all of computer science including access technology. 
This is a tough one for many people to understand. 
Let me know if you want some elaboration. 
Scott 
In Gregory's model, as I understand it, the user (client) has access to specialised style sheets, which suit their individual needs. 
They can apply that to well-structured content to get document htat fits their personal requirements much more precisely than a server-sided approach can approximate 
the requirements of a class of users. 
In addition, the client can determine 
whether they want images, or audio content, or other separate pieces at the 
time they read. 
They can use bookmarks that are the same whether they are 
sighted, deaf, blind, etc. 
In some cases there is value in serving content of different types according to diffferent requests. 
(An obvious one is the tablin service that linearises tables and adds headers according to specified options). 
But in many cases the best solution is still to serve well-created content the first time around. 
Charles 
Hi, Gregory I'm not sure we are using the same analysis. 
Let's break this up into two pieces. 
First there is the selection of what is delivered to the browser. 
The server is making the decision here. 
In your model, which is also a version of many-sizes-fits-all approach, the server generates a web page and chooses the style sheets all of which are sent to the browser. 
In my model, the server looks at the information, chooses a format and generates the web page which is then sent to the browser. 
In your model, the server is limited to the style sheets its knows about. 
In my model, the server can use some intelligence in creating the web page. 
As a result, the model I'm talking about for the server side is much more flexible than the server side model your talking about. 
(If your model uses inline style, what is the benefit of you model over my model?) My model has the added benefit of avoiding having to worry about the differences among implementations CSS without losing any flexibility. 
When a server is interacting with information, it has a better understanding about the purposes or concepts which relate to the different aspects of the page. 
For example, the server would better know which links are for advertising and which are for the web site. 
As a result, the server can group links by categories. 
Or, for example, the server could know which functions are probably most likely to be used and could improve blind user's efficiency by letting them be activated by keyboard events. 
When a page is created, these various concepts of relationships on the page disappear. 
The DOM cannot capture them. 
To understand what I'm discussing, you need to understand the "concept-barrier" that is a problem in all of computer science including access technology. 
This is a tough one for many people to understand. 
Let me know if you want some elaboration. 
Scott 
--Charles McCathieNevile mailto:charles@w3.org 
W3C Web Accessibility Initiative http://www.w3.org/WAI MIT/LCS - 545 Technology sq., Cambridge MA, 02139, USA 
aloha, charles! 
thank you for articulating more succinctly and precisely than i was capable my client side model... gregory. 
He that lives on Hope, dies farting -- Benjamin Franklin, Poor Richard's Almanack, 1763 Gregory J. Rosmaita unagi69@concentric.net 
WebMaster and Minister of Propaganda, VICUG NYC 
Hi, Charles 
You may have misread Greory's posting. 
In my note, I was addressing the section of his comments where he says: "yes, the server should assume half of the burden (which can be done via responsible browser sniffing, so that the stylesheet and inline style declarations delivered with the content" I disagree that client side style sheets can create the best document for a person's needs. 
In my note to Gregory, I brought up the issue of the "concept-barrier" in computer science. 
This is key to understanding the limitations of both access technology and client side style sheets because they both share the same problem. 
Suppose you have a collection of blocks of text with medical information. 
You need to hire someone to sort through the blocks of text and create a page where the information is presented in a way that will make it easy for the reader to understand. 
Two people apply. 
One person understands medicine and its various concepts. 
The other has no medical background. 
Who would more likely structure the web page in a way where the blocks of text are organized in an order which is logical for the concepts and also in an order of importance also indicated by the concepts. 
A server has a much greater chance of organizing a web page to match the concepts. 
For example, the user requests information in order of a particular scientific ranking and then by geographic area. 
The server can do that. 
However, client side stylesheets and access technology do not understand the concepts being used. 
Further, they are limited in their abilities to deduce the concepts, e.g. understanding the ranking, since they are working with very limited information, i.e. the web page, which has probably had the key ranking information obscured in the text. 
An important factor in optimisation is that the more information available, the better to optimisation. 
The server generally has more information. 
You might argue that the client-side technology might do better, but how will that work? 
For example, how would client side technology determine what are more important links and less important links so it knows the order? 
Given two forms on a page, how will the client side technology understand which form does what? 
Otherwise, the user will have to search. 
Take a look at the demo I set up. 
Check out the standard form. 
Then check out the blind version. 
How would client side technology be able to do the same reorganization? 
(no cheating - can't just wave your hands and hand it off to the client side programmers. 
smile ) Scott 
Yes, it does matter. 
The C in CSS stands for Cascading, that is, there is an ability for the presentation ideas of the author and the user to interact to provide the best blend - the author knew the material best, the user knows their requirements best. 
A system that does not support that potential for input from both sides, and "negotiation" is generally poorer than one which does (assuming in each case that they are well-implemented). 
Charles 
Hi, My impression is one reason for using CSS is to be able to create different presentations of web pages. 
From the user's point of view, does it matter how different presentation forms are created? 
I think the goal is to get the user a presentation of a web page which meets his/her needs and preferences. 
Scott --Charles McCathieNevile mailto:charles@w3.org 
W3C Web Accessibility Initiative http://www.w3.org/WAI 
MIT/LCS - 545 Technology sq., Cambridge MA, 02139, USA 
Hi, Charles The problem is that user style sheets do not understand concepts / subject material. 
The combination of knowledge of subject material and of user can significantly affect layout. 
For example, results from seach engines often have links for next page of search results and previous page of search results. 
These links are usually at the end of the search results. 
However, for a blind user the better solution is to have these links at the top of the page so the 
blind user doesn't have to read though the search results. 
An even 
better solution for blind users is to tie the links to a keys so that the blind user can jump to the next page of results no matter where he/she is on the page. 
The user style sheet will not understand the 
purpose of these links. 
I've put up some examples of how information is presented on web pages in visual forms. 
The URL is: Take a look at them. 
How would user style sheets display them in a way easier to use for blind people? 
Something to remember is that dynamically generating web pages in different formats for different types of users does not prevent user style sheets from being used. 
The over all combination user-specific dynamically generated web pages in combination with user style sheets results in web pages even better presented for the user. 
Scott 
And why would anyone want to skip unread search results? 
The first results are 
supposed to be more relevant. 
An even 
HTML has several solutions for that. 
One is the accesskey attribute. 
Also the link rel=next maybe used for navigating to the next in the sequence page. 
For going back, all browsers have a "previous page" key. 
The user style sheet will not understand the 
But HTML can. 
Nir Dagan Assistant Professor of Economics Brown University Providence, RI USA 
are 
They are not necessarily unread. 
One could have moved back two pages in error, and need to move forward one page to get to the page bearing the link that one wants to re-visit. 
Charles's comment is correct in terms of maintaining a convenient capability for hierarchical motion, and web pages in slidesets often have next/previous buttons at the top as well as at the foot. 
Anything HTML can understand, the user stylesheet can understand by using selectors keyed to the HTML namespace. 
The purpose of the parts of a document can be understood by the user stylesheet if the XML, CLASS and REL terms used are drawn from a schema published earlier and used in writing the user stylesheet. 
We have somehow to get an abstract definition of the purpose of the varieties of content in the page. 
The originating author does not understand the best possible use of the User Interface media for the particular user who is browsing the content, and we want to have technological support for graceful transformation of the content into a presentation that is tailored to the specific needs of the user. 
To get that, we need meaningful terms used in XML element and attribute names and values and/or HTML CLASS and REL attribute values. 
By meaningful, I mean the tokens relate to meanings that stylesheet-writers can depend on. 
This can be achieved by schemas published and adhered to, or it can be achieved by loosing media critics on the current web content and using a schema language to express the current idioms as documented from observation. 
The latter is technically harder, but probably easier to achieve sooner than performing the "herding cats" task of getting millions of autonomous web authors to follow our set of rules. 
Al 
