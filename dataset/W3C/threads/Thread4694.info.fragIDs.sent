Hello, at VLDB in Berlin, Michael Rys convinced me to send another email to the XQuery comment list. 
Since I don't expect my email to have any influence, I don't bother writing down all points of XQuery which I think should be corrected. 
Instead I concentrate on the points I think are really bad. 
Here they are: 1) Runtime Exceptions: A query language should not have runtime exceptions. 
This may not always be achievable but at least type-errors should all be discovered at compilation time. 
This is not true for XQuery. 
2) A query language should be deterministic. 
This is not true for XQuery. 
Essentially, these are the points why I write this email. 
Here is my motivating scenario: In XQuery, "p and q" and "q and p" may give a different result due to runtime exceptions. 
Why is this bad? 
Assume the following scenario: A big company developes a web-site based on millions of XML documents. 
In all these documents XQueries are embedded to give dynamic up-to-date information. 
Millions of the queries embedded in the documents use conjunctions and after thorough testing all queries work and the web site is put into operation. 
After several years, the XML document base grows and queries slow down. 
The sysadmin decides to gather new statistics and let the queries be reoptimized. 
The query optimizer decides that changing the order of conjunctions will result in better plans for about half a million queries. 
Unfortunately, due to the indeterminism, all queries crash. 
The web site is down for about three month, costing the company millions of dollars(!). 
What could be your answer? 
-- The programmers should have used cascading "if-then-else" expressions. 
NO! for two reasons: 1) It could well be that they are not aware of the complications involved with using "and" and "or" and runtime exceptions. 
(Remember that testing went all o.k.) 2) Using cascading "if-then-else" averts any query optimization. 
The query is not declarative any more. 
Now, what should be done to correct XQuery? 
Many things: 1) introduce NULL-values and three valued logic (Remember that OQL had the same design flaw as XQuery---although not that bad---and that they introduced NULL-values in later versions after having tried to correct things by introducing "andthen" and "orelse" (similar to "if-then-else").) 2) Don't let empty sequences partially play the role of NULL-values. 
(Remember: is_null(empty-sequence) is not true is_empty(NULL) is not true) These things are too different to be identified. 
3) Do not identify single items with singleton-sequences that contain that single item. 
Even in the most flexible type systems of real and used programming/query languages they are distinguished. 
Other points I don't like are: 1) too much implicit casting 2) no explicit grouping (grouping has to be expressed by nested queries. 
these are difficult to unnest. 
unnesting is not always possible and is an error-prone process due to its complexity.) 
This is also a mistake that was made by the OQL designers. 
(Not exactly the same, since they have an explicit grouping, but a nested query had to be used to work on the "partition" attribute. 
They subsequently corrected things half-way by introducing some syntactic sugar for common cases. 
But you wouldn't call that a perfect solution nor would you call it elegant.) best guido ps: although XQuery improved, some of the points of my first email are still valid. 
Just a nitpick: SQL WHERE clauses fail with a conversion error if a conversion fails and the query processor executes a plan that leads to the execution of the offending conversion. 
Actually, the current XQuery rules are pretty close to SQL's rules in that respect. 
From: public-qt-comments-request@w3.org [mailto:public-qt-comments- request@w3.org] 
On Behalf Of Bill Keese Sent: Thursday, October 16, 2003 7:11 PM Subject: Re: XQuery Guido, you suggested that null values be introduced into XQuery, and 
met 
with a lot of opposition. 
But, from your examples, it seems like what you really wanted was something like "use null semantics when 
evaluating 
where conditions". 
You don't actually want an XQuery expression to return null values, do you? 
What if where clauses operated like SQL where clauses, returning false when there was a type conversion exception? 
I guess this is pretty much what Michael Kay suggested. 
(Of 
course, the counter-argument is that type-exception messages help programmers catch errors in their code and their data. 
I understand both views.) 
for $p in document("p.xml")//person 
where is_null((number) $p/@age) /* not exactly XQuery syntax, 
sorry 
return $p/@name 
You can write this query using the "instance of" operator, right? 
(http://www.w3.org/TR/xquery/#id-instance-of) for $p in document("p.xml")//person 
where not($p/@age instance of xs:number) /* I think this is xquery 
syntax 
return $p/@name 
Indeterminism sucks! 
By the way, I don't think anyone was really debating your argument 
that 
non-deterministic languages have serious disadvantages. 
Basically, if 
I 
was to paraphrase all the responses, I would say that 
"non-deterministic 
languages have many problems, but we can't make XQuery deterministic because the performance would be unacceptably bad". 
Bill Keese PS: it took me a while to figure out that existentialism has nothing 
to 
do with Kafka. 
(Especially since every Kafka book's main character is named "K", which is pronounced the same as "Kay"...) 
Wow, I've been away from SQL too long, I had forgotten this. 
I had a dim memory that SQL is also non-deterministic; you might cause/avoid hitting an exception, for example, by creating an index on a certain column. 
Well, if XQuery is working like SQL then at least it's something that's been proven by experience. 
Basically, it seems like - a (non-null) column value in a relational table (accessed via SQL) corresponds to a sequence in an XML document (accessed via XQuery) (ie, a list of values rather than just a single value) - a NULL value in a relational table (accessed via SQL) corresponds to an empty sequence. 
(ie, a list of no values) Other than that SQL and XQuery are "the same", so to speak. 
Bill 
