Since this is a fairly significant change, I'd like to hear from a few more folks before adding this to the 3253 Errata. 
Thanks, Geoff From: ietf-dav-versioning-request@w3.org [mailto:ietf-dav-versioning-request@w3.org]On 
Behalf Of Clemm, Geoff Sent: Friday, April 26, 2002 6:06 PM Subject: RE: Label header vs PROPFIND depth 1 From: Julian Reschke [mailto:julian.reschke@greenbytes.de] - I'd like to see the label *header* deprecated - I'm happy with the LABEL method and the label-name-set property - I think that PROPFIND/label should be replaced by a specific REPORT Is the proposed DAV:labeled-version report OK with you? 
Yes. 
But I think it's Tim's turn to say whether this would work for him or not... - I'm unsure about other methods that are currently affected by the header -- what were the requirements...? The other methods are LABEL, CHECKOUT, GET, and COPY. 
For Depth:0 variants of these operations, the Label header just provided an optimization to save one roundtrip (i.e. first getting the version URL via the DAV:labeled-version report). 
I believe we can easily do without that Depth:0 optimization. 
As stated before, I think that's not the single problem. 
Having GET return a (representation of a) version rather than (a representation of) the VCR makes the version *by definition* a variant (representation) of the VCR -- and it seems that most of us want to avoid that interpretation. 
For Depth:infinity (only relevant for LABEL and COPY), the savings would be more significant, but unfortunately the semantics is broken (since if the namespace is being versioned, you'll get the wrong resources if you simply do a Depth operation on the current namespace). 
The Depth:infinity Label header operations are really just a way of trying to have the client fake workspaces and baselines, instead of having the server support them directly. 
Since it is much more efficient and reliable to have the server layer these constructs above a labeling infrastructure, rather than having the client do so, I believe the cost of maintaining these Depth:infinity Label header operations in the protocol is not warranted. 
Note though that (depth:0) labeling and baselining go very well together. 
Instead of doing a Depth:infinity LABEL, you can create a baseline (which under the hood the server may well implement with reserved labels, but maybe not), and then LABEL that baseline. 
Then when you want to do a Depth:infinity COPY, you retrieve the DAV:baseline-collection of the labeled baseline (using the DAV:labeled-version report), and copy that to wherever you want. 
Alternatively, if you want a "modifiable" selection, you can create a workspace (which under the hood the server may well implement with reserved labels, but maybe not). 
When you want to adjust the versions being selected, you just use UPDATE. 
Then when you want to do a Depth:infinity COPY, you just copy from that workspace to wherever you want. 
- Servers that decide to implement LABEL and DAV:label-name-set, but no not support the label header should *not* report the LABEL feature in OPTIONS. 
That's probably right. 
A client can find out if the LABEL operation is supported by querying the DAV:supported-method-set property values of a VCR. 
...and also use DAV:supported-live-property-set to discover the DAV:label-name-set property. 
Am Sonntag den, 28. 
April 2002, um 15:53, schrieb Clemm, Geoff: Maybe Greg could comment from subversion's point of view? 
//Stefan From: ietf-dav-versioning-request@w3.org [mailto:ietf-dav-versioning-request@w3.org]On 
Behalf Of Clemm, Geoff Sent: Friday, April 26, 2002 6:06 PM Subject: RE: Label header vs PROPFIND depth 1 From: Julian Reschke [mailto:julian.reschke@greenbytes.de] - I'd like to see the label *header* deprecated - I'm happy with the LABEL method and the label-name-set property - I think that PROPFIND/label should be replaced by a specific REPORT Is the proposed DAV:labeled-version report OK with you? 
- I'm unsure about other methods that are currently affected by the header -- what were the requirements...? The other methods are LABEL, CHECKOUT, GET, and COPY. 
For Depth:0 variants of these operations, the Label header just provided an optimization to save one roundtrip (i.e. first getting the version URL via the DAV:labeled-version report). 
I believe we can easily do without that Depth:0 optimization. 
So far, everyone has either agreed or remained silent on this topic, so as a motivator for anyone objecting to speak up (:-), I will mark this issue as resolved in the errata, with the resolution being that the Label header will be deprecated, and the DAV:labeled-version REPORT inserted in its place. 
In particular, I propose the following definition for the DAV:labeled-version REPORT: 8.3DAV:labeled-version Report The DAV:labeled-version report describes the requested properties of the version with that label in a specified version history. 
If the DAV:labeled-version report is applied to a version-controlled resource, it is applied to the DAV:version-history of that version-controlled resource. 
Marshalling: The request body MUST be a DAV:labeled-version XML element. 
ANY value: a sequence of zero or more elements, with at most one DAV:prop element and with exactly one DAV:label-name element. 
prop: see RFC 2518, Section 12.11 The response body for a successful request MUST be a DAV:multistatus XML element. 
multistatus: see RFC 2518, Section 12.9 The response body for a successful DAV:labeled-version REPORT request MUST contain a DAV:response element for each resource that satisfies the Depth header of the request. 
8.3.1Example - DAV:labeled-version Report REQUEST REPORT /folder/ HTTP/1.1 Host: www.webdav.org 
Content-Length: xxxx Depth: 1 RESPONSE HTTP/1.1 207 Multi-Status Content-Length: xxxx Cheers, Geoff Since this is a fairly significant change, I'd like to hear from a few more folks before adding this to the 3253 Errata. 
Thanks, Geoff -----Original Message----- From: ietf-dav-versioning-request@w3.org [mailto:ietf-dav-versioning-request@w3.org]On 
Behalf Of Clemm, Geoff Sent: Friday, April 26, 2002 6:06 PM Subject: RE: Label header vs PROPFIND depth 1 From: Julian Reschke [mailto:julian.reschke@greenbytes.de] - I'd like to see the label *header* deprecated - I'm happy with the LABEL method and the label-name-set property - I think that PROPFIND/label should be replaced by a specific REPORT Is the proposed DAV:labeled-version report OK with you? 
Yes. 
But I think it's Tim's turn to say whether this would work for him or not... - I'm unsure about other methods that are currently affected by the header -- what were the requirements...? The other methods are LABEL, CHECKOUT, GET, and COPY. 
For Depth:0 variants of these operations, the Label header just provided an optimization to save one roundtrip (i.e. first getting the version URL via the DAV:labeled-version report). 
I believe we can easily do without that Depth:0 optimization. 
As stated before, I think that's not the single problem. 
Having GET return a (representation of a) version rather than (a representation of) the VCR makes the version *by definition* a variant (representation) of the VCR -- and it seems that most of us want to avoid that interpretation. 
...and also use DAV:supported-live-property-set to discover the DAV:label-name-set property. 
Geoff, one concern, almost the same as with the old approach (PROPFIND with label header): Which hrefs should be reported? 
I think the href property should be the URI of the version, not the one of the VCR or the VHR. 
Also: what is the DAV:version property that appears in the example? 
Julian REQUEST RESPONSE From: ietf-dav-versioning-request@w3.org [mailto:ietf-dav-versioning-request@w3.org]On 
Behalf Of Clemm, Geoff Sent: Friday, April 26, 2002 6:06 PM Subject: RE: Label header vs PROPFIND depth 1 From: Julian Reschke [mailto:julian.reschke@greenbytes.de] - I'd like to see the label *header* deprecated - I'm happy with the LABEL method and the label-name-set property - I think that PROPFIND/label should be replaced by a specific REPORT Is the proposed DAV:labeled-version report OK with you? 
- I'm unsure about other methods that are currently affected by the header -- what were the requirements...? The other methods are LABEL, CHECKOUT, GET, and COPY. 
For Depth:0 variants of these operations, the Label header just provided an optimization to save one roundtrip (i.e. first getting the version URL via the DAV:labeled-version report). 
I believe we can easily do without that Depth:0 optimization. 
From: Julian Reschke [mailto:julian.reschke@greenbytes.de] one concern, almost the same as with the old approach (PROPFIND with label header): Which hrefs should be reported? 
I think the href property should be the URI of the version, not the one of the VCR or the VHR. 
As indicated in the DAV:labeled-version example, the URI is the one of the VCR (just like a Depth PROPFIND). 
But see the answer to your next question. 
Also: what is the DAV:version property that appears in the example? 
I should have mentioned that I resurrected the old DAV:version property to make the DAV:labeled-version report work cleanly. 
The DAV:version property only appears on version resources, and contains the server-defined URL for that version. 
So the DAV:labeled-version report always reports the VCR URL, but can also report the version URL (and/or the version history URL) if requested to do so by the client (i.e. specifies DAV:version and/or DAV:version-history in the DAV:prop request element. 
Does this address your concern? 
Cheers, Geoff this REQUEST RESPONSE From: ietf-dav-versioning-request@w3.org [mailto:ietf-dav-versioning-request@w3.org]On 
Behalf Of Clemm, Geoff Sent: Friday, April 26, 2002 6:06 PM Subject: RE: Label header vs PROPFIND depth 1 From: Julian Reschke [mailto:julian.reschke@greenbytes.de] - I'd like to see the label *header* deprecated - I'm happy with the LABEL method and the label-name-set property - I think that PROPFIND/label should be replaced by a specific REPORT Is the proposed DAV:labeled-version report OK with you? 
or - I'm unsure about other methods that are currently affected by the header -- what were the requirements...? The other methods are LABEL, CHECKOUT, GET, and COPY. 
For Depth:0 variants of these operations, the Label header just provided an optimization to save one roundtrip (i.e. first getting the version URL via the DAV:labeled-version report). 
I believe we can easily do without that Depth:0 optimization. 
For Depth:infinity (only relevant for LABEL and COPY), the savings would be more significant, but unfortunately the semantics is broken (since if the namespace is being versioned, you'll get the wrong resources if you simply do a Depth operation on the current namespace). 
The Depth:infinity Label header operations are really just a way of trying to have the client fake workspaces and baselines, instead of having the server support them directly. 
Since it is much more efficient and reliable to have the server layer these constructs above a labeling infrastructure, rather than having the client do so, I believe the cost of maintaining these Depth:infinity Label header operations in the protocol is not warranted. 
Note though that (depth:0) labeling and baselining go very well together. 
Instead of doing a Depth:infinity LABEL, you can create a baseline (which under the hood the server may well implement with reserved labels, but maybe not), and then LABEL that baseline. 
Then when you want to do a Depth:infinity COPY, you retrieve the DAV:baseline-collection of the labeled baseline (using the DAV:labeled-version report), and copy that to wherever you want. 
Alternatively, if you want a "modifiable" selection, you can create a workspace (which under the hood the server may well implement with reserved labels, but maybe not). 
When you want to adjust the versions being selected, you just use UPDATE. 
Then when you want to do a Depth:infinity COPY, you just copy from that workspace to wherever you Julian didn't like the marshalling of this report, because it makes it look like the properties are those of the VCR, when they actually are properties of the version (Basically, I was just being lazy and re-using the D:response element in a bogus fashion). 
So how about the following instead: 8.3DAV:labeled-version Report The DAV:labeled-version report describes the requested properties of the version with that label in a specified version history. 
If the DAV:labeled-version report is applied to a version-controlled resource, it is applied to the DAV:version-history of that version-controlled resource. 
Marshalling: The request body MUST be a DAV:labeled-version XML element. 
ANY value: a sequence of zero or more elements, with at most one DAV:prop element and with exactly one DAV:label-name element. 
prop: see RFC 2518, Section 12.11 The response body for a successful Depth:0 request MUST be a DAV:labeled-version-report XML element. 
prop: see RFC 2518, Section 12.11 The DAV:href identifies the selected version, and the DAV:prop contains the requested properties of that version. 
8.3.1Example - DAV:labeled-version Report REQUEST REPORT /folder/ HTTP/1.1 Host: www.webdav.org 
Content-Length: xxxx Depth: 1 RESPONSE HTTP/1.1 207 Multi-Status Content-Length: xxxx Cheers, Geoff report So far, everyone has either agreed or remained silent on this topic, so as a motivator for anyone objecting to speak up (:-), I will mark this issue as resolved in the errata, with the resolution being that the Label header will be deprecated, and the DAV:labeled-version REPORT inserted in its place. 
In particular, I propose the following definition for the DAV:labeled-version REPORT: 8.3DAV:labeled-version Report The DAV:labeled-version report describes the requested properties of the version with that label in a specified version history. 
If the DAV:labeled-version report is applied to a version-controlled resource, it is applied to the DAV:version-history of that version-controlled resource. 
Marshalling: The request body MUST be a DAV:labeled-version XML element. 
ANY value: a sequence of zero or more elements, with at most one DAV:prop element and with exactly one DAV:label-name element. 
prop: see RFC 2518, Section 12.11 The response body for a successful request MUST be a DAV:multistatus XML element. 
multistatus: see RFC 2518, Section 12.9 The response body for a successful DAV:labeled-version REPORT request MUST contain a DAV:response element for each resource that satisfies the Depth header of the request. 
8.3.1Example - DAV:labeled-version Report REQUEST REPORT /folder/ HTTP/1.1 Host: www.webdav.org 
Content-Length: xxxx Depth: 1 RESPONSE HTTP/1.1 207 Multi-Status Content-Length: xxxx -----Original Message----- Since this is a fairly significant change, I'd like to hear from a few more folks before adding this to the 3253 Errata. 
Thanks, Geoff -----Original Message----- Yes. 
But I think it's Tim's turn to say whether this would work for him or not... - I'm unsure about other methods that are currently affected by the header -- what were the requirements...? The other methods are LABEL, CHECKOUT, GET, and COPY. 
For Depth:0 variants of these operations, the Label header just provided an optimization to save one roundtrip (i.e. first getting the version URL via the DAV:labeled-version report). 
I believe we can easily do without that Depth:0 optimization. 
As stated before, I think that's not the single problem. 
Having GET return a (representation of a) version rather than (a representation of) the VCR makes the version *by definition* a variant (representation) of the VCR -- and it seems that most of us want to avoid that interpretation. 
...and also use DAV:supported-live-property-set to discover the DAV:label-name-set property. 
Yes, that's the problem, and I fear the new format doesn't address this. 
If the multistatus/response format is re-used for a REPORT (basically a good thing), it must not break the existing semantics, in particular: - the properties reported must actually be the properties of the resource identified by the reported URI (DAV:href) and - the properties reported actually must be properties (!). 
If this is not the case, the response seems to indicate that there's a DAV:labeled-version-report property, which isn't the case. 
So how about properly extending the response element, for instance: Hi, I'm looking at the description for the additional OPTIONS semantics for the version-history feature ([1]), but I don't really understand what problem this feature is supposed to solve. 
Given a specific resource on a Delta-V server, I can find one (or more) collections that may contain version histories on this server. 
What is a client supposed to do with this information? 
Assuming that there is a use case for this feature -- will a future RFC define an additional live property for this as well? 
[1] http://greenbytes.de/tech/webdav/rfc3253.html#rfc.section.5.5 Hi, I was just trying to implement 5.5 in our server and came across the following issue: - the request body is optional, so I check for the presence of a XML-wellformed request body. 
If there is none - fine. 
- if there is an XML request body, the protocol *requires* that it has a certain document element. 
This basically means that RFC3253 has occupied the format for *any* OPTIONS request body -- no other HTTP-extending protocol can go out and specify similar requirements without being in conflict with RFC3253. 
In particular, RFC3253 is in conflict with a potential HTTP revision that specifies request bodies for OPTIONS (!). 
So, at a minimum, the protocol MUST allow to ignore the request body if the document element is not DAV:options. 
In the long run, I'd like to see this removed from the protocol, and possibly changed into a live property. 
Julian From: Julian Reschke [mailto:julian.reschke@greenbytes.de] 
I'm looking at the description for the additional OPTIONS semantics for the version-history feature ([1]), but I don't really understand what problem this feature is supposed to solve. 
Given a specific resource on a Delta-V server, I can find one (or more) collections that may contain version histories on this server. 
What is a client supposed to do with this information? 
The main use case for DAV:version-history-collection-set is when you have deleted the last VCR for a version history, and now you want to retrieve the content of a version from that version history. 
You can browse for that version history in the DAV:version-history-collection-set. 
If your server supports baselines or version-controlled collections, it is likely to be much more effective to search for that version history in the baseline histories or collection histories, so I agree that the case for DAV:version-history-collection-set is not all that compelling. 
Assuming that there is a use case for this feature -- will a future RFC define an additional live property for this as well? 
We certainly could. 
Would anyone object to doing so? 
From: Julian Reschke [mailto:julian.reschke@greenbytes.de] ... if there is an XML request body for OPTIONS, the protocol *requires* that it has a certain document element. 
This basically means that RFC3253 has occupied the format for *any* OPTIONS request body -- no other HTTP-extending protocol can go out and specify similar requirements without being in conflict with RFC3253. 
In particular, RFC3253 is in conflict with a potential HTTP revision that specifies request bodies for OPTIONS (!). 
So, at a minimum, the protocol MUST allow to ignore the request body if the document element is not DAV:options. 
I agree. 
In the long run, I'd like to see this removed from the protocol, and possibly changed into a live property. 
Given that the ACL spec has decisively moved towards marshalling this kind of information as a property, and not as an OPTIONS request, the cleanest thing to do would be to update 3253 to also not use OPTIONS to marshall this information. 
This would then address the OPTIONS request body issue as well. 
I'll start a separate thread on this, to maximize the chance that folks will notice and respond to this proposal. 
Cheers, Geoff 
