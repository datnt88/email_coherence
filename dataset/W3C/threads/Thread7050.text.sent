With reference to: I just used this for information about the file: URI scheme, which I've used in some code that I plan to offer to the Haskell language library project. 
I'm wondering if there is any dispute over what this document says about the file: scheme (coped below). 
It all looks very good to me. 
I particular, I have followed the advice concerning URIs for Windows drive+path specifications. 
I have a small problem with the text. 
The example: file://usr/local/bin/ is confusing. 
'usr' should be an authority component, but to users of Unix/Linux systems it looks like part of the path. 
#g 2.7 FILES The file URL scheme is used to designate files accessible on a particular host computer. 
This scheme, unlike most other URL schemes, does not designate a resource that is universally accessible over the Internet. 
A file URL takes the form: file:// host / path where host is the fully qualified domain name of the system on which the path is accessible, and path is a hierarchical directory path of the form directory / directory /.../ name . 
As a special case, host can be the string "localhost" or the empty string; this is interpreted as "the machine from which the URL is being interpreted". 
However, this part of the syntax has been ignored on many systems. 
That is, for some systems, the following are considered equal, while on others they are not: file://localhost/path/to/file.txt file:///path/to/file.txt Some systems allow URLs to point to directories. 
In this case, there is usually (but not always) a terminating "/" character, such as in: file://usr/local/bin/ On systems running some versions of Microsoft Windows, the local drive specification is preceded by a "/" character. 
Thus, for a file called "example.ini" 
in the "windows" directory on the "c:" drive, the URL would be: file:///c:/windows/example.ini 
For Windows shares, there is an additional "/" prepended to the name. 
Thus, the file "example.doc" 
on the shared directory "department" would have the URL: file:////department/example.doc 
The file URL scheme is unusual in that it does not specify an Internet protocol or access method for such files; as such, its utility in network protocols between hosts is limited. 
Graham Klyne Graham Klyne scripsit: It should also be noted that file://department/example.doc is considered equivalent: that is, a Windows share can be expressed as either an authority or as the first part of paths that begin "//". 
John Cowan jcowan@reutershealth.com www.ccil.org/~cowan 
www.reutershealth.com 
"If he has seen farther than others, it is because he is standing on a stack of dwarves." 
--Mike Champion, describing Tim Berners-Lee (adapted) I think 'usr' is the host according to file:// host / path . 
/usr/local/bin in Unix/Linux should look like file:///usr/local/bin/ Israel Klyne With reference to: I just used this for information about the file: URI scheme, which I've used in some code that I plan to offer to the Haskell language library project. 
I'm wondering if there is any dispute over what this document says about the file: scheme (coped below). 
It all looks very good to me. 
I particular, I have followed the advice concerning URIs for Windows drive+path specifications. 
I have a small problem with the text. 
The example: file://usr/local/bin/ is confusing. 
'usr' should be an authority component, but to users of Unix/Linux systems it looks like part of the path. 
#g 2.7 FILES The file URL scheme is used to designate files accessible on a particular host computer. 
This scheme, unlike most other URL schemes, does not designate a resource that is universally accessible over the Internet. 
A file URL takes the form: file:// host / path where host is the fully qualified domain name of the system on which the path is accessible, and path is a hierarchical directory path of the form directory / directory /.../ name . 
As a special case, host can be the string "localhost" or the empty string; this is interpreted as "the machine from which the URL is being interpreted". 
However, this part of the syntax has been ignored on many systems. 
That is, for some systems, the following are considered equal, while on others they are not: file://localhost/path/to/file.txt file:///path/to/file.txt Some systems allow URLs to point to directories. 
In this case, there is usually (but not always) a terminating "/" character, such as in: file://usr/local/bin/ On systems running some versions of Microsoft Windows, the local drive specification is preceded by a "/" character. 
Thus, for a file called "example.ini" 
in the "windows" directory on the "c:" drive, the URL would be: file:///c:/windows/example.ini 
For Windows shares, there is an additional "/" prepended to the name. 
Thus, the file "example.doc" 
on the shared directory "department" would have the URL: file:////department/example.doc 
The file URL scheme is unusual in that it does not specify an Internet protocol or access method for such files; as such, its utility in network protocols between hosts is limited. 
Graham Klyne See my comments in I still didn't get answers to them in the current draft. 
About Is it a shared directory on the local host? 
How would it be in case of shared directory on a remote host? 
file://remote-host//department/example.doc 
Israel Klyne With reference to: I just used this for information about the file: URI scheme, which I've used in some code that I plan to offer to the Haskell language library project. 
I'm wondering if there is any dispute over what this document says about the file: scheme (coped below). 
It all looks very good to me. 
I particular, I have followed the advice concerning URIs for Windows drive+path specifications. 
I have a small problem with the text. 
The example: file://usr/local/bin/ is confusing. 
'usr' should be an authority component, but to users of Unix/Linux systems it looks like part of the path. 
#g 2.7 FILES The file URL scheme is used to designate files accessible on a particular host computer. 
This scheme, unlike most other URL schemes, does not designate a resource that is universally accessible over the Internet. 
A file URL takes the form: file:// host / path where host is the fully qualified domain name of the system on which the path is accessible, and path is a hierarchical directory path of the form directory / directory /.../ name . 
As a special case, host can be the string "localhost" or the empty string; this is interpreted as "the machine from which the URL is being interpreted". 
However, this part of the syntax has been ignored on many systems. 
That is, for some systems, the following are considered equal, while on others they are not: file://localhost/path/to/file.txt file:///path/to/file.txt Some systems allow URLs to point to directories. 
In this case, there is usually (but not always) a terminating "/" character, such as in: file://usr/local/bin/ On systems running some versions of Microsoft Windows, the local drive specification is preceded by a "/" character. 
Thus, for a file called "example.ini" 
in the "windows" directory on the "c:" drive, the URL would be: file:///c:/windows/example.ini 
For Windows shares, there is an additional "/" prepended to the name. 
Thus, the file "example.doc" 
on the shared directory "department" would have the URL: file:////department/example.doc 
The file URL scheme is unusual in that it does not specify an Internet protocol or access method for such files; as such, its utility in network protocols between hosts is limited. 
Graham Klyne I hope Paul's monitoring this ;-) This message is a bit of a round-up. 
With reference to: Also previous messages starting with: Lacking someone who's coming forward as a clear authority on these matters, here are my preferences: I have seen some software than changes (say) C: to C| within a URI. 
That seems pointless to me and I prefer to leave the ':' as-is. 
I think this should read: file:///usr/local/bin/ I think so. 
That's what I would expect. 
And looking to Israel's comments in: 1. 
What's the syntax for translating UNC paths ? 
\\hostname\share\file.pdf -- file://hostname/share/file.pdf 
I agree. 
That's pretty much what I've just done in my code. 
I don't think this is something the file: URI spec should try to tackle normatively. 
2. What about Macintosh drives ? 
They don't have ":" as a drive letter separator. 
So should it look like file:///MacHD1/folder/file.pdf ? 
I'm not a Mac person, but that looks plausible to me. 
I assume the drive latter is the first level of a hierarchical storage partitioning *within* a given machine? 
Again, I don't think this is something the file: URI spec should try to tackle normatively, but a non-normative example might help. 
But *this document* is about specific schemes, including file:. 
It also should mention that not putting the terminating "/" in case of a folder may influence on the result of relative URL resolving. 
Ah, yes, I think that would be a handy reminder. 
The example should be file:///usr/local/bin/ (3 slashes), unless you mean the usr is the hostname. 
Yes. 4. OS with a single root drive There is a difference between OS that has a single root drive and OS that doesn't have it. 
For example file:///usr/local/bin/ has a well defined meaning in Unix OS but it is not defined in Windows or Mac, since there is no root drive in these OS. Maybe we can suggest that the System disk / drive will be regarded as the root drive for Windows or Mac. 
I don't think I agree with this. 
Another way to look at it is that Unix-like systems have a more uniform hierarchy than (say) DOS and VMS which have a drive designator as the top level of the hierarchy. 
Whether a given path is actually meaningful in the context of a given authority is always going to be for the authority to determine. 
The given example above would not be meaningful even on a Unix system that did not have a /usr path from the root (and I'm pretty sure it is *possible*, if unconventional, to construct such systems). 
This spec is primarily about the file: URI specification rather than file system architectures, so I think care is needed to not get sidetracked into too much detail of this kind. 
At most, I think it should be at the level of non-normative examples in the text. 
And to another point I raised: Test case: file:///dir/subdir/file Is it legitimate to rewrite this as: file:/dir/subdir/file More generally, is it legitimate to remove the '//' that introduce an empty authority string? 
I think the answer in general should be "no", in consideration of: Even though for the file: system, they may be defined to reference the same file. 
(Similarly for removing trailing '#', etc.) That's all I can find for now. 
#g Graham Klyne Hi, I think an area where rfc1738bis *should* say something is in the area of mapping non-ASCII (or reserved ASCII) characters in path segment. 
For instance, what are file URLs for the following Windows file names? 
1) "c:/Dokumente und Einstellungen" 2) "c:/a#b" 3) "c:/?" 
I guess everybody agrees on the answers for 1) and 2) (hex-escape the reserved character), however things are less clear for example 3) (non-ASCII). 
IMHO, RFC1738bis should recommend to use UTF-8-encoding-then-hex-escaping). 
Note that similar considerations apply to other schemes in rfc1738bis (ftp) or other schemes currently proposed (smb). 
Regards, Julian I don't know about this. 
The perl URI module does this: $ perl -MURI::file -le 'print URI::file- new("c:/a#b", "msdos")' file://c:/a%23b The reason is that this is the only way that gave sane results when resolving relative URIs according to the standard URI rules. 
Alternative mappings are: file:/c:/a%23b file:/c:a%23b but these give strange results of you use them as base with relative URIs like "./foo" and "../foo". 
abs("./foo", 
"file:/c:/a%23b") == "file:/c:/foo" abs("../foo", "file:/c:/a%23b") == "file:/foo" abs("./foo", 
"file:/c:a%23b") == "file:/foo" abs("../foo"), "file:/c:a%23b") == "file:/../foo" Regards, Gisle 
