Hi Geoff, it seems you also made some changes in baselines for draft 13. 
I think it's clearer now. 
Nevertheless some questions. 
When asked a while ago about the difference between version controlled collections and baselines you told me that baselines are a depth 1 thing. 
If I understood that correctly this would mean that a baseline doesn't capture states of collections and their contents recursively. 
On the other hand I learned at one time that "member of collection" means "normal" and collection members. 
So it's not clear to me what you mean here. 
BTW, I use baselines which don't catch collection members. 
If I want them in my baseline I add them as a subbaseline. 
Also baselines only exist in the context of a workspace in my system. 
So a subbaseline can be identified by it's relative path from workspace root. 
As a remark, I'm still not sure why we need the terms "configuration" and "baseline". 
Isn't a baseline just a version of a configuration ? 
You argue correctly that a baseline is efficient by containing just version and path of the resources it contains. 
The same is valid for subbaselines. 
Imagine a medium sized baseline containing 1000 resources. 
Now you need a bugfix in one resource. 
You create a new baseline of the configuration duplicating 999 entries from the predecessor. 
Compare this with a baseline containing e.g. 10 subbaselines containing 100 resources. 
If you change a resoure in a subbaseline you get a new version containing 99 duplicated entries and a new one. 
I addition you have to update the super baseline containing 9 old and 1 new entries. 
A long way to the 1000 new data items you get with a single unstructured baseline. 
And now imagine how cheap new baselines will become if you work on a lightly bigger configuration containing 10000 resources e.g. containing 10 subbaselines with 1000 resources each, compared to a "simple" baseline. 
In 12.2.1 (DAV:subbaseline-set) you write: "A server MAY reject attempts to modify the DAV:subbaseline-set of a checked out configuration" My interpretation of this statement is, that a server understanding BASELINE at least must know about checking out subbaselines. 
This sounds plausible. 
Because if not it couldn't work with any baseline containing subbaselines. 
If that's right some comments: It MAY reject modifying the subbaseline-set. 
But probably it can change some resources and create a new baseline containing the old subbaselines ? 
So it already has to know a lot about subaselines, but can't do all with them. 
But not much is missing here. 
This can be confusing. 
I think make the whole subbaseline stuff optional or remove the MAY sentence. 
Cheers, Edgar edgar@edgarschwarz.de 
http://www.edgarschwarz.de * DOSenfreie Zone. 
Running Native Oberon. 
* Make it as simple as possible, but not simpler. 
Albert Einstein A version-controlled collection (VCC) is a VCR that refers to a baseline from its DAV:checked-in value. 
Conceptually, a baseline is simply an unordered, unstructured *set* of hrefs to version resources. 
(depth doesn't really apply: baselines are member resources rather than collections) If your collections are versioned, then it certainly does capture their state. 
Even though the baseline itself is unstructured, you can "reassemble" the collections by examination of the DAV:version-controlled-binding-set properties of the collection versions found in the baseline. 
Let's say that your baseline has { CV1, V2, V3, V4 } in it. 
CV1 is a collection version; the others are regular version resources. 
To reassemble these into a tree, you would fetch the binding-set and the version histories from the resources: Resource History Binding-set CV1 H1 { H2, H3, H4 } V2 H2 n/a V3 H3 n/a V4 H4 n/a As you can see, the members of CV1 are V2, V3, and V4, by matching up the version histories. 
The above is just the conceptual model. 
It is actually much easier to see the relationship by simply going to the DAV:baseline-collection of the baseline. 
That is a set of VCRs that are already arranged for you. 
This is one way to do it. 
A lot of baselines, but acceptable. 
I'm not a terminology guy. 
I'll leave this to somebody else. 
Nope. 
Just versions. 
No paths. 
Untrue. 
That is an *implementation* detail. 
Nobody said that you must store the set of versions this way. 
As a matter of fact, there is no way to *retrieve* the set of versions, thus no reason to ever truly keep a copy of them around. 
To query the set of versions, you must walk over the DAV:baseline-collection and fetch the DAV:checked-in values. 
[ as a counter-point: Subversion doesn't store anything when you "create" a new baseline. 
baselines are synthesized at request time from information within the repository. 
even then, we only synthesize a portion of the DAV:baseline-collection. even better: it is a very lightweight operation since the repository is logically organized as a set of baselines. 
concretely, each baseline is merely a diff against the previous baseline ] This is because a server may not support subbaselines, so this is how it prevents clients from using the feature. 
If you can't set the subbaseline-set, then the client can never create subbaselines. 
Thus, any subbaselines that exist are due entirely to the server's operation. 
If it is creating them, then yes: it must fully support them, including checking them out. 
Splitting subbaselines out into another option would be too complicated. 
It is much easier to cut it all off with a simple "MAY" sentence in 12.2.1. 
Cheers, -g Greg Stein, http://www.lyra.org/ 
No, baselines *do* capture the deep versioned state of a collection (i.e., a configuration), but a baseline resource _itself_ is not a collection. 
This must be what Geoff meant by 'baselines are a depth 1 thing' (actually depth 0). 
Read this sentence a couple of times, but couldn't figure it out. 
in my It is an important part of baselines that they represent the deep versioned state of a collection. 
Baselines are 'prerequisite dependencies' on the baseline. 
relative path "baseline". 
There you go, that simple definition is a good reason for the term! 
version Subbaselines are just baselines. 
All the characteristics (and no more) of a baseline are true for subbaselines. 
configuration 100 resources. 
super baseline you Yep, though most people would implement a single baseline as deltas too. 
But your observation is valid. 
lightly subbaselines to modify BASELINE at least Again, subbaselines are baselines. 
This MAY clause is because there are (heavy?) semantics for changing the value of the DAV:subbaseline-set, i.e., ensuring that there is only once VCR per history in the resulting combo-baseline. 
some them. 
sentence. 
Making this one property optionally mutable does make 'the whole subbaseline stuff optional'. 
Tim 
