<s> The basic distinction between ActiveNodeSet and StaticNodeSet is whether the node set is assembled at the time of the query versus at the time an individual node is accessed in the node set.  </s>
<s> However, ActiveNodeSet and StaticNodeSet have radically different signatures which would make it impossible to write code that could readily switch between evaluation modes.  </s>
<s> This requires the code author to make an apriori decision on which method is going to be more efficient and makes it difficult to check the assumption.  </s>
<s> I think you missed the point of ActiveNodeSet and StaticNodeSet.  </s>
<s> It is not so that the application writer can decide which one he thinks would be quicker, but rather so that he can decide which one he can deal with, since it was clear from several sources that each is a use case.  </s>
<s> A program  </s>
<s> that relies on an ActiveNodeSet is likely to not work with a StaticNodeSet and vice versa, even if the APIs were identical, because users of ActiveNodeSet can assume that the nodes are always still in the tree, but he cannot mutate the tree without invalidating his set, can only assume that he can mutate the tree without invalidating the list.  </s>
<s> It seems cleaner to me to have just the NodeSet interface with item() and length() methods and to add a boolean parameter, something like "lazyEvaluate" or similar, that, when true, allows the processor to lazily evaluate the node set if it wants.  </s>
<s> There is nothing preventing an ActiveNodeSet from doing complete evaluation up front or a StaticNodeSet from doing lazy evaluation (until the first mutation occurs, at which point it would have to complete the computation before permitting the mutation).  </s>
<s> There is no reason the caller has to know how it was implemented.  </s>
<s> The caller merely needs to know whether he wants a representation that invalidates or one that gets out of sync.  </s>
<s> This is clearly a choice that the caller, and not the implementor should make, because if the implementer makes the choice, the code will break.  </s>
<s> Implementations that did not expect lazy evaluation to offer significant advantages could simply ignore the lazy parameter.  </s>
<s> They can do this already with the current proposal.  </s>
<s> There is nothing stopping an ActiveNodeSet from evaluating completely or a StaticNodeSet from working incrementally (until the first mutation and then quickly finishing).  </s>
<s> Ray Whitmer rayw@netscape.com  </s>
<s> The basic distinction between ActiveNodeSet and StaticNodeSet is whether the node set is assembled at the time of the query versus at the time an individual node is accessed in the node set.  </s>
<s> However, ActiveNodeSet and StaticNodeSet have radically different signatures which would make it impossible to write code that  </s>
<s> could readily switch between evaluation modes.  </s>
<s> This requires the code author to make an apriori decision on which method  </s>
<s> is going to be more efficient and makes it difficult to check the assumption.  </s>
<s> It seems cleaner to me to have just the NodeSet interface with item() and length() methods and to add a boolean parameter, something like "lazyEvaluate" or similar, that, when true, allows  </s>
<s> the processor to lazily evaluate the node set if it wants.  </s>
<s> Calling length(), of course, might force a full evaluation of the NodeSet, so you would want to write iterative loops like: boolean lazy = true; NodeSet nodeSet = doc.evaluateAsNodeSet  </s>
<s> (targetElem,"lineitem",nsresolver, lazy); Element lineitem; try { for(int i = 0; ; i++) { // will throw exception when i  = length lineitem = (Element) nodeSet.item(i);  </s>
<s> // do stuff catch(DOMException ex) { The loop would work equivalently with either lazy or immediate construction of the node set.  </s>
<s> Implementations that did not expect lazy evaluation to offer significant advantages could simply ignore the lazy parameter.  </s>
<s> However, that would still not negate my point that objects that represent the same concept (a NodeSet) should at least share a common ancestor interface so that you don't have to create four different implementations of some code that doesn't care if the NodeSet is a NodeList, NamedNodeMap, ActiveNodeSet or StaticNodeSet.  </s>
<s> Though if those distinctions might be essential to some applications, they could be expressed by different derived interfaces or property values.  </s>
<s> A while before the draft was published the two interfaces did derive from a common base, but people wanted a more-iterator-like approach where it made most sense in the ActiveNodeSet, so it was changed.  </s>
<s> This makes the ActiveNodeSet very like an iterator which invalidates itself when the thing it is iterating over changes.  </s>
<s> The alternative seems to be to force implementations to be both lists and iterators, and everyone loses.  </s>
<s> At least now the user can choose one object or the other.  </s>
<s> If the current design is kept, I am reasonably certain that most implementations will still share a base implementation, but not at the public method level, and it is not clear that it is important for them to share public method names, since the behaviors of the two sets are quite different -- one tracks the current hierarchy whereas the other represents a snapshot.  </s>
<s> The two cannot behave identically.  </s>
<s> If your active implementation chooses to use a static snapshot and add invalidation on top, creating an iterator on top of a list is few lines of code.  </s>
<s> For other implementors, the active set might be the base, which doesn't need to set up caching since it can be incrementally computed since we know it is active, and building a static set on top of an active set implementation is, likewise, quite a trivial caching operation.  </s>
<s> I'm not sure of the value of ActiveNodeSet.  </s>
<s> For the usage scenario that you described, the tree being modified during the lifetime of the NodeSet, presumably by another thread, all ActiveNodeSet gets you is a check that the node is still a member of the result set at the instant of the call to item().  </s>
<s> Its membership in result set could be invalidated immediately after the call to item().  </s>
<s> If you have threads asynchronously modifying the tree, all bets are off for nearly any DOM use case I can think of.  </s>
<s> Consider it a given that there must be synchronization between threads operating on the same document managed by the application.  </s>
<s> There is NO substitute for synchronization between threads.  </s>
<s> DOM methods will crash without synchronization, and most DOM operations involve multiple operations that must be synchronized as a single operation or the program will crash.  </s>
<s> But for properly-synchronized applications, the ActiveNodeSet guarantees that the hierarchy has not been mutated since the set was computed, which is valuable to either a synchronized or to a single threaded application.  </s>
<s> If we had a distinct XPath expression interface, could the anticipated use cases not be more cleanly implemented by having evalute and evaluteAsNodeSet return a "static" list, but expose a method on the XPath expression that allows you to determine whether a particular node is instantaneously a member of the result set for the XPath expression.  </s>
<s> This would be more painful to use -- instead of just expecting an exception if the hierarchy has mutated, you would have to recheck every node.  </s>
<s> This also permits a number of mutations that impact the set, but may not be detected when testing one node at a time.  </s>
<s> It might answer "true" because the node has been moved to some prior location in the node set, meaning that the order has changed without the application being aware of it.  </s>
<s> Testing a single node tells you little about the general integrity of the set with respect to the current hierarchy.  </s>
<s> If the document is changed, it is likely that the processing has been invalidated, even though the current node may still be in the set.  </s>
<s> It also seems difficult to use efficiently, because it may cause repeated unnecessary reevaluation of the XPath expression that still fails to warn of the skew between the snapshot and the hierarchy.  </s>
<s> That's my take, anyway.  </s>
<s> Best regards,  </s>
<s> Ray Whitmer rayw@netscape.com  </s>
<s> Why not?  </s>
<s> It's easy enough to define a base interface so that the sharable operations can be shared.  </s>
<s> Not all users expect to be mutating the tree; why pessimize those other use cases?  </s>
<s> Sounds like what's been achieved is "must decide" (early), not "can decide" (later, if it's important).  </s>
<s> - Dave  </s>
<s> These seem to me like distinctly different use cases as previously indicated.  </s>
<s> Under what circumstances might an application start with one of these and subsequently migrate to the other?  </s>
<s> Jim.  </s>
<s> James Melton CyLogix 609.750.5190 609.750.5100 james.melton@cylogix.com  </s>
<s> www.cylogix.com  </s>
<s> Are you saying that the answer to "why not?" is just "these seem different"?  </s>
<s> I hoped for a real justification.  </s>
<s> If it's a "set", then the fact that Active ones can invalidate sure seems like something that non-mutating code would be able to ignore (except for error reporting) given half a chance.  </s>
<s> What's the justification for preventing that?  </s>
<s> Library code might quite reasonably be able to accept either kind of NodeSet implementation.  </s>
<s> The current scheme requires double the number of such library APIs, by pushing implementation attributes into the interface even for cases where those attributes are irrelevant.  </s>
<s> - Dave  </s>
<s> I'll try to reread the working draft this weekend with that in mind.  </s>
<s> However, that would still not negate my point that objects that represent the same concept (a NodeSet) should at least share a common ancestor interface so that you don't have to create four different implementations of some code that doesn't care if the NodeSet is a NodeList, NamedNodeMap, ActiveNodeSet or StaticNodeSet.  </s>
<s> Though if those distinctions might be essential to some applications, they could be expressed by different derived interfaces or property values.  </s>
<s> I'm not sure of the value of ActiveNodeSet.  </s>
<s> For the usage scenario that you described, the tree being modified during the lifetime of the NodeSet, presumably by another thread, all ActiveNodeSet gets you is a check that the node is still a member of the result set at the instant of the call to item().  </s>
<s> Its membership in result set could be invalidated immediately after the call to item().  </s>
<s> If we had a distinct XPath expression interface, could the anticipated use cases not be more cleanly implemented by having evalute and evaluteAsNodeSet return a "static" list, but expose a method on the XPath expression that allows you to determine whether a particular node is instantaneously a member of the result set for the XPath expression.  </s>
<s> XPathExpression expr = doc.createXPathExpression("lineitem",nsresolver);  </s>
<s> // generates list of lineitems currently in order at this instant NodeSet lineitems = expr.evaluteAsNodeSet(order);  </s>
<s> // get first lineitem Element firstItem = lineitems.item(0);  </s>
<s> // remove it from order order.removeChild(firstItem);  </s>
<s> // determines if the specific node (firstItem) is // at this moment a member of the result set of the XPath // expression when applied to the Order node // would be false if(expr.isResultSetMember(order,firstItem))  </s>
<s> {  </s>
<s> Okay, maybe it will all come to me when I get some time this weekend.  </s>
<s> I don't see a use case for ActiveNodeSet that justifies the apparent complexity.  </s>
<s> For any moderately complex XPath expression, it would seem to be very difficult to detect whether a document change would invalidate the NodeSet without recomputing the results and comparing it element by element or just throwing it away if any modification occurs.  </s>
<s> According to the spec, you do not try to detect whether or not the change invalidated the nodeset.  </s>
<s> Any change to the document invalidates the node set, whether it needed to or not, so there is interoperability between all specs, rather than having some smarter or stupider than others.  </s>
<s> Ray Whitmer rayw@netscape.com  </s>
