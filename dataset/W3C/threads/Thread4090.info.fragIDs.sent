The example in section 3.7.2.3 of the XQuery May 2 draft appears to contain an error (missing curly braces): It should be document { doc("bib.xml")//book/author 
} It is not a syntax error without these, but then the path will be included verbatim instead of executing it as an embedded expression. 
Cheers, Michael Brundage Writing as Author, "XQuery: The XML Query Language" (Addison-Wesley, to appear 2003) Co-author, "Professional XML Databases" (Wrox Press, 2000) not as Technical Lead Common Query Runtime/XML Query Processing WebData XML Team Microsoft 
I should add that the example will result in an error, since the doc() function returns a document node and document nodes are disallowed in element content (section 3.2.7.1, second rule numbered 1). 
Also, the two computed element constructor examples in section 3.2.7.1 that compute the name are both type errors: element {node-name($e)} {$e/@*, 2 * data($e)} (which has been reported previously) because node-name() returns an xs:QName? 
instead of an xs:QName, and also element {$dict/entry[word=name($e)]/variant[lang="Italian"]} {$e/node()} (which returns an element instead of xs:QName). 
Either the examples need to be corrected to match the rules, or else the rules need to be corrected to match the examples (possibly by applying atomization to the name expression). 
Michael, Thanks for your suggestions. 
I'll fix the errors in the next edition of the document. 
Specifically: (1) I will add the missing curly braces to the example document node constructor in Section 3.7.2.3. 
I believe that the example will then be correct. 
The path expression doc("bib.xml")//book/author 
returns a sequence of zero or more author elements, not a document node. 
(2) In the first example of Section 3.7.2.1, the use of the function node-name($e) to compute the node name of the constructed element is an example of a reasonable and valid query that is nevertheless considered to be a "type error" by our conservative rules for static type checking. 
There are a great many such examples. 
That is why type checking is optional in XQuery. 
A system that performs dynamic type checking will execute this query without any problem. 
A system that performs only static type checking will be unable to execute this useful query. 
(3) In the second example of Section 3.7.2.1, I will insert a "data" function call into the name expression to fix the bug you have noted. 
The name expression will then look like this: {data($dict/entry[word=name($e)]/variant[lang="Italian"])} Regards, --Don 
