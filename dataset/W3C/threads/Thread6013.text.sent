I enclose this to the mailing list for the completeness. 
It is essentially the same as the previous example I sent in many months ago (ref: Cheers Steve T This example is interesting, but it seems like a lot of machinery to describe what is essentially just connecting to something like a GetStockQuote service. 
What if you try to do something just a little harder, such as pulling (or pushing) the results of a StockQuote service through a CurrencyConverter service? 
Does the amount of pi-calculus machinery then become so cumbersome, in that case, that it starts to loose its intuitive appeal? 
Jeff Jeff, I agree with your comments. 
The reason for the use case and the reason for using the pi-calculus is that it is such a simple use case with no real business interest to it. 
The aim was to flush out fairly basic requirements by using an example that was easy to specify in an unambiguous way (hence the use of the pi-calculus). 
I don't think that anyone who is familiar with the pi-calculus would suggest using it as a one-to-one mapping to a language for choreography. 
Rather it has interesting properties that one can exploit. 
In the same way lambda calculus, upon which most imperative programming languages are based, is not evident. 
Syntactic sugar can be used to hide the formalism and help the intuitive appear and at the same time enable us to ask questions of a language with a formal base (even if not proven) that we perhaps could or would not otherwise be able to ask. 
Cheres Steve T This email is confidential and may be protected by legal privilege. 
If you are not the intended recipient, please do not copy or disclose its content but delete the email and contact the sender immediately. 
Whilst we run antivirus software on all internet emails we are not liable for any loss or damage. 
The recipient is advised to run their own antivirus software. 
I certainly found this to be the case when attempting to formalise work on a coordination language. 
There were a variety of issues, but mostly because pi-calculus is designed for describing the behaviour of a concurrent program and not the cooperative behaviour of autonomous distributed participants. 
As noted in my first post (http://lists.w3.org/Archives/Public/public-ws-chor/2003Jul/0065.html) the solution was to develop a formalism reflecting the higher-level semantic concepts. 
I did consider building that formalism on top of the pi-calculus or other process algebra, but found other limitations as well (global state assumption, interleaved concurrency model, difficult to model locality). 
Ciao, AndyB 
