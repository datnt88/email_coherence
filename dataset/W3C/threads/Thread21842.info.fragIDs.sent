Graham - CWM proposed builtins used in rule antecedents or in queries are typically succeeding when the object unifies with the result of the predicate operating on the subject argument (list). 
For example, the query (1 1) math:sum _:X. 
succeeds and the proof is (1 1) math:sum [iw:Variable "_:X_2"; = 2]. 
Also (1 1) math:sum _:X. 
(1 _:X) math:product _:X. 
succeeds, but (1 1) math:sum _:X. 
(1 _:X) math:difference _:X. 
doesn't succeed. 
A more elaborate query is at and it's proof is # Generated with http://www.agfa.com/w3c/euler/#R3629 on 30 Oct 2003 22:58:38 GMT ). 
http://www.w3.org/2000/10/swap/log#conjunction = @prefix iw: http://www.ksl.stanford.edu/software/IW/spec/iw# . 
@prefix xsd: http://www.w3.org/2001/XMLSchema# . 
@prefix math: http://www.w3.org/2000/10/swap/math# . 
@prefix rdfs: http://www.w3.org/2000/01/rdf-schema# . 
@prefix log: http://www.w3.org/2000/10/swap/log# . 
@prefix : http://www.agfa.com/w3c/euler/builtins# . 
@prefix rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns# . 
@prefix str: http://www.w3.org/2000/10/swap/string# . 
("a" "b" "c") str:concatenation [iw:Variable "_:X_1"; = "abc"]. 
("a" "b" "c") str:concatenation "abc". 
"xyz" str:equalIgnoringCase "XYZ". 
"xyz" str:notEqualIgnoringCase "ABC". 
"xyz" str:greaterThan "abc". 
"abc" str:notGreaterThan "xyz". 
"abc" str:lessThan "xyz". 
"xyz" str:notLessThan "abc". 
"xyz" str:notLessThan "xyz". 
"abc" str:startsWith "ab". 
"abc" str:endsWith "bc". 
"abc" str:endsWith [iw:Variable "_:X_1"; = "abc"]. 
"abcXYZ" str:contains "cX". 
"abcXYZ" str:containsIgnoringCase "Cx". 
(1.2 2.3 3.5) math:sum [iw:Variable "_:Y_1"; = 7.0]. 
(7.0 1) math:difference [iw:Variable "_:Z_1"; = 6.0]. 
(1 2 3) math:product [iw:Variable "_:U_1"; = 6]. 
(6 3) math:quotient [iw:Variable "_:V_1"; = 2.0]. 
(7 3) math:quotient [iw:Variable "_:A_1"; = 2.3333333333333335]. 
(7 3) math:integerQuotient [iw:Variable "_:B_1"; = 2]. 
(6.0 2.0) math:remainder [iw:Variable "_:W_1"; = 0.0]. 
(7 3) math:remainder [iw:Variable "_:C_1"; = 1]. 
-5 math:negation [iw:Variable "_:I_1"; = 5]. 
-5.1 math:absoluteValue [iw:Variable "_:D_1"; = 5.1]. 
-5.7 math:rounded [iw:Variable "_:E_1"; = -6]. 
(2 10) math:exponentiation [iw:Variable "_:J_1"; = 1024]. 
(1 2) math:atan2 [iw:Variable "_:T1_1"; = 0.4636476090008061]. 
2 math:cos [iw:Variable "_:T2_1"; = -0.4161468365471424]. 
0.5 math:cosh [iw:Variable "_:T3_1"; = 1.0471975511965979]. 
2 math:degrees [iw:Variable "_:T4_1"; = 114.59155902616465]. 
2 math:sin [iw:Variable "_:T5_1"; = 0.9092974268256817]. 
0.5 math:sinh [iw:Variable "_:T6_1"; = 0.5235987755982989]. 
2 math:tan [iw:Variable "_:T7_1"; = -2.185039863261519]. 
0.5 math:tanh [iw:Variable "_:T8_1"; = 0.4636476090008061]. 
("a" ("b" "c") "d") math:memberCount [iw:Variable "_:K_1"; = 3]. 
[iw:Variable "_:U_1"; = 6] math:greaterThan [iw:Variable "_:V_1"; = 2.0]. 
[iw:Variable "_:V_1"; = 2.0] math:notGreaterThan [iw:Variable "_:U_1"; = 6]. 
[iw:Variable "_:V_1"; = 2.0] math:lessThan [iw:Variable "_:U_1"; = 6]. 
[iw:Variable "_:U_1"; = 6] math:notLessThan [iw:Variable "_:V_1"; = 2.0]. 
[iw:Variable "_:U_1"; = 6] math:equalTo [iw:Variable "_:U_1"; = 6]. 
[iw:Variable "_:V_1"; = 2.0] math:notEqualTo [iw:Variable "_:U_1"; = 6]. 
:x log:equalTo :x. :x log:notEqualTo :y. :b log:includes :e. :b log:notIncludes :x. # Proof found for http://www.agfa.com/w3c/euler/builtins.n3 in 47 steps (671 steps/sec) using 3 engines For the easter test case, the dates are indeed calculated. 
The query here for instance could be i.e. _:A :hasEasterOnDay _:B; :hasEasterOnMonth _:C. 
and the according proof, given is then # Generated with http://www.agfa.com/w3c/euler/#R3629 on 30 Oct 2003 23:03:03 GMT ). 
http://www.w3.org/2000/10/swap/log#conjunction = @prefix str: http://www.w3.org/2000/10/swap/string# . 
@prefix xsd: http://www.w3.org/2001/XMLSchema# . 
@prefix : http://www.agfa.com/w3c/euler/easter# . 
@prefix log: http://www.w3.org/2000/10/swap/log# . 
@prefix rdfs: http://www.w3.org/2000/01/rdf-schema# . 
@prefix math: http://www.w3.org/2000/10/swap/math# . 
@prefix owl: http://www.w3.org/2002/07/owl# . 
@prefix iw: http://www.ksl.stanford.edu/software/IW/spec/iw# . 
@prefix rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns# . 
http://www.agfa.com/w3c/euler/easter#easter1 . 
[iw:Variable "?Y"; = 2003] a :Year. 
(2003 19) math:remainder [iw:Variable "?J"; = 8]. 
(2003 100) math:integerQuotient [iw:Variable "?K"; = 20]. 
(2003 100) math:remainder [iw:Variable "?H"; = 3]. 
(20 4) math:integerQuotient [iw:Variable "?M"; = 5]. 
(20 4) math:remainder [iw:Variable "?N"; = 0]. 
(28 25) math:integerQuotient [iw:Variable "?P"; = 1]. 
(20 3) math:integerQuotient [iw:Variable "?Q"; = 6]. 
(176 30) math:remainder [iw:Variable "?R"; = 26]. 
(3 4) math:integerQuotient [iw:Variable "?S"; = 0]. 
(3 4) math:remainder [iw:Variable "?U"; = 3]. 
(3 7) math:remainder [iw:Variable "?V"; = 3]. 
(360 451) math:integerQuotient [iw:Variable "?W"; = 0]. 
(143 31) math:integerQuotient [iw:Variable "?X"; = 4]. 
(143 31) math:remainder [iw:Variable "?Z"; = 19]. 
(19 1) math:sum [iw:Variable "?DAY"; = 20]} = {[iw:Variable "_:A_2"; = 2003] :hasEasterOnDay [iw:Variable "_:B_2"; = 20]}. 
http://www.agfa.com/w3c/euler/easter#easter1 . 
[iw:Variable "?Y"; = 2003] a :Year. 
(2003 19) math:remainder [iw:Variable "?J"; = 8]. 
(2003 100) math:integerQuotient [iw:Variable "?K"; = 20]. 
(2003 100) math:remainder [iw:Variable "?H"; = 3]. 
(20 4) math:integerQuotient [iw:Variable "?M"; = 5]. 
(20 4) math:remainder [iw:Variable "?N"; = 0]. 
(28 25) math:integerQuotient [iw:Variable "?P"; = 1]. 
(20 3) math:integerQuotient [iw:Variable "?Q"; = 6]. 
(176 30) math:remainder [iw:Variable "?R"; = 26]. 
(3 4) math:integerQuotient [iw:Variable "?S"; = 0]. 
(3 4) math:remainder [iw:Variable "?U"; = 3]. 
(3 7) math:remainder [iw:Variable "?V"; = 3]. 
(360 451) math:integerQuotient [iw:Variable "?W"; = 0]. 
(143 31) math:integerQuotient [iw:Variable "?X"; = 4]. 
(143 31) math:remainder [iw:Variable "?Z"; = 19]. 
(19 1) math:sum [iw:Variable "?DAY"; = 20]} = {[iw:Variable "_:A_2"; = 2003] :hasEasterOnMonth [iw:Variable "_:C_2"; = 4]}. 
http://www.agfa.com/w3c/euler/easter#easter1 . 
[iw:Variable "?Y"; = 2004] a :Year. 
(2004 19) math:remainder [iw:Variable "?J"; = 9]. 
(2004 100) math:integerQuotient [iw:Variable "?K"; = 20]. 
(2004 100) math:remainder [iw:Variable "?H"; = 4]. 
(20 4) math:integerQuotient [iw:Variable "?M"; = 5]. 
(20 4) math:remainder [iw:Variable "?N"; = 0]. 
(28 25) math:integerQuotient [iw:Variable "?P"; = 1]. 
(20 3) math:integerQuotient [iw:Variable "?Q"; = 6]. 
(195 30) math:remainder [iw:Variable "?R"; = 15]. 
(4 4) math:integerQuotient [iw:Variable "?S"; = 1]. 
(4 4) math:remainder [iw:Variable "?U"; = 0]. 
(19 7) math:remainder [iw:Variable "?V"; = 5]. 
(284 451) math:integerQuotient [iw:Variable "?W"; = 0]. 
(134 31) math:integerQuotient [iw:Variable "?X"; = 4]. 
(134 31) math:remainder [iw:Variable "?Z"; = 10]. 
(10 1) math:sum [iw:Variable "?DAY"; = 11]} = {[iw:Variable "_:A_2"; = 2004] :hasEasterOnDay [iw:Variable "_:B_2"; = 11]}. 
http://www.agfa.com/w3c/euler/easter#easter1 . 
[iw:Variable "?Y"; = 2004] a :Year. 
(2004 19) math:remainder [iw:Variable "?J"; = 9]. 
(2004 100) math:integerQuotient [iw:Variable "?K"; = 20]. 
(2004 100) math:remainder [iw:Variable "?H"; = 4]. 
(20 4) math:integerQuotient [iw:Variable "?M"; = 5]. 
(20 4) math:remainder [iw:Variable "?N"; = 0]. 
(28 25) math:integerQuotient [iw:Variable "?P"; = 1]. 
(20 3) math:integerQuotient [iw:Variable "?Q"; = 6]. 
(195 30) math:remainder [iw:Variable "?R"; = 15]. 
(4 4) math:integerQuotient [iw:Variable "?S"; = 1]. 
(4 4) math:remainder [iw:Variable "?U"; = 0]. 
(19 7) math:remainder [iw:Variable "?V"; = 5]. 
(284 451) math:integerQuotient [iw:Variable "?W"; = 0]. 
(134 31) math:integerQuotient [iw:Variable "?X"; = 4]. 
(134 31) math:remainder [iw:Variable "?Z"; = 10]. 
(10 1) math:sum [iw:Variable "?DAY"; = 11]} = {[iw:Variable "_:A_2"; = 2004] :hasEasterOnMonth [iw:Variable "_:C_2"; = 4]}. 
# Proof found for http://www.agfa.com/w3c/euler/easterC.n3 in 1013 steps (624 steps/sec) using 1 engine so next year, Easter should be on April 11 (well, at least I hope so :-)) Jos De Roo, AGFA http://www.agfa.com/w3c/jdroo/ 
Graham Klyne g cc: Subject: How does Euler handle CWM builtins? 
2003-10-30 06:13 PM Jos, I'm doing a mini-survey of RDF inference techniques, with particular reference to how datatype-related inferences are handled in different systems. 
Mostly it seems fairly crude. 
I notice that Euler seems to have some support for CWM builtins, but how do you use them? 
(As defined for use with CWM, I think they can only be used in forward chaining mode -- though clearly they could be adapted). 
I'm wondering what you do. 
Judging by: it appears that you must process the builtin's in the antecedent of a rule. 
Can you actually calculate the day of Easter here, or just confirm that a given day is correct or not? 
If the former, how do you process builtins in the antecedent of a rule? 
(Hmmm... could be left-to-right, as one would if interpreting a Prolog clause?) #g Graham Klyne 
Jos, thanks for this. 
I think I'm getting the picture ... let's see if I get it right: Built-in functions in a rule antecedent are treated as terms to be unified 
with the knowledge base, just like any others, except that there is special 
code to handle the particular features of the built-in properties. 
I judge 
that you take the terms in the antecedent of a rule in the order they are given, and unify them one at a time in a new context created for the purpose, adding new variable-to-value bindings as you go. 
I am guessing that ordering is important because unification of terms that appear later in the antecedent may depend on bindings created by unification of preceding terms. 
Am I on the right track? 
It's not so clear whether you allow for some built-in properties that there 
may be multiple possible unification patterns; e.g. in the simple case: (2 3) math:product _:Y would be satisfied by binding _:Y to 6. 
But in special cases, other variable-binding patterns might be allowed, such as: (1 _:X) math:product _:Y. is recognized as a fact by unifying _:X with _:Y, because the built-in knows that 1*x == x, forall x. Similarly: (0 _:X) math:product _:Y. 
can be allowed by binding _:Y to zero and leaving _:X unbound. 
In summary, reverting to a Prolog-ish notation, I would imagine the following cases are supportable for math:product (using ? 
in the signature 
to indicate unbound variables): math:product(1,?x,?y) :- x = y . 
math:product(?x,1,?y) 
:- x = y . 
math:product(0,?x,?y) :- ?y 
= 0 . 
math:product(?x,0,?y) 
:- ?y 
= 0 . 
math:product(x,y,?z) :- z = x*y . 
math:product(?x,y,z) :- x = z/y . 
math:product(x,?y,z) :- y = z/x . 
Looking at your examples and test cases, it looks as if you may allow only 
more restricted patterns, in which the object must be fully bound and a new 
binding is created for the subject. 
This would seem to be consistent with 
the way CWM defines these properties. 
#g 
Graham Klyne 
unified 
special 
judge 
Yes Graham and w.r.t. ordering, we anticipate already the day when clause and antecedent reordering will be fully automatic which will also give a real and tremendous performance boost. 
(a while back I did some manual owl-rules reordering and went from 60 min to 6 min test case manifest execution time) 
there 
signature 
We don't (yet) handle such cases, but they could be done... 
only 
new 
with 
That's right Graham and the future will learn us more ;-) Jos De Roo, AGFA http://www.agfa.com/w3c/jdroo/ 
