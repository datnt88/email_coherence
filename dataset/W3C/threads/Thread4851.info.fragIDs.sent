-- Name -- Generically discover and publish a server's functionality -- Description -- Abelard, an independent publisher of web publications, often needs to query an arbitrary list of RDF storage servers for assertions about a set of URIs he cares about. 
The RDF storage servers are RSS feed aggregators. 
The set of URIs identify Abelard's web publications. 
Abelard wants to use RDF to keep track of the things people say in weblogs about his publications. 
Abelard's client software includes support for three different query languages. 
Abelard's client software connects to each RDF storage server and determines whether it supports one of the three query languages it knows about. 
Abelard's client software chooses, based on priorities set by Abelard, to send different queries to different servers. 
Heloise, an aggregator of RSS feeds, publishes RDF (extracted from RSS feeds) on the Web using an RDF storage server. 
Heloise's server supports several RDF query languages. 
Heloise's server publishes its supported query language available in a machine readable form. 
It negotiates with clients in order to choose the most appropriate query language that they have in common. 
-- Value -- Abelard can use software to automate the process of tracking the things people say on the Web about his publications. 
Abelard can formulate queries in a variety of query languages, which preserves his existing investment. 
Abelard's software vendor and Heloise's software vendor can develop and sell extensible, relatively generic systems. 
Abelard and Heloise are able to exchange third party data in an interoperable fashion without requiring out-of-band, human negotiation about capabilities. 
-- Other -- Rather than writing several parallel use cases just like this one, I invite the reader to substite the following for "query languages" in this use case: * RDF serialization types * context support * publicly available models with read access * publicly available models with write access 
This is a nice specialization of the more generically stated use cases PS-1: Discovery of authoritative knowledge via URI PS-3: Third-Party Knowledge Discovery; query by known identity which apply to any resource whatsoever denoted by a URI, such as a web service. 
Thus, if the client software knows the URI of the web service in question, it can then (hopefully) use the DAWG solution to obtain a description of that web service, and decide how best (or if) to interact with that service. 
"Negotiation" is taken to equate to the client learning what protocols, query languages, parameters, etc. the server supports and deciding for itself how best (or if) to proceed. 
Yes? Patrick 
Patrick Stickler Nokia, Finland patrick.stickler@nokia.com 
I think so, yes; though I reserve the right to change my mind after actually thinking about it. 
: 
Yes. 
Exactly; and, though I guess this is already clear, I want clients to be able to "learn" these things via RDF. 
(This is why I'm trying to analogize to con-neg, though this is really more like capability negotiation.) 
The only diff in my use case and yr 1 &amp; 3 is that I think DAWG will have to -- and this takes us beyond *use cases* strictly speaking -- work out some actual RDF vocabulary and conventions. 
(I should look at the capabilities stuff the W3 has already done, of course; but first I wanna finish writing more UCs.) Kendall 
