In the range specification section it says: * In the case that the second integer is smaller than the first one, an empty range is returned. 
Since the specification says just above that point that: * The first integer must always be less than or equal to the second one. 
I would suggest that in cases where the second integer is smaller than the first, an error message indicating a malformed header should be returned (rather than an empty range). 
An empty range doesn't tell the requester what went wrong; an error message might. 
In the section on the return of multiple ranges as multipart MIME messages, the draft says "A server may send also a single byte range as a multipart message." 
Why should a server send a single byte range in a multipart message, and would that break any clients expecting, not unreasonably, multiple parts to a multi-part message? 
I also note that the draft gives the response Range header as Range: bytes x-y/z . 
Is z in use to handle situations where a new version has occurred between the clients request of one byte range and another, and, if so, isn't that already handled by the other headers (you note that the if-modified-since works with this)? 
I also assume that the Last-modified header and if-modified since header will generally be applied to the document as a whole, not to the individual byte-ranges, but I'm afraid I didn't find the draft to be too clear on this point. 
Regards, Ted Hardie NAIC 
Could we discuss the benefits/drawbacks of this algorithm? 
Oh, Brian, there you go again actually creating solutions instead of arguing about philosophy and who understands the problem better. 
:-) I'm no proxy maven, but this solution appears workable for both servers and end clients. 
Given that a client that wants to get more of an aborted download can just as easily create a "Request-Range: bytes=" as it can a URL as proposed, I believe that the optional HTTP header from the client is the preferable solution than the overly-extended URL. 
Basically, users mess up URLs all the time, but I feel safe in letting client software handle headers. 
If both schemes give the same result, headers will be more reliable and less prone to user error. 
--Paul Hoffman --Proper Publishing 
For reliability, shouldn't Request-Range requests be accompanied by a "if-not-modified-since", under the view that the range is likely invalid if the resource has changed? 
There needs to be a method for using if-modified-since with request-ranges but it shouldn't be required as it won't always be necessary or desired. 
:lou Lou Montulli http://www.netscape.com/people/montulli/ 
Netscape Communications Corp. 
Just a few points: If the byte range is carried in the URL, and is generated by the client, then the client needs to know whether or not the server suports byte ranges before generating the request- otherwise the request will be rejected. 
If the information is stored in a header, then servers that don't understand the header will just send the entire object. 
Also, a general subdocument addressing facility must necessarily be more complicated than a simple range, as it must be able to cope with discontiguous areas. 
This sort of ability isn't need for restarting HTTP requests, but is essential for caching proxies that are using lossy media specific transfer protocols, where the initial fetch may be performed in real-time, with losses, but which needs to be completed in non-real-time before being used to serve other requests (see some of the RODEO work for why lossy transports will become important). 
All that's needed at the moment for this limited sub-problem is a quick hack; since sticking stuff on the end of URLS takes more work than sticking in an extra header in the request, and another in the response, I'd go for the later approach. 
Add nocache to make sure that proxies which don't understand byte-ranges don't cache it, and add another pragma to reenable caching for proxies which do understand byte-ranges. 
Request- X-Byte-Range: [start]-[finish] Response- Pragma: no-cache, cache-if-you-understand-byte-range X-Byte-Range: [start]-[finish] (defun modexpt (x y n) "computes (x^y) mod n" (cond ((= y 0) 1) ((= y 1) (mod x n)) ((evenp y) (mod (expt (modexpt x (/ y 2) n) 2) n)) (t (mod (* x (modexpt x (1- y) n)) n)))) 
We don't need a hack here. 
Using a 205 response to signify a partial document is being returned seems far better than the "no-cache" nonsense. 
The 205 response is also necessary for the client to tell the difference between a full document and a partial document response. 
:lou Lou Montulli http://www.netscape.com/people/montulli/ 
Netscape Communications Corp. 
Lou- the 205 response is not part of http/1.0 as described, and this can lead to some caching confusion; if a 1.1 client is talking through a 1.0 proxy to a 1.1 client, and a partial fetch is done, it's possible to the 1.0 proxy to keep a copy of the partial contents, yet not be aware that the contents are bogus- the next client to do a fetch could end up with partial data, yet not be aware of it. 
Simon 
Simon Spero writes (in reply to Lou Montulli): 
As fas as I know, 1.0 proxies think that only 200 responses are cachable. 
Are there bogus proxies caching responses with any or unknown response codes? 
Andrew. 
(Endre Balint Nagy) bne@bne.ind.eunet.hu 
