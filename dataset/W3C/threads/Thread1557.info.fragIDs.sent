As a variant of my previous question, how would I fetch a particular file from a particular baseline on a readonly server? 
Specifically, if I'm not allowed to do a MKCOL, a BASELINE-CONTROL, or an UPDATE (on an existing baseline selector), then how can I use a baseline? 
Conceivably, I could get the version-history for a given VCR, use a 
DAV:baseline-version report to find the specific version of that collection, 
get the collection version's members and execute DAV:baseline-version on those, etc. 
But this is a far cry from random-access to a specific path within a baseline. 
Note that I can't simply use the Depth: header, as that would apply "once" to the collection version history (which has no children); the Depth header would not apply to the collection versions. 
Cheers, -g Greg Stein, http://www.lyra.org/ 
From: Greg Stein gstein@lyra.org 
As a variant of my previous question, how would I fetch a particular file from a particular baseline on a readonly server? 
Specifically, if I'm not allowed to do a MKCOL, a BASELINE-CONTROL, or an UPDATE (on an existing baseline selector), then how can I use a baseline? 
OK, I was wavering before, but now you've pushed me over the edge. 
I 
believe it is reasonable to do what you want, and you shouldn't have to do a "write" operation to get it. 
So I propose the following: 
Add a DAV:baseline-collection property on a baseline, which holds a DAV:href containing a server-defined URL. 
This URL identifies 
a read-only collection that exposes that baseline as a collection. 
Access to that read-only collection would be the message to the 
server to "cache" that baseline as a collection. 
The server would then just have to automatically clean up that cache when it needs the space, rather than counting on a DELETE from the client to tell it when to do so. 
This is a burden on the server, but probably not an unreasonable one. 
In particular, I don't think that Greg's will be the only server that will have very different performance/implementation tradeoffs for a read-only view of a baseline (what Greg wants) and a writeable view of a baseline (aka a workspace). 
Conceivably, I could get the version-history for a given VCR, use a DAV:baseline-version report to find the specific version of that collection, get the collection version's members and execute DAV:baseline-version on those, etc. 
But this is a far cry from random-access to a specific path within a baseline. 
Yes, that would be really gross. 
Note that I can't simply use the Depth: header, as that would apply "once" to the collection version history (which has no children); the Depth header would not apply to the collection versions. 
Yes, that wouldn't work. 
So, Greg: Does the DAV:baseline-collection property on a baseline give you what you want (I presume, yes). 
So, everyone else: any objections? 
(For Greg at least, I presume, no :-). 
Cheers, Geoff 
No objections at all, on the contrary: I'd really like to have this property. 
Boris. 
From: "Boris Bokowski/OTT/OTI" Boris_Bokowski@oti.com Date: Wed, 17 Jan 2001 09:40:18 -0500 
No objections at all, on the contrary: I'd really like to have this property. 
Also note that this property allows us to get rid of the DAV:baseline-version-set property, since you can get the same information by doing a PROPFIND for the DAV:checked-in values in this collection. 
This is probably cleaner anyway, since the DAV:version-set property had scalability problems (just imagine how useful it would be to get the DAV:version-set property of a baseline with 10,000 elements). 
In contrast, with the collection approach, you can just obtain the version info for a particular resource or subtree of interest. 
Cheers, Geoff 
No objections here, boss. 
How'd you guess? 
:-) 
Yes, I'd prefer to see that nuked. 
As you point out later, it scales poorly and it has little utility anyways. 
Somebody mentioned "four implementations" of DeltaV that were occurring. 
Have we seen feature sets from any of these other three? 
I'd be interested in what others are implementing. 
(to consider interop) Cheers, -g Greg Stein, http://www.lyra.org/ 
hehe :-) 
Speaking for Subversion, this isn't actually a burden as we'll synthesize the collection as the user requests it. 
(i.e. we don't have to worry about constructing and tossing a set of baseline resources) [ well, asking for an old baseline will be a bit painful since we use a reverse-delta storage system, but I believe the intent is to cache those as part of normal operation (meaning the new baseline collection won't burden us any more than we already had) ] Cheers, -g Greg Stein, http://www.lyra.org/ 
