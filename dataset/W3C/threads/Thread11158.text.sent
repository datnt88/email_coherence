I'm still trying to figure out the right categories within which to think about formatting, presentation, and behavior. 
In section 1.5, the current draft says: 4. link formatting: Links commonly differ in how they should be presented. 
This includes both how the user is informed that a link is present (such as highlighting, perhaps conditioned on history or other factors as in typical Web browsers), but also how the other termini are presented, such as having their title, summary, or explainer shown, or even being completely followed and presented inline with no user action required for traversal. 
5. link behavior: Links may have a wide variety of effects when traversed, such as opening, closing, or scrolling windows or panes; displaying the data from various termini in various ways; testing, authenticating, or logging user and context information; executing various programs. 
Ideally, link behavior should be determined by a semantic specification based on link types, pointer roles, user circumstances, and other factors; just as element formatting is determined by a stylesheet based on element type, context, and other factors. 
It is recognized that there is significant overlap between the areas of link formatting and link behavior. 
The list of things that need to be specified is very helpful, but I don't think that the division between formatting and behavior is quite right yet. 
For one thing, it seems clear to me that inline presentation without user action belongs to behavior rather than formatting. 
It's very difficult to get these things sorted out, but I persist in the belief that it's necessary to do so. 
I also persist in the belief that presentation and behavior are at root the same thing, but the list above has persuaded me for the moment that it's more useful to talk about all of this under the heading of behavior rather than presentation. 
I think that part of the problem is an unexamined tendency (in which I participate) to make the basic cut between that which is visible to the user and that which is not. 
While this distinction is important, perhaps it should not be the one with the highest logical priority. 
This leads me to suggest the following. 
Instead of the two categories "4. link formatting" and "5. link behavior", which I don't think are separable, make a single item number 4, "link behavior", and then distinguish between two categories of behavior, link display and link traversal, as follows: A. Link display How termini are presented to the user. 
- Possibly conditioned on history - Possibly including (e.g.) menus to display alternative link target labels ("explainers"), termini represented as animated figures, etc. as well as the usual underlining, etc. B. Link traversal What happens when a link is traversed. 
- Effects when traversed: opening/closing windows, scrolling, displaying data from termini in various ways (including the automatic transclusion of data without user action) - Testing, authenticating, and logging user context information - Running programs Note that in this taxonomy, the distinction between visible and invisible and the distinction between user-initiated and automatic are secondary to the distinction between display behavior and traversal behavior. 
Jon Certainly it's termini and not links that in the first instance appear somewhere, and therefor may need to be displayed, if you have that kind of application (e.g. a browser). 
But neither traversal or action is at the right level of generality. 
[See next message about traversal] Both you and Martin are too focussed, in my view, on browsers and mouse clicks. 
As a possibly useful example, consider the case of external, non-participating 2-ended links to annotate the translation relationship between the sentences of french and english versions of a bilingual document. 
A terminology extraction tool will exploit the semantics of such a link (i.e. behave in a certain way) completely differently to a translation tutorial program. 
I realise this is dragging us back towards the whole link {semantics/type/behaviour} debate, which I have done my best to follow, but it leaves me feeling that although we need to clearly distinguish between 1) intrinsic XML semantics for links, i.e. termini, participation, etc.; 2) XML Application (in the strict SGML sense of 'application') semantics, e.g. the bilingual alignment example above; 3) Implemented application behaviour we are only in the business of specifying (1). 
ht I'm sorry to go back to basics, but I think we need to. 
I think a LOT of the terminological problems we're wrestling with stem from a simple failure to distinguish things from their specifications, just like the SGML spec. 
failed to distinguish between text and tree. 
Our specific problem is not distinguishing between link descriptions and links. 
Links are out there in the ether, CONNECTING points in document groves. 
Link descriptions are things you find in documents. 
Links (types) have a topology (number of ends, directionality), sub-structure (e.g. terminus roles) and contextually-bound semantics (see previous message about Application semantics vs. application behaviour). 
Links (tokens) have actual end-points. 
Link descriptions have a syntax (GI, attribute names and values, etc.) and a semantics (what type of link they specify, how to instantiate individual links when processing a link description in a document context). 
Of course you all understand this distinction, the use of the words 'implicit' and 'explicit' makes that clear (when a link description (type) describes a link one of whose ends is the link description itself, that's the implicit case). 
But not making the distinction clear in the terminology sows confusion. 
Consider the text of 1.4.2: 2. link: A data object which explicitly represents a relationship between two or more termini. 
A link has link-type, a name intended to communicate the overall significance of the relationship. 
This doesn't GIVE us a name for the thing itself (the 'relationship') and uses 'link' for the description thereof. 
This may be from a desire to stay close to ordinary usage, but it's causing more trouble than it's worth. 
The most obvious case is in 1.4.6 6. traversal: The action of using a link; that is, of accessing another terminus from an initial terminus. 
Usually traversal is considered a user action (commonly initiated by clicking on a displayed terminus), but it can also occur under program control. 
where the incoherent (and not elsewhere defined) idea of an 'initial terminus' is appealed to. 
Point is, MOST applications will 'use' a link by starting from the link DESCRIPTION, which may or may not be a terminus. 
Note further that a particular link description may well describe DIFFERENT links at different times or if its host document moves, a point difficult to address if you can't distinguish between the two. 
I'll try to produce a redraft of 1.4 and 1.5 which points the way to how things might change if this distinction were made explicit. 
ht We may have problems with "links in the ether" because that sounds an awful lot like a platonic form, but press on. 
A record is a set of values which can be processed by some function. 
I do not know what a "contextually-bound semantic" is. 
I did not get that from the last post either, so please clarify. 
Tag soup is still tag soup. 
Ok. 
I prefer "link representation" but that is a thin difference. 
I also prefer element type definition where what is being described is in fact, an SGML element type. 
What is missing is the notion of the class by which one can declare that element types in different DTDs are in fact, instances of a class (e.g, arch form). 
However, as soon as you say, "processing a link" we are out of the world of declarative language and into functional language requirements. 
Whether defined axiomatically or indirectly, it is still a record or a structure. 
So far, none of this is simpler or more usable than HyTime. 
And in fact, it is getting harder to explain by the minute. 
len bullard [Henry Thompson:] I think that Henry is on to something. 
Please do. 
Jon 
