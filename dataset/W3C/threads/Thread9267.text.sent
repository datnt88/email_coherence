OK, I alluded to a question that I've asked several times about a characteristic of the S approach for which I feel I haven't gotten a satisfactory answer. 
I did get one very short comment from Pat, which merely emphasized my point (and concern). 
Here is the question again with examples: The S examples include statements such as the following: Bob ex:age _:1 . 
_:1 s:integer "10" . 
s:integer rdfs:domain xsd:integer . 
I understand this to mean that the node '_:1' denotes a value of type xsd:integer and there is a mapping to that value from the lexical form "10" which is presumed to be a member of the lexical space of xsd:integer. 
However, this is extending the semantics of rdfs:domain in a way that only apples to data type properties by saying something about the object of the statement rather than the class of the subject -- i.e. that "10" is a member of the lexical space of xsd:integer. 
Furthermore, what if we use rdfs:subPropertyOf as follows: Bob ex:age "10" . 
ex:age rdfs:subPropertyOf s:integer . 
s:integer rdfs:domain xsd:integer . 
Now things get messy. 
This basically asserts that Bob denotes a value in the value space of xsd:integer, which is not (I would presume) what is intended. 
In this case, it is the literal labled node that denotes both the value and lexical form. 
Thus, the interpretation/semantics of the S data typing property and use of rdfs:domain seems to depend on whether the subject is a bNode or not. 
I am concerned about these (apparent) inconsistency. 
It also seems to indicate that data typing properties are some other kind of property than current RDF properties for which the currently defined semantics of rdfs:domain, rdfs:subPropertyOf, etc. is insufficient and that we would need to modify/extend/constrain the semantics of these mechanisms to address these new data typing properties. 
I would appreciate folk's comments regarding the above, and apologize if I have not communicated my questions and concerns clearly enough. 
Thanks, Patrick The statements above, as given, don't express the idea that "10" is a member of the lexical domain of xsd:integer. 
Hence... There's no extension to the semantics of rdfs:domain. 
The "special treatment" of datatypes is that the datatype-defining URIs have fixed interpretations. 
In the your example, having the definition of s:integer fixed so that its relational extension contains pairs of the form: etc. #g Graham Klyne MIMEsweeper Group Strategic Research http://www.mimesweeper.com 
From: ext Graham Klyne [mailto:Graham.Klyne@MIMEsweeper.com] 
Sent: 12 December, 2001 23:12 Subject: Re: Question about S Then can you provide an alternate example that does? 
I'm presuming that somehow, somewhere, we need to know that "10" is a member of the lexical space of xsd:integer. 
How is that defined in S if not as above? 
And then how do you declare a given URI as a datatype-defining URI? 
Perhaps you (or someone) could try (for my benefit, seemingly having a rather challenged perspective) to give one or two examples of how a pairing ("10", xsd:integer) is defined in terms of the S 'idiom'? 
It seems that every time I think I have a handle on the S proposal, it appears I don't. 
Or maybe I do, iteratively, but it seems to keep changing insofar as which mechanisms are used to do what. 
Leading off from Frank's list of basic requirements, and taking the conceptual view of "doing" data typing by capturing the pairing of lexical form and data type, how does one, using the S idioms (of whichever flavor): 1. define the pairing ("10", xsd:integer) locally, with explicit arcs on the object node; i.e. the equivalent of the DAML idiom: xxx ex:prop _:1 . 
_:1 rdf:value "10" . 
_:1 rdf:type xsd:integer . 
2. define the pairing ("10", xsd:integer) globally, with typing defined in a schema; i.e. the equivalent of the P idiom: xxx ex:prop "10" . 
ex:prop rdfs:range xsd:integer . 
[I see the P++ and U idioms to be synonymously equivalent "contractions" of the DAML local typing idiom, so I won't bother with them here] As for S, I tried once to capture the various proposals/idioms using this single example, including S, but it seems that I've never quite gotten S nailed down. 
Perhaps someone else can. 
My earlier (apparently flawed) understanding had me doing S local typing with something like the following (based on the earliest S examples) xxx ex:prop _:1 . 
_:1 xsd:integer "10" . 
which had me wondering why one couldn't also do S global typing with xxx ex:prop "10" . 
ex:prop rdfs:subPropertyOf xsd:integer . 
but then folks started bringing rdfs:domain into play, to avoid the need for xsd:integer itself to be a property, and sets of different URIs for the lexical and value spaces, etc. and things just got a bit too muddy for me... Examples would be much appreciated to help clarify how S serves to define such pairings (presuming it does/can/cares to). 
Cheers, Patrick Hi Patrick, Consulting in section 4.9 we find: [ ] --foo:prop-- [ ]--xsd:integer.map-- 
"10" URI's dont' define datatypes; they are names of resources. 
I believe Sergey has done something rather similar (using date rather than integers) in: The aforementioned document does both of these. 
Brian 
