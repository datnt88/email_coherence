It seems to me that much (but not all) of the discussion over the last few months on the Expires, Last-Modified headers is really due to the desire of server administrators to control whether a document is cached. 
One of the big improvements in the current HTTP spec is the "Pragma: no-cache" header. 
This provides a way to say, "Don't cache this," without the need for fictitious expiration or last-modified dates. 
This is important. 
There are often good reasons for saying that a document should not be cached, but having a future expiration date (for example, if the validity of the document doesn't, in fact *expire* until that date). 
The only problem is that server admins often want to prevent local disk caching as well as proxy caching and the Pragma: no-cache applies only to the latter. 
Perhaps we also need a "Pragma: no-local-cache". 
One thing of which I am thoroughly convinced is that if a clean mechanism for giving administrators this capablility is not made available then every conceivable ugly hack which has the desired effect will gain widespread use. 
We will see 1970 expiration dates (always a lie) and future last-modified dates (also a lie). 
These hacks will likely work with some clients/proxies and fail with others. 
There will, no doubt, even be those who use different hacks based on the User-Agent header of the request! 
Why not make life easier for everyone and allow a server to cleanly request that a document not be cached to local disk. 
This should be a separate request from the Pragma: no-cache request to prevent proxy caching. 
John Franks I recently changed netscape to interpret "Pragma: no-cache" and not cache the object. 
This is slightly different than a "Expires" header because the object will not even be cached for history navigation. 
(Documents that are expired are still shown when traversing the session history). 
Haveing the client interpret "Pragma: no-cache" lets servers tell the client that this information is highly sensitive or volitile and should not be cached in any way. 
:lou Lou Montulli http://www.mcom.com/people/montulli/ 
Netscape Communications Corp. 
According to Lou Montulli: Well, I find this reasonable. 
But, I believe that the latest version of the spec says the client should ignore Pragma: no-cache. 
What I think is important is that there be some way to stop the client from caching -- as apparently there now is with Netscape. 
:) I don't care if it is Pragma: no-cache or if there is a separate way (Pragma: no-local-cache ?) but apparently someone does since the spec wants the client to ignore Pragma: no-cache. 
Could someone explain the rationale for this? 
John Franks It is an interesting question: there are any good reasons to forbid clients to cache documents in its non-shared cache? 
Doubtful, I think. 
But if anybody can give good examples explaining the need for this, then we shall consider adding the function proposed by "Pragma: no-local-cache", but (see later) Oops! 
The draft-02 states: (in section 8.13) Pragma directives do not apply to the end-points of a request/response chain. 
For example, a user agent's internal (non-shared) cache and/or history mechanism should ignore all pragma directives in received messages. 
Similarly, pragma directives are not applicable to the origin of a resource, though they may be applicable to a server's internal response cache. 
Your change is a non-conformance! 
(continuing on "Pragma: no-local-cache") but we should do this using some other machanism, not a pragma! 
Andrew. 
(Endre Balint Nagy) bne@bne.ind.eunet.hu 
In article 199508160450.XAA04365@hopf.math.nwu.edu 
John Franks I would prefer a more standardized way of doing it if one exists or is created. 
I haven't released any code that parses Pragma: no-cache yet, so lets come up with something different and use that. 
:lou Lou Montulli http://www.mcom.com/people/montulli/ 
Netscape Communications Corp. 
I believe this is the wrong design. 
The user *MUST* be able to always flip the page backward and see the same material just viewed. 
THis is a critical user interface usability issue. 
Within the same session/ instance of UAgent execution. 
I believe it would be/is wrong to silently refresh a document during history navigation when the history cache has overflowed. 
I (and many users I know) expect the history to be a record of what I've seen. 
I would have not objection to a browser which checked currency and via a non-modal message advised that the history copy wasn't current ("Current copy not current, RELOAD for the latest copy" for example). 
Dave Morris The reason Pragma: no-cache is not a redundant way of saying Expires: = now is that it allows servers to send essentially "private" documents to particular clients where these documents need not expire immediately. 
If intermediate proxies cannot cache the document (due to Pragma: no-cache) but clients can, this makes for more flexibility at the client end. 
The client would not be required to issue a new HTTP request when revisiting the non-expired document. 
Since this appears to be the only added functionality of Pragma: no-cache as a return header, though, I think it probably should have been called something else, such as Pragma: private (or something equally, or more, mnemonic). 
The problem with calling it Pragma: no-cache is that user-agent designers will feel that it ought to have some effect on the client, which it shouldn't, because Expires is sufficient for controlling caching in the client. 
So I think the above mentioned changes to Netscape are probably ill advised and in fact defeat the purpose of this header. 
If it stays in the Netscape browser as mentioned, the new header will have been rendered useless. 
(It will not be possible to send "private" documents that are client-cacheable, which is the only added benefit of it in the first place). 
--Shel Kaphan sjk@amazon.com 
Hmmm, that's a different interpretation than what I perceived from the third-hand descriptions of what this feature might do. 
It really is better to hear about protocol experiments from the source. 
Something that the WG needs to keep in mind is that what I write in the *draft* specification is what I believe to be the abstract and specific semantics of each feature in the protocol. 
I am counting on people to correct me when what I write does not match their own interpretation of the protocol. 
Since I've developed my own client library, client, and small portions of two servers, most of the time I do get it right, but certainly not all of the time. 
What I wrote in Draft 01 for the Pragma field's abstract semantics may be wrong. 
It is based on my interpretation of the meaning of the current "no-cache" request header, and I merely extended that semantics to the other directives. 
Pragma directives must be passed through by a proxy, regardless of their significance to that proxy, since the directives may be applicable to all intermediaries along the request/response chain. 
It is not possible to specify a pragma for a specific proxy; however, any pragma directive not relevant to a proxy should be ignored. 
Instead of "intermediaries", we could say "recipients", and the following paragraph: Pragma directives do not apply to the end-points of a request/response chain. 
For example, a user agent's internal (non- shared) cache and/or history mechanism should ignore all pragma directives in received messages. 
Similarly, pragma directives are not applicable to the origin of a resource, though they may be applicable to a server's internal response cache. 
could be replaced with Pragma directives only apply to recipients that implement features corresponding to the directive's semantics. 
For example, a no-cache directive tells the recipient not to make use of its caching mechanism in satisfying the request when it occurs in a request header, or in storing the response when it occurs in a response. 
Pragma directives are also unidirectional in that the presence of a directive in a request does not imply that the same directive be given in the response. 
We can then add a new directive to cover the semantics of a response that must not be shared by multiple users. 
We could call it "private", but I am afraid that this would also imply privacy, which it shouldn't. 
Unfortunately, there does not seem to be an antonym for "shared" or "communal", so how about Pragma: non-shared no-sharing do-not-share Er, on second thought, maybe we should just use "private"... ....Roy T. Fielding Department of ICS, University of California, Irvine USA Visiting Scholar, MIT/LCS + World-Wide Web Consortium (fielding@w3.org) 
(fielding@ics.uci.edu) 
I agree, this is the right approach. 
According to this, I change my statement on 'Pragma: no-local-cache' from doubtful to useless. 
I has experience with client cache only using netscape 1.1N. 
Netscape has 3 options on contolling local cache freshness: a) re-check on every access. 
b) re-check once per execution. 
c) never. 
I preferred the b) variant normally, and c) every time when I worked off-line and never choosed a). 
When I follow a link in a not fully readed document, I want to go back into the same document, preferably into same position where I left - when I'm done with the followed link. 
Now I'm reading web documents this way, and netscape supperts me in doing this. 
I'll be worried, if I can't do the same in the future. 
Or somebody in the WG prefers to see a changed document when returns back from a link to the original, not yet completely read document? 
I will be suprised if somebody says yes! Andrew. 
(Endre Balint Nagy) bne@bne.ind.eunet.hu 
I agree; it seems more robust (and useful) to include end-points in the set that can be affected by pragma directives. 
If you don't, half the implementations are going to get it wrong anyway. 
How about Pragma: for-your-eyes-only? 
Anyhow, what you suggest seems good, because it not only allows for private documents (without ugly URL mangling schemes), but it also allows for something else that Koen and I were trying to accomplish with our report on the Expires header (http://www.amazon.com/expires-report.{html,txt}) which is to provide for a way that history functions *could* cause automatic reloading of a document. 
With your new proposed pragma semantics, and the way it has been interpreted already by Lou Montulli in Netscape, this would then be enabled, and the Netscape changes mentioned could be "rehabilitated" (to borrow a political term). 
My earlier objections to that were based on a value judgment that being able to direct a document to one client only was considerably more valuable than being able to have history commands invoke reloading. 
But if we can have both, lets! 
I suppose it is still open to interpretation whether pragma: no-cache is to be interpreted to preclude history mechanisms (as opposed to caches) from storing documents, but I see no other use for it at the client end (given the existence of Expires), so why not? 
--Shel Kaphan In article 199508162029.NAA13943@bert.amazon.com 
Shel Kaphan sjk@amazon.com 
Great, pragma's can now be interpreted I'm happy. 
Should I still interpret "no-cache" or should there be something else? 
"no-cache" does seem cleanest. 
While we are on the subject it would be nice to have a header that specified the level of privacy of a document. 
Simply using the level of encryption of the document is not enough because I believe that eventually every document will end up being transfered securly. 
If there was a header that transmitted the privacy level, we could selectively encrypt the disk and memory cache to prevent unwanted access. 
It is not currently practical to do it to every file. 
Is there a header that does this already? 
Or should there be a new Pragma directive? 
:lou Lou Montulli http://www.mcom.com/people/montulli/ 
Netscape Communications Corp. 
I found the Draft 01 concerning Pragma: no-cache in particular and pragmas in general acceptable. 
I vote for no change. 
Otherwise why to introduce pragmas at all. 
(there wolud be no differenc between pragmas and request/response headers.) ... snip ... snip ... snip ... But what is the difference between the Pragma: no-cache and Pragma: private? 
I see only formal difference, but no semanthical. 
Andrew. 
Yes, and I'll update the specs [I wish we had this discussion before I split them in two]. 
Yikes! 
Then we have to define "level of privacy" first, and I don't think this belongs in a Pragma header anyway. 
The W3C security people have been working on a generic extension mechanism for this purpose (and a few others) which should be a proposal for HTTP/1.2 once the documentation is complete. 
I'd like to get 1.0 set in stone first, before we open the mondo can-o-worms that generic extensions will entail. 
....Roy T. Fielding Department of ICS, University of California, Irvine USA Visiting Scholar, MIT/LCS + World-Wide Web Consortium (fielding@w3.org) 
(fielding@ics.uci.edu) dwm@shell.portal.com 
said: I think this is a limited view of the world. 
The way that I have implemented it (yesterday, that is) is to let it be up to the user to choose what action to be taken if an expired history object is encountered: 1) Do nothing at all and show the document 2) Notify the user that the document is stale but do not refresh it 3) Do an automatic reload when the document becomes active (visible) to the user. 
This looks like a nice "option menu" to me! 
Henrik Frystyk Nielsen, frystyk@w3.org 
World-Wide Web Consortium, MIT/LCS NE43-356 545 Technology Square, Cambridge MA 02139, USA private would mean the response is intended for a single user agent and thus must not be stored in a shared response cache. 
no-cache would mean the response must not be stored in any response cache. 
....Roy T. Fielding Department of ICS, University of California, Irvine USA Visiting Scholar, MIT/LCS + World-Wide Web Consortium (fielding@w3.org) 
(fielding@ics.uci.edu) 
YES! Shopping basket applications and highly dynamic documents *require* total defeating of caches at every stage. 
The results otherwise are extremely ugly as the user's idea of what is going on becomes radically unsynchronized from what the server thinks is going on. 
Believe me - Expires: does not cut it at all. 
Too many browsers have either truely broken implementations or no implementation at all. 
Mosaic is a particular offender on that front. 
The cleanest solution to the whole problem is no-cache. 
Benjamin Franz Let me repeat this: If current system elements don't properly implement the current protocol, adding more protocol they also don't implement doesn't solve the problem. 
If changing broken system elements to implement the current protocol correctly fixes the problem, we don't need protocol changes. 
This would introduce an incompatibility between HTTP/1.0 and HTTP/1.1! 
I suggest not touching the 1.0 semantics for no-cache pragma because it's implemented in current applications, but we can add a new 'Pragma: dynamic' or something else with the same semantics. 
Pros: There is a demand for the semantics (or better shall I name it feature?), generated by - important in present and even more important in near future - shopping-basket applications. 
It is simpler, than the alternate solution. 
Cons: (regarding Pragma: dynamic) This will change the general semantics of the pragmas. 
In 1.0 pragmas have effect only on intermediates. 
This isn't a big issue, because we have only the pragma no-cache in 1.0. 
Leaving it untouched, we will not introduce incompatibility really, the incompatibility will be formal only. 
Alternate solution: There is an unanswered (on this list at least) proposal by Shel Kaphan to introduce event-driven document expiration. 
Implementing evend-driven document expiration can be done in two ways: a) outside the http protocol This case shall be discussed not in this list, I presume, but see URL http://morse.colorado.edu/~wessels/Proxy/Thesis/newproxy.html by Duane Wessels on rcached. 
b) in http protocol While servers doesn't initiate connections to clients (we can safely assume, that they never will - or firewall implementors will kill us), this can be done by enabling expiry notifications stuffed into response headers. 
(eg, in responses to POST-ing shopping actions for shopping basket apps), but general-purpose expiry notifications stuffed into response header of unrelated URL-s will make caching proxies a lot more complicate. 
(proxies shall interpret the expiry notifications, forward to current client, and then store them independently of the currently requested URLs, and later propagate it in other response headers to clients and other proxies, possibly having stale copies.) 
I don't know, it is possible within http/1.x or not. 
Andrew. 
I'm sorry, I just realised that I'm completely wrong in assumption about no-cache pragma in responses is in current practice. 
I erroneusly assumed, that no-cache pragma work while really the absence of Last-Modified header prevented caching. 
Andrew (Endre Balint Nagy) bne@bne.ind.eunet.hu 
P.S.: now I go offline till 28-th Aug for small vacation. 
Roy, Please correct me if I miss your point... What do we gain by having both a 'no-cache' and a 'private' Pragma in terms of functionality ? 
A 'shared response cache' is basically a proxy/cache, and Pragma is meaningful to proxies only, not to user agents. 
So both headers really mean "don't cache this response in a proxy/cache", and both let a user-agent local cache free to cache the response or not. 
What's the point of adding 'private' then ? 
I would understand it if 'non-shared response proxy/caches' were a reality, but AFAIK, they are not ! 
I think both cases you described above should use 'Pragma: no-cache'. 
Jean-Philippe Jean-Philippe Martin-Flatin: Pragma: private would instruct a user agent not to cache the response if its cache memory (say part of a harddisk in an MS-DOS pc in a university PC lab) is publicly accessible. 
This is particularly important for user agents that do not clear their caches at the end of the session. 
Of course, the user agent needs to be configured to know that its cache is publicly accessible, one could have a configuration option like `cache private responses on local disk?'. 
Koen. 
Instead of "recipients", I would prefer "proxies". 
"Recipients", which isn't defined in section 1.3 of draft-ietf-http-spec.html, encompasses the proxies and the user agent in my view, whereas the Pragma header field is not destined for the user agent. 
This somewhat changes the scope of Pragma, which is no longer restricted to proxies in the new paragraph. 
I think the name "Pragma" confuses a number of people (cf Lou's initial interpretation), and it's not clear to all whether a Pragma header field is destined for proxies only, or for proxies and user agents. 
Based on the fact that not so many WWW clients and servers already implement Pragma, I propose that we replace the name "Pragma" with the name "Proxy". 
Maybe in HTTP/1.1 specs ? 
It would be crystal clear that 'Proxy: no-cache' is not destined for user agents. 
Jean-Philippe When I say the "Pragma" header orginially, my first throught was #pragma in ANSI C: an escape hatch to provide implementation-specific information. 
Now, this was added originally for the benifit of the CERN proxy server, and the language of the specs reflect this, but I'm not sure we need to stick with this if we can be clear what the scope of particular Pragmas is... the nature of this sort of thing is that implementations will (and usually should) ignore/discard unknown pragmas. 
I _would_ like us to use some kind of current-practice or best-current-practice interpretation of Pragma: no-cache and If-Modified-Since: rather than redefining them in some more complicated/tricky way: thus I tend to favor the suggestions that add new headers/pragmas to offer new semantics. 
(Should any of this discussion go to www-proxy or is that a dead list?) Albert Lunde Albert-Lunde@nwu.edu Regarding the name "Pragma" Yes, it is a bad choice for a protocol element name. 
We have two choices: 1) Change the name to something relevant, e.g., "Caching" 2) Continue using the same name and simply define the semantics such that it means what we say it means. 
I vote for 1), 2) has proved too confusing already. 
The name will depend on what you want to achieve: 1) If you want only proxies not to cache, I vote for: Proxy: no-cache This leaves scope for other proxy-specific directives to be defined at a later stage. 
2) If you want both proxies and user agents not to cache, you can either do: Caching: all=no Caching: proxy=no Caching: user-agent=no or Proxy: no-cache Expires: now To choose between these 2, let me quote Shel Kaphan who summarized very well the 'Pragma: no-cache' vs 'Expires: now' debate on the 16th: Thus I think there's no need for the 'Caching' solution, and vote for the 'Proxy: no-cache' solution as a replacement for 'Pragma: no-cache'. 
The first choice may look cleaner, but it neglects the fact that Pragma is already in use, already recognized (and forwarded) by proxies, and already has the de-facto semantics that we need. 
From my reading of the different WWW newsgroups this year, I got the opposite impression: almost nobody has a WWW client or server which uses Pragma. 
This is not based on solid stats, though. 
So, what do we do for HTTP/1.1? 
I am planning on issuing the first 1.1 draft on Monday, so I'd like to hear your opinions now rather than later. 
Leaves little time for this side of the Atlantic to react ;-) Jean-Philippe This explanation is a little different from others floating around. 
The other interpretation is that Private means that no other user-agent should be allowed to access a cached copy of this document, which would presumably mean that it should not be cached in any intermediate proxy (except possibly for use by the originally requesting user-agent, but that's too hard and not very useful). 
--Shel For the record, the message I gave that title to was (if memory serves) really about the fact that I wanted there to be a response header that identified the resource, so that caches would have a unique cache key for a resource. 
I got what I wanted: Location can now be used for 2xx responses. 
What I didn't get (unless this has changed since last reading) was language in the spec describing the impact on caches of this header for 2xx responses. 
--Shel Kaphan Regarding the name "Pragma" Yes, it is a bad choice for a protocol element name. 
We have two choices: 1) Change the name to something relevant, e.g., "Caching" 2) Continue using the same name and simply define the semantics such that it means what we say it means. 
The first choice may look cleaner, but it neglects the fact that Pragma is already in use, already recognized (and forwarded) by proxies, and already has the de-facto semantics that we need. 
I like something option (2) Keep the behavior and name of "Pragma: no-cache the same", and document new semantics for other pragmas or pragmas in general (and/or add another header as needed.) Are there any other widely implemented Pragma: headers? 
Albert Lunde Albert-Lunde@nwu.edu 
