Hugo: Thanks for the free advice! 
(I certainly *hope* it's free....) 
All of your recommendations make sense, but we would obviously prefer that our extensions for shared key authentication conform as closely as possible to the main body of the TLS spec, to avoid confusion and ease implementation. 
Hence, if your suggestions regarding MAC and PRF as primitives (as well as the corrections to the HMAC primitive) are adopted in the TLS spec as a whole (an excellent idea that we strongly support), then we will revise our shared key authentication draft accordingly. 
Regarding the adaptation of the shared-key authentication response to the new primitives (assuming that they are adopted), it appears to me that if a PRF primitive is defined, the natural approach would be simply to define the authentication response as PRF(auth_write_key, data + shared_key), thus achieving both the MAC property and concealment of the shared key (assuming a good PRF). 
Of course, if the PRF primitive does not get incorporated into the spec, then I suppose the simplest solution would be to treat HMAC/SHA-1 as an implicit PRF, which gives us your solution (2) (which happens to be--in content, if not in form--identical to the currently specified format). 
Regarding solution (3), one of the reasons for generating a separate "auth_write_key" was that such a key, used for only one purpose, would be safe to reveal to the authentication service. 
Hence, the separation idea you suggest may be redundant. 
Solution (1), on the other hand, is much more interesting, since it reduces the strength of the assumption required from the MAC function, as you point out. 
I'm currently checking into some implementability details, and if there are no problems, we'll look at incorporating this revision as well, in the case where the PRF primitive isn't incorporated into TLS. 
Comments, anyone? 
Daniel Simon Cryptographer, Microsoft Corp. (dansimon@microsoft.com) 
From: HUGO@watson.ibm.com[SMTP:HUGO@watson.ibm.com] 
Sent: Monday, December 02, 1996 4:06 PM Subject: Implementation of Shared Key Authentication Ref: Your note of Mon, 2 Dec 1996 12:16:29 -0800 Dan, Tom, I hope you read my previous message on how I'd like to see MAC functions handled in SSL. 
I'd recommend that you adopt these changes already now into your shared-key proposal (to preclude future backward compatibility problems). 
This includes changing to a generic MAC definition and implementing it with the "official" HMAC as the default transform. 
The text affected by such a change would be: 
SharedKeyVerify.shared_key_response hash (auth_write_secret + pad_2 + hash (auth_write_secret + pad_1 + hash (handshake_messages) + SharedKeyVerify.auth_service.auth_service_name + SharedKeyVerify.auth_service.display_string + SharedKeyVerify.auth_service.challenge + SharedKeyVerify.identity + shared_key) ) 
It should be re-written using a generic MAC (which could be implemented as HMAC or any other MAC). 
The problem is then how to combine in general the two keys auth_write_secret and shared_key into the generic MAC. 
The two possibilities that come to my mind are: XOR the two keys (or hash them together, etc.) to create one single MAC key or (as you do now) append the shared_key to the MAC-ed text. 
That is: 1) SharedKeyVerify.shared_key_response MAC(auth_write_secret XOR shared_key, data) where data = hash (handshake_messages) + SharedKeyVerify.auth_service.auth_service_name + SharedKeyVerify.auth_service.display_string + SharedKeyVerify.auth_service.challenge + SharedKeyVerify.identity 2) SharedKeyVerify.shared_key_response MAC(auth_write_secret, data + shared_key) In the first case one would be assuming that the MAC function uses random (unstructured) strings as keys (which is the usual case). 
In the second case this assumption is not needed but instead you will be assuming that the MAC does not leak information on its output. 
The latter is not a common assumption on MAC functions. 
It would require the assumption that the MAC behaves as a "pseudorandom function" which is a stronger assumption. 
(In particular, I trust more HMAC as a MAC than as a pseudorandom function). 
As for later solution notice that once MAC is implemented as HMAC then the function will be the same as you use now (except for the changes that you need to comply with the "official" HMAC, ie, XOR of pads instead of concatenation). 
There is a third solution: If you assume MAC to be pseudorandom (as is needed in solution (2)) then you could do the following 3) SharedKeyVerify.shared_key_response MAC(temp_key, shared_key) where temp_key=MAC(auth_write_secret, data) One potential advantage of this method is that in pass-through authentication the (SSL) server needs to pass to the authentication server only the value of temp_key and not of auth_write_secret which the server may want to keep secret only between itself and the client. 
I don't know how important this may be in actual uses but sounds as a good "key separation" property. 
Hugo PS: even if you do not want to go at this point to a generic MAC definition I recommend that you already switch to the official HMAC and consider doing (1) or (3). 
Ref: Your note of Tue, 3 Dec 1996 18:15:14 -0800 (attached) 
Free indeed (a joke here would fit well but I know Microsoft may not be joking about this...) 
I hope they will... 
However, SSL/TLS does not specify a unique way to do MAC but has several ad-hoc variants of HMAC. 
This means that implementers do not have a unique function that they can call everytime a MAC is required inthe protocol. 
SO there is no problem for you to use yet another variant (in this case the official HMAC which I guess/hope TLS will eventually adopt). 
So even if you do not go for a more generic presentation of the protocol using MAC or PRF at this time, you can already change your definition to comply with draft-ietf-ipsec-hmac-md5-01.txt. 
Moreover , you can decide on one of the options 1, 2, or 3 discussed in my previous message and stick to it already now. 
Since you are inviting independent implementations you want to avoid the compatibility and upgrade problems later. 
If auth_write_key is *guaranteed* to be used only once for this purpose why not use it as a one-time pad to encrypt the challenge response in the way from client to TLS server? 
Thanks for considering the changes. 
Hugo 
Well, let's put it this way: If TLS *does* end up standardizing on something usable, I'd like shared-key authentication to use it. 
Hopefully, the working group will come to a decision soon, and we can put out a revised shared-key authentication spec immediately thereafter. 
It's a matter of appeasing the export gods. 
We already spit out a long, public-key-exchanged secret at the server end; if we also output data that was one-time-pad encrypted with it (as opposed to some hash of the two together), I fear the wrath of export control might well rain down upon us. 
So instead, we chant the talismanic intonation, "never will we output strongly encrypted plaintext", and hope for the best. 
(I know--you're going to ask why we don't just hash the one-time-pad-encrypted response. 
Well, we'd still like to use standard TLS primitives, if we can; the current response format, for instance, is modeled on one.) Keep those comments coming, Daniel Simon Cryptographer, Microsoft Corp. (dansimon@microsoft.com) 
