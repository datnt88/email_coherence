This allows the DOM APIs to be implemented as a thin veneer on top of legacy applications with their own data structures, or on top of newer applications with different class hierarchies It is my understanding that it is legal for such applications to implement only some of the interfaces defined in DOM. 
For example, few legacy applications could make meaningful use of a ProcessingInstruction. 
What should such an application do, for example, in createProcessingInstruction? 
Throw an error, silently return NULL or do something entirely different? 
Also, is DOMException HIERARCHY_REQUEST_ERR thouwn only when trying to create a parent-child combination that is disallowed in DOM (such as TEXT being parent to ELEMENT), or can it also be thrown when the combination is allowed in DOM, but would violate local rules (a DTD or the legacy application business logic)? 
Ari Krupnikov Depends on how you define "legal." 
If you don't implement at least the full "core" DOM, you may not claim to be a compliant DOM implementation. 
You may say that you are a compatable subset of the DOM APIs, but that's an important distinction. 
There are, in fact, a number of such DOM subsets out there. 
It's a perfectly reasonable concept; it allows _limited_ reuse of code and skills, and if it's done properly anything written for the subset can be migrated to a full DOM though the reverse may not be true. 
But you owe it to the user to call this to their attention and explain the differences between your API and the DOM API. 
The XML spec says that PIs which aren't meaningful to an application should be ignored by that application. 
They are, however, part of the document's Infoset, and a standard parser should put them into the DOM. 
You may be able to argue that the DOM you present to the user is not the parser's output, but the output of a filtering stage that has discarded the PIs... but to be a compliant DOM, you have to allow the programmer to explicitly create and insert PIs, if that's what they want to do. 
Also, a PI may be meaningful to _their_ code even it isn't meaningful to the application itself, so stripping out PIs may impose an unreasonable limitation on how they apporoach their tasks. 
If it's a compliant DOM, createProcessingInstruction should return a ProcessingInstruction node. 
If it isn't a full DOM, all bets are off. 
The DOM Working Group has not yet defined behavior for partial or subset DOMs, There has been discussion of introducing the concept of a read-only DOM, but there seem to be at least four different definitions of how that should behave and we have not yet reconciled them. 
The former. 
The DOM does not apply continuous validity checking. 
DOM Level 3 will introduce ways to ask the Content Model whether an insertion would or would not be valid, but you'll have to call those explicitly before doing the insertion rather than having the insertion itself throw an exception. 
(Programmers will often know an insertion is acceptable -- or will be after other changes are made -- and really won't want every insertion checked every time.) Of course you can define something derived from the DOM which blocks inappropriate insertions, if you really want to. 
But once again, the result would not be a fully compliant DOM implementation. 
Joe Kesselman / IBM Research Could you give some pointers? 
If you are working with an existing data structure, such as an existing database schema, or a filesystem, and don't keep any data in memory, you might have no reasonable way to represent a PI (or a comment, for that matter) in the underlying data storage. 
You could keep all the nodes that you cannot persist in memory, and discard them when the application exits (or the object is destroyed)... 
However, these nodes will not persist between sessions. 
PI is defined as an Extended Interface (1.3): "As such, HTML-only DOM implementations do not need to have objects that implement these interfaces." 
Is it specified what an HTML-only implementation should do in this case? 
It might be outside the developer's powers to permit such insertions. 
Most filesystems will not allow FILE DIRECTORY/ /FILE , but will instead throw exceptions. 
The "veneer" DOM implementation might be able to catch these exceptions and map them to something a DOM consumer expects. 
A partial DOM implementation that also thrown I/O exceptions (or SQL, or network) will not be a strict subset. 
Ari Krupnikov In that case, your documents will never contain a PI initially. 
If the user is permitted to create and insert one, you need to find a way to represent that. 
If they aren't permiitted to do so, you aren't a fully compliant DOM. 
Which one makes more sense depends on what your users will demand. 
If you really want a DOM-like interface on this data structure, it sounds to me like this should be described as a subclassed DOM with additional behaviors superimposed, rather than a fully compliant DOM. 
DOM-like, DOM-compatable within very specific limits, but not a general-purpose DOM per se -- because you explicitlyi do not want to permit all forms of editing on this "document". 
For read access, this pseudo-DOM needs to appear as a DOM; accessing code should not be required to make any assumptions about compatibility. 
For example, an XPath search should be possible with standard XPath tools (like org.apache.xalan.xpath). 
On the other hand, code that modifies the data will have to be aware of the special structure imposed on the document. 
However, it should not be concerned with the specifics of possible exceptions, because it shouldn't care what physical system is used to store the data. 
The spec for createProcessingInstruction says "NOT_SUPPORTED_ERR: Raised if this document is an HTML document." 
It doesn't specify what's done if someone implements a Core DOM with _neither_ the HTML or Extended modules... Do you think it is an issue worth considering, in light of the rec's suggestion for "veneer" implementations (1.1.2 Memory Management)? 
Ari Krupnikov 
