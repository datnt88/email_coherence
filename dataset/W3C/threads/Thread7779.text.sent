Whoops, I sent this to the wrong address last night.... My comments in my previous note remind me of something else. 
If I have a lock-null resource, and if someone places a lock on the parent collection, am I blocked from doing a BIND or MOVE on my lock-null URI? 
I believe the intent of the lock-null is to insure that we can do operations like PUT/MKCOL there... but I'd think that BIND and MOVE also apply... at least in intent... but that seems to conflict with what we've been saying about BIND/MOVE being an operation on the state of the parent collection... and thereby blocked if someone else locks the parent. 
Any thoughts? 
Yaron? 
:-) It is my understanding that locking a collection simply locks the namespace of the collection. 
If /a is locked by L1 and /a/b is locked by L2 Then to change /a/b I only need to give L2, since /a's namespace will not change. 
Thus if /a/b is a null-resource, and you have the lock, then you can change it at will through a PUT. 
MOVE/COPY are interesting in the fact that if the whole operation is not automic, then the Delete will fail due to the changing namespace.. 
I would assume that the MOVE/COPY would work without L1 if I were a client program. 
Is this not how it is supposed to work?? 
Kevin [mailto:w3c-dist-auth-request@w3.org]On 
Behalf Of ccjason@us.ibm.com 
Whoops, I sent this to the wrong address last night.... My comments in my previous note remind me of something else. 
If I have a lock-null resource, and if someone places a lock on the parent collection, am I blocked from doing a BIND or MOVE on my lock-null URI? 
I believe the intent of the lock-null is to insure that we can do operations like PUT/MKCOL there... but I'd think that BIND and MOVE also apply... at least in intent... but that seems to conflict with what we've been saying about BIND/MOVE being an operation on the state of the parent collection... and thereby blocked if someone else locks the parent. 
Any thoughts? 
Yaron? 
:-) Step 1 - User A successfully take out an exclusive write lock on a/b, which is a lock null resource. 
Step 2 - User B tries to take out an exclusive write lock, depth = infinity on a/. 
The write lock will fail because a/b is already locked. 
Yaron The intent is that a lock on the parent collection preserves that namespace by preventing the addition or removal of members. 
So any method that effects a DELETE would fail as it changes the namespace even though it might be temporary. 
The owner of the lock on the parent collection can change the collection members, and the owner of the lock on the lock-null resource can set the resource contents with PUT. 
But the owner of the lock-null resource cannot UNLOCK or DELETE the lock-null resource, or MOVE it to a different parent. 
ccjason@us.ibm.com on 08/19/99 02:14:09 PM Subject: LOCK NULL reserves what? 
Whoops, I sent this to the wrong address last night.... My comments in my previous note remind me of something else. 
If I have a lock-null resource, and if someone places a lock on the parent collection, am I blocked from doing a BIND or MOVE on my lock-null URI? 
I believe the intent of the lock-null is to insure that we can do operations like PUT/MKCOL there... but I'd think that BIND and MOVE also apply... at least in intent... but that seems to conflict with what we've been saying about BIND/MOVE being an operation on the state of the parent collection... and thereby blocked if someone else locks the parent. 
Any thoughts? 
Yaron? 
:-) Step 1 - User A successfully take out an exclusive write lock on a/b, which is a lock null resource. 
Step 2 - User B tries to take out an exclusive write lock, depth = infinity on a/. 
The write lock will fail because a/b is already locked. 
Perhaps I should have been clearer. 
What if step two is a singleton, not a depth lock request. 
Can User A do a BIND/MOVE/and other operations that we usually think of as modifying the state of /a/? 
I'm asking for the original design philosophy and the what we'd actually like to see now. 
Two questions. 
It does beg a second question. 
Reverse the order of the steps. 
Can the lock null resource be created if the parent is locked? 
I think the answer to this is easier. 
:-) To quote from section 7.5: A write lock on a collection, whether created by a "Depth: 0" or "Depth: infinity" lock request, prevents the addition or removal of member URIs of the collection by non-lock owners. 
Hence if a/b is WRITE locked then a singleton WRITE lock on a/ will fail because the WRITE lock on a/b, as specified in section 7.1, reserves the write for DELETE. 
In other words: 1. a/b is WRITE locked and thus has exclusive use of DELETE 2. The depth: 0 WRITE lock on a/ reserves the write to DELETE on a/ and its immediate children. 
3. Since a/b is WRITE locked the WRITE lock depth:0 request on a/ MUST fail. 
Yaron To quote from section 7.5: A write lock on a collection, whether created by a "Depth: 0" or "Depth: infinity" lock request, prevents the addition or removal of member URIs of the collection by non-lock owners. 
Hence if a/b is WRITE locked then a singleton WRITE lock on a/ will fail because the WRITE lock on a/b, as specified in section 7.1, reserves the write for DELETE. 
I take it you mean the "right to delete" rather than "write for DELETE". 
If not perhaps you can explain your phrasing. 
Also 7.1 of RFC 2518 doesn't talk about rights that the lock gives you, only what it prevents other folks from doing. 
In other words: 1. a/b is WRITE locked and thus has exclusive use of DELETE 2. The depth: 0 WRITE lock on a/ reserves the write to DELETE on a/ and its immediate children. 
3. Since a/b is WRITE locked the WRITE lock depth:0 request on a/ MUST fail. 
1. Hmm. 
Since I guess I asked for original intent, I guess this is fine, but my reading of the spec is that it doesn't give rights as much as it blocks other people's rights. 
If it's write locked, you have to hold the lock to modify it. 
If it's exclusively locked, noone else can get a write lock on it. 
BTW, I take it you mean that the write lock on a/b gives the holder the right to delete a/b. 
Although believable, that's interesting, because deletion has been thought to be an operation on the parent collection. 
And because this is the only case (except for URI protection) where a lock would lock a specific part of a collection. 
I do think this is valuable though. 
2. Once again, I miss the part where the spec says a lock reserves a right... other than to block another principle. 
This might be implicit in the spec though. 
Of course, I asked intent, not what the spec says. 
2. Also, Does a lock on a/ reserver the right to DELETE a/? 
We have been saying that locking a/ only controls the membership of a/ and doesn't apply to deleting a/ itself. 
If what you say was the intent, I think something has changed since this was originally conceived. 
3. Interesting. 
Thanks. 
This definitely deserves discussion. 
BTW, the reason I make the distinction between a write lock giving one the right to modify a resource and a lock simply blocking others is because of URI protection. 
(You also provided a potential example.) 
I had assumed that if a resource deep in a tree was locked and therefore the URI was protected, another principle would still be allowed to write lock an ancestor collection. 
But that that write lock wouldn't give the second principle the right to break the protected URI. 
/a/b/c If /a/b/c is locked and the /a/b/c URI is protected... 
I assume someone else (person S) can write lock /a/. 
And I assume that the write lock on /a/ doesn't actually give person S the right to delete /a/b because that binding is protected by the lock at /a/b/c which he doesn't hold. 
But it does give person S the right to prevent someone else from deleting /a/b. 
This does of course beg the question of the effect of obtaining these locks in reverse order. 
This might be contrary to our expectations. 
I don't think of this as a problem with protection as much as a problem with our definitions of write lock... or more importantly, our lack of any other type of lock. 
J. 
