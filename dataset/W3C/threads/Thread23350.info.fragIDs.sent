Does the spec define what should happen with 
node.insertBefore(child, child) 
From my reading of the spec [1], what should happen is that first the 
child node should be removed ("If the newChild is already in the tree, it is first removed."), then a "NOT_FOUND_ERR" exception should be thrown, since the node is no longer in the tree and so can't be found. 
This isn't useful, and isn't what UAs appear to have implemented. 
Based on this testcase: ...Opera, Mozilla, IE6, and Safari all simply ignore the call, not changing the DOM and not raising any exceptions. 
Could the spec be clarified to specify this interoperable behaviour? 
-- References -- [1] http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-952280727 
Cheers, Ian Hickson )\._.,--....,'``. 
fL U+1047E /, _.. \ _\ ;`._ ,. 
I understand perfectly the reasons behind your proposal but I hate thinking of a spec allowing the concept "insert that before itself" without complaining about an illegal request. 
After all, it does not mean "do nothing", it really _means_ nothing at all. 
It's conceptually non-sense. 
-----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1 
This is true from my point of view but not really usefull, just as you said. 
Well, a blind spec implemented (damn, just like me) would provide the behavior just as the spec acutally specifies, but I now intent to raise a DOMException of type HIERARCHY_REQUEST_ERR since this is really a hierarchy request error. 
However, ignoring the methods function is really not the best behavior as the currently supporting browsers do so :( 
I propose to clarify this as I said above. 
Regards, Christian Parpart. 
22:51:28 up 53 days, 8:48, 3 users, load average: 0.07, 0.07, 0.03 -----BEGIN PGP SIGNATURE----- Version: GnuPG v1.2.3 (GNU/Linux) iD8DBQE/x8U2Ppa2GmDVhK0RAu+nAJ4+Zn/otBDaZjxKiaL2ysG3K3b2/ACeKoGt sWWo+jfP6XCozWBMRlGSzTA= =YKPd -----END PGP SIGNATURE----- 
It is indeed the behavior of common UAs, but unfortunately, it is not the case on Xerces. 
Given that at least one significant implementation is following the specification, we cannot render it non conformant by modifying the specification to accomodate and describe the behaviors of 
the UA implementations. 
node.insertBefore(child, child) and 
node.replaceChild(child, child) are now described as "implementation dependent" in the specification. 
It does not clarify anything except that DOM applications should now be aware of no interoperability for those cases. 
Let us know if this decision satisfies or not your request, 
Philippe 
Why not? 
Is there any code anywhere that depends on Xerces raising an exception? 
Does Xerces really do what the spec says? 
(i.e. both remove the node and raise an exception.) 
node.insertBefore(child, child) and node.replaceChild(child, child) are now described as "implementation dependent" in the specification. 
It does not clarify anything except that DOM applications should now be aware of no interoperability for those cases. 
That's even less useful than raising an exception! 
:-) 
Not really. 
:-) 
I'd rather the behaviour be well specified and useless than not specified at all (and would much rather it was well specified and useful, especially 
given the number of interoperable implementations, even if there is one 
implementation that currently removes the node and raises an exception). 
Cheers, Ian Hickson )\._.,--....,'``. 
fL U+1047E /, _.. \ _\ ;`._ ,. 
I don't know. 
It does remove the node and insert it again. 
While the spec does say 
that you should raise an exception if the refChild is not in the tree, 
it doesn't say if you must do the hierarchy check _after_ removing the refChild. 
node.insertBefore(child, child) and node.replaceChild(child, child) are now described as "implementation dependent" in the specification. 
It does not clarify anything except that DOM applications should now be aware of no interoperability for those cases. 
It does acknowledge the fact that UAs don't follow the specification, which is better than nothing imho. 
... as long as the behavior matches your view of interoperable implementations, but we just demonstrated that at least one 
implementation does not interoperate with the others at the functionality level.True 
enough, this implementation is not a UA, but it is still a DOM implementation that is trying to follow the specification. 
It would be much better if DOM applications were not 
trying to do node.insertBefore(child, 
child). 
Philippe 
IMHO this should be an important part of the decision here. 
:-) 
I am confused. 
What exactly does Xerces do? 
While the spec does say that you should raise an exception if the refChild is not in the tree, it doesn't say if you must do the hierarchy check _after_ removing the refChild. 
The spec says: # If the newChild is already in the tree, it is first removed. 
I interpreted "first" as meaning that was the initial step of the algorithm. 
node.insertBefore(child, child) and node.replaceChild(child, child) are now described as "implementation dependent" in the specification. 
It does not clarify anything except that DOM applications should now be aware of no interoperability for those cases. 
Unfortunately it also prevents implementors from knowing what they should do. 
:-) 
Given the five UAs mentioned so far -- Mozilla, WinIE, Opera, Safari, Xerces -- four have the same result, and the fifth (if I understand you) does something else. 
You can't claim interoperability if there is only one implementation. 
:-) This doesn't have anything to do with my "view". 
but we just demonstrated that at least one implementation does not interoperate with the others at the functionality level. 
Actually I would be interested in a demonstration, I don't really understand what Xerces does based on this thread so far. 
True enough, this implementation is not a UA, but it is still a DOM implementation that is trying to follow the specification. 
I have nothing against server-side libraries being considered just as much as client-side Web browsers. 
There are some algorithms that are neater and simpler if doing that is a no-op. 
For example, the algorithm set out in: ...step 5. Of course it's no big deal as the algorithm can just say "check that the two nodes aren't the same" first, but that seems inefficient when one could just rely on the API defining this. 
What's the use case for doing what the spec currently says? 
Ian Hickson )\._.,--....,'``. 
fL U+1047E /, _.. \ _\ ;`._ ,. 
Xerces is just an illustrative case. 
We can't contact every possible Xerces user; we can't contact everyone who has ever implemented a DOM. 
If they met the spec as it was written, they're compliant, even if the way they met it isn't the way you'd prefer. 
Some things really were left as quality-of-implementation and flexibility-for-performance-tuning issues. 
So what you're proposing here is an erratum against DOM Level 1. Errata have a pretty high activation energy barrier to jump over or tunnel through before they can be approved; "it might be nice" or "we would have done it that way if we'd thought of it" generally don't do it. 
I think this one's going to fall into the latter category, but good luck... Joe Kesselman, IBM Next-Generation Web Technologies: XML, XSL and more. 
"The world changed profoundly and unpredictably the day Tim Berners Lee got bitten by a radioactive spider." -- Rafe Culpin, in r.m.filk 
It "works". 
In other words, it will remove the child, and insert it again, with all the appropriate events. 
The "first" was necessary in order to specify the order of the events that are generated underneath, not as a way to specify an algorithm. 
The use case for not changing the current behavior without breaking existing implementation is simple: as Joe mentioned, this is a DOM Level 1 erratum and we don't modifying DOM Level 1 unless a really good reason. 
node.insertBefore(child, child) was already discussed in January 
2001 by the DOM WG. 
We did contact some implementers at that time. 2 implementations were known to do a no-op, 2 or 3 were considering the case valid (i.e. it "works"), 1 was raising an exception. 
We declared the first 2 and the last one invalid according to the specification and didn't change anything. 
With your number and an update, we now have 4 implementations doing nothing, 3 or 4 considering the case valid (it "works"). 
The WG is now rendering the case "implementation dependent". 
It is better imho that the previous status quo (and will avoid dealing with this case in 2006 :). 
Philippe Note to myself: the FAQ needs to be updated to match this "implementation dependent" behavior [1] http://www.w3.org/DOM/faq.html#insertBeforeSelf 
I surveyed multiple implementations on this issue in preparation for last week's WG conference call. 
I believe Crimson came closest to your definition of "following the spec", that is removing the reference node and then throws a NOT_FOUND_ERR. 
This behavior is undesirable since it is not atomic (it both mutates the tree and throws an exception) and makes a call to insertBefore(child,child) act like a call to removeChild(child). 
Multiple vendors decided that the "following the spec" behavior was not good thing and took their own approach, either performing a no-op 
(observed behavior of browser), removing and reinserting the node to trigger mutation events (Xerces-J) or throwing a HIERARCHY_REQUEST_ERR (Oracle). 
Since all of these behaviors are reasonable and widely deployed and the "following the spec behavior" is undesirable, the best that we can do at this time is warn people not to make that type of call. 
The current spec is either poorly defined or defined to do something undesirable, depending on how one reads it. 
Isn't that a good enough reason? 
With your number and an update, we now have 4 implementations doing nothing, 3 or 4 considering the case valid (it "works"). 
The WG is now rendering the case "implementation dependent". 
It is better imho that the previous status quo (and will avoid dealing with this case in 2006 
Would it be possible to have it at least partially defined? 
As a user I don't mind if mutation events are fired for this case, what concerns me is the final position of the node and whether an exception is raised. 
I don't understand why "the best we can do" is not "specify an explicit useful behaviour" and have non-compliant UAs change to match. 
As far as users are concerned, well defined specifications are the most useful. 
My proposal would be that the behaviour be that no exception should be raised, and that the node remain where it is, optionally with the firing of two mutation events, one for the removal of the node and one for the reinsertion of the node at the same point. 
This would seem to cover the majority (all but one?) of the implementations mentioned in this thread. 
Ian Hickson )\._.,--....,'``. 
fL U+1047E /, _.. \ _\ ;`._ ,. 
Can't speak for other implementors, but certainly in my case I didn't deliberately depart from specification: I implemented it in the only way I could see that made sense. 
(That is, inserting the child in the position it already was - since pxdom doesn't support MutationEvents this is indistinguishable from a no-op.) IMO it takes a really perverse reading of the spec to interpret the "it is first removed" directive as occurring *before* the "existing child node" precondition. 
I'm not too familiar with Crimson, but I very much suspect its non-atomic behaviour to be an accident rather than something deliberatly coded for. 
And all this also applies to Node.replaceChild doesn't it? 
The spec has the same language here. 
Certainly for Levels 1 and 2, but surely it would be safe to state insertBefore(child, child) is OK in Level 3 (if there is still time to put it in)? 
The only implementation we've found with a different opinion is Crimson, which makes no claims to support Core 3.0. 
As you say, both possibilities are reasonable given the letter of the spec (although IMO the non-atomic one only just barely!) so this would be a tightening of the spec rather than a full change in existing behaviour. 
Andrew Clover 
That more elegantly states what I was trying to say. 
A strictly literal interpretation of the description resulted in undesirable behavior. 
Most implementations reasoned that a no-op was best, Oracle thought that throwing a HIERARCHY_REQUEST_ERR was best and Crimson didn't identify the issue and did the remove followed by throwing a NOT_FOUND_ERR. 
The apparent intent of the order of steps was to describe the order of mutation events and not prescribe the details of the implementation. 
That was caught and the resolution also applied to it. 
I don't think anyone would reject an errata because it declared Crimson's behavior non-conformant since it is obviously undesirable. 
Throwing a HIERARCHY_REQUEST_ERR is probably the very best thing to do since a call to node.insertBefore(child, child) would strongly suggest a coding error. 
However, that is not what the browser vendors did. 
The current wording allows the implementer a choice, either throw an exception if you are most concerned about identifying bugs and program correctness or do a no-op if you are concerned with compatibility with the currently deployed user agents. 
I agree with the WG resolution and can identify scores of other issues that are more significant to end users than continuing to beat up this issue. 
Fixing up the holes in the L3 drafts before they become specs is a much better use of time than trying to trying to tweak the behavior for an abnormal scenario in a spec that is 6 or so years old. 
Ian, 
given the differences between the implementations (at least 2 known implementations would be broken if the specification was updated following your proposal), the group decided not to reopen this issue and leave it as "implementation dependent". 
We will therefore report this issue as objection [1] to the Director when reviewing the issues list, 
Philippe [1] 
That's ok, I can live with the working group decision. 
I'm glad you considered my input, even if you didn't agree! 
:-) Cheers, Ian Hickson )\._.,--....,'``. 
fL U+1047E /, _.. \ _\ ;`._ ,. 
