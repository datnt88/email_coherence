Re: IPP Chunked POST Roy T. Fielding (fielding@kiwi.ics.uci.edu) 
Thu, 17 Dec 1998 22:03:24 -0800 
In my opinion, Ken Coar is correct in saying that for a server to be *both* HTTP/1.1 compliant and CGI/1.1 compliant it MUST buffer chunked POST data and provide a Content-Length for the CGI script. 
Sending 411 is HTTP/1.1 compliant. 
Failure to parse the chunked encoding (and puking) would be non-compliance, but requiring a content-length for a given resource is necessary for many reasons (DoS and legacy system protection). 
This is a meaningless distinction. 
Consider this thought experiment: we have 
two HTTP servers, A and B. 
Server A can and does parse the chunked encoding. 
But it sends a 411 "Length 
Required" response with a "Connection: close" header in response to any 
request that does not include a "Content-Length" header. 
This is a compliant 
server. 
Server B understands no transfer-coding except "identity". 
It cannot receive 
or decode the "chunked" transfer-coding. 
It sends a 411 "Length Required" 
response with a "Connection: close" header in response to any request that 
does not include a "Content-Length" header. 
This is a non-compliant server. 
If we look at these servers as black boxes, observing their behavior only 
through their external interfaces, they are virtually indistinguishable 
(unless we look at the product tokens or something). 
So it's meanless to say 
that all HTTP/1.1 applications that receive entities must understand (be able 
to receive and decode) the ?chunked? 
transfer-coding. 
Sending 411 is HTTP/1.1 compliant. 
Failure to parse the chunked encoding (and puking) would be non-compliance, but requiring a content-length for a given resource is necessary for many reasons (DoS and legacy system protection). 
If the purpose of the text was to delineate one lame example from another, 
then I'd agree with you. 
The reason it is there is to prevent an HTTP/1.1 
application from mistakenly thinking the chunked encoding is *no* encoding 
and saving the chunk-sizes as part of the data. 
As far as the protocol 
is concerned, recognizing Transfer-Encoding chunked, and responding with 
411 and connection close, is equivalent to parsing the chunked encoding. 
Nobody is going to prevent you from building a server that responds with 
411 to every request without implementing chunked. 
It would be a dumb 
thing to do, but the standard doesn't prevent people from doing dumb things 
(only things that won't interoperate with others via HTTP). 
....Roy 
Sending 411 is HTTP/1.1 compliant. 
Failure to parse the chunked encoding (and puking) would be non-compliance, but requiring a content-length for a given resource is necessary for many reasons (DoS and legacy system protection). 
That's the clarification I was looking for. 
[Not that it's good news.] 
So, for interoperability, a client always needs to be prepared to fall back to Content-Length with "identity" transfer-coding, and it's just plain out of luck 
(or at least forced to buffer) if it cannot determine the message length in advance. 
Or should it fall back to HTTP/0.9 behavior and signal the end of the message by closing the connection? 
-Carl 
cc: http-wg@hplb.hpl.hp.com Subject: Re: IPP Chunked POST 
Sending 411 is HTTP/1.1 compliant. 
Failure to parse the chunked encoding (and puking) would be non-compliance, but requiring a content-length for a given resource is necessary for many reasons (DoS and legacy system protection). 
have 
luck 
Oops, just realized after sending this that it won't do for the client to close the connection, since it would never be able to get a response. 
So the only real interoperable option is Content-Length/identity. 
Maybe we're just missing an appropriate usage of "SHOULD" in the HTTP spec. 
This needs another editing pass, but roughly: 
"An HTTP/1.1 server SHOULD not only receive and interpret data with a chunked encoding, it SHOULD treat chunked data as if it had received data 
with Content-Length. 
Note, however, that some server implementations will accept data with Content-Length but will reply with "411 Length Required" to chunked data, at least for those URLs that are implemented via CGI 1.x[ref] because of CGI/1.x's requirement that the Content-length be supplied. 
Even in those cases, it would be preferable for implementations to buffer the data in order to compute the length to pass on to the CGI program." 
Larry 
From: kugler@us.ibm.com [mailto:kugler@us.ibm.com] 
Sent: Wednesday, August 18, 1999 8:00 AM Subject: Re: IPP Chunked POST 
Sending 411 is HTTP/1.1 compliant. 
Failure to parse the chunked encoding (and puking) would be non-compliance, but requiring a content-length for a given resource is necessary for many reasons (DoS and legacy system protection). 
to receive and decode) the =93chunked=94 transfer-coding. 
Right, a client can interoperate with any server as long as it sticks to Content-Length. 
But if it cannot determine the message length in advance it's 
probably SOL. 
-Carl 
"Roy T. Fielding" fielding@kiwi.ics.uci.edu on 08/18/99 11:59:21 PM 
yarong@exchange.microsoft.com , http-wg@hplb.hpl.hp.com Subject: Re: IPP Chunked POST 
We might make replying '411 and connection close' to a chunked encoding 'conditionally compliant' rather than 'compliant' because otherwise, as has been pointed out, there are inteorperability problems. 
There is no interoperability problem here. 
The server response is understandable by the client. 
Any server has the right to deny service rather than buffer an unknown amount of data. 
No change is needed to the spec. 
....Roy 
original article:http://www.egroups.com/group/http-wg/?start=8712 
Sending 411 is HTTP/1.1 compliant. 
Failure to parse the chunked encoding (and puking) would be non-compliance, but requiring a content-length for a given resource is necessary for many reasons (DoS and legacy system protection). 
experiment: we have 
411 "Length 
any 
compliant 
cannot receive 
Required" 
request that 
non-compliant server. 
only 
indistinguishable 
meanless to say 
(be able 
to receive and decode) the =93chunked=94 transfer-coding. 
another, 
HTTP/1.1 
encoding 
protocol 
with 
encoding. 
with 
things 
Isn't that what Apache does with chunked POSTs? 
No. It is what mod_cgi requires. 
Apache implements chunked in the core, where any module can make use of it if they so desire. 
As I've said many times before, implementing a new protocol service using CGI is a bad idea. 
Making HTTP requirements based on the limitations of CGI is even worse. 
....Roy 
I don't want to implement a new protocol service using CGI. 
But I'm worried about things like proxies refusing to forward chunked requests. 
I haven't kept up with the Jakarta thing, but it will be interesting to see if the Apache Java servlet implementation supports chunked POST. 
-Carl "Roy T. Fielding" fielding@kiwi.ics.uci.edu on 08/20/99 11:47:01 AM Subject: Re: IPP Chunked POST 
No. It is what mod_cgi requires. 
Apache implements chunked in the core, where any module can make use of it if they so desire. 
As I've said many times before, implementing a new protocol service using CGI is a bad idea. 
Making HTTP requirements based on the limitations of CGI is even worse. 
....Roy 
First message to the list.. 
I bumped into HTTP POST version issues about a month ago, and am looking for a definative reference to some data that defines the standard HTTP POST formats for HTTP/0.9, HTTP/1.0 and HTTP/1.1 
I managed to figured out by brute force that the HTTP version was required on the POST /url line in order to get the server to support multple headers. 
But upgrading the version from 1.0 to 1.1 caused the servers (Apache and NES) to abort with "invalid protocol" messages. 
Web searches, RFC reads, and consultation with Netscape and it's affiliates has not produced an answer. 
Any help would be greatly appreciated... Wilbur Putting A Human Face On Technology ;-) Literally! 
http://www.monmouth.com/~wstreett/FaceIT/ 
