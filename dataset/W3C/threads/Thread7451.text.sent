I asked this once before and no one jumped on my bandwagon, so I left it alone.... However after playing with the IE release I will bring it back up :) I am concerned by the Spec section 8.9.3 and 8.8.4 "If the resource exists at the destination and the Overwrite header is "T" then prior to performing the move the server MUST perform a DELETE with "Depth: infinity" on the destination resource." 
Wow that's a STRONG statement. 
If you point a IE browser at a webdav server (or if you play webdav server in your spare time), and you do a MOVE to a directory that already exists: IE = MOVE http://foo/bar to http://foo/fee/bar Overwrite = F I respond = 412 Precondition Failed IE displays to user : This folder already contains a folder named 'bar'. 
If the files in the existing folder have the same name as files in the folder you are moving, they will be replaced. 
Do you still want to move the folder? 
If I say yes IE = MOVE http://foo/bar to http://foo/fee/bar Overwrite = T Hang on a second... 
Where is the big message saying "ALL INFO IN THE DESTINATION FOLDER WILL BE LOST" Now granted IE does not do everything correctly when it comes to move (again if I am wrong here please tell me, I am simply playing server). 
If I give IE a 207 response telling it that some subdirectory didn't move because 412 Precondition Failed, IE assumes the whole move failed. 
Which means my display in IE is screwed up and allows me to ask for directories that no longer exist.... 
So it seems that the only responses to MOVE and COPY are succeeded or failed. 
But back to the BIG DELETE problem, what happens if the big delete fails for some reason??? 
What is the error code there? 
Do I still do a MOVE??? Go through that scenario IE = MOVE http://foo/bar to http://foo/fee/bar Overwrite = T My server sees that http://foo/fee/bar exists, therefore does a DELETE with Depth Infinity. 
BUT that command gives back a 207 saying that some downwind resource was Locked by someone else or something. 
Therefore the entire directory tree WAS NOT deleted, and a skeleton still remains. 
What do I do then?? 1) Fail the Move, give IE a 412 or something. 
But somehow tell IE "and o yea I didn't do the move, but blew away everything I could at the destination", unless I can rollback the delete somehow. 
2) Try to do the Move, and only move the things that I can. 
But if I do that logic, why don't I do this in the first place and not kill off all the data at destination??? 
I have a overwrite flag to Y therefore I know to actually overwrite. 
and what is the alternative for a client if they DON'T want the Move to destroy the directory?? 
They could call individual Moves for each file I guess, but that could be quite costly. 
Also what happens if I have Write permission on a file, and not Delete permission?? 
If I do the delete first it will fail, and then I will do the write during the move and copy and it will succeed. 
That will probably confuse any client... 
It seems funny that a Move will act differently when Delete permissions are used. 
I am not trying to Delete anything. 
So in order to get my desired server feel, I need to set all of my files to NoDelete and everything Writeable... Try explaining that to a user.... 
I think that the Kill All feature of DELETE and COPY is wrong and should be changed. 
Again, I know of no OS that deletes first (I think, its late). 
The move and copy should do what they can without clearing space for themselves... Sorry if this has been discussed w/out me before and I am just being stupid :) Also playing webdav server might have made me make some mistakes :) Kevin From: "Kevin Wiggen" wiggs@wiggenout.com 
"If the resource exists at the destination and the Overwrite header is = "T" then prior to performing the move the server MUST perform a DELETE = with "Depth: infinity" on the destination resource." 
Wow that's a STRONG statement. 
When it comes to DELETE, you really want to know what the server will do. 
A statement like "the server MAY do a DELETE" will not make you a happy camper if you get used to one that doesn't (i.e. does some kind of merge operation), and then try the same operation on a server that does the DELETE. 
If you point a IE browser at a webdav server (or if you play webdav = server in your spare time), and you do a MOVE to a directory that = already exists: IE =3D MOVE http://foo/bar to http://foo/fee/bar Overwrite =3D F I respond =3D 412 Precondition Failed IE displays to user : This folder already contains a folder named 'bar'. 
So far so good. 
If the files in the existing folder have the same name as files in the = folder you are moving, they will be replaced. 
Do you still want to move = the folder? 
Using the term "move" for a "merge" is rather bogus, but with the prefacing statement, the user will know what they meant. 
If I say yes IE =3D MOVE http://foo/bar to http://foo/fee/bar Overwrite =3D T OK, if that's what IE does, the IE implementors were not reading the spec very carefully (or even, very cursorily :-). 
Or maybe there was an earlier version of the spec that didn't make this clear. 
At any rate, either the prompt or the request is wrong. 
Hang on a second... 
Where is the big message saying "ALL INFO IN THE = DESTINATION FOLDER WILL BE LOST" Exactly. 
Now granted IE does not do everything correctly when it comes to move = (again if I am wrong here please tell me, I am simply playing server). 
= If I give IE a 207 response telling it that some subdirectory didn't = move because 412 Precondition Failed, IE assumes the whole move failed. 
= This is an incorrect assumption, but a compatible with the previous incorrect assumption (i.e. that "move overwrite" means "merge"). 
Which means my display in IE is screwed up and allows me to ask for = directories that no longer exist.... 
So it seems that the only = responses to MOVE and COPY are succeeded or failed. 
=20 I'm not sure what you mean by "the only responses". 
It is true that they either succeed or fail (but with various flavors of each). 
If you mean that IE is assuming that when MOVE or COPY are done, a failure means no change on the server, then IE is counting on things the protocol does not provide. 
But back to the BIG DELETE problem, what happens if the big delete fails = for some reason??? 
What is the error code there? 
Do I still do a = MOVE??? =20 That is an excellent question. 
As far as I can tell, the spec is silent on that point. 
I think the only sensible thing to do is to fail the MOVE and leave the rubble lying on the server (:-). 
In any case, it would be worth adding some words here. 
Go through that scenario IE =3D MOVE http://foo/bar to http://foo/fee/bar Overwrite =3D T My server sees that http://foo/fee/bar exists, therefore does a DELETE = with Depth Infinity. 
BUT that command gives back a 207 saying that some = downwind resource was Locked by someone else or something. 
Therefore = the entire directory tree WAS NOT deleted, and a skeleton still remains. 
Yes, the 207 sounds like the right thing to do. 
What do I do then?? 1) Fail the Move, give IE a 412 or something. 
But somehow tell IE "and = o yea I didn't do the move, but blew away everything I could at the = destination", unless I can rollback the delete somehow. 
The contents of the 207 multi-status should give IE the data it needs to know what got deleted. 
If it ignores it, then there's not much you can do. 
2) Try to do the Move, and only move the things that I can. 
But if I = do that logic, why don't I do this in the first place and not kill off = all the data at destination??? 
I have a overwrite flag to Y therefore I = know to actually overwrite. 
That would be a "merge", not a "move" (a "move" is basically a "rename", extended to handle cross-server renames). 
and what is the alternative for a client if they DON'T want the Move to = destroy the directory?? 
They could call individual Moves for each file = I guess, but that could be quite costly. 
I agree that a "collection-merge" method would be useful. 
But we need to clearly distinguish it from a "move". 
Also what happens if I have Write permission on a file, and not Delete = permission?? 
If I do the delete first it will fail, and then I will do = the write during the move and copy and it will succeed. 
That will = probably confuse any client... 
It seems funny that a Move will act = differently when Delete permissions are used. 
I am not trying to Delete = anything. 
So in order to get my desired server feel, I need to set all = of my files to NoDelete and everything Writeable... Try explaining that = to a user.... Sure, "move" is not a good way to implement "merge" (:-). 
I think that the Kill All feature of DELETE and COPY is wrong and should = be changed. 
Again, I know of no OS that deletes first (I think, its = late). 
The move and copy should do what they can without clearing space = for themselves... Here I'll disagree strongly. 
A "move" (i.e. "rename") command is essential. 
A merge command is useful, but not a replacement for move. 
Cheers, Geoff Caught by the spam filter. 
- Jim I am concerned by the Spec section 8.9.3 and 8.8.4 "If the resource exists at the destination and the Overwrite header is "T" then prior to performing the move the server MUST perform a DELETE with "Depth: infinity" on the destination resource." 
Wow that's a STRONG statement. 
In general I like how the WebDAV spec has turned out so far, but this clause bothers me a whole lot. 
I brought this topic up when the versioning group had a meeting here in Orem and nobody could give me a good reason for the requirement. 
Implementing such dangerous behaviour in a commercial product is a wonderful way to get in serious trouble with your customers. 
I agree that it should be removed. 
If you perform a copy of a collection with the Overwrite header set to "T" then individual files with identical URIs should be overwritten, but saying that the target should be completely wiped clean before beginning the copy operation is not a good idea. 
essential. 
Ahhh.... The spec makes more sense when read that "Move" is a "Rename". 
But then what is a "Copy"???? 
Is it a rename or a Copy?? 
This is confusing. 
I feel that Move and Copy should be made to be "Merge" type functions. 
The overwrite flag allows for the "Rename", its simply a Move with overwrite set to "F". 
In this case, if a file exists, it tells you it cannot rename to a file that already exists... 
I see a few possibilities in desired functionality. 1) A person wants to "Rename" a file or directory. 
The Webdav client issues a "Move" with the overwrite flag set to "F". 
This will cause the "Rename" to succeed if no file exists, or to fail if the file does exist. 
At this point the user can do a delete to get rid of the older file or dir, or simply not do the move. 
(A Webdav client could also implement the delete then move if that IS the desired functionality, but the server won't do this on its own). 
2) The person wants to "Move/Merge" files. 
Webdav client issues the "Move" with overwrite to "F". 
If the file exists, an error is returned. 
This gives the client the chance to ask the user if she wants to "Overwrite/Merge" the files into the existing directory (or replace the existing file if this is at the file level). 
Then the overwrite = "T" will do the merge. 
3) The person wants to "Copy/Merge". 
This works just like number 2, except for copies of the files are made at the destination instead of "Moving" the originals. 
4) The person wants to "Move/Replace" the existing files. 
If the Webdav client supports this, it can simply do a "Move" with overwrite to "F". 
When the Webdav client gets the error, it can issue the "DELETE", then do the "MOVE". 
No functionality lost. 
Or the Webdav client can make the User issue the delete, this way the user won't loose any files unknowingly. 
The Webdav client also has time to respond to an error during the "Delete" phase, it could decide not to do the move and give a valid response to the user. 
5) "Copy/Replace" see number 4. In this way the Spec will be able to do what it does today, AND have the merge functionality. 
This means that we won't need another method type put into HTTP. 
A client can then implement #1-5 above by simply issuing Webdav commands. 
If we stick with the spec, there will be long-term confusion and problems with permissions and locking on the "Delete" phase of Move/Copy. 
I believe it far safer (and more understandable to the user) to have Move/Copy do merges. 
I also believe that the use-case of merge will be used far more than the complete replace. 
If the move is accross servers http://foo/bar to http://foobar/fee/bar the only way the server can do this is by doing a "Head" or "Propfind" or sometyhing to the other server to see if the file exists (and erroring if the overwrite = "F"). 
Then follow it up by a "Put". 
The server could do a "Delete" if the overwrite = "T", but this is not necessary, I think it should simply do a "Merge" by doing the "Put". 
If the user or Webdav client wants to do a replace, have IT do the "Delete" to the other server, foobar, itself..... 
The only drawback is that replace now takes 2 Webdav calls instead of just 1. 
Not too terrible, and the user (or Webdav client) is in charge of the whole thing :) Kevin I'm in agreement with you on this. 
Indeed, while there may be some questions concerning details of the implementation, the general principle that "Move and Copy should be made to be "Merge" type functions" seems like the most sensible way of implementing them. 
My reasoning (mostly applied to "move"; "copy" is similar) is the following: 1) Those that consider it linguistically wrong for a command like MOVE to do a merge type operation seem to focus their attention on the collection as being the main object which is being moved. 
However, it is equally legitimate to think of the collection as a container (or location) and to think of the content of that container as the main thing which is being moved. 
That is, "MOVE col1 to col2 " can be legitimately interpreted as saying: "move the content of col1 into col2 ". 2) The behavior where a MOVE request does an implicit DELETE followed by a MOVE is neither useful nor desirable. 
It's not useful, because if a client wants to do that it can send a DELETE request and then issue a MOVE. 
The cost of sending two requests instead of one is very small. 
It's not desirable, because with a destructive operation of this type it is better to have the client issue an explicit DELETE rather than have it done implicitly. 
An implicit DELETE is something that should be avoided, except in cases where it is clearly the only way of doing things. 
Also, if the DELETE is done separately and it runs into a problem, then the client gets to decide what to do about it (which seems much better than having it arbitrarily decided by the server). 
3) The "merge type" operations are clearly needed (see 4 below), and there is currently no other way of doing them short of moving individual resources. 
(In general, this might require a huge number of requests instead of one.) 4) The "merge type" behavior is how Windows Explorer does things (I suppose some other file managers do that as well. 
UNIX file managers don't usually do that, but they will usually not overwrite a directory unless it's empty, so they don't have the current WebDAV behavior either). 
Since it is clearly the most widely used file manager in the world, its behavior (logical or not) is what most people would expect. 
Furthermore, Microsoft would clearly want to have their web folders do things in this way (in order for them to be consistent with the rest of Explorer) and the current implementation actually assumes that MOVE/COPY have the "merge type" behavior. 
One can point fingers at them for not reading the spec (or for reading it and still doing things differently), but this won't solve the problem. 
They really do seem to have a legitimate need to have the "merge type" functionality, and I somehow doubt that they are going to recognize this as their bug and change it. 
They might say that it is the protocol which is bogus and needs to be fixed, and in this particular case, I think this is basically true. 
Yoram 
