In a recent series of mail votes and meetings, the ERB has resolved several XML design issues. 
Under pressure of time, we moved very rapidly and votes may not have been fully and exactly recorded where the sense of the ERB on some issue became quickly obvious. 
It is possible that ERB members may wish to correct their reported votes. 
As always, accompanying rationales, where present, have not been reviewed by the ERB and may be subject to correction. 
[No item number] Decided unanimously to change PIC for XML to be '? '. 
This will allow a lot of things to fit into PI's that currently can't (most notably some proposed server-side scripting languages). 
A.8, B.7 XML will have INCLUDE/IGNORE marked sections in DTD's Passed, Bray and Paoli dissenting. 
A.20' XML will change the COM delimiter from '--' to some other string, to minimize user errors. 
(Candidates: !!, /*, //, **, ??, ;;, ~~. !?, ?!, (), [], others ...) Defeated, Sperberg-McQueen voting in favor A.22 XML will have no CONREF attributes (11.3.3, 7.3, 7.9.4.4). 
Passed (no CONREF), Kimber and Maler dissenting B.9' Should XML require system and public identifiers to be FORMAL (13.5)? 
This had actually become a discussion of whether to allow the url formulation in front of external identifiers, which must be URL's in XML. 
Decided, DeRose, Kimber, Maler, and Sperberg-McQueen dissenting, not to allow the url prefix. 
C.10 Should XML allow nondeterministic content models (11.2.4.3)? 
Voted (Bray, Paoli, and Sharpe dissenting) to retain SGML's restriction in this area. 
Rationale: Existing SGML tools, for example the SP family, have this rule wired deeply into their logic, and those who wish to use these tools on XML documents won't be able to if they have non-deterministic content models. 
C.14 Should XML allow more than one enumerated type (name-group declared value) to contain the same possible value (11.3.3)? 
Voted unanimously to remove SGML's restriction in this area. 
Rationale: This is incompatible with 8879, but there is every expectation that WG8 will fix this problem soon; furthermore, making this change is not expected to cause serious inconvenience to existing SGML products, whereas the rule is a very serious inconvenience to users of XML and authors of XML software. 
D.2 Should XML provide shorthand ways of summarizing the salient points of a document's DTD? 
Discussion: This turned out to be one of the hardest problems the ERB dealt with, and the key issue became that of EMPTY elements. 
Remember that in a previous decision we had agreed to recommend the e/ syntax, but accept the 8879 syntax. 
Here are some of the sticky parts: - for a well-formed document to be network-usable, it is important that EMPTY element declarations be available in the document entity so that a browser can be guaranteed of not having to fetch a DTD over the network before starting to parse. 
- requiring all the !element foo EMPTY declarations to appear in the internal subset could lead to a situation where documents were valid but not well-formed. 
- Also, it would require those using big existing DTD's to hash them around to make sure these declarations appeared in the internal subset. 
- As the WG pointed out, supporting two forms of EMPTY is bad design. 
- The proposal for a PI that summarized the empty elements worked around a few of these problems, but introduced a new syntax and was a possible source of inconsistencies. 
- Falling back to a position allowing only the e/ syntax solves all the problems cleanly, but makes it *impossible* for a valid HTML document to be XML - several on the ERB felt this was political suicide. 
Bearing all this in mind, the ERB voted, Maler dissenting, that: - XML support only the e/ syntax for EMPTY elements - this means that all the language in the spec about "undistinguished" EMPTY elements can come out. 
- In order to make it possible that a valid HTML document can be a valid XML document, the XML spec will state that XML processors, when they are processing HTML documents, should recognize, in a built-in way, that the elements declared as EMPTY for HTML 3.2 (BR, HR, IMG, etc.) are empty even without syntactic indication. 
The manner in which an XML processor is to decide whether a document is HTML is not constrained by the spec. 
Rationale: For technical reasons, requiring and allowing only e/ is a big winner. 
However, many of us, who anticipate an uphill struggle selling XML to web-heads felt that the marketing advantage in making it possible for HTML documents to be valid, and being able to say "XML processors can read HTML", were impossible to give up. 
In opposition, Eve Maler in particular felt it was unconscionable to kowtow to the requirements of one particular DTD. 
The ERB acknowledged that allowing BR , etc., does *not* enable to XML to grandfather, on a large scale, the existing inventory of XML; simply to state that (at least some normalized) HTML documents can be read by XML processors. 
D.3 Should XML specify short-hand element declaration keywords (e.g. %ANY-ELEMENT;) for element content in which any element in the DTD is legal (same as ANY, but element not mixed content)? 
Defeated, Sperberg-McQueen voting in favor. 
Cheers, Tim Bray tbray@textuality.com 
http://www.textuality.com/ 
+1-604-488-1167 
From: bosak@atlantic-83.Eng.Sun.COM (Jon Bosak) [Paul Grosso:] |  From: bosak@atlantic-83.Eng.Sun.COM (Jon Bosak) | |  Note also that this strategy does not discriminate against the |  existing SGML document base. 
There are probably as many existing SGML |  documents that will work unchanged in an XML environment as there are |  HTML documents. 
My Shakespeare and Religious Works collections are |  valid XML just as they stand | How is that? 
How are empty elements represented in your existing SGML | document base for your Shakespeare and Religious Works collections? 
There are none. 
| Irrespective of the answer to the above, what SGML authoring tools | would produce valid XML given document instances in your Shakespeare | and Religious Works collections? 
The SGML authoring tools that I actually did use: emacs and perl. 
The fact that these are probably not examples of what you have in mind when you say "SGML authoring tools" says something important about the preconceptions you may have about XML. 
You're wrong. 
The answer you give is exactly what I expected. 
| Assuming neither Author/Editor nor Adept Editor (whose output, I | believe, are very similar) are answers to the above question, what | would be the list of modifications necessary to convert what they would | produce given document instances in your Shakespeare and Religious | Works collections into valid XML? 
I think that Lee has addressed this. 
However, the question misses the point. 
The primary use of XML is to convey structured information from SGML databases to Web applications. 
The batch processes that I used to generate the Shakespeare and Religion collections are actually much closer in spirit to the problem domain that XML is primarily designed to address than anything having to do with native authoring. 
Again, your answer is not a surprise to me, but I think it is useful to see it in print. 
I have sensed a lot of people trying to give lip service to the claim that XML is a subset of SGML--at least in spirit if not in fact--and it's refreshing to have you admit that this is not your intent. 
It's not your intention that the base of existing SGML authoring tools will handle XML. 
The point I was trying to make (but complicated by using the word "valid") is that if you strip off the current doctype header from the Shakepeare and Religion files, you have well-formed XML that could (if such things existed) be fed directly to XML browsers. 
The fact that I was writing well-formed XML in 1992 says to me that XML is "natural SGML" -- it is what I intuitively thought that SGML was when I started. 
And consequently I believe that a lot of existing "monastic SGML" can be made into XML much more easily than the great majority of existing HTML documents. 
"Natural SGML" may well be some subset that omits a lot of esoterica. 
However, XML as being defined now will require new tools and will force new decisions upon potential users that will cause extra confusion as they try to figure out what to do with their data. 
Whether this ends up being good for the users is still an open question. 
I will repeat the point that I want to make sure doesn't get lost here: the XML spec does not favor HTML legacy data over SGML legacy data; quite the contrary. 
Jon 
I'm not sure a comparison to HTML is of as much interest for me as the comparison between XML and SGML legacy, both in terms of legacy instances as well as legacy DTDs, information modeling, and processes. 
There is a huge and important customer base that has a whole lot invested in "legacy" SGML. 
I suspect that only a very small portion of the total investment is, for example, based on the various minimization techniques of 8879, so I'm happy to see them tossed. 
But I suspect, for example, about 99% of the investment is built on assumptions that there are EMPTY elements. 
I'm not afraid from a tool producer point of view. 
Let's face it, for any organization that's developed an SGML aware authoring tool, it's not going to be hard to add an "XML-mode" switch to it. 
What I'm a bit more concerned about is the confusion among potential adopters we'll be creating just at the time I thought SGML was finally getting over the "it's too new to try out yet" hump. 
People who just jumped on the SGML bandwagon will now all say "shoot, I jumped too soon, now it looks like XML is the latest thing--geez I knew it was still too early to commit to SGML." 
This WG has been concentrating on the technical issues, but it's the effect the technical definition of XML has on the market place reaction that has me concerned. 
Insofar as XML is just "a subset of SGML without the cruft" then I don't have as much of the marketing problem I describe above. 
Maybe if all the vendors hop to it and add "XML-mode" and "Convert to XML/convert from XML" options in their tools, then we can minimize the effect of the market confusion. 
Meanwhile, it'll be interesting to see how all this plays in Boston when it gets more into the hands of community at large. 
paul 
[Jon Bosak] 
The primary use of XML is to convey structured information from SGML databases to Web applications. 
The batch processes that I used to generate the Shakespeare and Religion collections are actually much closer in spirit to the problem domain that XML is primarily designed to address than anything having to do with native authoring. 
Whoops! 
Yikes! 
It isn't good for the existing SGML users and vendors. 
It is an alternative to SGML, not a subset. 
That is bad news. 
I will repeat the point that I want to make sure doesn't get lost here: the XML spec does not favor HTML legacy data over SGML legacy data; quite the contrary. 
Pardon, but only one existing application of SGML is contributing to a tag pool, so far. 
I understand what political suicide is. 
I suggest if that is what you want to avoid, retain e and state that the added complexity of the parser in XML is to retain compatibility with existing SGML applications and systems such as Netscape and Microsoft IE because these are the only Shogun's that will compel you to ritual suicide. 
Political suicide allows one to reincarnate. 
Clinton does it regularly. 
It is for me because I generate information in that notation. 
However, I also use the others and get them for conversion into hypermedia. 
XML is *for me* a legal target for simplifying the systems and markup required for that. 
SGML server to HTML client is just one particular technical approach. 
Using rewrite languages such as PERL to create markup products is another. 
XML was *I thought* to be a simplified SGML that works in the *current* network environment and enables products to be created and interoperated at lower costs by reducing the requirements for absolute two way fidelity. 
In other words, give up some legal and abnormal exception handling; get back the ability to build and choose structures. 
But, still, generalized validatible markup. 
The requirements that are compelling beyond that are the markup structures and properties which are used in the interface processes, e.g, hyperlink types. 
These we share because it makes the net go. 
Then stylesheets, because fidelity is always a requirement. 
What the stylesheet is used for vis a vis protocols, operations, etc, is a more difficult question. 
If my sample is significant, I agree. 
Maybe, but if the cost of converting existing legacy to XML is greater than the cost to kluge a way to move SGML onto the Internet even at the risk of monkey-wrenching HTTP, we will do it. 
So far, nothing I see makes me think we even have to do that. 
All we have to do is be careful about what features we use and do it. 
Interoperability with other vendors choices can be an issue worked out in the marketplace, just as it is being done now by the HTML vendors. 
What I was hoping for from this group was a serious effort to avoid a competition between XML on The Web and SGML On The Web. Seems counterproductive. 
I'd love to see that, but I will be in Orlando trying to convince members of my corporation that we should be targeting XML for IETM products if possible. 
If not, no sale. 
We already know how to use SGML for that and the Web and we already know which features of SGML not to use for our purposes. 
XML is a chance to cooperate. 
Pardon Jon and members of the ERB: it is yours to vote on the content of the spec. 
It is ours to implement what we choose to implement. 
The investment of the SGML tool vendors is important. 
I doubt that you are going to have as quick a success with your other romances. 
len bullard ps: out of town from tonight until next friday. 
y'all have fun. 
