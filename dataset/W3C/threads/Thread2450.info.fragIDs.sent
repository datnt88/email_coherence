So I have finished my analysis of digest auth and am recommending that IE 5.0 implement it as a password protection mechanism, nothing more. 
While I like to think my recommendation carries some weight the reality is that it does not assure implementation, now or ever. 
The following spec issues were brought up: 1) In section 3.3 of ftp://ietf.org/internet-drafts/draft-ietf-http-authentication-00.txt, 4th paragraph, it says "The client will follow the redirection, and pass the same Authorization header, including the opaque data which the second server may require." 
This sounds like a typo. 
If the client were to pass the same authentication header it used before the redirection then the information, such as digest-uri, in the header would be incorrect. 
This could be used as the basis for a replay attack. 
2) The proxy-authenticate headers seem to all use 401s, shouldn't these be 407s? 
3) Assuming using a new nonce for every request becomes a MUST it will be impossible to use pipelining or concurrent requests. 
The performance implications are chilling. 
As such we were thinking of an addition to the standard which would be 100% backwards compatible but would help with performance. 
The idea is to send a "next-nonce" header which includes a list of nonces. 
The client MUST use the nonces in order, this is necessary to make the server's job of tracking nonces tractable. 
Current clients would ignore the header and just use the nonce provided in the authentication response header. 
I am not privy to the black corridors of security so I can't be sure this wouldn't weaken the algorithm but it seems to make the mechanism no weaker than providing the next nonce in the authentication response header. 
4) We wish to apply the same preauthorization rules we now use for basic. 
So, for example, a URI in the domain list would imply that all that URI's children are part of the same domain. 
In the worst case we end up sending in a bad response and get a new challenge. 
It doesn't seem to hurt and it definitely could help. 
5) We will not support the digest-required option on a digest-challenge. 
If we receive such a challenge we will look for another authentication option in the www-authenticate. 
Failing to find one, we will inform the user that we can't authenticate. 
There are a number of reasons for this decision but the primary one is performance. 
Because the body authentication information must be placed at the beginning of a message, with the exception of chunked transfers, we would be required to buffer an entire message before sending it off. 
The performance ramifications when compared to the security advantage provided by hashing the body was not seen as a sufficiently good trade off to justify the cost. 
I suspect that digest is the best hope for reasonable security in the next twelve to eighteen months. 
However work should begin now on a new standard, digest-ng. 
It should provide for message based authentication of arbitrary headers as well both public key and single key encryption. 
Connection based security mechanisms like TLS require smashing through firewalls and proxies. 
A message based mechanism would be significantly preferable for these very reasons. 
Just some thoughts, from someone working on a Saturday, Yaron 
From: John Franks[SMTP:john@math.nwu.edu] 
Sent: Tuesday, January 20, 1998 3:25 PM Subject: RE: Some comments on Digest Auth 
From: John Franks[SMTP:john@math.nwu.edu] 
It is also a good idea to embed the requestor's IP address. 
This will be broken when there is a proxy farm, each with its own IP address, and where the client chooses the particular proxy based on the URL. 
If the client chooses the proxy based on URL it will work because the URL requested without credentials (which elicits the nonce) will be the same as the URL requested with credentials. 
If the first request without credentials and the second with credentials are from different proxies, then you are right it will break. 
And the third and subsequent, with credentials, through a URL-dependent proxy, will also break. 
One thing that I would like to do, but which would conflict with a pre-delivered list of nonces, is to embed the (strong) ETag of a document in the nonce. 
This is simpler than timestamping and guarantees that a replay can only retrieve exactly the same document (which a MITM has presumably already seen when he captured the nonce.) 
Both would be good -- otherwise you can retreive the same document indefinitely into the future. 
You could only receive *exactly* the same document indefinitely into the future as any update of the document changes the ETag. 
I don't see repeatedly obtaining exactly the same document as a problem with idempotent methods like GET. 
Of course, PUT and POST are a different matter, but I don't think they have ETags. 
Actually, my comment (that both Etag and timestamp are good) was wrong. 
You can't use an Etag in the nonce, because nonces aren't per-resource. 
I do a 
GET on http://www.foo.com/bar.html, 
and get a nonce. 
I use the same nonce when I do a GET on http://www.foo.com/waz.html. 
Paul 
They certainly can be. 
This is purely an implementation decision. 
Some existing implementations work this way. 
Nothing in the spec prohibits this and I doubt if that will change. 
Incidentally, whether an implementation is stateful (e.g. remembers all nonces used) or stateless is also an implementation decision. 
I very much doubt that any consensus could be reached on a specification change which either requires the server to be stateful or prohibits it from being so. 
John Franks john@math.nwu.edu 
