The discussion at Friday's telecon reminded me why I was keen to have test case A still in. 
I've tried to raise this point a couple of times and just wanted to put it more formally. 
It is suggested that, even with untidy literals: _:a p "lit" . 
_:b p "lit" . 
entails: _:a p _:l . 
_:b p _:l . 
Consider a statement and its reification: s p "a" . 
(1) _:s rdf:subject s . 
_:s rdf:predicate p . 
_:s rdf:object "a" . 
(2) _s: rdf:type rdf:Statement. 
Does the object of statement (1) denote the same thing as the object of statement (2)? 
Given the model theory as it stands (Pat - is this right?) the answer to this question is yes. 
Now consider: jenny foo:age "10" . 
(3) film dc:title "10" . 
(4) foo:age rdfs:range xsdr:decimal . 
dc:title rdfs:range xsdr:string . 
and two reifications: _:a rdf:subject jenny . 
_:a rdf:predicate foo:age . 
_:a rdf:object "10" . 
(5) _:a rdf:type rdf:Statement . 
_:b rdf:subject film . 
_:b rdf:predicate dc:title . 
_:b rdf:object "10" . 
(6) _:b rdf:type rdf:Statement . 
Then the objects of statements (5) and (6) cannot denote the same thing as the objects of statements (3) and (4) respectively. 
I confess I find this rather bizarre. 
In the case where the object of a statement is a literal, then the value of the rdf:object property of the reification of that statement denotes a syntactic entity, otherwise it denotes a semantic one. 
(Sorry that doesn't sense to a logician, but Pat'l know what I mean.) Is that what we mean to say? 
If the answer to test case A is yes, then we need an non-entailment test: s p "a" . 
_:s rdf:subject s . 
_:s rdf:predicate p . 
_:s rdf:object "a" . 
_s: rdf:type rdf:Statement . 
where _:s is a reification of the first statement does not entail: s p _:o . 
_:s rdf:object _:o . 
Brian How are reifications of statements with blank node objects handled? 
Seems to me like the same problem (or non-problem) exists for both blank nodes and untidy literals. 
Consider s p _:x . 
if reified (e.g. by rdf:bagID) do we get _:s rdf:subject s . 
_:s rdf:predicate p . 
_:s rdf:object _:x . 
_:s rdf:type rdf:Statement. 
or _:s rdf:subject s . 
_:s rdf:predicate p . 
_:s rdf:object _:y . 
_:s rdf:type rdf:Statement. 
If the former, then it would be reasonable also to expect to have for untidy literals s p _:x"a" . 
_:s rdf:subject s . 
_:s rdf:predicate p . 
_:s rdf:object _:x"a" . 
_:s rdf:type rdf:Statement. 
But even with s p _:x"a" . 
_:s rdf:subject s . 
_:s rdf:predicate p . 
_:s rdf:object _:y"a" . 
_:s rdf:type rdf:Statement. 
there's still no problem. 
See below... 
I would agree that the two objects should denote the same thing, otherwise there would not be any true 'stating' captured by the rdf:Statement. 
Whether or not the two objects are the same syntactic node is a separate question. 
They could very well be different syntactic nodes yet still denote the same 'thing'. 
They can. 
The solution is simply to include reifications into the scope of global datatyping so that the object of the triple and the object of the reification are interpreted as having the same datatyping context. 
I.e. p rdfs:range ?d . 
s p _:x"a" . 
_:s rdf:subject s . 
_:s rdf:predicate p . 
_:s rdf:object _:y"a" . 
(note not same node) _:s rdf:type rdf:Statement. 
gives us (?d, "a") in both cases, which evaluates to the same datatype value and hence they denote the same 'thing'. 
Thus, there is no problem. 
Even with having different literal nodes in the triple and reification, their meaning is unambiguous and identical. 
If the answer to test A is 'yes', then that is a vote for tidy literals, right? 
And if literals are tidy, then there is no issue. 
If we have untidy literals, the answer to A can never be a solid yes in the absence of a global datatyping constraint for the property, as is demonstrated by your analog to test A using rdf:_N properties. 
Thus, to be absolutely sure of the meaning of an untidy literal, you must have a datatype context explicitly associated *somewhere*. 
The property alone is insufficient. 
Literal nodes without an associate datatype are like blank nodes. 
You just don't know if two such nodes denote the same thing. 
They might. 
They might not. 
Yet even so, if literals are untidy, and we extend the scope of datatyping interpretation to reification, then again, there is no need for the non-entailment test since in fact, the entailment holds since the datatyping context for both the triple and the reification is taken to be the same. 
So everything is well and good with literal objects of reifications, no matter whether we choose tidy or untidy. 
Eh? Patrick As it stands, that is correct. 
(I have to admit that I was thinking of urirefs rather than literals when I wrote it, but that is what it says even in this case.) But notice that the current MT assumes tidy literals, so case A is a non-issue: the answer has to be Yes. 
Er.... why not? 
In the current stake proposal, they all denote the string "10" (which conforms to the lexical form requirements of both xsdr:decimal and xsdr:string, so everything is fine.) Reification works OK, I think. 
What we cannot do would be to conclude from the following: _:a rdf:subject jenny . 
_:a rdf:predicate foo:age . 
_:a rdf:object "10" . 
_:a rdf:type rdf:Statement . 
_:a ex:composedBy ex:BirthdaySource . 
that the string "10" was composed by that source. 
But we couldn't say that anyway :-). 
Well, it is bizarre, but the bizarritude arises from the fact that we have made these pieces of syntax denote themselves, thereby neatly confusing the syntactic and semantic domains by putting the former into the latter. 
Again, I think this is valid in the current 'stake' proposal (for literals and urirefs). 
And if literals were semantically untidy, then any entailment from distinct literal nodes to common bnodes would be invalid. 
In other words, I don't think reification introduces any new issues. 
The issue is: If we allow untidy literal nodes, when can we assume that two literals denote the same thing? 
Answer: when they are the same *node*. 
It's the nodes that do the denoting, not the labels. 
Then it all works coherently, including reification and containers (that is, containers are weak; eg datatyping a container doesn't datatype its contents. 
But we knew that already, right?) Pat IHMC(850)434 8903 home 40 South Alcaniz St.(850)202 4416 office phayes@ai.uwf.edu 
Following on from my reply I highlight: But Brian is in the context of the f2f suggestion that the denotation of literals depends on the property and the literal, not just the literal. 
Brian: Pat: Ahh, this links up better with the f2f. 
Brian: Pat: This entailment holds for literals, and the corresponding entailment holds for urirefs. 
So if the object is a uriref or bNode we enatil: s p _:o . 
_:s rdf:object _:o . 
but if the object is a literal then we don't. 
Jeremy I'm thinking in terms of the proposal made at the f2f where literals are "untidy". 
Ah, there was more to this syntactic/semantic tidyness than i appreciated. 
So you are saying my example should have been: jenny foo:age _:l1"10" . 
(3) film dc:title _:l2"10" . 
(4) foo:age rdfs:range xsdr:decimal . 
dc:title rdfs:range xsdr:string . 
and two reifications: _:a rdf:subject jenny . 
_:a rdf:predicate foo:age . 
_:a rdf:object _:l1"10" . 
(5) _:a rdf:type rdf:Statement . 
_:b rdf:subject film . 
_:b rdf:predicate dc:title . 
_:b rdf:object _:l2"10" . 
(6) _:b rdf:type rdf:Statement . 
and all is well. 
Except: is then equivalent to n-triples: jenny age _l1:"10" . 
johnny age _l2:"10" . 
To be clear, we should rewrite test case A as the rdf/xml above because that is what folks will be writing. 
Rewritten in that way, it fails to give the desired outcome, that an rdf processor can conclude that jenny and johnny have the same age. 
Brian 
