Its simpler than it seems. 
Each insertion or removal involves incrementing or decrementing the index by one. 
That's not quite so simple, unless I'm missing something. 
You're proposing we update the index of all the listed Nodes after the insert or delete point. 
I looked at that approach. 
For insertion, it means doing a common-root search (or some equivalent thereof) between that point and all the currently listed nodes until you find the appropriate insert point in the NodeList. 
Not cheap, though it probably beats repeating the search from scratch every time you increment the index. 
You have to do this for all the currently-active NodeLists that might want to know about that portion of the tree. 
That "currently-active" phrase looks to be a disaster in Java. 
There's no architected way to terminate a NodeList, and the reference from the tree to the NodeList (required to ensure that the NodeList responds when the tree is changed) will also ensure that the latter is never garbage-collected until the tree itself goes away. 
So even if the above can be made to run quickly, it's a memory leak begging for an opportunity. 
Am I misunderstanding your suggestion, or misunderstanding the spec? 
Myrddin, 
Your idea has merit but when I did not choose trees and linked list because it is my opinion that, in most case, DOM will be used to create and access documents rather than editing. 
I do expect sporatic editing to occur but they will be limited in scope and size so that there is no need to choose implementation strategy for high performance editing over high performance access, especially enumeration. 
My strategy is to use a non-synchronized vector with modification count and have each child node caches its index position which is validated with its parent's modification count. 
Most of the time, the index will be correct so that getNextSibling is simple and fast. 
Each node's index is updated individually and on-demand to avoid scalability problem. 
Don Park CTO/Docuverse 
On 27 Jul 1998 17:52:10 -0700 steve@crc.ricoh.com 
(Stephen R. Savitzky) sent this message: 
I think that ``in practice'' depends on who is practicing what; in my opinion the advice you got was worth exactly what you paid for it. 
In a multithreaded environment (which we have in our application) with very 
large 
documents (such as a database or document store) this kind of 
implementation 
trick is unacceptable. 
snip 
I'll stand by my original statement. 
For example, consider a document derived in the obvious fashion from a table in a relational database. 
A node with several million children is not unreasonable to expect. 
If the document is ``live'', the implementor might have to query the database and obtain the entire table at each iteration. 
In the Berlin project we intend to use DOM exactly for editing text. 
In fact we are aiming at using it as the Model (in a Model/View/ Controller sense) for a standard text widget! 
I sure hope it will have better support for editing text-documents in a later level of the spec! 
Cheers ANOQ of the Sun / Johnny Andersen E-Mail: anoq@vip.cybercity.dk or anoq@berlin-consortium.org Homepage: http://users.cybercity.dk/~ccc25861/ 
