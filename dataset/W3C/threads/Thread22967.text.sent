I don't think the liveness requirement is described very carefully; It's defined very carefully, though tersely. 
A somewhat more readable description is available at http://www.w3.org/DOM/faq.html#nodelist 
if I have a node that I remove from the tree, and then add to another location, should the node be included in any NodeList objects returned from getElementsByTagName()? 
The NodeList should always look as it would if you had just requested it. 
When you remove the node, it drops out of the NodeList. 
When you insert it, it will be inserted into the NodeList IF the insertiion point is within the subtree of the node on which getElementsByTagName() was issued. 
Note that the location where it's inserted may be different from where it was removed, since the NodeList displays the nodes in document order. 
Joe Kesselman / IBM Research Well, I'm quite familiar with this section of the FAQ and it too does not address this particular issue. 
Ahh, insertion, that's a kicker. 
You say "When you insert it, it will be inserted into the NodeList IF the insertiion point is within the subtree of the node on which getElementsByTagName() was issued". 
But it also becomes necessary that the new Node match the tag named specified in the original getElementsByTagName query. 
In reference to my previously described "solution", I guess the structure that contains the list of NodeLists could host this string and be queried when an isertion is performed. 
The solution's getting more complicated though :~( Mike From:Joseph Kesselman [SMTP:keshlam@us.ibm.com] 
Sent:Wednesday, July 11, 2001 4:58 PM Subject:RE: NodeList (was RE: NamedNodeMap) I don't think the liveness requirement is described very carefully; if I have a node that I remove from the tree, and then add to another location, should the node be included in any NodeList objects returned from getElementsByTagName()? 
You gave the specific scenario of removing and reinserting a node. 
You didn't alter it between those two operations. 
Ergo, in this case, it WILL still match. 
(Actually, the only alteration you can make to an Element node's name is to change its namespace prefix, and even that is possible only if the node was generated with createElementNS.) The basic principle is that the NodeList always responds as if the query had just been issued. 
Everything beyond that is either illustration of the implications of that statement, or implementation details. 
I may already have said this, but: You might want to look at how other implementers have solved this problem. 
I believe many (most?) of us have treated the "deep" NodeList as a cache (for performance reasons), with something similar to a "dirty" flag on the tree, or mutation events, used to signal when it must be refreshed. 
That isn't necessarily the best approach, but it seems to work. 
(Note that standard DOM Level 2 mutation events won't do the job because they could be cancelled before reaching the listener. 
This is one reason "listener groups" are on the wishlist for DOM Level 3.) Joe Kesselman / IBM Research 
