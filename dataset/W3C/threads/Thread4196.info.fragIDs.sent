I have read the FTS requirements document and the use cases (http://www.w3.org/TR/xmlquery-full-text-requirements/ and to make some comments. 
First of all, I'm happy that work is proceeding in the general direction of providing more IR functionality in XQuery. 
It is dear to my heart :-) I have two comments: 
* Application of SCORE to non-text conditions. 
I believe that vagueness and uncertainty, the central issues of Information Retrieval, are vital features for systems even outside the domain of full text. 
Consider the infamous used-car database example: say the user searches for a white Lincoln Continental from 2001 with a given mileage (is that the right word? 
number of miles run by that car is what I mean) and price. 
There are no full text conditions in this example. 
Yet, what happens if there are no cars fulfilling the exact condition but only cars that are "close matches"? 
One approach would be to interpret the conditions vaguely. 
Another approach requires the user to specify another query to find those "close matches". 
However, the latter approach requires the user to know which of the query conditions to relax to find that close match, and thus requires knowledge of the contents of the database. 
Surely this is not desirable: if the user knew what's in the database, why search? 
Therefore, the "best match" approach is important also for non-text conditions. 
In the requirements document it says that the SCORE language should be either equal to the FTS language or a superset thereof. 
I couldn't find a use case where a vague interpretation is given to a non-text condition. 
I'm saying that it should be possible for the user to specify a vague interpretation for *every* query condition: wherever XQuery allows strict equality, allow vague equality, too. 
Wherever XQuery allows strict less-than, allow vague less-than, too. 
Wherever XQuery allows Boolean and, allow a vague version, too. 
And so on. 
(XQuery does not seem to allow vague conditions on the XML structure, either...) * Higher-level, semantic, search predicates. 
The use cases document talks a lot about proximity search and that the user should be able to specify various special cases: word order required or not required, number of stopwords or non-stopwords allowed between the matching terms, whether or not an element boundary is allowed, and other things. 
I think that the user really wishes to do phrase search. 
All the above specifications are just (poor) approximations on that goal. 
I don't think that the user wishes to think about the word order or the number of intervening stopwords that are allowed. 
The 
user just wants to search for "information retrieval" and find "... retrieval of information ..." but not "... retrieval. 
Information about...". 
The situation is similar to stemming: in the old days the systems had wildcards, and then it was up to the user to emulate stemming with wildcards. 
Now the FTS use cases talk about stemming, carefully sidestepping the problem of actual implementation. 
In the same vein, I suggest to talk about phrase search, and leave the implementation up to the, err, implementors. 
(Actually, you offer wildcards in addition to stemming, so I guess it's okay to offer proximity search in addition to phrase search. 
But phrase search is more important than proxmity search IMHO.) (I think the use cases document uses "phrase" to describe a sequence of words. 
I use "phrase" in a linguistic sense of, say, a noun phrase.) 
Kai A preposition is not a good thing to end a sentence with. 
I agree with you, certainly as far as the average end user is concerned. 
But the "power users", professional librarians and the like, seem to want this fine-grained control. 
Or as Winston Churchill said: this is nonsense up with which I will not put. 
Michael Kay 
Yes. I think (hope) I said elsewhere in that message that I don't want to take these capabilities out, just like wildcards are still present even though the FTS extensions allow stemming. 
The passive voice should never be used. 
Kai, These are all personal responses. 
I can't speak for Working Group. 
See inline. 
Pat Case, Librarian, LIS Interface Team Congressional Research Service Library of Congress 101 Independence Ave., SE, LM-223 Washington, DC 20540-7000 202-707-9104 pcase@crs.loc.gov 
Kai Gro?johann kai.grossjohann@uni-duisburg.de 03/22/03 04:18PM 
I have read the FTS requirements document and the use cases (http://www.w3.org/TR/xmlquery-full-text-requirements/ and to make some comments. 
First of all, I'm happy that work is proceeding in the general direction of providing more IR functionality in XQuery. 
It is dear to my heart :-) I have two comments: 
* Application of SCORE to non-text conditions. 
I believe that vagueness and uncertainty, the central issues of Information Retrieval, are vital features for systems even outside the domain of full text. 
Consider the infamous used-car database example: say the user searches for a white Lincoln Continental from 2001 with a given mileage (is that the right word? 
number of miles run by that car is what I mean) and price. 
There are no full text conditions in this example. 
Yet, what happens if there are no cars fulfilling the exact condition but only cars that are "close matches"? 
One approach would be to interpret the conditions vaguely. 
Another approach requires the user to specify another query to find those "close matches". 
However, the latter approach requires the user to know which of the query conditions to relax to find that close match, and thus requires knowledge of the contents of the database. 
Surely this is not desirable: if the user knew what's in the database, why search? 
Therefore, the "best match" approach is important also for non-text conditions. 
In the requirements document it says that the SCORE language should be either equal to the FTS language or a superset thereof. 
I couldn't find a use case where a vague interpretation is given to a non-text condition. 
I'm saying that it should be possible for the user to specify a vague interpretation for *every* query condition: wherever XQuery allows strict equality, allow vague equality, too. 
Wherever XQuery allows strict less-than, allow vague less-than, too. 
Wherever XQuery allows Boolean and, allow a vague version, too. 
And so on. 
(XQuery does not seem to allow vague conditions on the XML structure, either...) [Pat Case: I too would like to see score applicable to all XQuery.] * Higher-level, semantic, search predicates. 
The use cases document talks a lot about proximity search and that the user should be able to specify various special cases: word order required or not required, number of stopwords or non-stopwords allowed between the matching terms, whether or not an element boundary is allowed, and other things. 
I think that the user really wishes to do phrase search. 
All the above specifications are just (poor) approximations on that goal. 
I don't think that the user wishes to think about the word order or the number of intervening stopwords that are allowed. 
The user just wants to search for "information retrieval" and find "... retrieval of information ..." but not "... retrieval. 
Information about...". 
The situation is similar to stemming: in the old days the systems had wildcards, and then it was up to the user to emulate stemming with wildcards. 
Now the FTS use cases talk about stemming, carefully sidestepping the problem of actual implementation. 
In the same vein, I suggest to talk about phrase search, and leave the implementation up to the, err, implementors. 
(Actually, you offer wildcards in addition to stemming, so I guess it's okay to offer proximity search in addition to phrase search. 
But phrase search is more important than proximity search IMHO.) (I think the use cases document uses "phrase" to describe a sequence of words. 
I use "phrase" in a linguistic sense of, say, a noun phrase.) 
[Pat Case: Please remember that a phrase query is a proximity query (ordered, allowing no intervening words). 
Also remember we are defining the functionalities which will be available for implementors. 
We don't expect most end users to define the 
parameters for a proximity query, but we do expect them to profit from 
proximity querying. 
We expect implementors to build GUIs which utilize proximity queries. 
For example, a system may take any search terms in the Words search box and return them in any order within 9 words of each other, then offer a More button which might use an "and" operator. 
Or the implementors might build queries under buttons or links. 
The functionality has to be there so we can develop GUIs for end users. 
And yes, I do want the functionalities to surface for the small number of expert users who can use them. 
I do not emphasize phrase querying because I think it is as dangerous 
as "or" querying is useless. 
I advise end users to do wider unordered 
proximity queries instead. 
In a system which supports phrase query I would build a More button that runs a wider unordered proximity query to 
pick up the missed results. 
My favorite example is in the internal system I work on for congressional documents. 
Folks search on "elementary education" and find very little. 
It is a reasonable query 
but it fails because congressional bills almost exclusively carry the 
phrase "elementary and secondary education". 
Allow a few intervening characters and hundreds of bills are returned.] 
Kai A preposition is not a good thing to end a sentence with. 
I'm currently not very active in full-text, but I wanted to offer my thoughts on this. 
This has come up a number of times. 
Here's my opinion: the semantics of "close match" for a structure can be highly application-dependent, and it's not clear to me whether there is an approach to approximate structural match that will work at all well across a variety of structures from different application areas. 
For instance, in this case, is a car a close match if the price is too high, or is that an absolute criterion for the user? 
To get useful results, it may be the case that the user really does need to let us know, in some way, which criteria to relax. 
There may be literature or products that tell us that we actually know how to do this well in the general case - do you know of any that we might want to look at? 
Jonathan 
Jonathan, I can point out to a preliminary research work in which we focused on approximating structure in XML. 
There are several other works (2 of them pblished at the same conference) and many others including Grossjohann's work. 
Sihem Amer-Yahia, SungRan Cho, Divesh Srivastava: Tree Pattern Relaxation, in EDBT 2002. 
It is available from my webpage www.research.att.com/~sihem 
Please, follow the publications pointer. 
I also have presented a tutorial on Approximating XML Queries in the last ICDE 2003. 
The slids will be available this week on my webpage. 
Thanks Sihem 
Kai, 
From where I sit, the first thing we need is full-text querying in XQuery encompassing functionalities which currently exist. 
As a librarian and expert searcher, I find even stemming algorithms fail me often enough that I want to retain the crude, but totally controllable predictable wildcards. 
I build better queries with wildcards then I can with stemming, because stemming doesn't allow me to 
decide which related words to include on a word by word basis. 
Just because it is linguistically related doesn't mean it returns the results 
I want. 
Stemming is black box which works against expert searchers as 
often as it work for them. 
We feel the same about scoring and ranking. 
Different users benefit from different tools. 
I wouldn't expect a novice user to use wildcards or to be so annoyed with scoring and ranking. 
Which doesn't mean I wouldn't welcome the likes of a linguistic parser. 
It would be a boon to all end users. 
Are you recommending we add a use 
case which calls an implementation-defined linguistic parser (as we did 
for stemming) or are you recommending more than that? 
Pat 
Kai Gro?johann kai.grossjohann@uni-duisburg.de 03/24/03 01:14PM 
IMHO this is an unnecessary limitation. 
In the following I will say "linguistic phrase search" when talking about the operation I mean, to avoid confusion with the FTS document. 
the 
from 
Proximity querying is a good thing, but linguistic phrase search is even better :-) -- at least for some common use cases. 
(Just like wildcards are a good thing, but often, stemming is even better.) 
dangerous 
unordered 
to 
query 
the 
If you have a linguistic parser that recognizes that "elementary and secondary education" is the same as "elementary education and secondary education", then you don't need kludges such as proximity search to correctly find the linguistic phrase "elementary education". 
So by focussing on the ordered/unordered proximity search with various constraints, system containing a linguistic parser are left standing in the rain. 
My suggestion is to imagine what does the user want to do, semantically, and then define search predicates that capture this idea. 
Then it is left to the implementor (of the XQuery processing engine) to decide how to do it. 
Of course, it's possible to recognize that linguistic parsers are not common in text retrieval systems yet, and to include some other search predicates to accomodate for this fact. 
But why let the standards definition be influenced by what current systems do? 
The FTS definition has successfully made the step from the syntactic level (wildcards) to the semantic level (stemming) in one case -- normalization of derived forms. 
I am suggesting to make this very same step in other cases, as well: searching for (linguistic) noun phrases (perhaps other kinds of phrases), searching for similarly-sounding words (Soundex is only one algorithm for this), accomodating for OCR errors or typos (the Damerau-Levenshtein metric is one approach), searching for similar dates, searching for similarly-looking colors, and so on. 
Note that the FTS document does not say how to implement stemming. 
So I don't expect that a similar lack of specification how linguistic phrase search will be implemented is a problem. 
I think that I'm having problems to express the ideas in my mind. 
I hope you can understand them even though the expression is clumsy. 
A preposition is not a good thing to end a sentence with. 
Thank you for the education. 
I'm not an expert searcher, it never occurred to me that stemming could be a problem in this way. 
It is very close. 
I am suggesting to add a use case which does "linguistic phrase search" and leave it to the implementation whether they use a linguistic parser or map it to proximity search or they ask the Oracle of Delphi. 
A preposition is not a good thing to end a sentence with. 
Dear Kai, while I see this as a use case, please note that the use case document also serves as a way for the working group to define what use cases it currently investigates for its current version of the language design. 
That means that certain use cases may be beyond the scope of the current version. 
Best regards Michael 
From: Kai Gro?johann [mailto:kai.grossjohann@uni-duisburg.de] Sent: Monday, March 24, 2003 13:05 PM Subject: Re: FTS comments 
Kai, I will propose adding such a use case and build it if the group wants to add it. 
Pat 
Kai Gro?johann kai.grossjohann@uni-duisburg.de 03/24/03 04:04PM 
to 
results 
as 
ranking. 
Thank you for the education. 
I'm not an expert searcher, it never occurred to me that stemming could be a problem in this way. 
parser. 
use 
did 
It is very close. 
I am suggesting to add a use case which does "linguistic phrase search" and leave it to the implementation whether they use a linguistic parser or map it to proximity search or they ask the Oracle of Delphi. 
A preposition is not a good thing to end a sentence with. 
The situation is quite the same as a full-text query where the user has entered, say, ten words. 
Which of the words is most important? 
It's the same problem. 
One way to approach it is to provide a weighted-sum operator in the query language (that's what we did for XIRQL). 
Then users can say 0.3 * color=red + 0.7 * price 10,000; or they can swap the coefficients. 
(This example was not intended to conform to any particular syntax, I hope you can understand what I meant.) Another way to approach it is to use what IR people would call idf: suppose that there is only one red car in the whole collection. 
Then maybe it should come out first even if it violates the price condition. 
(One red car in the whole collection == low "document frequency" == high "inverse document frequency".) Still another way to approach it is to use relevance feedback: using the weighted sum operation, we guess some coefficients and present results to the user. 
The user tells us which cards he likes. 
We use that information to tune the coefficients. 
(Relevance feedback for fact conditions is still an open research issue, AFAIK. 
Maybe if the user consistently marks convertibles as being highly interesting, then we should introduce a new condition into the query, asking for convertibles?) Maybe I should make one thing explicit: I am not thinking about a Boolean point of view. 
Maybe you consider a car to be red or not red, and that's it. 
For me, it's more or less red. 
(This is a somewhat silly example, but you could include color similarities, then it would make more sense. 
And for other conditions such as price 10,000 it's clear that the condition can be fulfilled to different degrees.) So for each of the basic query conditions (let's consider color=red and price 10,000 as the basic conditions) there is a degree of it being fulfilled, and these degrees are then combined. 
Fuzzy logic aficionados say that any car belongs to the result set in a lesser or higher degree, friends of probabilities (I'm one of them) say that there is a lower or higher probability of the car being relevant to the information need of the user. 
But as long as there is a number of some kind that can be interpreted as the score or degree or probability, then I'll be happy :-) A preposition is not a good thing to end a sentence with. 
The situation is quite the same as a full-text query where the user has entered, say, ten words. 
Which of the words is most important? 
It's the same problem. 
One way to approach it is to provide a weighted-sum operator in the query language (that's what we did for XIRQL). 
Then users can say 0.3 * color=red + 0.7 * price 10,000; or they can swap the coefficients. 
(This example was not intended to conform to any particular syntax, I hope you can understand what I meant.) Another way to approach it is to use what IR people would call idf: suppose that there is only one red car in the whole collection. 
Then maybe it should come out first even if it violates the price condition. 
(One red car in the whole collection == low "document frequency" == high "inverse document frequency".) Still another way to approach it is to use relevance feedback: using the weighted sum operation, we guess some coefficients and present results to the user. 
The user tells us which cards he likes. 
We use that information to tune the coefficients. 
(Relevance feedback for fact conditions is still an open research issue, AFAIK. 
Maybe if the user consistently marks convertibles as being highly interesting, then we should introduce a new condition into the query, asking for convertibles?) Maybe I should make one thing explicit: I am not thinking about a Boolean point of view. 
Maybe you consider a car to be red or not red, and that's it. 
For me, it's more or less red. 
(This is a somewhat silly example, but you could include color similarities, then it would make more sense. 
And for other conditions such as price 10,000 it's clear that the condition can be fulfilled to different degrees.) So for each of the basic query conditions (let's consider color=red and price 10,000 as the basic conditions) there is a degree of it being fulfilled, and these degrees are then combined. 
Fuzzy logic aficionados say that any car belongs to the result set in a lesser or higher degree, friends of probabilities (I'm one of them) say that there is a lower or higher probability of the car being relevant to the information need of the user. 
But as long as there is a number of some kind that can be interpreted as the score or degree or probability, then I'll be happy :-) A preposition is not a good thing to end a sentence with. 
I think the challenge will be to come up with a spec small enough and simple enough that it can be reviewed, understood, implemented and tested, yet large enough to be useful, and extensible enough that the sort of features you describe can be added in later versions, or by individual implementations. 
And to do so in under five years :-) 
I understand that this is a problem. 
But I think that you might have to try to work around this problem to a certain extent. 
I think it comes from the point of view that a standard for a query language must define completely a function that, given a query and a set of database records (or XML documents), produces a set of results. 
I believe that this just won't work for Information Retrieval: in Information Retrieval, the exact result set is a distinguishing criterion between systems! 
Some IR systems have better retrieval quality than others, because they compute different result sets. 
So you need to find a way to craft a meaningful spec WITHOUT prescribing the exact result set. 
One example to support this view: you say that it might become necessary to specify a stemming algorithm before FTS becoms a standard. 
But in some languages, it is not feasible to do stemming algorithmically (like the Porter stemmer does for English) -- dictionary-based approaches are needed. 
I think the consequences of this for prescribing the stemming algorithm are obvious. 
In the same vein, it's clear that linguistic phrase search is a useful feature, but it's totally unclear how to implement it. 
And different systems will compute different results, and this will be a discriminating factor between systems. 
Therefore you need to write a standard that says "there shall be linguistic phrase search" *without* prescribing the exact results. 
And the above are just examples. 
Besides stemming and (linguistic) phrase search, there will be many other places where the standard can't prescribe the results. 
It will be the norm, rather than the exception. 
That is my opinion, at least. 
A preposition is not a good thing to end a sentence with. 
1. As I mentioned in a separate mail, the use cases should encompass functionality that the consensus in the WG considers to be important for discussion for the first version more than giving a repository of all possible use cases in the area of information retrieval. 
2. Your use case of application of SCORE to non-text conditions is captured in the requirements document mainly for allowing researchers, vendors and at some point in time the WG to add such functionality. 
I personally consider that to be an important use case in the future, but do not see it as an important feature for this release and thus having it as part of the use cases seems a bit premature. 
Nobody is asking you to save the whole world in two days :-) I'm just saying that there are two important fields, DB and IR. Doing querying on XML documents, for me, is half IR and half DB. But the current XQuery effort appears to be something like 0.1 IR and 0.9 DB. 
If things stay this way, then XQuery will become something that is useful for the DB community, but it won't be useful for the IR community. 
People who want to build an IR system for XML documents won't be able to use XQuery as the standard, not even with the currently discussed FTS features. 
There was a panel discussion during the XML-IR workshop at the SIGIR 2002 in Tampere, and the impression I got was that the XQuery effort is not currently useful for IR and that folks are eager to help out, if only they were asked. 
I'm just a lowly PhD student who should rather be working on his thesis. 
But I had the urge to go out and wave the IR flag at least a little bit, to do what little I can. 
(I'm dreaming of a probabilistic version of XQuery but will have to settle for a probabilistic version of XPath, and that will be quite incomplete. 
But it is going to include vagueness and uncertainty as central concepts, in all parts of XPath. 
I don't even dare dreaming of a probabilistic RDF (yet?).) If you say that XQuery/FTS needs its first version soon, then maybe the way to go is to ask some IR folks to make sure you're not preventing XQuery from being developed in the general direction of IR later on. 
Then you can save the big discussion for XQuery/FTS version 2. Thank you for listening. 
A preposition is not a good thing to end a sentence with. 
