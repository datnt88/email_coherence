the spreadsheet format is great, but will it include the glossary of footnote resolutions? 
as that is likely to be perpetually evolving as well. 
My remarks in the Internet-Draft about using a spreadsheet were not intended to describe a form directly available to "users". 
What I wrote was: The use of a spreadsheet would allow separate editing of the requirements summary, followed by semi-automatic insertion into the master copy of the HTTP/1.1 specification. 
I.e., it would be a convenience for the editorial process of the HTTP/1.1 specification. 
It might also allow semi-automatic extraction of subset requirements application to specific kinds of implementations. 
which I suppose could be useful to people who are trying to generate application-specific subsets of the requirements summary. 
However, since this requirements summary is not meant to be used independently of the formal specification (and anyone who tries to use it independently will get no sympathy from me!), I don't think it makes sense to try to make it entirely self-contained. 
I.e., don't expect to see the glossary of footnotes included in any spreadsheet representation. 
-Jeff 
Here is a question arising from the interoperability test. 
If a server receives a byte range requests for a 100 byte file like a) Range: bytes = 0-10, 130-140 or b) Range: bytes = 30-20 or c) Range: bytes = 0-10, 30-20, 40-50 what is the correct response? 
In case a) one of the two ranges is invalid, but the spec says send a 416 only if *all* are invalid. 
If the valid ones are returned with a 206 then there is no way to signal an error. 
In case b) the spec says If the last-byte-pos value is present, it must be greater than or equal to the first-byte-pos in that byte-range-spec, or the byte-range-spec is invalid. 
The recipient of an invalid byte-range-spec must ignore it. 
If the server ignores it then it should send what? 
Case c) is like b) except it is possible to send the valid ranges. 
John Franks john@math.nwu.edu 
And another one I forgot: rom section 14.17 A server sending a response with status code 416 (Requested range not valid) SHOULD include a Content-range field with a content-range-spec of "*". 
What is the purpos of this? 
BUT 10.4.17 says about status 416: When this status code is returned for a byte-range request, the response MUST include a Content-Range entity-header field specifying the current length of the selected resource (see section 14.17). 
I don't think '*' specifies the length. 
On the other hand I see no way to make a Content-Range header which would be legal and would specify the length. 
Maybe what is needed is to allow something like Content-Range: bytes *-*/200 when an illegal range (like 300-400) has been requested from a 200 byte file. 
John Franks john@math.nwu.edu 
From section 14.17 A server sending a response with status code 416 (Requested range not valid) SHOULD include a Content-range field with a content-range-spec of "*". 
What is the purpos of this? 
BUT 10.4.17 says about status 416: When this status code is returned for a byte-range request, the response MUST include a Content-Range entity-header field specifying the current length of the selected resource (see section 14.17). 
I don't think '*' specifies the length. 
On the other hand I see no way to make a Content-Range header which would be legal and would specify the length. 
What happened here is that I drafted the revised language and BNF too quickly, and screwed up. 
Maybe what is needed is to allow something like Content-Range: bytes *-*/200 when an illegal range (like 300-400) has been requested from a 200 byte file. 
In fact, what we had intended to specify was something very much like that, except that we meant to have: Content-Range: bytes */200 So, here's another stab at this - hopefully, correct this time. 
(But, unlike the last time, maybe someone should else review what I wrote?) (1) The BNF in 14.17 should be: Content-Range = "Content-Range" ":" content-range-spec content-range-spec = byte-content-range-spec byte-content-range-spec = bytes-unit SP byte-range-resp-spec "/" ( entity-length | "*" ) byte-range-resp-spec = (first-byte-pos "-" last-byte-pos) entity-length = 1*DIGIT (2) The following four paragraphs should read: The asterisk "*" character in an entity-length means that the entity-length is unknown at the time when the response was generated. 
Unlike byte-ranges-specifier values, a byte--range-resp-spec may only specify one range, and must contain absolute byte positions for both the first and last byte of the range. 
A byte-content-range-spec with a byte-range-resp-spec whose last-byte-pos value is less than its first-byte-pos value, or whose entity-length value is less than or equal to its last-byte-pos value, is invalid. 
The recipient of an invalid byte-content-range-spec MUST ignore it and any content transferred along with it. 
A server sending a response with status code 416 (Requested range not valid) SHOULD include a Content-range field with a byte-range-resp-spec of "*". 
The entity-length specifies the current length of the selected resource. 
A response with status code 206 (Partial Content) MUST NOT include a Content-range field with a byte-range-resp-spec of "*". 
-Jeff 
If a server receives a byte range requests for a 100 byte file like a) Range: bytes = 0-10, 130-140 or b) Range: bytes = 30-20 or c) Range: bytes = 0-10, 30-20, 40-50 what is the correct response? 
In case a) one of the two ranges is invalid, but the spec says send a 416 only if *all* are invalid. 
If the valid ones are returned with a 206 then there is no way to signal an error. 
In case b) the spec says If the last-byte-pos value is present, it must be greater than or equal to the first-byte-pos in that byte-range-spec, or the byte-range-spec is invalid. 
The recipient of an invalid byte-range-spec must ignore it. 
If the server ignores it then it should send what? 
Case c) is like b) except it is possible to send the valid ranges. 
I think the confusion here arises because, when I drafted this part of the spec, I failed to make a clear distinction between "syntactically invalid" byte-range-specs, and what I probably should have called "unsatisfiable" byte-range-specs. 
A "syntactically invalid" byte-range-spec is one for which there are no circumstances in which it would ever be valid. 
E.g., "bytes = 30-20" and "bytes = 10-20-30" are both syntactically invalid byte-range-specs. 
Basically, this is a coding bug in the client. 
An "unsatisfiable" byte-range-spec is one that is syntactically valid, but which cannot be satisfied (even partially) given the current state of the resource. 
The fact that the client made such an unsatisfiable request might not be the result of a coding bug; it might just be because the client's information about the resource's current length is either out-of-date or "optimistic". 
Note that some of this terminology already appears in section 14.17, but it isn't used consistently in the entire document. 
The philosophy behind the entire byte-range design is that requests that have "syntactically invalid" byte-range-specs should be treated as buggy, and the server should simply ignore the Range header and treat the request just as it would have treated a regular GET without the buggy Range. 
However, when a request contains a Range header which is syntactically valid, the server should provide as much as it can to the client, consistent with the request. 
That means that if any of the byte-range-specs are even partially satisfiable, then the server should send a 206 (Partial content) response; if none of the byte-range-specs are satisfiable, then the server should return a 416 response. 
This is basically an application of the Robustness Principle ("be conservative in what you send, be liberal in what you accept"). 
However, I have a problem with section 10.4.17, 416 Requested range not found. 
The helpful hint, "(For byte-ranges, this means that the first-byte-pos of all of the byte-range-spec values were greater than the current length of the selected resource.)" is incorrect. 
The byte-range-spec "30-20" (as in (b) above) is invalid, but the first-byte-pos is valid. 
I think the "helpful hint" is accurate if you treat 416 as meaning "Requested range not satisfiable" rather than "Requested range not valid". 
(1) Section 10.4.17 416 "Requested range not valid" should be retitled "Requested range not satisfiable", and in section 6.1.1, the BNF for Status-Code should be changed from 
"416" ; Requested range not valid 
to 
"416" ; Requested range not satisfiable 
This name change should also be applied at three places in section 14.17 where this status code is mentioned. 
(2) In section 14.36.1 Byte Ranges, change If the last-byte-pos value is present, it must be greater than or equal to the first-byte-pos in that byte-range-spec, or the byte-range-spec is invalid. 
The recipient of an invalid byte-range-spec must ignore it. 
to If the last-byte-pos value is present, it must be greater than or equal to the first-byte-pos in that byte-range-spec, or the byte-range-spec is syntactically invalid. 
The recipient of a byte-range-set that includes one or more syntactically invalid byte-range-spec values MUST ignore the header field that includes that byte-range-set. 
(3) Also in section 14.36.1 Byte Ranges, before the paragraph that starts "Examples of byte-ranges-specifier values ...", insert this paragraph: If a syntactically valid byte-range-set includes at least one byte-range-spec whose first-byte-pos is less than the current length of the entity-body, or at least one suffix-byte-range-spec with a non-zero suffix-length, then the byte-range-set is satisfiable. 
Otherwise, the byte-range-set is unsatisfiable. 
If the byte-range-set is unsatisfiable, the server SHOULD return a response with a status of 416 (Requested range not satisfiable). 
Otherwise, the server SHOULD return a response with a status of 206 (Partial Content) containing the satisfiable ranges of the entity-body. 
-Jeff 
That's much clearer. 
But I think it's backward. 
I think 416 should mean the request (and therefore the client) is buggy. 
And if none of the ranges are satisfiable, return everything (pretend there's no Range header). 
I think it's a little strange to return an error if the Range header was well-formed and ignore Range if it's ill-formed. 
Dave Kristol 
I also think this clears up the meaning. 
Thanks. 
But I would like to see 416 returned if the request is either syntactically incorrect or unsatisfiable. 
I agree with Dave that it is strange to ignore a syntactically incorrect header. 
It is unlikely to be helpful to the (buggy) client. 
Indeed, to the user it might well look like the server is buggy. 
I much prefer for the server to announce definitively, "Hey, your client screwed up!" 
But it also makes sense to communicate the correct length of the resource when the client has somehow misjudged it. 
So an error message for an unsatisfiable request is a good idea. 
John Franks john@math.nwu.edu 
But I would like to see 416 returned if the request is either syntactically incorrect or unsatisfiable. 
I agree with Dave that it is strange to ignore a syntactically incorrect header. 
It is unlikely to be helpful to the (buggy) client. 
Indeed, to the user it might well look like the server is buggy. 
I much prefer for the server to announce definitively, "Hey, your client screwed up!" 
It might seem strange to ignore a syntactically incorrect header, but there are plenty of other HTTP headers that could be sent with incorrect syntax, and the HTTP/1.1 spec says nothing at all about what to do. 
For example, what does the server return for GET /home.html 
HTTP/1.1 Host: foo.com If-Modified-Since: cheeseburger or GET /home.html 
HTTP/1.1 Host: foo.com Accept-Encoding: Tue, 04 Nov 97 17:04:50 GMT The specification for the 400 (Bad Request) status code says 10.4.1 400 Bad Request The request could not be understood by the server due to malformed syntax. 
The client SHOULD NOT repeat the request without modifications. 
but it's not clear if the examples above are "could not be understood" by a server. 
I tried sending "If-Modified-Since: cheeseburger" in an HTTP/1.0 request to www.apache.org; it ignored the malformed header, and sent me a status-200 response. 
So, based as before on the Robustness Principle, and especially given the general lack of definitive statements about this kind of problem in the HTTP/1.1 spec, that we're better off with servers ignoring malformed non-mandatory headers, rather than sending status-400 responses. 
And I certainly think it's a mistake to use the same response code to mean both "your code is buggy" and "your code is fine, but your cache is out of date". 
The latter implies that the client might take some automated action to recover; the former implies that the client should probably not try to do an automatic recovery. 
-Jeff 
That gets to my point, which John Franks didn't quite get right. 
My remark was, Why send a 416 in response to a well-formed header (whose byte-range-spec is unsatisfiable), but respond with 200 to a malformed header? 
Why the distinction, in other words? 
The Robustness Principle would argue against the 416 response, too, wouldn't it? 
Surely the Content-Length or equivalent would be enough to clue the recipient that the byte-range-spec was unsatisfiable. 
Dave Kristol 
My remark was, Why send a 416 in response to a well-formed header (whose byte-range-spec is unsatisfiable), but respond with 200 to a malformed header? 
Why the distinction, in other words? 
The Robustness Principle would argue against the 416 response, too, wouldn't it? 
Surely the Content-Length or equivalent would be enough to clue the recipient that the byte-range-spec was unsatisfiable. 
Not quite. 
Content-Length is defined (section 14.14) this way: The Content-Length entity-header field indicates the size of the message-body, in decimal number of octets, sent to the recipient or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET. 
For a GET request with an unsatisfiable Range request-header, the message-body is clearly NOT going to have the same length as the "full entity-body", and so we needed a different mechanism. 
I suppose we could have used a 206 response with this kind of thing: Content-Range: */200 but it was feared that this would break already-deployed implementations that "knew" how to parse a 206 response. 
Maybe this fear was groundless. 
-Jeff P.S.: In case anyone wishes to point out that the term "full entity-body" in 14.17 is confusing: I agree. 
18 months ago, the HTTP editors group had a long argument over how to define the meaning of the word "entity"; I was on the losing side. 
We ended up with no term defined to mean "the content that would be returned right now with a status-200 response for the request". 
Don't complain to me. 
