Peeps, For the telcon tomorrow, please try to glance at version 1.40, or higher, of which I have just checked in. 
Some of the notable changes include rewording several requirements, including some we seem to have reached some consensus about recently. 
I've also included a more complete Design Objectives section, which includes 6 or 7 requirements that have some support. 
I've also started working on a set of technical terms for our design space, to be included in an eventual glossary. 
I don't expect that will necessarily live in the pub'd draft of UC&amp;R, but I'd like to keep them there for now as a reminder to myself and to others, as a way of trying out new terms, and because I don't want to start another doc just yet. 
: Best, Kendall Clark PS--I've been having mail troubles lately (that is, I've go entirely too much mail!); thus, if you review 1.40 and don't see something you were expecting to see, the most prudent course of action is to email me directly with your question, comment, or patch. 
Kendall, OK - will do. 
And thanks fo rpointing out the areas of change. 
Have there been significant changes to the Use Cases? 
I'll take a complete look at it tomorrow before the telecon but I did notice that the title to "3.1 Multiple Triple Matching" has got out of step with the text and is not discussed in email. 
The title in the agenda is "Multiple RDF triple matching" The requirement title might be better as "RDF Graph Matching" to match (sic) the text change to graph patterns as of 0269. 
"RDF Graph" is a defined term in the RDF concepts. 
(Well - it shows I've looked at the new draft at least!) Andy Peeps, For the telcon tomorrow, please try to glance at version 1.40, or higher, of which I have just checked in. 
Some of the notable changes include rewording several requirements, including some we seem to have reached some consensus about recently. 
I've also included a more complete Design Objectives section, which includes 6 or 7 requirements that have some support. 
I've also started working on a set of technical terms for our design space, to be included in an eventual glossary. 
I don't expect that will necessarily live in the pub'd draft of UC&amp;R, but I'd like to keep them there for now as a reminder to myself and to others, as a way of trying out new terms, and because I don't want to start another doc just yet. 
: Best, Kendall Clark PS--I've been having mail troubles lately (that is, I've go entirely too much mail!); thus, if you review 1.40 and don't see something you were expecting to see, the most prudent course of action is to email me directly with your question, comment, or patch. 
No. Well, those are *titles*, names, really, which means (in my mind, at least) that shorter is better than longer. 
I like "Triple" and "RDF Triple" are exactly equivalent in most cases in this document, certainly in titles. 
That is, I prefer the shorter title and don't consider it out of phase with the text. 
(But I'm open to being convinced that this is wrong...) Hmm, yes, that's more convincing; though I think "Graph Pattern Matching" ("...by providing a graph pattern...") is better. 
Any thoughts on that? 
Kendall Hmm... looking at the diff (attached), I see some, but not a lot. 
Dan Connolly, W3C http://www.w3.org/People/Connolly/ see you at the WWW2004 in NY 15-21 May? 
Doh! "like" above should have been "think". 
Kendall I couldn't find significant comments re: use cases since last time, nor did I receive any new use cases via mail or see any on the list other than Bryan's, and I spoke with him directly about his. 
I'm pretty happy with the UCs as they are, except for one or two places that need to be fleshed out, so I've been concentrating on the requirements, design objectives, and on fleshing out some of the bits of connective tissue here and there. 
I hope that reflects the sense of the group? 
Kendall From: Kendall Clark mailto:kendall@monkeyfist.com Date: 10 May 2004 21:20 Only that we ought to follow the terminology set up in: Which talks of "RDF Triples" and "RDF Graph", especially as an RDF graph isn't the general graph found in elsewhere graph theory (e.g. graph must have at least one arc; RDF triples don't have literal subjects or bNodes for predicates). 
"RDF Graph Pattern Matching" is OK. v1.46 looks in good shape, especially the text for UCs which is fairly stable. 
== Section 1. Introduction Para 2/end: Not sure what the "domain specific semantics" refers to. 
Para 3: Suggest: There are also a variety of approaches for accessing remote RDF data. 
Even when the basic protocol ... == Section 2. Use Case [[[ http://www.w3.org/2001/sw/DataAccess/UseCases#uc 3. Use cases Each use case describes a concrete application of future technology recommendation, setting a user-oriented context in which the query language or protocol or both are used to solve a real problem. 
We were going to have text more like the OWL requirements doc: [[[ http://www.w3.org/TR/2004/REC-webont-req-20040210/ one should not assume that OWL will directly support every aspect of the use cases. 
that made it clear we are not completely solving the use cases but providing technology for them. 
== 2.3: Finding Unknown Media Objects "Smiley uses his web browser to establish a query" reads awkwardly to me; I don't know what establishing a query is. 
Suggest something like: "Smiley's web client has a UI for setting up queries to be executed regularly." 
== 2.5: Avoiding Traffic Jams "Using his cell phone, Neil asks his car" hints at a voice interface (which, in a car, it should be if he's driving!). 
Could make it framed more in setting up things before he drives off as voice interaction is not in our scope so the focus is more on out bit? 
== 2.8: Sharing Vacation Photos has a [XXX:finish]. 
Just noting it to make sure it does not get forgotten. 
== 2.9: Fining Input and Output Documents for Test Cases. 
Seems to have lost the bit about filtering only for test cases with status of "approved". 
Last sentence is a remnant from having benefits with use cases. 
Para 2: s/process of the/process the/ == Section 3: Candidate requirements For publishing, should we have a one line note in each requirement to say what's adopted and what's not. 
Or a list of adopted ones. 
"Mandatory" - This is an intermediate published draft so maybe "expected to be" to give the WG a chance to find out that some things do not work well together. 
== 3.6: Optional Match Instead of "optional triples", I would prefer to talk about an optional part of the graph pattern so as to be more neutral to optional triples and/or may-bind variables. 
My attempt was: Which doesn't talk about triples until the second sentence. 
Also "named part of the query" implies labeling of query parts. 
Suggest "identified" or "nominated" or "marked". 
== 3.9 Bandwidth-efficient Protocol == 3.10 Result Limits These will be important features of our recommendation. 
Given the framing of section 4, "design objectives", they seem to fit better there because they are not quantifiable. 
That would still acknowledge that they are important design objectives alongside a readable syntax. 
== 4.5 Multigraph Query I have difficulty with this one because of the ambiguity. 
I don't oppose query on multiple graphs (independently) then merging the results. 
I can't support merging the graphs and getting the results of a query over the merged result. 
Either it is query routing or it is building potentially large intermediate graphs from unrelated sources - while it might make sense when the two source are close, it does not across the web in general. 
For the latter, creating an explicit merge of the two datasets and querying that does not require any support from our work. 
Its just aggregation which is a potential point in the business value chain. 
1.47 takes account of most of these (a few I think are fine as-is or want to wait to here from others). 
I've bitten the bullet on this one and chosen the "aggregate query" option, that is, querying multiple graphs independently and merging the results. 
Thus, I've renamed it from multigraph query to aggregate query. 
I still think my cell phone FOAF-RSS example is dispositive, but I guess I'm the only one. 
: Anyway, version 1.47 should be available now. 
Kendall Thanks Kendal for the new version. 
The document looks like it is really coming together. 
Here are some comments on 1.47. 
Please be patient if some of my comments are not accurate due to my being a newbie and misunderstanding something. 
Comments on Use Cases: -We should be consistent and explicit to mention RDF store when talking about knowledge bases in use cases. 
Some use cases do (2.1, 2.4, 2.5, 2.7, 2.8, 2.9) and some dont (2.2, 2.3). 
-In Use case 2.2 (Motorcycle parts) there is no clear link between manufacturer's parts database an the Endeavour parts database. 
Suggest replacing "manufacturer's parts database" with "Endeavor's parts database" -2.6 Discovering What People Say about News Stories (Publishing) Not clear why the use case talks about multiple query languages. 
Is multiple query languages a goal of DAWG. 
Is the idea that DAWG describes one abstract syntax with one or more concrete bindings and the multiple query languages map to multiple bindings of DAWG? 
-2.7 Exploring the neighborhood This use case verbiage could be simplified. 
Suggest alternate wording: Jose wants to find out the latitude, longitude, name, and type of everything within 1 mile of the hotel in Washington D.C. where he is staying so that he can plan his meals and sightseeing time accordingly. 
The U.S. Census Bureau provides interesting geographic data in its new RDF database. 
Jose sends a query to the Census Bureau's new RDF database and requests that the results be passed to an XSLT transformation service so that he can print the resulting XHTML. 
Comments on Requirements: 3.2 Variable Binding Result This one I find is difficult to parse and understand. 
Archive search is not helping. 
Can someone provide an example and clearer description of the requirement? 
Thanks. 
3.3 Extensible Value Testing Suggest changing "to extensibly calculate with and test values" to "to calculate and test values in an extensible manner". 
3.4 Subgraph Results Prefer wording of 3.4 compared to 3.4a. 
I seem to grok it better. 
3.6 Option Match Suggested re-wording based on my limited understanding.... 
It must be possible to express a query with optional parts such that the query does not fail to match when one or more optional parts of the query fails to match. 
Any such triples matched by this optional part, or variable bindings caused by this optional part, can be returned in the results, if requested. 
3.10 Result Limits I think this requirement should be replaced with a requirement for a database cursor like requirement. 
This is essential for scalability according to my experience with ebXML Registry etc. Suggested wording is.... 3.10 Iterative Query Support The query language or protocol must be able to handle large result sets of any size by iterating over the result set and fetching it in chunks. 
Thats all for now. 
Regards, Farrukh Cursors are explictly utside the charter: but this seems reasonable and does not require cursors, per se. 
To me the important distinction is that cursors require sone inter-query state, whereas limit and offset are explictly coded into the query. 
- Steve No, this UC is meant to motivate requirements that the data access protocol be able to transport RDF query languages other than the one we design. 
That is, the multiple query languages here are some subset of the 20 or so existing RDF query languages. 
Thanks, Farrukh, for the comments. 
I have used some of yr suggestions, and deferred others till I have a better sense of the group. 
A new version, 1.48, is now available. 
Best, Kendall Farrukh, Steve, I understood "3.10 Result Limits" to be about having LIMIT in queries, that is "get a maximum of N results even if there are more", not cursors and chunking nor OFFSET. 
We had the requirement: """ from the F2F: The query language/protocol supports limit, offset and ordering of results. 
But it didn't get as much support. 
It got 5 yes, 3 no: whereas just "limit" got 9/2. 
OFFSET is problematic in RDF (no ordering) and also gets into stability of the result sets over a period of time which is difficult in a federated, web environment. 
The phrase "fetching it in chunks" still seems to be cursors to my reading. 
Farrukh - Could you say some more about your experience with ebXML Registry etc? 
It is a problem if the results are large - just as if a web page is a large PDF or a database backed URL generates huge amounts of HTML. 
It just that machine processing makes it worse as they don't hit the "stop" button. 
Andy From: public-rdf-dawg-request@w3.org 
Date: 11 May 2004 14:12 
