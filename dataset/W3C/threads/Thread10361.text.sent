It seems that there is some concern about XMLLiterals denoting octet sequences. 
As I understand things, RDFCore doesn't feel strongly that the denotation MUST be octet sequences. 
Pat has layed what we really care about in: I suggest we accept Pat's suggestion and reconsider the denotation of XMLLiterals. 
I have seen three suggestions, as I recall: A) be a bit vague about XMLLiterals really are - just define their essential properties B) have them denote XPATH nodesets C) have them denote a pair (uri, lex form), where uri is the uri of rdf:XMLLiteral. 
Concern has been expressed about A being to vague. 
Others have responded saying thats normal - integers are defined in terms of their properties. 
Concern has been expressed that XPATH nodesets are too vague, we don't really know that they are and are thus no better than A, but are in some way worse. 
Cannonicalization does define an equality relation on them I have heard a private concern expressed about C, that if we did that, shouldn't we treat all datatypes that way. 
Further, that this does guarantee that there are no other ways of denoting the same pair with another, posibly user defined datatype. 
How do we choose? 
If you have a preference and rationale, it would be good hear it. 
Brian * Brian McBride bwm@hplb.hpl.hp.com [2003-08-06 12:29+0100] I'd missed that 1st time around. 
Nice summary. 
I can live with this, something along lines of Slight nervousness - which version of XPath? 
be dissapointed if RDFCore has just gone to REC with a normative reference to the ageing 1.0 Xpath. 
Some sympathy there. 
I have no strong view (except lately I keep running into use cases for properties-of-literals, but that I guess is water under the bridge...). 
Dan I think that's a con, not a pro. 
Currently we have one datatype for XMLLiteral; preserving the ability to produce subtypes is important. 
What Pat said: clearly XMLLiterlas can be lots of different things to different people. 
I don't think Pat's idea was "vague". 
Basically for testing purposes, we need an equivalence relationship that can tell when one XMLLiteral is the same as the other. 
However, u to now many "concrete" suggestions for the value space have aimed at this equivalence relationship and provided it by making the value space "just another lexical form" - ie, just another representation. 
There are reasons why you'd want to consider XML as "rich text" - I18N. 
There are reasons why you'd want to treat it as something navigable with the DOM. 
There are probably even reasons why you'd want to consider it an octet sequence, although they escpae me for the moment. 
There are bugger-all reasons to exclude two out of three of the use cases by picking just one of the above. 
Pat's option makes sense. 
jan grant, ILRT, University of Bristol. 
http://www.ilrt.bris.ac.uk/ Goedel would be proud - I'm both inconsistent _and_ incomplete. 
Whatever solution we choose, it should provide enough information to test equality of values. 
Option A does not do that. 
The argument that integers are thus vaguely defined is bogus, in that integers are defined sufficiently well to test for equality, among other things. 
Option A is quite a bit more vague than the definition of integers. 
Option B seems the most promising. 
I'd like to hear a summary of the concerns with this. 
I don't recall seeing anything on the WG list. 
Option C is completely unnacceptable to me. 
It again introduces a unique treatment for the rdf:XMLLiteral datatype, among other shortcomings that I've detailed before and won't repeat here. 
If none of the above seem to work, then there is the fourth option which is to say that XML literals are self denoting, being canonicalized XML fragments, and those fragments are comparible by character sequence, and may be mapped by XML applications to other things, such as XML Infosets, DOM trees, XPath nodesets, whatever. 
Patrick It seems that there is some concern about XMLLiterals denoting octet sequences. 
As I understand things, RDFCore doesn't feel strongly that the denotation MUST be octet sequences. 
Pat has layed what we really care about in: I suggest we accept Pat's suggestion and reconsider the denotation of XMLLiterals. 
I have seen three suggestions, as I recall: A) be a bit vague about XMLLiterals really are - just define their essential properties B) have them denote XPATH nodesets C) have them denote a pair (uri, lex form), where uri is the uri of rdf:XMLLiteral. 
Concern has been expressed about A being to vague. 
Others have responded saying thats normal - integers are defined in terms of their properties. 
Concern has been expressed that XPATH nodesets are too vague, we don't really know that they are and are thus no better than A, but are in some way worse. 
Cannonicalization does define an equality relation on them I have heard a private concern expressed about C, that if we did that, shouldn't we treat all datatypes that way. 
Further, that this does guarantee that there are no other ways of denoting the same pair with another, posibly user defined datatype. 
How do we choose? 
If you have a preference and rationale, it would be good hear it. 
Brian * Patrick Stickler patrick.stickler@nokia.com 
[2003-08-06 15:40+0300] I just sent one: we would need to decide which version of XPath to reference, and understand any costs/risks re blessing XPath 1.0 when 2.0 is looming. 
Dan Sorry, if I've not been clear. 
With option A, I had in mind something close to what Pat suggested. 
This includes the notion that the mapping from the lex space to the value space of xml literals is 1:1. 
Thus it is possible to test whether xml literal values are equal by comparing their lexical forms. 
Thanks for being brief Patrick, but in this case I could do with a reminder. 
I have had a search and didn't find the post(s) you refer to. 
Could you provide a link? 
The trouble with that seems to be that it fails to distinguish between markup and text, e.g. _:a eg:prop "br/br" . 
rdf entails _:a eg:prop " br /br "^^rdf:XMLLiteral . 
I think there is general agreement that is a bad thing. 
* Patrick Stickler patrick.stickler@nokia.com 
[2003-08-06 15:40+0300] I just sent one: we would need to decide which version of XPath to reference, and understand any costs/risks re blessing XPath 1.0 when 2.0 is looming. 
Thanks. 
Can someone more familiar with the W3C process clarify if/how choosing XPath 2.0 might delay the rec process for RDF? 
Isn't it one level of lag allowed for dependent specs? 
So if XPath 2.0 is at CR, RDF could reference it and still go to PR? But XPath 2.0 would need to go to PR before RDF could go to Rec? Patrick Sorry, if I've not been clear. 
With option A, I had in mind something close to what Pat suggested. 
This includes the notion that the mapping from the lex space to the value space of xml literals is 1:1. 
Thus it is possible to test whether xml literal values are equal by comparing their lexical forms. 
OK. 
I can see how that would be sufficient, albeit a little odd. 
Perhaps we can use that approach in conjunction with XML Infosets, specifying that the value space consists of Infosets which are serializable as canonical XML according to the defined lexical space of rdfs:XMLLiteral, in 1:1 correlation with the canonical lexical forms, and that the comparison function for the members of the value space is character sequence equality of their canonicalized form. 
So, testing for equality utilizes the canonicalized lexical forms, but the values are Infosets, with all that implies, and not just character sequences. 
This would solve the primary deficiency of the Infoset spec, that it fails to provide a method of comparison, yet still capture the desired result that we are dealing with something much richer than strings. 
Yeah. 
What a nice change, eh? ;-) In a nutshell, a URIref denotes some resource. 
That URIref is not an inherent part of that resource. 
Positing some value that pairs a specific URIref with a lexical form strikes me as a layering error. 
It also precludes using other URIrefs to denote the same datatype, or from using mechanisms such as owl:sameIndividualAs or rdfs:subClassOf to equate or relate other, proprietary vocabularies or specialized datatypes to the core of RDF. 
In short, it goes against what I see as fundamental aspecs of RDF and the (still overly vague but emerging) SW architecture. 
Agreed. 
I think that my proposed approach of marrying XML Infosets with canonicalized comparison may avoid that problem (hopefully without creating too many others). 
Patrick I agree that the choice of octet sequences is probably confusing. 
In that, I understood we were simply following an existing spec. 
I'm not sure that I follow the concern with (C): XML is an inherently character-sequence-based format, so why not use a form of denotation that contains that sequence. 
To do that for, say, numbers is unhelpful and unnecessary IMO (and I believe has led to some shortcomings in XML schema datatype treatment of numbers). 
In particular, the form (C) asserts precisely the condition that Pat requires for the semantics: a 1:1 correspondence between lexical and denoted forms. 
Another advantage of (C), it seems to me, is that it may make it easier to achieve something approaching the unification between plain literals and XML literals that Martin desires: it would be a relatively easy for an application to interpret a sequence of characters S in a context where text is expected to be equivalent to (rdf:XMLLiteral,S). 
#g Graham Klyne _________ GK@ninebynine.org ___|_o_o_o_|_? 
(nb Helva) ~~~~~~~~~~~~~~~~~~ @Cliveden, River Thames * Brian McBride bwm@hplb.hpl.hp.com [2003-08-06 12:29+0100] Thinking about this some more, I'm increasingly uncomfortable with the idea of picking one of these 3 somewhat different answers, and then storming on to REC without another cycle of external review. 
The relationship(s) between RDF and XML is _the_ big problem that's haunted the entire RDF project since 1997. 
To be having such a straw poll at this stage, without expectation of major review from the RDF and XML developer community, is a cause for concern. 
Nobody's fault but that's where we're at. 
If the choices A, B, C actually mean anything and matter, and have substantive differences amongst them, I suggest the answer to your question 'how do we choose' is 'with outside help from XML and RDF implementors'. 
If A, B and C don't really have any observable differences in the workings of an RDF implementation, maybe this wouldn't matter. 
But we seem to be discussing the choice as if it was a real one with consequences that matter in the world. 
Declaring a dependency on some version of XPath, for example, is a non-trivial thing to do. 
I'm coming round to the view that we need a CR[1]. 
In 1999, RDF M+S was promoted prematurely to REC with minimal implementation experience; we're still cleaning up the resulting mess. 
I fear we're about to do the same thing regarding RDF's relationship to XML. 
If A vs B vs C is non-trivial, a CR will help us evaluate our decision. 
If it is trivial and our decision doesn't matter at all, then let's just flip a 3-sided coin... Dan [1] http://www.w3.org/2003/06/Process-20030618/tr.html#q70 
DanBri: I think this is a misplaced concern. 
We *have* a dependency on xpath 1.0 in that we depend on exc-c14n which depends on c14n which depends on xpath 1.0. 
Yes, we have swept that dependency under the transitivity carpet ... but to make it explicit would not be a substantive change. 
A particular issue is to do with processing instructions; the last time I looked (a while ago) xpath 2.0 was treating these differently than in xpath 1.0. 
Life is not perfect and of course some of our dependencies are aging. 
For the XML 1.0 to XML 1.1 variation we have worked harder to be aware of the implications. 
This is not something we have done for xpath 1.0 to 2.0, and I do not believe we have the energy to do it now. 
Jeremy 
