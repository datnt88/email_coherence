Hyperlinking and locating anchors and anchor awareness is all quite easy if the only mechanism for locating is ENTITY and IDREF. 
A number of people have expressed interest in using the TEI style linking (having never used seen TEI, that is difficult for me to evaluate. 
Anyone have a good 
reference for me where I could get some info/examples of TEI locators?). 
Another group (largely composed of HyTime TC1 editors no less) is carrying the HyTime torch. 
For this to succeed I believe that either one side needs to give in (and I pity the TEI people if they try to get the HyTime people to abandon HyTime) or some general mechanism needs to subsume both somehow. 
How difficult the anchor awareness problem is depends on the richness of the locator model intended to be used. 
David (and others) requested the ability to locate data which has no ID. How far do people want this to go? 
A full query model a.k.a. 
HyTime, where anything can be located and if HyTime can't then you just use an external handler with QueryLoc (which used to be NotLoc, for "Notational locator"). 
If a simple static locator model is used it greatly simlifies the process of problem of determining anchor awareness (talking as someone who has approched this from an implimentation angle). 
If general locators are used, allong the lines of HyTime's nameloc, treeloc, etc, do you allow document A to use document B's locators? 
This gets to be a messy situation (which is why I broke it out to a seperate level in my previous post about resolution levels),a nd can be difficult to implement, and costly to do in a general way (costly in terms of programmer time, cpu time, UI time/complexity, document complexity, etc). 
Much as I must agree with Steve and Eliot that the HyTime/DSSSL grove concept is "cool" (I was part of it's development, I hope I think it is cool...), I think that it is too much for what we are trying to do _right_now_. 
If we want a full model, then we should just use TEI or HyTime. 
So the question is, how much do people really demand? 
What can we trim? 
independent links apprears to be in the "in" box, but what about locating mechanisms. 
I have seen/heard almost no discussion regarding what capabilities people want (other than requests not to be limited by IDREF). 
The answer to this questoin is crutial to the answering Steven's questions. 
(None of which are easy. 
He an I have spent long hours "discussing" some of these issues to the point of sending the rest of the office into hiding.) 
I might propose as some starting requirements: - IDREF (obviously) - ENTITY (what does this really mean?) - inter-document IDREF (i.e. refering to an ID in a different document) - sub-element tree traversal (avoid the whole issue raised before over pseudo-elements messing the traversal by exlicitly ignoring them) - content (linking to the content of an element... but what does this mean? 
are subelements content?) I specifically avoided any attempt to do general, or complex queries. 
keep to the KISS method of design, for simpler explanation and implimentation. 
Anther questin is how should the locating mechanisms tie into the Linking mechanisms? 
Are they treated as one and the same, or is locating seperated, as in HyTime? 
-derek "that which is not slightly distorted lacks sensible appeal: from which it follows that irregularity - that is to say, the unexpected, surprise, and astonishment, are an essential part and characteristic of beauty" - Charles Baudelaire 
Fortunately, you're incorrect in thinking there is a conflict between TEI and HyTime. 
There is not. 
With the TC, HyTime processing can now be integrated with any addressing scheme you care to support. 
All you have to do is define for the HyTime engine what sort of nodes you'll be returning, which you do by defining a property set and creating the appropriate software to provide a "grove view" of the data. 
If you're not using a HyTime engine, then just do what you would have done anyway. 
As I've said in other notes to this group, this should be almost trivial for TEI locators because they're both designed to address SGML documents and well documented (and implemented to some degree by at least two browsers). 
This means that defining how TEI locators address groves, SGML document groves in particular, should be very straight forward, and adapting the existing facilities to support whatever XML needs shouldn't be hard (it may already be inherent in those tools' functionality). 
Note that HyTime would consider TEI locators to be queries, no different in nature from any other query language you might want to use. 
I am already on record as probably preferring TEI locators as a good syntax for the XML target audience. 
But the use of TEI locators in an XML-specific, HyTime-derived linking and addressing architecture does not preclude the use of other HyTime facilities, such as basic name indirection, treelocs, datalocs, etc. Cheers, E. W. Eliot Kimber (eliot@isogen.com) 
Senior SGML Consulting Engineer, Highland Consulting 2200 North Lamar Street, Suite 230, Dallas, Texas 75202 "Rats in the morning, rats in the afternoon...if they don't go away, I'll be re-educated soon..." --Austin Lounge Lizards, "1984 Blues" 
This is a good point and we shouldn't lose sight of it. 
I tend to assume that queries will be used for addressing, both because it's right powerful and because the Web allows it today. 
But Derek's point is well taken: limiting our addressing power makes anchor-awareness much more tractible. 
In my hyperworld view [sorry Terry] I assume queries are allowed and therefore assume that there will be a class of anchors for which pre-knowledge of anchorness is unknowable. 
My impression is that Steve N. tends to the opposite world view, in which all anchors should be (and, ideally, must be) known in advance. 
I think these two views reflect focuses on different use scenarios, not fundamental differences about what hypertext is or how things like HyTime should work. 
Cheers, E. W. Eliot Kimber (eliot@isogen.com) 
Senior SGML Consulting Engineer, Highland Consulting 2200 North Lamar Street, Suite 230, Dallas, Texas 75202 "Rats in the morning, rats in the afternoon...if they don't go away, I'll be re-educated soon..." --Austin Lounge Lizards, "1984 Blues" 
On Mon, 23 Dec 1996 12:28:03 -0800 Derek Denny-Brown said: 
I believe Lou Burnard is currently working on a free-standing document describing TEI extended pointers, to make it unnecessary to consult the TEI Guidelines themselves. 
In the meantime, for the TEI Guidelines as a whole, try For chapter 14, on "Linking, Segmentation, and Alignment" try -C. 
M. Sperberg-McQueen 
On Mon, 23 Dec 1996 12:28:03 -0800 Derek Denny-Brown said: 
... A number of people have expressed interest in using the TEI style linking (having never used seen TEI, that is difficult for me to evaluate. 
Anyone have a good reference for me where I could get 
| some info/examples of TEI locators?). |I believe Lou Burnard is currently working on a free-standing |document describing TEI extended pointers, to make it unnecessary to c 
A first draft of a brief tutorial intro to the TEI extended pointer syntax is now available at 
For authoritative information, it is still best to onsult the TEI Guidelines themselves. 
In the meantime, for the TEI Guidelines as a whole, try For chapter 14, on "Linking, Segmentation, and Alignment" try -C. 
M. Sperberg-McQueen 
Lou, Thanks for making this summary available. 
The summary reinforces my opinion that TEI extended pointers are probably a good thing for XML. 
The only wrinkles I see in integrating TEI pointers with HyTime are: 1. TEI pointers use a slightly different "grove plan" than HyTime, to wit, TEI extended pointers only see elements (and not pseudo elements) in the tree rooted at the document element. 
This doesn't cause any problems with specification, it just might confuse people (any location address can specify the grove plan to be used when resolving it). 
2. The XREF element's to and from attributes cannot be directly mapped to a HyTime contextual link because HyTime expects there to be a single attribute for each link end, but TEI allows two (three if you count "doc"). 
The only ways to resolve this that I can see are: A. Allow To, From, and Doc and then use a separate fixed query as the value of the HyTime anchor-addressing attribute that then refers to the values of the To/From attributes. 
This is pretty twisted but it could be made to work (e.g., I could create an SDQL "resolve TEI pointer" function and then use that as the value of the anchor-addressing attribute). 
B. Allow the DOC specification directly in the TEI extended pointer, e.g.: to="DOC (P3) ID (ABCD)" and limit XREF to "to" attribute. 
This seems like a useful thing regardless--maybe it's already there and it just wasn't mentioned in the tutorial? 
A few minor points wrt to mentions of HyTime and overlaps with HyTime terminology and functionality in the tutorial (and I assume in the current official TEI specs): location path/location ladder/step - Both HyTime and TEI pointers have the concept of location ladders and location paths (I don't know who influenced whom here). 
In the original HyTime standard, the terms location ladder and location path were not always used consistently. 
In the TC, we've taken pains to sort out the terms. 
A "location ladder" is the equivalent of a single TEI extended pointer: it specifies the list of nodes selected by successive narrowing of the set of possible nodes, e.g. "first para of third chapter of second part of doc A". 
A "location path" is a series of "steps", each step the bottom rung of a single location ladder, i.e., a series of indirections where one location address refers to another (this would be like one XPTR element pointing to another XPTR element). 
These terms seem to be slightly different from the way Lou has used them. 
In particular, we use "rung" to distinguish stages in a location ladder from steps in a location path--TEI appears to use the term "step" where HyTime uses "rung" and doesn't appear to necessarily distinguish rungs in ladders from steps in paths (this may be because in TEI extended pointers, the location ladder is always contained in a single pointer specification, whereas in HyTime a ladder consists of multiple address elements). 
- From the tutorial: "The token and str methods are defined as behaving in exactly the same way as their HyTime equivalents tokenloc and strloc respectively." 
Note that tokenloc and strloc were replaced by "dataloc" in the final HyTime standard. 
Dataloc survives in the TC, although the original "quantum" attribute is now "filter". 
The filter value corresponding to TEI's "token" is "norm", meaning SSEP-delimited tokens. 
- HyQ: HyQ is dead and replaced by SDQL from the DSSSL standard. 
- Spans: The TEI "from" and "to" attributes let you address data by pointing to the start and end points and addressing everything in between. 
HyTime calls this form of address a "span". 
Any location address in HyTime can indicate that it is addressing a span, in which case, every pair of nodes addressed is taken to be the start/end (to/from) of a span. 
Thus, the concept is there, but the syntax is different [my understanding is that spans were added specifically to reflect the TEI functionality.] 
Note that when using a query in HyTime, spanning is a function of the query's semantics--HyTime doesn't care how the query arrives at the node list it returns. 
Thus, if we assume that XPTR elements are treated as queries in a HyTime context, the TEI to/from attribute syntax is fine because the TEI engine will simply return the entire list of nodes addressed, not just the separate to and from values. 
- "HERE" keyword. 
With the TC, HyTime now has the equivalent of the "HERE" keyword, which is the ability of the location source of a location address to be the "referrer", i.e., the non-location address element that first points to it. 
When used with the relloc (relative location address) element in particular, it lets you do things very much like TEI extended pointers by making it possible to have a single location ladder that locates the "next" or "previous" element. 
[I originally suggested this addition to HyTime specifically to mirror the TEI functionality.] - DOC attribute. 
The TEI "doc" attribute corresponds to the HyTime location source attribute when it refers to a document or subdocument entity. 
In original HyTime, the locsrc attribute could only be an IDREF. 
With the TC, any location address element type can be declared as an ENTITY attribute, so that you can specify entities directly as location sources. 
Given the above, the TEI XPTR element form can be declared to a HyTime engine like so: !NOTATION TEIXPTR PUBLIC "-//TEI P3//NOTATION TEI Extended-Pointer Syntax//EN" !ATTLIST #NOTATION TEIXPTR to CDATA #IMPLIED -- Lextype(TEIXPTR) -- from CDATA #IMPLIED -- Lextype(TEIXPTR) -- !ATTLIST XPTR doc ENTITY #IMPLIED -- Constraint: document or subdocument entity -- to CDATA #IMPLIED -- Lextype(TEIXPTR) -- from CDATA #IMPLIED -- Lextype(TEIXPTR) -- notation (TEIXPTR) #FIXED "TEIXPTR" HyTime NAME #FIXED "queryloc" HyNames CDATA #FIXED "locsrc doc" The TEI XREF element, using option B given above, can be declared like so: !ATTLIST XREF to CDATA #IMPLIED -- Lextype(TEIXPTR) -- refloc CDATA #FIXED "to queryloc TEIXPTR" HyTime NAME #FIXED "clink" HyNames CDATA #FIXED "linkend to" Note that neither of these definitions change the element instances at all. 
Cheers, E. W. Eliot Kimber (eliot@isogen.com) 
Senior SGML Consulting Engineer, Highland Consulting 2200 North Lamar Street, Suite 230, Dallas, Texas 75202 "Rats in the morning, rats in the afternoon...if they don't go away, I'll be re-educated soon..." --Austin Lounge Lizards, "1984 Blues" 
