My apologies if this has been answered elsewhere in the email discussion. 
[1] suggests that only the P and P++ proposals involves the use of rdfs:range. 
Is this true? 
If so, it seems like we've missed a major opportunity to capture the intent of the ontology developer and make life easier on programmers using the ontology (who otherwise must presumably be prepared to handle any datatype or instance as the property value). 
Mike [1] http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2001Nov/0295.html 
The X and U proposals also support the use of rdfs:range and I presume that the DC proposal does as well, from the viewpoint of rdfs:range being treated as a "constraint". 
The ability of a given system to define rdfs:range constraints which can be used to "filter out" knowledge that is expressed in a fashion that is either unsupported or uninterpretable by that system is very important, and I've tried to point that out in the recent discussions, though I'm not sure that it has been fully appreciated by a majority of the WG. 
And I agree that given common usage of rdfs:range to "name" the mapping from lexical form to data type value, that proposals that preclude continued use in that fashion are less attractive -- and possibly even ruled out by the charter, depending on one's interpretation... Cheers, Patrick Hi Mike, This is a good question, and an opportunity for me to check an assumption. 
Within the context of the S proposal, I've been assuming that the value spaces of XSD datatypes are resources and we could assign URI's to them. 
Thus if eg:int denotes the value space xsd:integer, we could define foo:someProperty rdfs:range eg:int . 
xsd:integer would have a domain constraint: xsd:integer rdfs:domain eg:int . 
and thus given bar foo:someProperty _:int . 
_:int xsd:integer "10" . 
we can infer _:int rdf:type eg:int . 
by two different routes. 
Brian 
