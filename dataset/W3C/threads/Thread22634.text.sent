a particular locale (US English). 
It might be something that is specific to the ECMAScript binding, since it doesn't affect Java implementations. 
I'm not even sure I understood this concern! 
For Python, each specific exception code is mapped to specific subclasses of the DOMException, and all such exceptions have the appropriate .code 
attribute. 
If you are accessing a COM DOM using JScript (and probably true for other ECMAScript implementations), there is no portable mechanism for determining the DOMException code for the exception. 
try { charData.substringData(-5,-5); 
catch(ex) { // on JScript you can access the HRESULT from a COM implementation // which is an very large negative number with little // or correspondance to the DOMException codes and // a textual description of the error which may // be sensitive to the locale var hresult = ex.number; var desc = ex.description; // currently if you want to respond to an specific exception // you have to somehow determine from the hresult // and description if it was the exception that you // intended var domExceptionCode = someImplementationAndLocaleSpecificRoutine(hresult,desc); I was thinking the implementation specific routine might be replaced with a standard call back the the DOMImplementation that could decipher their own error messages. 
try { charData.substringData(-5,-5); 
catch(ex) { var domExceptionCode = domImpl.getExceptionCode(ex); 
However, I'm not saying that that is the right solution, however I do think the problem is legitimate. 
If the DOM you are using follows the W3C Recomendation then you use the instanceof operator in JavaScript to find out what exception object was thrown. 
After you get that then you use the value of the code property to get the exact error thrown. 
If the DOM you are using follows the W3C Recomendation you can use the following: try{ //error prone code }catch(err){ if( err instanceof DOMException ){ switch( err.code ){ case DOMException.INDEX_SIZE_ERR: //error handling code here case DOMException.DOMSTRING_SIZE_ERR: //error handling code here case DOMException.HIERARCHY_REQUEST_ERR: //error handling code here case DOMException.INVALID_ACCESS_ERR: //error handling code here } else if( err instanceof EventException ){ if( err.code == EventException.UNSPECIFIED_EVENT_TYPE_ERR ) //error handling code here } else if( ... ){ Jeff Yates e-mail: PBWiz@PBWizard.com 
Homepage: http://www.PBWizard.com 
[...example code...] This is an enlightening example! 
I must confess I don't know enough ECMAScript -- I didn't even know it *had* a try/catch construct! 
It's good that it does. 
Sounds like it, but... [...example code...] This example seems to indicate that an implementation which follows the W3C bindings doesn't need any additional functions. 
So let's avoid the extra method. 
Perhaps Curt is using a non-conforming implementation? 
Fred L. Drake, Jr. fdrake at acm.org PythonLabs at Digital Creations Hi, A problem with the W3C recommendation and its ECMAScript binding is that it does not require DOMException (and many other interfaces) to be a constructor AFAIK. 
If an ECMAScript builtin object is no constructor, it is most likely that its type is not visible to scripts, i.e. "DOMException" is no valid type and the code line above fails. 
If I run this little JS script on my Mac var exc = new Object(); if (exc instanceof DOMException) // do something MSIE5, Opera5, Netscape6 and Mozilla 0.9 fail to execute it (I have not checked how Windows browsers handle this script). 
Of all the browsers on my hard disk only iCab reveals the type "DOMException". 
Maybe the W3C-DOM ECMAScript binding should explicitely state that interface types should be visible to scripts? 
In ECMAScript you do not need them for casting, but for type checking. 
bye, Thomas Fred, I believe the problem is that there is no conforming implementations built into a browser as yet. 
The closest I have run into is Mozilla and it has it's bugs. 
The one that applies to this is that the DOM constructors are NOT exposed until an object of that type is constructed first. 
Example: The Range object constructor is not exposed until you create one first. 
//example code alert( Boolean( Range ) ); //alerts false; document.createRange(); 
alert( Boolean( Range ) ); //alerts true; This is a major weakness. 
Jeff. 
Jeff Yates e-mail: PBWiz@PBWizard.com 
Homepage: http://www.PBWizard.com 
Sounds like a pretty serious bug from the user's standpoint! 
But as long as it's an implementation but, then there should be no need to change the DOM specification or even the ECMAScript mapping. 
Fred L. Drake, Jr. fdrake at acm.org PythonLabs at Digital Creations 
