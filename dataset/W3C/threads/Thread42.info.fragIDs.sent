Hi, I've noticed the following behavior on HTML Tidy with ASP server side scripting. 
The following construct: % If (Request.Cookies("NumVisits")  0) then % You last accessed this web page at %= LastAccessTime % on %= LastAccessDate % gets translated to % If (Request.Cookies("NumVisits") &amp;gt. 
0) then % You last accessed ---- Breaks the script! 
this web page at %= LastAccessTime % on %= LastAccessDate % 
when the &amp; conversion settings are passed to Tidy. 
Future enhancement request: bypass conversions inside of ASP % % delimiters. 
This would probably apply to other server 
side scripting languages as well such as Cold Fusion CFML, and others. 
Regards, Darren Forcier Allaire Corporation. 
From: Darren Forcier dforcier@allaire.com 
I suggest a different approach: upgrade tidy to know about processing instructions, and allow the passing of the open and close delimiters in the config file. 
For XML and XHTML, the delimiters are ? 
and ? 
For RCS SGML (i.e., the default), the delimiters are ? 
and For HTML, there are no delimiters For HTML as allowed by some servers for server-side include, the delimiters are !-- # and -- For ASP and JSP, the delimiters are % and % 
Processing instructions are a good thing: they allow embedded messages targeted at distinct processing-phases. 
Server-side includes are just processing instructions: they don't use ? 
and ? 
because HTML is a delivery format and has (until XHTML) rather shied away from document construction issues. 
But the delimiter issue is secondary to the functionality. 
Rick Jelliffe 
For backward compatibility, maybe yes. 
But the Right Thing (TM) for the future would probably be for server implementors to stuff their processing instructions inside XML CDATA. 
This eliminates the need for parsers like tidy and others to know the gritty details about all kind of processing pragmas. 
Steinar Kj?rnsr?d steinar@infostream.no 
InfoStream AS 
From: Steinar Kj?rnsr?d steinar@infostream.no 
I don't see why that is the right thing at all. 
A CDATA section just alters the delimiter recognition rules. 
With server-side includes and ASP and JSP we have a kind of tag introduced which looks, smells and tastes like a PI. 
Why have two parsers (one for HTML/XML markup and one for % % markup)? 
Rick Jelliffe 
But they are not valid XML PIs, which cause otherwise well formed XML/XHTML pages to be rejected by XML parsers/validators. 
We already have different types of parsers in different flavors. 
Stuffing proprietary PIs inside legal XML constructs would impose only small modifications and minimal overhead on parsers for those proprietary PIs. 
The nice thing however, is that these XML/HTML files may be procesessed by XML parsers as well. 
I see that as a great benefit, others may not. 
Please direct further replies to me directly, as this thread is off tpoic for the tidy list! 
Steinar Kj?rnsr?d steinar@infostream.no 
InfoStream AS 
I like Rick's suggestion. 
Tidy has always been a practical tool. 
This suggestion looks pretty straight forward and would be helpful. 
Especially considering the recent posts by folks having trouble on this issue. 
Rick, are 
you volunteering to code up this enhancement? 
Eric 
From: Eric Blossom eric@neomorphic.com 
are 
I'll check with my boss. 
Rick P.S. I have made a C interface header for DOM (level 1 XML) at It is just a big C struct, but I think it is useful to allow implementation-independent access to DOM data. 
If anyone is wondering how DOM might fit in with their all-C applications, it might be interesting. 
The big issue for C is that the DOM API uses 16 bit chars: there might be scope for a Son-of-DOM API for C programs that uses char, to prevent spurious conversions. 
I thought the issue that DOM uses objects and C is not an OOPL would be more important than it was; the problem for C is that IDL to C mappings programs all are written to generate networking stubs and that the CORBA IDL-to-C mapping does not include conventions for creating or releasing objects: DOM seems to assume that this will happen using the OOPLs normal create and release mechanism, but C of course does not have them; so there will always be scope for variant DOM APIs in C. Which is why I made the headers, to make it easy for programmers to use a common API for DOM in C, if they want. 
P.P.S. On the issue of writing parsers for XML and HTML, people may be interested in XXX "eXperimental Xml leXer" at a different parser architecture, the "notation processor", based on figuring out what a generic tokenizer routine for SGML/XML/HTML is, highly parameterized to cope with every kind of token: it is a state machine where every state is the same and the transition carries all the specifics. 
The advantage of this approach might be that the same lexer can be used to also parse other embedded notations: PI contents, JavaScript, CSS, DTDs, etc. Basing the parse on that kind of tokenizer may then allow the rest of well-formedness checking to be performed by a regular expression checker: again implemented using a generic routine that also can perform the XML content model and attribute validation: I am looking at whether it can reduce code size and complexity a real lot. 
There is discussion material at "XXX Notation Processors" Models on other Targets" http://www.ascc.net/xml/en/utf-8/OtherValid.html 
