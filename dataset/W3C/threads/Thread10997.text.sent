I don't know what Martin means by "link chains". 
This is not a HyTime term. 
If he means "location ladders", then you can have location ladders without requiring entity declarations (although the use of entities would be the SGML/HyTime recommended method). 
I did mean location ladders. 
The HyTime TC says (twice, so you have to believe it!) that "The ultimate location source for any location ladder is the root of a grove". 
It also says "If the location source is a document, subdocument or data entity, the location source is within the grove constructed from that entity". 
(Note the use of the term entity!) In XML terms, where application dependent groves are not likely to be permitted, this in practice means the root of the file being referenced if no finer resolution is given in the pointer as it has to be presumed that the reference is to a free-standing XML document. 
While this reference could be done indirectly using a query that contains a URL the SGML way of identifying files is by having the root of the document identified via a uniquely named entity declaration. 
What I am unclear about is what would constitute a the grove of something pointed to using a URL of the form report.html#point1 if the HTML page pointed to was constructed as follows: p The points raised were: ul li a name=point1 /a How useful is HyTime Given the fact that most documents on the Web would not allow sensible groves to be constructed from existing named anchors the relevance of HyTime location sources for linking XML files to HTML anchors must be considered. 
My personal preference would be to say that pointers to named HTML anchors should be handled by a special architectural form that has nothing to do with HyTime location addresses, but that we provide HyTime compatible architectural forms for handling links that cannot be expressed using the far-too-simple HTML anchor constructs. 
Martin Bryan, The SGML Centre, Churchdown, Glos. 
GL3 2PU, UK Well, if it _requires the entity reference,_ then we should not use HyTime. 
It doesn't require an entity reference. 
Great! 
This is important! 
You're darn tootin' it's important. 
It's the only way we can hope to have the power of HyTime with the convenience of things like URLs and TEI locators. 
Using my proposed scheme, you could use a queryloc to contain the URL, e.g.: P See link linkend="bookrev" my book review site /link for a draft introduction to HyTime. 
But surely you can also do something like: p See link linkend="http://www.drmacro.com/bookrev" 
my book review site /link for ... Certainly you can do this (it's the whole point of the refloc facility). 
But I was trying to satisfy Martin's requirement for a re-uable ID reference to a URL. 
I also think we need to look at the #-sign hack. 
I've as yet seen no justification for _not_ using URL-compatible link formats. 
Gavin has argued for a different kind of URL-compatibility, but it still has a real flaw: I think the #-sign hack is a reasonable solution. 
A similar facility has been proposed for the SGML revision (but not designed to the point where we are confident in the final sytax) where you can combine an entity name with an ID to do simple direct cross-document ID references. 
I think the #-sign hack is consistent semantically with this proposal: in both cases you're binding a name to the object that defines the name space. 
The only difference is the way you name the name space (entity vs. direct URL reference). 
Cheers, E. W. Eliot Kimber (eliot@isogen.com) 
Senior SGML Consulting Engineer, Highland Consulting 2200 North Lamar Street, Suite 230, Dallas, Texas 75202 "Rats in the morning, rats in the afternoon...if they don't go away, I'll be re-educated soon..." --Austin Lounge Lizards, "1984 Blues" I think we could do quite well with a very simple notation for these extensions which includes simple query and tree location abilities. 
The extension is parsed similar to the path portion of the URL in that it is a "/" separated list of specializers/filters. 
If the specializer is a number, pick that subelement. 
If not it must conform to a name = value form where name is an attribute name and value is an attribute value you are trying to match to. 
(this explanation is rushed bec. 
I want to beat traffic home... sorry) That's what a TEI extended pointer is. 
The syntax is very compact, was developed by a diverse international body, and has been implemented in both DynaText and Panorama, so it's proven and already in use. 
TEI extended pointers also do a lot more than the simple sketch above, like allowing you to choose elements in all tree-directions (ancestors, children, siblings, predecessors, followers, etc) based on position numbers and filters on GI and/or attributes. 
They can also address into multidimensional graphics and other media, do what HyTime calls spanlocs, and more. 
If you haven't yet looked at the TEI guidelines section on extended pointers, *please* look at http://dynaweb.ebt.com:8080/usrbooks/teip3/26759 (this link takes you directly to the section, with access available to the rest of the guidlines). 
The spec is half the length of XML, it won't take long. 
Since you can encapsulate a TEI pointer as a locating notation in HyTime, we can have a rather nice cake and eat it too. 
Steve 
