The ERB voted (correctly, in my view) that the linking part of the spec. 
doesn't need any new syntax productions. 
Someone observed in the last few days that we have studiously avoided the issue of an API for XML processing. 
So what are we doing in this section? 
I think it is more than spec'ing a meta-DTD and a family of XML Applications which could use it. 
The API question points to the answer. 
DSSSL and the HyTime TC give the means for framing this 
answer: The xml-link document should define a new Property Set module, which (using the terminology from my proposed redraft) provides an HLINK class to represent links, with e.g. HLINKTYPE and ENDPOINTS properties. 
(Note: Irritatingly, the value of ENDPOINTS can't be a NamedNodeList, because several endpoints can have the same type, in my view, so there will have to be an ENDPOINT class as well, with something like TYPE, NODELOC and DATALOC properties.) 
On this account the result of processing an XML document with link 
definition elements in it is TWO groves: the document grove and a link grove. 
So-called 'Link databases' (I don't like the name) are just documents whose processing output is mostly in their link grove. 
One of the NODELOC properties of TLINKs will point back to the document 
grove; other NODELOC properties will be (lazy) pointers into the groves of other (..ML) documents altogether, while DATALOC is for non-SGML endpoints. 
More later, got to run. 
ht 
I said, in summary: 
As promised, a bit more. 
1) Note that I don't mean by the link grove proposal to say that all XML parsers have to buy in to the grove model, just that groves are a useful language for answering the question Jon implicitly asked a 
while back, namely, what do Applications have to work with when processing links. 
The link grove proposal answers that question in the abstract---the concrete representation of that information is up to implementors. 
2) I'm sure a lot of this is crypto-HyTime, and Eliot would have said it first if he weren't too busy. 
3) Using TC language again, the 'link description' in my terminology is pretty much isomorphic to the node in the document grove derived from the link description element, as that node has (directly or indirectly) all the relevant information in its properties. 
On this account, we'd add a new (urefnode) HLINK property to the ELEMENT class, which would point to the appropriate HLINK node in the link grove from all such element nodes. 
4) Note that since most locators take a lot of work to chase, the laziness of HLINK.ENDPOINTS is important, with the values of ENDPOINT.NODELOC properties on HLINK nodes in the link grove just being a node and property version of the original locators, with in a few cases, e.g. where the locator is an IDREF, a urefnode to the thing itself. 
So class ENDPOINT needs a LOCATOR property, value from a set of classes for the different locator languages, and a (urefnode) SOURCE property, pointing back to the ELEMENT node that gave it birth. 
If this is right, it means that conforming XML processors do NOT have 
to be capable of implementing most of the locator languages we bless, although the ability to do so will clearly make them more attractive to application developers. 
5) I've redone the picture that goes with my partial redraft, and fixed a few things, see the URL below again, good luck getting Netscape to reload the image! 
ht 
definition elements in it is TWO groves: the document grove and a link grove. 
The XML 1.0 spec doesn't require a parser to construct a grove, does it? 
will that be a requirement of xmllink? 
Regards, Terry Allen Fujitsu Software Corp. tallen@fsc.fujitsu.com 
"In going on with these experiments, how many pretty systems do we build, which we soon find outselves obliged to destroy?" - Benjamin Franklin A Davenport Group Sponsor: http://www.ora.com/davenport/index.html 
If the group could look carefully and with an unbiased view at the grove concepts, they could benefit from that work and put XML linking on much firmer foundation. 
eventually you have to work with the output of the parser. 
duh! 
len bullard 
to be capable of implementing most of the locator languages we bless, although the ability to do so will clearly make them more attractive to application developers. 
To me this implies that the server must negotiate with the client to discover what processor the client uses (or vice versa, the client must negotiate with the server to discover whether it can handle the link syntax it's to be served). 
Is that right? 
Regards, Terry Allen Fujitsu Software Corp. tallen@fsc.fujitsu.com 
"In going on with these experiments, how many pretty systems do we build, which we soon find outselves obliged to destroy?" - Benjamin Franklin A Davenport Group Sponsor: http://www.ora.com/davenport/index.html 
I can't find the graphic that diagrams link parts and terms or a link to the graphic in the 1.02 Partial Revision. 
In the first version it was inline, correct? 
Aw, *$*#, I blew it as I ran out the door. 
Fixed now. 
ht 
