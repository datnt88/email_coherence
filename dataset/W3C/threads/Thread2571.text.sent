Greetings HTTP Working Group, I am hereby forwarding a note that I had sent to some colleagues. 
They agreed that the response_delay is counted twice. 
My colleagues felt that the apparent_age definition should stay as is, but that the corrected_initial_age should equal the corrected_received_age exactly. 
Can you look at this issue? 
Thank you. 
Regards, Burt Silverman, IBM Networking Division ---------------------- Forwarded by Burt Silverman/Watson/IBM on 23/02/98 15:58 Burt Silverman 20/02/98 16:45 To: From: Burt Silverman/Watson/IBM @ IBMUS Subject: Age calculations in HTTP 1.1 11/21/97 document Hi, Looking at section 13.2.3, 
I found that I could only make sense of the formulas if I switched the definition of apparent_age from apparent_age = max(0,response_time - date_value); to apparent_age = max(0,request_time - date_value); For example, if in year 1981, the user sent a request 1989, date_value 1990, request from the cache to the server 2000, resonse_time 2001, now then, apparent_age = 1 year response_delay = 10 years corrected_initial_age = 11 years resident_time = 1 year and, current_age = 12 years. 
This seems to make sense. 
But with the official definitions, apparent_age = 11 years response_delay = 10 years corrected_initial_age = 21 years resident_time = 1 year and current_age = 22 years. 
This brings us back to 1979, and doesn't make much sense. 
Am I correct? 
Burt Looking at section 13.2.3, 
I found that I could only make sense of the formulas if I switched the definition of apparent_age from apparent_age = max(0,response_time - date_value); to apparent_age = max(0,request_time - date_value); For example, if in year 1981, the user sent a request 1989, date_value 1990, request from the cache to the server 2000, resonse_time 2001, now then, apparent_age = 1 year response_delay = 10 years corrected_initial_age = 11 years resident_time = 1 year and, current_age = 12 years. 
This seems to make sense. 
But with the official definitions, apparent_age = 11 years response_delay = 10 years corrected_initial_age = 21 years resident_time = 1 year and current_age = 22 years. 
This brings us back to 1979, and doesn't make much sense. 
It's misleading to try to discuss this in terms of years, since it's highly unlikely that the difference between request_time and response_time would be larger than a few minutes at most. 
Anyway, the problem we're trying to solve here is that in this timeline request_time date_value response_time ------|----------------|-----------------------|------- it really makes no sense to compute apparent_age = max(0, request_time - date_value); because if the clocks are synchronized, then (with non-zero speed-of-light delay) the value (request_time - date_value) is always negative, and so the max(0, request_time - date_value) would always be zero. 
The fact that the response_delay is counted twice in the final result is an attempt to correct for clock skew, since if you can't guarantee that the client and server clocks are synchronized (and we can't!), then the apparent_age could be wrong by a significant amount. 
(Trace studies show that a lot of the clocks in HTTP servers are set wrong, and we suspect that the situation for clients could be even worse.) Adding in the response_delay helps to avoid underestimating the Age of a response in the presence of clock skew. 
The actual magnitude of the error is normally quite small, since response_delay ought to be on the order of several seconds, or several minutes at most. 
-Jeff In the course of my testing, I've found that those proxies (the few we've had to play with) which attempt to adjust for clock skew generally get it wrong, especially when there is no Date header (noclock11.agranat.com). 
I don't want to restart the debate, but if it were me I'd just record my local time of reception, and construct my outgoing Age header based on how long I'd held it plus any Age that I received. 
Forget about trying for any absolute truth - that's for philosophers - go for Good Enough. 
