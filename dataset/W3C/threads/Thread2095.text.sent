Dear Team, I represent a firm producing HTTP clients and servers for use in vertical mobile computing environments, using PDA-style devices. 
In the last year, we have produced a HTTP 0.9 compliant browser, and are currently collaborating with other firms to produce a HTTP 1.0 compliant browser and proxy server for wired or wireless access to devices which may or may not have an underlying TCP/IP stack. 
To this end, we have reviewd the draft IETF HTTP spec (0.1, dated 19 December 1994, expiring June 19, 1995) quite thoroughly, and it has been very useful in both the development of our implementation and in developing proxy servers for this and other applications. 
In our work, we have seen a fairly strong need to reduce the amount of document data transferred between proxy and mobile client - traditionally, this link is achieved via a slow-bandwidth or high-byte-cost connection (or more often, both) such as the ARDIS network or a 2400bd modem connection. 
As we approach incorporating HTTP 1.0 support, we have debated adding a subdocument query extension to HTTP, to support the following scenario: 1. 
The mobile client requests a document from the proxy, indicating it only wants a single "page" (of client-specified length). 
2. The proxy fetches the full document (or perhaps only the first page, depending on the version of its source) 3. The proxy returns the desired "page" to the client. 
This page is an arbitrary range of bytes, which requires that the client have some mechanism of dealing with fragmented data (split HTML tokens, for example, or reuniting pieces of a split graphic as required). 
By allowing this "paging" to be performed by the proxy, which presumably has an inexpensive high-bandwidth connection, we can decrease transfer time and transfer cost. 
Our user studies have indicated that in a large number of situations, only a small segment of a document (usually, although not always, the beginning) is used by a user before pursuing another. 
Rather than using a start/stop scheme, we thought that this paging mechanism would be more robust. 
Based on our experience in mobile data transfer, we think an extension to the Request Header of HTTP 1.0 requests to permit the request of only a certain byte range may be of use to more than just us and our customers; as wireless access to the network grows, proxy servers used by wireless providers could offer this mode to lower transfer time and save customer costs, for example. 
Thus, we felt it would be best to call your attention to our efforts in the hopes that a unified standard for this mechanism could be made. 
We would thus respectfully submit an additional keyword to the Object header to denote the range of octets for a particular document being requested. 
This keyword would be known as Octet-Range, and perform as follows. 
BNF Description of Octet-Range in the Object Header: Octet-Range = "Octet-Range" ":" start "-" end start = 1 * DIGIT end = 1 * DIGIT Requests including the Octet-Range Object Header would generate responses containing only those octets in the Object Body offset by the start value (counting from zero) and through the end, or the end of the Object Body, whichever resulted in the smallest Object Body. 
It is an error to return Octets before the indicated start offset, or after the indicated end offset. 
A response incorporating the Octet-Range would return the Octet-Range of the request, and the associated octets of the Object Body as the Object-Body. 
In the event that the end offset was greater than the total number of octets, the Octet-Range Header still has its original value, but the Content-Length Object Header shall indicate the number of octets actually returned. 
(The client may be able to then deduce the true total length of the document as its start plus the returned number of octets without the need for a HEAD request). 
Your consideration of this matter is appreciated. 
Please feel free to contact us with any comments, questions, or feedback you may have. 
Best Regards, Ray Rischpater Software Craftsman AllPen Software, Inc. (408) 399-8800 voice dove@allpen.com 
dove@eWorld.com 
In message 9503230830.tn68105@eworld.com of Thu, 23 Mar 1995 08:30:44 The mobile client can do this by specifying a small TCP receive window and not opening it again. 
If you want the first 1024 bytes, for instance, you set the TCP receive window to 1024 + the probable length of the reply header. 
When you receive the reply header, make sure the TCP window doesn't move, but will decrease to zero. 
If the user wants more of the document (or it doesn't fill a page, or whatever), a TCP ACK can be sent reopening the window. 
If the proxy hasn't timed out yet, then you win (why? 
because under your proposed scheme the client would have to make a second request to the server for the next page in all cases). 
If the proxy has timed out you have to reconnect. 
To prevent overloading the proxy, the client should reset the quiet TCP connection after a while. 
It's ungracious, but a normal close would wait for the proxy to download the rest of the data, which is wrong. 
This was discussed on the http list a short while ago. 
Some servers implement a hack where ";bytes=0-1023" can be appended to a URI to request the first 1024 bytes, etc. Larry Masinter mentioned a GET_PARTIAL request, which I'd prefer if you're going to do something like Octet-Range. 
The Relative URI draft mentions the "param" part of the URI (after the semicolon). 
This seems to bless WN's ;bytes=start-finish hack. 
Plus it has prior implementation (I'm told GN does the same thing). 
So I'd recommend using a WN-style "bytes" param in the URI. 
There's no technical problem implementing Octet-Range that I can see, it's just that it seems aesthetically important that the URI should correspond to the data returned (rather than to a larger body containing the returned data). 
Interesting job title. 
Adrian.Colley@sse.ie 
g=Adrian;s=Colley;o=SSE;p=SSE;a=EIRMAIL400;c=ie employer: Software and Systems Engineering (+=disclaimer) (Perth)- o~^\ Y!AWGMTPOAFWY? 
4 lines, ok? qebas perl unix-haters kill microsoft \@##/ The mobile client can do this by specifying a small TCP receive window and not opening it again. 
If you want the first 1024 bytes, for instance, you set the TCP receive window to 1024 + the probable length of the reply header. 
When you receive the reply header, make sure the TCP window doesn't move, but will decrease to zero. 
Manipulating the TCP window in this way is potentially risky, because it can interact with the so-called "Silly-Window Syndrome Avoidance Algorithm" to produce long delays when absolutely nothing happens for many seconds. 
Presumably, on a low-bandwidth link, this is exactly what you don't want to do! 
The standard sender-side SWS-avoidance algorithm will not send less than one TCP segment if it has ever seen a window larger than one segment. 
E.g., if your segment size (MSS) is 512 bytes, the receiver has at least once advertised a window of 1024 bytes, and has shrunk the window to (say) 256 bytes, the sender-size SWS-avoidance algorithm will delay transmission. 
In theory, this delay is supposed to be about 200 msec (i.e., not very long), but in most BSD-derived systems, a bug pegs this delay at about 5 seconds. 
So the key to making your suggestion work is "never shrink the window size below the MSS." 
(In fact, the lower limit might be 2*MSS; I remember that this was a critical limit in some cases, but I can't remember exactly which ones. 
It has to do with the standard delayed ACK policy.) 
I suppose it is likely that on a low-bandwidth link, the MSS will be set fairly small ... but it is not always possible for the application to know/control the actual MSS. 
Proceed with caution. 
-Jeff What's more, HTTP should be considered transport independent. 
Relying on something as cheesey as twaddling the underlying protocol to do something that should be under conscious control between the client and server is a gross hack. 
Either build the mechanism into HTTP or live without it. 
Hacking the transport layer as a means to this end is a recipe for wreck and ruin the minute someone sticks this protocol on top of something besides TCP/IP. 
Remember, WWW != Unix and HTTP != TCP/IP. 
Chuck Shotton cshotton@biap.com http://www.biap.com/ 
cshotton@oac.hsc.uth.tmc.edu "I am NOT here." 
In message ab973a1d0802100484fc@[129.106.201.2] of Thu, 23 Mar 1995 Well, of course it's a cheesey hack. 
But to continue the distraction for a moment, I note that all transports of note have a flow-control element which can be abused to implement "tentative download". 
Jeff Mogul's comments on SWS are well taken: I'd forgotten about SWS. 
I still think it should be done using uri;bytes=... Adrian.Colley@sse.ie 
g=Adrian;s=Colley;o=SSE;p=SSE;a=EIRMAIL400;c=ie employer: Software and Systems Engineering (+=disclaimer) (Perth)- o~^\ Y!AWGMTPOAFWY? 
4 lines, ok? qebas perl unix-haters kill microsoft \@##/ 
