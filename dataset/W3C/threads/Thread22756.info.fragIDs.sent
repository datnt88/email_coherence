Hi, 
Is a NodeNamedMap ever used to hold anything but the Attrs of an Element? 
Might an Attr be an entry in more than one 
NamedNodeMap? 
A simply way to implement NamedNodeMap in c is to just add nextAttr and previousAtt members to Node and make NamedNodeMap a struct like: struct DOM_NamedNodeMap { unsigned long length; 
DOM_Node *first; DOM_Node *last; 
If the answers to the above questions are "no" I don't see a problem with this technique. 
Do you? 
Thanks Mike 
Yes -- they are used to hold the entity and notation definitions in the DocumentType node. 
I don't think Attr nodes can appear in more than one map. 
Whether or not this is a reasonable implementation approach depends on how you handle default attributes derived from the DTD; if you support a DTD, this may not be a good approach, especially if you support DOM mutation. 
(And yes, I think mutation should be a separate feature from simple read-access! 
But that's a different topic.) -Fred Fred L. Drake, Jr. fdrake at acm.org PythonLabs at Digital Creations 
Yes, I've since been informed by others that using members of Node to directly implement the NodeList will not work. 
I have a separate data structure for this now. 
It's a little inelegant to perform the pointer manipulations for each operation twice though; once for the NodeList itself and then again to update the members of Node. 
However, I have a new question. 
Imagine a NodeList is returned by getElementsByTagName. 
Then a Node in the DOM tree is modified (e.g. replaced, removed, etc). 
Will these changes be reflected in the NodeList returned by getElementsByTagName? 
If so this requires active communication between the DOM and any outstanding NodeLists. 
Is this true? 
Is there a way to make the view passive so that no active updating of outstanding NodeLists is required? 
Thanks, 
Mike 
From:Fred L. Drake, Jr. [SMTP:fdrake@acm.org] 
Sent:Wednesday, July 11, 2001 2:57 PM Subject:Re: NamedNodeMap 
From the Document Object Model (DOM) Level 2 Core Specification [1]: "NodeList [p.43] and NamedNodeMap [p.44] objects in the DOM are live; 
that is, changes to the underlying document structure are reflected in all relevant NodeList and NamedNodeMap objects. 
For example, if a DOM user gets a NodeList object containing the children of an Element [p.52], then subsequently adds more children to that element [p.98] (or removes children, or modifies them), those changes are automatically reflected in the NodeList, without further action on the user's part. 
Likewise, changes to a Node [p.34] in the tree are reflected in all references to that Node in NodeList and NamedNodeMap objects." 
Christopher Watson Sr. Software Engineer Lightspan, Inc. [1] http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ 
However, I have a new question. 
Imagine a NodeList is returned by getElementsByTagName. 
Then a Node in the DOM tree is modified (e.g. replaced, removed, etc). 
Will these changes be reflected in the NodeList returned by getElementsByTagName? 
If so this requires active 
communication between the DOM and any outstanding NodeLists. 
Is this true? 
Is there a way to make the view passive so that no active updating of outstanding NodeLists is required? 
This is the only interpretation I've ever heard, and I've heard little but griping about it. 
For most purposes, a fairly static NodeList is sufficient; for NodeList objects used to implement the childNodes attribute, there's not much of a problem, but the getElementsByTagName() and getElementsByTagNameNS() return values are problematic. 
My own DOM implementation is non-conforming in this regard, and I haven't heard any complaints from the users. 
I don't think the liveness requirement is described very carefully; 
if I have a node that I remove from the tree, and then add to another location, should the node be included in any NodeList objects returned from getElementsByTagName()? 
It's still "owned" by the document, and I may well stick it back in the tree somewhere. 
I'm sure this is covered somewhere, but this kind of thing ends up being a sticking point for me. 
-Fred Fred L. Drake, Jr. fdrake at acm.org PythonLabs at Digital Creations 
Yes, I'm quite familiar with this. 
The childNodes NodeList easy. 
It's when a select non-continous group of Nodes must be maintained and up to date. 
Ok, I'm glad I'm not the only one that is confused by this. 
The only way to implement this functionality verbatium that I can see would be to have an active NodeLists table for each Node. 
If a Node is 
selected for inclusion in a NodeList a pointer to that list is saved in a list of NodeLists that reference this Node. 
Then, at any time, if that Node is modified, replaced, removed, etc the appropriate action is performed on all active NodeLists for that Node. 
The table could be a hashtable member of Document. 
Whenever a node is freed the table entry is removed (after all it's NodeLists are updated of course). 
I beleive it could be done in an efficient manner actually. 
I think I'll get the basics working first. 
Thanks for your help, Mike 
From:Fred L. Drake, Jr. [SMTP:fdrake@acm.org] 
would  be to have an active NodeLists table for each Node. 
Think about memory management and object lifetime issues before you go that route. 
Joe Kesselman / IBM Research 
Whoops; not for *each* Node. 
Only one hash table per tree would be necessary. 
Mike 
-----Original Message----- From:Fred L. Drake, Jr. [SMTP:fdrake@acm.org] 
I don't think Memory Management would be an issue. 
In your destroyNode function you remove the list of NodeLists and if it's not NULL remove the entry from each . 
Then free the node per usual. 
I'm not really sure what you mean by object lifetime issues though. 
Do you mean their liftimes would be so short that all the extra machinery becomes silly? 
I agree, but I see no alternative. 
Mike 
From:Joseph Kesselman [SMTP:keshlam@us.ibm.com] 
Sent:Wednesday, July 11, 2001 4:48 PM Subject:RE: NamedNodeMap 
I don't know that it would be a problem for you (I vaguely recall you said you were working in C or C++), but it could be a problem for garbage-collected system. 
Circular references were considered a huge problem in older versions of Python because it used only reference counting for GC, and even today the cycle detector is optional (it *does* have a performance penalty, as all "real" GC systems do). 
With non-refcount GC, there can be a lack of temporal proximity between an object becoming garbage and being collected; unless you collect frequently (higher overhead), you can accumulate an enormous amount of garbage very quickly if you use a lot of temporary objects. 
-Fred Fred L. Drake, Jr. fdrake at acm.org PythonLabs at Digital Creations 
