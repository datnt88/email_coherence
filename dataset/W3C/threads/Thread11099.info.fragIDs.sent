From: Peter Murray-Rust Peter@ursus.demon.co.uk ... when I demonstrate this facility to people who haven't seen XML before, and tell them it *comes free with the [draft] language* they are impressed. 
It's a very strong selling point over other approaches. 
I just conducted the technical half of a day-seminar on XML. 
They gave an ovation at the end (because of excitement about XML, not my fascinating teaching postures :-) They were most impressed with SHOW and ACTUATE. 
I think their view was that these are simple enough to do lots of wonderful things. 
It would make sense, I guess, if XML 2.0 had a link behaviour specification language, I think SHOW and ACTUATE provide nice, generic defaults and they should *definitely* be kept in XML 1.0. 
They asked about how what gets returned by a ID(x1)..ID(x2) when these ids of element in 
different branches of the element tree: does just the text get returned or does a clipped tree 
get returned or what. 
If text is returned, is it XML.. I didn't know. 
Any ideas yet? 
One thing to do (I guess Elliot "Dr Fragment" Kimber is more on top of the issues) would be: 
traversing a link with pointer ID(x1)..ID(x2) to would get a document like this: 
I don't see how we can have .. between branches without also specifying some fragment 
exchange conventions, since otherwise the XML document must be well-deformed and invalid. 
Another approach would be an index into the actual character of the document (RS=nominal record 
start =~ start of line). 
Lets assume that fragments are always generated by computer, and that no transcoding goes on that changes the number of characters, and that any header adjustments get done before the doctype. 
The document could be pruned of data outside the range, and any optional outside elements, if the implementor felt like it, for efficiency reasons. 
If we don't define a fragment convention, I think xml-link spec will have to say that ranges that span branches are only possible on the client, i.e. with "#" not "?XML-LINK=". 
[Of course they ask about regexp :-)]. 
No. Mine didn't: they were commmercial HTML &amp; SGML suppliers, from legal &amp; CALS areas mainly, 
and they were more interested in users being able to access information only by the elements 
the providers had marked up. 
They generally don't want users to play with the data. 
Rick Jelliffe 
In all of these discussions, it's critical to keep separate the source, which is what XML lang (like SGML) defines the rules for, and the parsed result of processing that source, which is what XML Link (like HyTime) operates on. 
Once the documents have been put into memory, issues like well-formedness and even validity go away, because those are syntax issues, and syntax is transcended once the document is parsed (and only resurface when you want to create a new source document). 
Validation is only an issue if you make it one--editors, for example, have states where validation issues are ignored. 
Browsers may never care about 
validity because it doesn't matter if the document conforms to a particular 
schema. 
Perhaps it's better to say that validity *can be ignored* in the abstraction, not that it goes away. 
Cheers, E. 
In all of these discussions, it's critical to keep separate the source, which is what XML lang (like SGML) defines the rules for, and the parsed result of processing that source, which is what XML Link (like HyTime) operates on. 
Once the documents have been put into memory, issues like well-formedness and even validity go away, because those are syntax issues, and syntax is transcended once the document is parsed (and only resurface when you want to create a new source document). 
Well-formedness is a syntax issue. 
Validity remains an issue for the application because it is also a statement about the abstract structure of the 
document. 
Matthew Fuchs 
matt@wdi.disney.com 
of element in 
does a clipped tree 
ideas yet? 
Thinking of it as returning some actual data inevitably leads to problems. 
Whether it "returns" something, and just what, is hard to say. 
Remember that a reference to data is not the same as the data itself. 
And spans only really make much sense as a *reference*. 
This is much like the distinction missed by an infamous query language long ago, which required that if you searched for a word, say "foo", what you would get back was every "foo" in 
the searched document(s): foo 
foo foo This is just a tad less useful than returning ID (sec2.1) 
CHILD (5 P) TOKEN (5) ID (sec3.7) 
CHILD (99 I) TOKEN (27) ID (sec3.7) 
CHILD (99 I) TOKEN (39) It is possible to get a list of three copies of the string "foo" from a list of three pointers to them; the reverse is not possible (if it is, you're carrying around some *other* information secretly to do it, and *that* information is what we're really talking about then). 
this: Exactly the point: you *don't* get "a document" at all. 
You get a reference to a range of data in a document. 
Not the same thing. 
Whether the string that existed in the pre-parsed XML document is a useful thing to retrieve and process apart from its context is application-dependent. 
An editor might want to support pasting it in in place of an identically-asynchronous span in some other document, for example; but a viewer could not likely make much sense of it (even if it recovered gracefully from WF violations). 
A span is not a subtree; that's why it's a span. 
CALS areas mainly, 
only by the elements 
the data. 
In that environment, it may well be that you don't need spans; or even that you specifically need to rule out use of spans. 
Or you might want to insist that spans are never tranferred out of context. 
Indeed, many applications will always want to send subtrees of a given level (say, SECTION), and then simply highlight a target within it. 
Perfectly normal hypertext system behavior, and "selection" and "document" need not by interchagneable concepts. 
Steven J. DeRose, Ph.D., Chief Scientist Inso Electronic Publishing Solutions (formerly EBT) 
of element in 
does a clipped tree 
ideas yet? 
issues) would be: 
this: Nothing is "returned"; you don't "get to a document". 
Pointers address data structures in memory, not literal documents. 
Thus, the wellformedness of what's addressed isn't an issue. 
Remember that editors and browsers operate on an abstract representation of the parsed document, not the document itself. 
Communication among tightly-integrated processors must be in terms of these abstractions, not literal syntax. 
This is why DSSSL and HyTime had to have groves: they needed a common way to talk about the 
result of parsing, which is what groves are. 
It's the same reason the DOM 
group exists. 
SGML is complicated enough that there are many possible equally valid and equally useful abstract representations of parsed results. 
Therefore, you either need to agree on one or define a meta-mechanism by which such abstractions can be defined (which is what property sets and grove plans are for DSSSL and HyTime). 
In all of these discussions, it's critical to keep separate the source, which is what XML lang (like SGML) defines the rules for, and the parsed result of processing that source, which is what XML Link (like HyTime) operates on. 
Once the documents have been put into memory, issues like well-formedness and even validity go away, because those are syntax issues, and syntax is transcended once the document is parsed (and only resurface when you want to create a new source document). 
Cheers, Eliot W. Eliot Kimber, Senior Consulting SGML Engineer Highland Consulting, a division of ISOGEN International Corp. 2200 N. Lamar St., Suite 230, Dallas, TX 95202. 
214.953.0004 www.isogen.com 
If links are the same kind of thing as formatting, then we should anticpate: * an equivalent to inline attribute-based formatting like HTML FONT (i.e. SHOW, ACTUATE, BEHAVIOUR), * an equivalent to CSS (drm's suggested stylesheets), and * an equivalent to DSSSL (HyTime queries?). 
Each of which will be useful to various groups. 
I don't think one competes with the others, except for appropriateness in any given system and user group. 
In any case, an application can ignore the values of any attribute it wants to. 
The SHOW and ACTUATE attributes can act as defaults or hints for browsers in the absense of any other policy. 
Rick Jelliffe 
