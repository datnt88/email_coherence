I hope that the views in this posting won't upset too many people - they are meant to re-emphasise the unknown areas that XML will be used in and what it needs to cater for. 
I am assuming that XML will be a success. 
In that case, most of the people using it will be completely new to SGML, its traditions, its terminology and its syntax. 
I suspect that most of the people on the WG - who are battle- hardened SGML professionals - have forgotten how hard it is to learn SGML. 
I don't know whether there are other webhackers on this list (i.e. people who have never had to hack SGML as part of their raison-d'etre) - if so I think that their views should be listened to. 
If not, then please treat mine as a sample of 1 from a very large population and scale accordingly. 
Having been called the WG's bellwether (sic) - a ('ringleader, or loud turbulent fellow' according to my dictionary) the rest of this presents my view of the webhacker and what they want (not necessarily what they need) from XML. 
It took me three years to learn SGML, its terminology, its syntax (which I find the most difficult I have come across). 
90% of the XML-users in a years' time will have had no contact with SGML. 
Most will not be CS graduates - most will be Dirty Perl Hackers and HTML hackers. 
I base this on the likelihood that they will encounter it through browsers, through webzine hype, etc. 
When Java came out it was seen as a way of making images dance across the screen, rather than the (good) OO language that it is. 
XML will similarly be seen as a roll-your-own tag factory. 
The real power will be ignored (at least at first). 
Most webhackers need quick fixes. 
They have little time to go into the difficult parts of languages until they have to. 
DTDs take a great deal of time to create well. 
I know this is true because every time someone posts on c.t.s the universal reply is 'you really have to take time to understand your data model, don't rush into creating a DTD quickly, you have to keep revising it till you've got it right.' 
I don't quarrel with this :-) Most of the next generation of XML-techies are not going to create DTDs. 
They don't know how, haven't been apprenticed, and don't see the point. 
So the number of DTDs created will be quite small. 
Most of these will come from the currently SGML-literate. 
IMO this represents quite a small proportion of the XML community - if it doesn't then XML will not be a universal success. 
To make XML a success initially it has to be simple. 
I hope that whatever the ERB decides on the last 3-4 weeks' discussions, they recognise that XML must have an entry point that entices non-SGML-literates to start playing, **without help from the SGML community.** Please also accept that some of the things labelled 'simple' in the XML spec are not necessarily simple for newcomers. 
PE's may now be simple, but their implementation is not easy to determine from the spec. 
If they really are as simple as DEFINE, then highlight the rules, please :-) Personally I believe that DTD validation will be a fairly small part of what people will require from the validation process. 
IMO a serious lack in SGML is any requirement to add any machine or textual semantics to the DTD. 
There is no mechanism for extracting DTD information into processing code, no WEB-like (in the DEK sense) way of documenting it. 
How do I find out what FOO actually means to a human? 
How do you extract the human semantics from (say) HTML2.0 - it's in a completely separate document. 
What most people will want is intimate linking of tags to semantic information. 
This isn't to say that DTDs aren't important. 
I've written them for CML, but they have to be so flexible that they have few constraints. 
What is far more important is what semantics attach to each element, and I've put a lot of (probably very amateur) work into that with glossaries, Java methods, etc. 
I have just come back from two days about Objects in Bioinformatics - the human genome, etc. 
Our community are addressing information sharing, and they don't use SGML. 
They currently use FORTRAN-formats. 
Now they are looking for the next generation - and the embryonic universal solution is CORBA and JAVA/C++. 
This will manage most of what they want to do. 
So I am trying to sell them XML. 
Why, and how? 
- it is simpler (unless it gets made too complicated). 
- it can be read by humans. 
They can touch and feel the data. 
They aren't frightened of angle brackets any more. 
It can be hacked. 
It's the obvious replacement for their FORTRAN files. 
- it will be in the browsers. 
(BUT so ar ORBs (the latest Netscape has an ORB - Visibroker, I believe.) This means that they will discover this wonderful thing XML and start hacking. 
Not the slightest chance that they will use DTDs. 
So IMO this posting represents something moderately close to 90% of the likely XML community. 
If you want XML to be widely used you have to take note of it. 
You may not like it, but it's reality. 
I am really looking forward to July 1. 
I will do my best to implement what emerges. 
:-) P. Peter Murray-Rust, domestic net connection Virtual School of Molecular Sciences On Fri, 20 Jun 1997 18:12:18 -0400 (EDT) Peter Murray-Rust said: All likely enough. 
These are good reasons not to force people to use DTDs in XML, and it is for reasons like these that DTDs were made optional in the first place. 
When did these become reasons to *forbid* DTDs to those who do know how to make them, or who do want to use the DTDs made by others? 
OK. I've made one suggestion (define PE resolution as optional for non-validating parsers). 
If that is adopted, PE resolution can be performed by a pre-processor which knows about nothing except PE entity declarations, marked sections, and PE references (attending to marked sections is presumably the one thing Henry Thompson's preprocessor doesn't do: if it did, Henry wouldn't be bothering to expand PE references within ignored sections ...), and any copy of Software Tools should allow you to build the PE pre-processor. 
(You can extend it to expand all general entities except  etc., too, if you want to really simplify life downstream.) 
Here's another. 
I've said that the XML restrictions on where PE refs are recognized and expanded are easy to enforce if the relevant entity boundaries are exposed in the grammar (I'm assuming a yacc/lex-style division of labor; those writing recursive-descent parsers will need longer look-aheads than a single token, but should get by with finite lookahead). 
To make this process simpler, I've made an experimental version of the XML spec, in which the % operator appears *only* when it governs the entire right-hand side of a production. 
Each rule of the form lhs ::= %(r1 r2 r3) can be translated into yacc in the form lhs ::= r1 r2 r3 PE_START r1 r2 r3 PE_END From there on out, the parser generator should take care of things, if you're using one. 
If you're not bothering to expand the PE refs, then the rule is translated into yacc as: lhs ::= r1 r2 r3 PE_REF In which case the lexer is responsible for returning PEREF at the right times. 
If those interested would take a look at the resulting grammar and see whether it helps or not, I'd be grateful for comments. 
The experimental version of the spec is at: (as the path suggests, this is not intended for public distribution; please don't point at it from public pages, and remember I will probably take it down without warning.) Don't bother pointing out that the names of the new non-terminals aren't very good ones: I know that. 
If you can think of better ones, I'd like to hear them. 
Tim asked whether we could at least forbid PE refs in the internal subset. 
Answer: not without loss of function. 
The customization of DTDs via PEs uses the internal subset -- at the very least, as in the TEI, you need to declare a couple PEs with magic names, so the parser knows where to find your local modification files. 
In other DTDs, all the local customization typically takes place in the internal subset. 
So the compromises which seem plausible to me are: - make PE resolution optional for non-validating parsers (somehow; this will require a language-lawyer's eye to ensure that the end of the internal subset can be detected) - make PE error-detection optional for non-validating parsers (i.e. say 'non-validating parsers can treat this as if it were macro expansion -- users, however, should not try to get clever') - simplify the grammar by restricting PEs further, if need be, or by restricting the % operator to action on entire right-hand-sides, as in my test version of the spec (*if* that change seems like a simplification to those concerned) -C. 
M. Sperberg-McQueen [... Michael also took the trouble to write separately as well, and I think we have a clear understanding...] To make it quite clear, I wasn't suggesting dropping DTDs, but was concerned that the requirement to implement highly complex DTDs (i.e. thousands of lines) required a PE system which some implementers would find too difficult and which wasn't *required* for their much simpler DTDs. 
[... PE syntax snipped...] I am prepared to take on trust that Michael's new proposal(s) is/are straightforwardly implementable and support the ERB in whatever solution they propose. 
If it's clearly presented then I think that it's implementable by a webhacker. 
P. Peter Murray-Rust, domestic net connection Virtual School of Molecular Sciences On the contrary, I suspect that most battle-hardened SGML professionals think its so hard to learn SGML that the possibility of SGML-like dialects would only make matters worse. 
Yes! 
The WebSGML TC has a parameter called "Application Requirements", with the keyword "SEEALSO" followed by identifiers. 
It allows an SGML document to be decorated with locations of human-readership documentation about the semantics of the document, and indeed, about any syntactical or semantic conventions used in the document in addition to SGML. 
You can see this described in the draft WebSGML TC at under "Application Requirements". 
Everyone on this WG should at least glance through it, I think. 
SEEALSO allows you, for example, to document that in your element types declarations, there is a fixed link attribute giving the location for documentation of the semantics of the element. 
(I.e. a dreaded Architectural Form). 
!ATTLIST elementX memymomemu CDATA #FIXED "http://www.me.com/dtd-doco.xml#elementX" 
These additional requirements are different from conventional comments, in that they are simple identifiers, which an application can use to switch in any extra validity checks the vendor has cared to implement. 
I hope people will support Application Requirements to their national standards representatives, and suggest any improvements. 
For example, they should be in the DOCTYPE declaration, not the SGML declaration, IMHO: !DOCTYPE cml SYSTEM SEEALSO PUBLIC "IDN//W3C//NOTATION XML 1.0//EN" SYSTEM "http://www.me.com/xml-subset-used-by-cml.html" 
SYSTEM "http://www.me.com/cml-doco.html" [...] I hope that XML will adopt this too. 
Arjun is right: documents should be able to be labelled with everything needed to use them. 
Rick Jelliffe This is a correction to a statement made by Peter M-R that has as much to do with SGML as XML. 
Peter Murray-Rust would be correct to say that SGML *has not had* an a mechanism for documenting the semantics of GIs, attribute names and values, etc. Thankfully, however, that is no longer the case. 
The SGML Extended Facilities (Annex A of ISO/IEC 10744, 2nd edition) provides mechanisms for stating rigorously (and electronically retrievably) the semantics of DTDs, including both their intrinsic and their emergent semantics. 
The intrinsic semantics are attachable by means of property location addresses used by hyperlinks. 
Using a proploc (or queryloc using SDQL) you can point at the element type definition of a particular element type, an attribute definition of that element, etc., perhaps making a hotspot at the DTD end, at the semantic definition end, and perhaps also at each instance of the element type. 
The names of the properties of SGML documents, including their DTDs, are standardized in the SGML Property Set found in Clause 9 of DSSSL (ISO 10179) and in the 2nd edition of 10744. 
If the properties of documents conforming to certain DTDs (architectures) are "emergent" (i.e., they do not correspond in a one-to-one manner with DTD-defined constructs), you can create a property set for documents conforming to such architectures, and link the document instance's instances of such emergent phenomena with documentation that described them in an "architecture definition document". 
Again, a proploc (or queryloc using SDQL) can be used to address (and link) to the constructs exhibiting such emergent properties. 
The standard property set for HyTime appears in Annex B of ISO 10744 2nd Edition. 
Best regards, --Steve Steven R. Newcomb President voice +1 716 271 0796 TechnoTeacher, Inc. Internet: srn@techno.com 
Rochester NY 14618) FTP: ftp.techno.com 
P.O. Box 23795 WWW: http://www.techno.com 
Rochester, NY 14692-3795 USA 
