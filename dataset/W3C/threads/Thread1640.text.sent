Given a VCR that has been checked-out by userA. 
userB's versioning unaware client performs a PROPFIND of DAV:lockdiscovery on that VCR. 
Should the DAV:lockdiscovery value be the same as if userA had performed a LOCK request? 
Thanks, Steve If it was "checked out" with a LOCK (server doesn't support, or client didn't use CHECKOUT), then yes. 
Otherwise no. 
There are other properties that can be used to determine if a resource is checked out. 
Given a VCR that has been checked-out by userA. 
userB's versioning unaware client performs a PROPFIND of DAV:lockdiscovery on that VCR. 
Should the DAV:lockdiscovery value be the same as if userA had performed a LOCK request? 
Thanks, Steve I guess I wasn't too clear... UserA performs a CHECKOUT on a VCR. 
UserB performs a PROPFIND of DAV:lockdiscovery to determine if the resource is "locked" (since the client is versioning unaware, ie only a class 2 DAV client) What will DAV:lockdiscovery be? 
If UserB's client is unaware of the DAV:checked-out property, then how will they know it is "locked"? 
Thanks, Steve Steve, If UserA does a CHECKOUT, the resource won't be locked, it will just be checked out. 
PROPFIND on DAV:lockdiscovery won't show any locks to anyone. 
Now UserB doesn't know anything about versioning. 
If UserB just looks for locks and upon not finding any assumes the resource is writable, the write will fail because the resource is already checked out. 
LOCK will also fail for the same reason, it tries to do an implicit checkout. 
We assume that versioning unaware clients are not DAV unaware. 
That is, they can use PROPFIND and look at properties, including properties that indicate something is checked out. 
Its actually the user that's interperting this information, not the client. 
The client doesn't have to support any versioning specific protocol to access these properties. 
Although such clients make their users do extra work. 
I guess I wasn't too clear... UserA performs a CHECKOUT on a VCR. 
UserB performs a PROPFIND of DAV:lockdiscovery to determine if the resource is "locked" (since the client is versioning unaware, ie only a class 2 DAV client) What will DAV:lockdiscovery be? 
If UserB's client is unaware of the DAV:checked-out property, then how will they know it is "locked"? 
Thanks, Steve That's impossible. 
Many clients won't show properties that they're not aware of. 
C.F. Web Folders. 
lisa [mailto:ietf-dav-versioning-request@w3.org]On 
Behalf Of Jim Amsden Steve, If UserA does a CHECKOUT, the resource won't be locked, it will just be checked out. 
PROPFIND on DAV:lockdiscovery won't show any locks to anyone. 
Now UserB doesn't know anything about versioning. 
If UserB just looks for locks and upon not finding any assumes the resource is writable, the write will fail because the resource is already checked out. 
LOCK will also fail for the same reason, it tries to do an implicit checkout. 
We assume that versioning unaware clients are not DAV unaware. 
That is, they can use PROPFIND and look at properties, including properties that indicate something is checked out. 
Its actually the user that's interperting this information, not the client. 
The client doesn't have to support any versioning specific protocol to access these properties. 
Although such clients make their users do extra work. 
I guess I wasn't too clear... UserA performs a CHECKOUT on a VCR. 
UserB performs a PROPFIND of DAV:lockdiscovery to determine if the resource is "locked" (since the client is versioning unaware, ie only a class 2 DAV client) What will DAV:lockdiscovery be? 
If UserB's client is unaware of the DAV:checked-out property, then how will they know it is "locked"? 
Thanks, Steve From: Steve K Speicher [mailto:sspeiche@us.ibm.com] 
I guess I wasn't too clear... UserA performs a CHECKOUT on a VCR. 
UserB performs a PROPFIND of DAV:lockdiscovery to determine if the resource is "locked" (since the client is versioning unaware, ie only a class 2 DAV client) What will DAV:lockdiscovery be? 
It will be whatever it was before the CHECKOUT. 
A CHECKOUT does not affect the DAV:lockdiscovery property of a resource. 
If UserB's client is unaware of the DAV:checked-out property, then how will they know it is "locked"? 
The DAV:checked-out property has nothing to do with the locked status of a resource. 
If you want to know if a resource is in the checked-out state, you look to see if it has a non-null DAV:checked-out property. 
If you want to know if a resource is locked, you look at the DAV:lockdiscovery property. 
From: Jim Amsden If UserA does a CHECKOUT, the resource won't be locked, it will just be checked out. 
PROPFIND on DAV:lockdiscovery won't show any locks to anyone. 
Right. 
Now UserB doesn't know anything about versioning. 
If UserB just looks for locks and upon not finding any assumes the resource is writable, the write will fail because the resource is already checked out. 
The write will succeed unless the locks and acl's of a resource do not allow it (it is irrelevant whether userA or userB did the CHECKOUT ... the result is a writeable checked-out resource). 
LOCK will also fail for the same reason, it tries to do an implicit checkout. 
LOCK does not do an implicit CHECKOUT. 
When the DAV:auto-version property is set, a write operation on a write-locked *checked-in* resource can automatically cause a CHECKOUT, but it is the write operation, not the LOCK that does the CHECKOUT, and this only occurs when the write-locked resource is in a *checked-in* state. 
We assume that versioning unaware clients are not DAV unaware. 
That is, they can use PROPFIND and look at properties, including properties that indicate something is checked out. 
Its actually the user that's interperting this information, not the client. 
The client doesn't have to support any versioning specific protocol to access these properties. 
Although such clients make their users do extra work. 
From: Lisa Dusseault [mailto:lisa@xythos.com] That's impossible. 
Many clients won't show properties that they're not aware of. 
C.F. Web Folders. 
Impossible is a bit strong ... a WebDAV clients can (and arguably should) show properties they are not aware of (otherwise dead properties become rather useless). 
And for clients that choose to display only the properties they know about, it is pretty much inevitable that a user of such a client will not be able to find out about protocol extensions such as versioning. 
Cheers, checked Actually, the resource will have the same locked status as before the CHECKOUT. 
write Being checked-out does not make writes fail! 
I'm not sure what you were thinking of here Jim, but when User B shows up, there is a checked-out VCR so, from a versioning point of view it is mutable. 
The fact that it was User A that did the CHECKOUT and User B that does the PUT is irrelevant in the versioning story. 
(Of course there is still the lock status that existed before the checkout and acls etc to clear before you can be assured that the write will succeed.) LOCK will also fail for the same reason, it tries to do an implicit checkout. 
LOCK doesn't do an implicit CHECKOUT -- ever. 
Are you thinking of auto-versioning of a checked-in version-controlled resource? 
Within the versioning protocol we don't assume that version unaware clients have any knowledge of the versioning properties to make things work, and we have not put any such requirements on RFC2518, so I'm not sure what you mean here. 
That would require the user to be versioning aware, which is almost the same thing. 
Tim I guess all this boils down to is that UserA should first do a LOCK then a CHECKOUT? 
...or a CHECKOUT then a LOCK? 
But section 4 "CHECKOUT Option" states: "The checkout option provides an alternative method that avoids the complexity of the locking protocol". 
How am I to interpret this sentence based on what I've heard in this thread? 
Thanks, Steve Actually, it all boils down to 'what are you trying to do'? 
g LOCKing is designed to prevent the lost update problem. 
CHECKOUT marks a version-controlled resource as mutable, and is used with CHECKIN to create a new version. 
Acquiring a LOCK on a checked-in version-controlled resource is harmless, but versioning semantics will prevent the content of the checked-in version-controlled resource from changing anyway. 
So it depends upon your client goals -- a typical sequence for updating content and capturing it in version history would be: LOCK /foo CHECKOUT /foo GET /foo PUT /foo CHECKIN /foo UNLOCK /foo (or even GET after LOCK and before CHECKOUT). 
This will guarantee that the update that you PUT is based on the content that you GET, and that the new state is captured in the version history. 
However, your initial LOCK does not prevent others from checking the resource out 'in parallel' and creating a 'branch' (there are other solutions for that if it is of concern). 
Well, to be fair you have to take that sentence in context. 
The preceding sentence talks about the undesirable proliferation of versions that can occur if every modification is a new version, and how LOCK can be used to bound the version creation. 
The locking protocol is only 'complex' in that it obviously requires a DAV 2 server and client (i.e. capable of composing and parsing locking messages, considering the If: header, remembering the lock token, etc.) Maybe 'complexity' should be rewritten as 'overhead' or something a little less onerous. 
Tim UserA's client could do it in either order. 
It really doesn't matter. 
If the client does the LOCK first, it maximizes the chance that UserA will beat someone else who's trying to get a LOCK as well, but if someone else gets in with the LOCK of the checked out resource before you, it just means you have to wait until they are done to make your changes. 
As for "providing an alternative method", this assumes you have multiple workspaces or are using working resources. 
In these cases, you just do CHECKOUT, update, CHECKIN. 
No need really for a LOCK, since you have your own private workspace or working resource. 
Of course, you have to resolve merges in case you ended up doing this in parallel, so you avoid complexity only in cases where you don't end up in a merge situation. 
If you believe the "avoids complexity" sentence is misleading, let me know and I'll revise/remove it. 
Cheers, Geoff I guess all this boils down to is that UserA should first do a LOCK then a CHECKOUT? 
...or a CHECKOUT then a LOCK? 
But section 4 "CHECKOUT Option" states: "The checkout option provides an alternative method that avoids the complexity of the locking protocol". 
How am I to interpret this sentence based on what I've heard in this thread? 
Thanks, Steve IMHO: Since the sentence didn't state that it "avoids complexity" with the use of workspaces or working-resources, I think it should be revised. 
Steve Take the following typical actions of a non-versioning aware client: LOCK /foo GET /foo PUT/foo UNLOCK /foo If the resource is a VCR, then I think what you are saying is that the LOCK will succeed and the PUT will fail (if DAV:auto-version is "never"), since the resource is DAV:checked-in and modifying it would therefore change an already existing version of /foo (not good). 
Though, if the PUT would fail with Locked status-code (assuming it would) but the client would realize that they owned the lock on the resource and think, "Now what do I do?". 
I realize that wanting your versioning server to be DAV class 2 compatible, you wouldn't/shouldn't have DAV:auto-version of "never". 
Do I have a point? 
I guess I just want some justification on my interpretation of this and if the PUT does fail, with what status-code: "423 Locked", ??? Thanks, Steve From: Steve K Speicher [mailto:sspeiche@us.ibm.com] 
Take the following typical actions of a non-versioning aware client: LOCK /foo GET /foo PUT/foo UNLOCK /foo If the resource is a VCR, then I think what you are saying is that the LOCK will succeed and the PUT will fail (if DAV:auto-version is "never"), since the resource is DAV:checked-in and modifying it would therefore change an already existing version of /foo (not good). 
Yes, modifying the body of a checked in version controlled resource is forbidden (in Section 2.10). 
Note: The PUT is being applied to a VCR, not a version, so it wouldn't change an existing version of /foo in any case. 
Though, if the PUT would fail with Locked status-code (assuming it would) but the client would realize that they owned the lock on the resource and think, "Now what do I do?". 
It would not fail with a Locked status code (remember, a checkin is not a lock). 
I realize that wanting your versioning server to be DAV class 2 compatible, you wouldn't/shouldn't have DAV:auto-version of "never". 
Correct. 
Do I have a point? 
I guess I just want some justification on my interpretation of this I'm not sure what you have in mind by "justification". 
You can't modify a checked-in VCR, since that would break the semantics that the content of the VCR is the same as its DAV:checked-in version. 
and if the PUT does fail, with what status-code: "423 Locked", ??? 
The error response (defined in section 2.10, "Additional PUT Semantics"), would be a 403 (if the resource couldn't be checked out) or a 409 (if the resource could be checked out) with a DAV:cannot-modify-version-controlled-content tag in the response body. 
Cheers, Geoff If you're going to have DAV:auto-version == "never", then I'd simply suggest refusing the LOCK request. 
As an empirical data point, mod_dav with Subversion for a back-end will NOT support locking at all (nor auto-versioning). 
Some future version, maybe. 
Instead, we will simply require a version-aware client (which is fine; the SVN command line client is our only required client at this time, and it is certainly aware :-) Cheers, -g Greg Stein, http://www.lyra.org/ 
