I see: 6.4.19.1 Examples * fn:escape-uri 
("gopher://spinaltap.micro.umn.edu/00/Weather/California/Los%20Angeles#ocean", true()) returns "gopher%3A%2F%2Fspinaltap.micro.umn.edu%2F00%2FWeather%2FCalifornia%2FLos%20Angeles%23ocean" 
but the % after Los needs to be escaped, no? 
i.e. the result should be ala... 
from urllib import quote s = 
"gopher://spinaltap.micro.umn.edu/00/Weather/California/Los%20Angeles#ocean" 
quote(s, safe='') 
'gopher%3A%2F%2Fspinaltap.micro.umn.edu%2F00%2FWeather%2FCalifornia%2FLos%2520Angeles%23ocean' 
Note the ...Los%2520... Hmm... the spec seems to special-case this: 
The "%" character itself is escaped only if it is not followed by two hexadecimal digits (that is, 0-9, a-f, and A-F) I don't understand why. 
Also... what does 'when escaping an entire URI or URI reference' refer 
to? 
Hmm... Graham, have you thought about a suite of tests for URI escaping issues? 
Dan Connolly, W3C http://www.w3.org/People/Connolly/ 
from urllib import quote s = 
quote(s, safe='') 
I assume it means escaping a URI, e.g. to be embedded inside another, or 
something like that. 
Not specifically, though I did include some in my suite; e.g. below. 
I've not at all considered escaping entire URIs, which seems to be the thrust of your comments. 
With the respect to the special case you mention, my reading of the spec was that '%' not followed by two hex digits is not valid in a URI. 
Hence my invalid tests. 
My full test suite is in file "URITest.hs" 
at: Of course, many of the tests were lifted from yours. 
#g Excerpts from my tests... -- Invalid testURIRef083 = testURIRef InvRf "%" testURIRef084 = testURIRef InvRf "A%Z" testURIRef085 = testURIRef InvRf "%ZZ" testURIRef086 = testURIRef InvRf "%AZ" testRelative40 = testRelative "testRelative40" "http://example/x/y%2Fz" "http://example/x/abc" "abc" testRelative41 = testRelative "testRelative41" "http://example/a/x/y/z" "http://example/a/x%2Fabc" "../../x%2Fabc" testRelative42 = testRelative "testRelative42" "http://example/a/x/y%2Fz" "http://example/a/x%2Fabc" "../x%2Fabc" testRelative43 = testRelative "testRelative43" "http://example/x%2Fy/z" "http://example/x%2Fy/abc" "abc" testRelative44 = testRelative "testRelative44" "http://ex/x/y" "http://ex/x/q%3Ar" "q%3Ar" testRelative45 = testRelative "testRelative45" "http://example/x/y%2Fz" "http://example/x%2Fabc" "/x%2Fabc" -- Apparently, TimBL prefers the following way to 41, 42 above -- cf. http://lists.w3.org/Archives/Public/uri/2003Feb/0028.html -- He also notes that there may be different relative fuctions -- that satisfy the basic equivalence axiom: -- cf. http://lists.w3.org/Archives/Public/uri/2003Jan/0008.html testRelative46 = testRelative "testRelative46" "http://example/x/y/z" "http://example/x%2Fabc" "/x%2Fabc" testRelative47 = testRelative "testRelative47" "http://example/x/y%2Fz" "http://example/x%2Fabc" "/x%2Fabc" Graham Klyne PGP: 0FAA 69FF C083 000B A2E9 A131 01B9 1C7A DBCA CB5E 
fornia%2FLos%20Angeles%23ocean" 
RFC 2396 states (in section 2.4.2) "Because the percent "%" character always has the reserved purpose of being the escape indicator, it must be escaped as "%25" in order to be used as data within a URI. 
Implementers should be careful not to escape or unescape the same string more than once, since unescaping an already unescaped string might lead to misinterpreting a percent data character as another escaped character, or vice versa in the case of escaping an already escaped string." 
The reason we have specified escape-uri() as we have is that if the input string contains a "%" sign followed by two hex digits, this probably means that escaping has already been carried out. 
We can't be sure, of course, but it's a weakness of the escaping scheme that we have no way of telling. 
We are following the advice "Implementers should be careful not to escape or unescape the same string more than once". 
We followed precedent here from some other spec, but I forget which it was. 
The escape-uri() function has two modes, controlled by a parameter. 
In one mode characters such as "/" and "?" are escaped, in the other mode they are not. 
The first mode is suitable for escaping parts of a URI, for example an individual parameter in the query string. 
The second mode is suitable when a string representing an entire URI is to be escaped in a single operation. 
This isn't recommended practice but is sometimes unavoidable. 
I would like to make this sentence clearer if we can but I don't understand why you had difficulty understanding it! 
I have to say that I find the various RFCs on URI syntax incredibly difficult to follow, and in many places ambiguous or contradictory. 
Since there seems to be a belief that URIs are the foundation on which the web is built, I would be much more comfortable if the specs were rock-solid rather than shifting sand. 
With the escape-uri() function (and the rules for URI escaping in XSLT serialization) we've done the best we can, but it's pretty flakey stuff. 
Michael Kay 
