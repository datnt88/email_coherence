Hi DOM-ers I have a problem with modifying the text component of a node. 
What I am hoping to achieve could have the affect of removing emphasis from text, for example, ie, this xml document: gets transformed to: The approach which I am using is: 1. Get the text associated with the emph node. 
2. append it to the text component of the myDoc node 3. delete the emph node Using Sun's Java xml-ea2 DOM API (http://developer.javasoft.com/developer/earlyAccess/xml/index.html), check out the following code for this purpose. 
In the example above, the method copyIntoParent (Node) would be called with emph as the parameter. 
The trouble is with the setNodeValue(String) method in the Node interface of Sun's API. 
I call it in the setTextInNode(Node n, String newText) method, but the print outs I have in the copyIntoParent(Node) method show that it has no affect. 
So: - are there any other DOM-ers using Suns DOM API? - is setNodeValue(String) the right method to call. 
if not, what? 
Any help/ suggestions will be cool thanks N public void copyIntoParent(Node n) { // get current node's text content copy it // into parent node, in place of current node // Has the affect of removing elements from // text content. 
// Print out the current text value of this node System.out.println("child " + n.getNodeName() + " " + getTextFromNode(n)); // update the text value of this node with the "** my new text **" setTextInNode(n, "** my new text **"); // Print out the updated text value of this node System.out.println("child " + n.getNodeName() + " " + getTextFromNode(n)); public void setTextInNode(Node n, String newText) { // Read the text that this node has // and append to it the new text that is to be added String currentText = getTextFromNode(n); currentText += newText; n.setNodeValue(currentText); public String getTextFromNode(Node n) { // get current node's text content Node child; String textData = ""; NodeList children; int numberOfChildren; // If the node has any child nodes, // bung all of them into a nodelist called children children = n.getChildNodes(); numberOfChildren = children.getLength(); 
// Read each child now for (int i = 0; i  numberOfChildren; i++) { child = children.item(i); 
// If this child has some text, let's get it! if (child.getNodeType() == 3) textData += child.getNodeValue(); 
return textData; The DOM Level 1 defines the nodeValue of an Element to be null (see the table in the discussion of the Node interface), so your approach wouldn't work in the DOM standard. 
It is, however, a source of irritation and confusion for many people, and some DOM implementers have defined a method similar to setNodeValue to do what you want to do with an Element. 
It's hard to come up with a clean, elegant solution here without adding serialization and parsing interfaces to the DOM, and that is considered by many to be a can of worms. 
The "DOM-ically correct" way strip out the emph markup, I believe, is to get the text nodes of "myDoc" and "emph" and concatenate them together, remove the "emph" element, then set the new Text node to be the only child of "myDoc". 
Mike Champion Simplest is to 1. Get the TEXT node child of the "emph" node. 
2. Get the parent of that "emph" node. 
2. Use parent.replaceChild() 
to replace the "emph" node with the text. 
Right, DOM does not specify any behavior other than not throwing any exception in this case ... perhaps it's annoying, but that's how it's specified. 
(The only exception that can be thrown is for a read-only node; since that element isn't read-only, it mustn't be thrown there.) - Dave Hi Mike and David Thanks for your replies. 
The sun DOM API doesn't allow me to do this directly. 
But I managed to come up with a simple solution which does what is required. 
The approach is (see setTextInNode(Node n, String newText)): - make a clone of the text node which is to be modified - modify the text value of the node - replace this cloned node with the old one. 
The code for this is below. 
Thanks again Nigel ======================= 8  ==================== public void copyIntoParent(Node n) { // get current node's text content copy it // into parent node, in place of current node // Has the affect of removing elements from // text content. 
System.out.println("child " + n.getNodeName() + " " + getTextFromNode(n)); setTextInNode(n, "** my new text **"); System.out.println("child " + n.getNodeName() + " " + getTextFromNode(n)); public void setTextInNode(Node n, String newText) { Node child = n.getFirstChild(), clone; final boolean deep = false; // Read the text that this node has // and append to it the new text that is to be added String currentText = getTextFromNode(n); currentText += newText; clone = child.cloneNode(deep); 
clone.setNodeValue(currentText); 
n.replaceChild(clone, child); public String getTextFromNode(Node n) { // get current node's text content Node child; String textData = ""; NodeList children; int numberOfChildren; // If the node has any child nodes, // bung all of them into a nodelist called children children = n.getChildNodes(); numberOfChildren = children.getLength(); 
// Read each child now for (int i = 0; i  numberOfChildren; i++) { child = children.item(i); 
// If this child has some text, let's get it! if (child.getNodeType() == 3) textData += child.getNodeValue(); 
// else // System.out.println("No text with one child of " + child.getNodeName() 
+ " Type: " + child.getNodeType()); 
return textData; I think a more correct statement is that "DOM" doesn't let you do what you want without writing some additional code. 
You were neither running into bugs, nor were you using extended facilities in Sun's implementation (e.g. namespace support). 
So it's nothing specific to work Sun has done. 
There are more and less efficient ways to do what you're doing, within the context of the DOM APIs. 
We're glad that you have a solution that works for you! - Dave 
