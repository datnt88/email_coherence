Roy Fielding fielding@beach.w3.org said: 
Also, I've been playing around with various formats and have found that the optimum for most transfers uses a simple one-byte prefix to encode the length of each packet, with a zero byte indicating end-of-packets. 
Could you elaborate? 
I'd be curious to know the tradeoffs you examined before choosing this approach. 
In particular, was the overhead of an ASCII packet length (i.e., human readable) so onorous? 
So, without further ado, here's the format: Content-Transfer-Encoding: packet Entity-Body = *( packet ) NUL footer CRLF NUL = octet 0 packet = packet-size packet-data packet-size = OCTET, excluding octet 0, representing the unsigned integer (1-255) packet-data = packet-size(OCTET) footer = *( Entity-Header ) Note that the footer is terminated by an empty line (just like the headers) and is optional. 
The semantics of a footer are as if the given Entity-Header fields are part of the message headers. 
[most of un-packetizer algorithm omitted] replace Content-Length value with length. 
In other words, the result looks like a normal message, with the Content-Length computed by the unpacketizer. 
In actuality, it is often faster to read packet-size + 1 bytes, slurping in the next packet-size as part of the prior packet read. 
The proposal looks reasonable to me. 
I have these questions: 
1) If I understand correctly, there is always at least a blank line following packetized data (for a null footer Entity-Header). 
True? 
2) Does the footer applies only for C-T-E "packet", or would it apply to other (to be specified) C-T-E's? 
3) What happens if (yes, it would be bizarre) one of the footers is Content-Length? 
(It looks like it gets overwritten with the one that the packetizer computes.) 
4) Will support for packetization be a required part of HTTP/1.1? 
5) How will acceptable packet sizes be negotiated (or specified)? 
Dave Kristol 
According to Dave Kristol: 
Also, I've been playing around with various formats and have found that the optimum for most transfers uses a simple one-byte prefix to encode the length of each packet, with a zero byte indicating end-of-packets. 
Also a maiximum packet size of 255 bytes seems quite small. 
Could you explain the rationale for that? 
John Franks 
An ASCII decimal format is, yes. 
Human readable was not an issue in this case. 
The advantages that the one-byte packet-size has is that it takes up a minimal amount of space in the stream of bits to the transfer and is trivial for any system to produce or consume. 
Allowing larger packets means we have to use decimal (with the additional CRLF delimiters) or hope that everyone remembers to read the number in network byte order. 
*NOTE* We need to keep in mind that the CTE packet size has little to do with the TCP packet size. 
There is absolutely nothing preventing an application from writing up to X CTE packets per network write, where Usable Window X = ------------- 256 It does have an impact on the receiving application's read buffer size, but that is usually not an issue these days (most systems are capable of reading data from the TCP buffers much faster than it gets filled, so the application's reads are not in the critical path). 
The BIG question is what effect it will have on the number of internal system calls and data copies required by the server or the client. 
That I do not know, and Jim Gettis (the W3C person who is about to start looking into HTTP/2.x) mentioned earlier today that they may overwhelm any gain from simplicity. 
Of course, this is also dependent on the average size of dynamic data transfers (i.e., if the vast majority of transfers is "small", than a small packet size is preferable). 
So, here is a task for the WG: If you have a simulator handy (or just some free time on your hands), please attempt to analyze the behavior of a representative sample of dynamic responses, with the idea being a comparison between the simple "256packet" implementation of my last message 199507230403.AAA10044@beach.w3.org and the following "decimal packet" CTE: Entity-Body = *( packet ) "0" CRLF footer CRLF packet = packet-size packet-data packet-size = ("1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9") *DIGIT packet-data = packet-size(OCTET) CRLF footer = *( Entity-Header ) and report your results back to the mailing list. 
Keep in mind that the goal is consensus and submittal of a proposed standard RFC on HTTP/1.1 by September 21. 
That depends on where you consider the beginning of the line to be. 
If you consider it to be after the zero (NUL), then yes, since the 256packet scheme would end in last-packet NUL CRLF if there is no footer. 
In the decimal packet scheme there would indeed always be an empty line, since it would end in last-packet 0 CRLF CRLF if there is no footer. 
Only to CTE packet, unless we defined more new CTEs (unlikely, except for the possibility of a packet64 CTE for 7bit transfer). 
It gets overwritten (in fact, it *must* be overwritten). 
Yes. 
Well, if we have small packets, they won't be. 
If we have decimal packets, then that is another matter for discussion. 
Does it matter? 
....Roy T. Fielding Department of ICS, University of California, Irvine USA Visiting Scholar, MIT/LCS + World-Wide Web Consortium (fielding@w3.org) 
(fielding@ics.uci.edu) 
Roy, one thing. 
would you mind not calling it a content-transfer-encoding? 
The possibility of something with a c-t-e of "packet" escaping into mail, or the possibility of something with (for some reason) c-t-e base64 losing its c-t-e because it's being sent with "packet" disturbs my sense of orthogonality. 
"Content-encoding" I wouldn't mind, since it is wholly a Web thing; "Transfer-mode" I wouldn't mind either, for the same reason, but throwing a packetized transfer mode into a field used for some other purpose disturbs me deeply. 
Yes, it should have been "content-encoding" in MIME, because that fits what it really is better, but it's too late to change MIME now. 
Harald A 
I thought 'content-transfer-encoding' was appropriate, but might prefer to name it more explicitly as 'binary-packet'. 
You wouldn't send c-t-e base64 in a binary-packet encoding just as you can't nest other MIME c-t-e. 
(On a related thought, I've been thinking of a new MIME top-level type called 'container', where 'container/zip' or 'container/tar' or 'container/bento' might be allowable registered types. 
The interpretation is that a container contains one or more other objects packed together in a binary encoding; the goal is to forstall the unfortunate current use of multipart/zip.) 
Yes. The proposed "packet" CTE is a transfer encoding. 
That is, it indicates what (if any) type of transformation has been applied to the entity in order to safely transfer it between the sender and the recipient. 
This differs from the Content-Encoding in that the CTE is a property of the message, not of the original resource. 
That is because they are not orthogonal. 
As I mentioned earlier, we may want to define a packet64 encoding for this case, but we do not want to allow a packet encoded message to be CTEd by another encoding. 
The packetizing must be the last encoding applied to the message. 
It fits the definition (if not practice) of MIME. 
Those fields are extensible, so it is reasonable to extend them. 
The packet scheme is not a transfer mode -- it applies to the message body, and could be independent of the protocol (if other protocols used it). 
I disagree -- that is not what content-encoding means in HTTP, nor do I think it is too late to change MIME now. 
Not allowing layered encodings is a fundamental problem with the media type mechanism. 
MIME chose to use a mechanism that replaces the content-type, thus destroying some very important information. 
HTTP can't do that, so we invented something different. 
Internet mail will have to do the same eventually, whether it is in the MIME spec or not. 
My job (in HTTP/1.x) is to describe a protocol in which both can coexist, using the same basic abstractions and theory, such that the implementation of the protocol remains relatively simple. 
....Roy T. Fielding Department of ICS, University of California, Irvine USA Visiting Scholar, MIT/LCS + World-Wide Web Consortium (fielding@w3.org) 
(fielding@ics.uci.edu) 
Roy, two points: - MIME is an installed base now, and we can't change labels on them just because the meaning of the labels in current practice doesn't fit the meaning of the labels in English - The MIME spec deliberately made it harder to register a c-t-e than it is to register a content-type, because having more destroys interoperability. 
- There were fierce battles in the MIME group about whether to ban nested c-t-es outright, discourage the practice, or allow it. 
I don't think that it is a choice one should make without thinking about it carefully. 
If you want to name it transfer-encoding, because that is what it is, fine, and if you want to remove content-transfer-encoding entirely from HTTP, I wouldn't mind too much, but using the same label with different semantics than in MIME is, IMHO, going to lead to problems. 
Harald A 
In what way does what is being proposed here (the "packet" proposal however you name it) have different semantics from MIME c-t-e? 
Content-transfer-encodings generally stay with the message in store, and are not used to find the end of a message, but to protect the content. 
The "packet" encoding's primary purpose is to locate the end of the message without requiring scanning for special strings or knowing the complete length before starting transmission. 
Note that an almost identical mechanism was proposed for SMTP - I think it is still one of the "draft-ietf-mailext" drafts. 
Harald A 
Yep, and the above two paragraphs are equivalent under HTTP. 
The packetized CTE would stay with the message (until it was removed), and its purpose is to protect the content from a premature closure of the connection (i.e., it allows the recipient to know if it got the whole thing, and it allows the sender to apply a signature to the whole thing). 
Yes, I am aware of draft-ietf-mailext-smtp-binary-07.txt . 
That mechanism uses a series of separate messages (each message given a 1*DIGIT length) to send the binary data. 
In other words, it is a stateful message sequence, which is something HTTP doesn't do. 
It does demonstrate that both protocols 
need such a thing, and conversion between the two methods would be trivial. 
....Roy T. Fielding Department of ICS, University of California, Irvine USA Visiting Scholar, MIT/LCS + World-Wide Web Consortium (fielding@w3.org) 
(fielding@ics.uci.edu) 
Could please clarify what you mean by 'series of separate messages' since this terminology doesn't fit my understanding of SMTP chunking. 
The BDAT command doesn't in any way change data content in the pipe. 
It's also streamable in the sense that you can have more than on outstanding BDAT chunk pending on the connection. 
... ian 
Sorry for the delay in responding -- all three of the machines I was using died on Aug 1 due to separate hardware failures. 
Personally, I think it was a curse brought on by the WG minutes ... 
Ooops, confusing terminology. 
SMTP involves sending a series of commands and getting a series of responses, with many commands per mail message. 
HTTP sends one "command" in the form of a message, and gets one response. 
So, while the concept is similar (and easily translatable for an HTTP - SMTP gateway), they are not "almost identical". 
....Roy T. Fielding Department of ICS, University of California, Irvine USA Visiting Scholar, MIT/LCS + World-Wide Web Consortium (fielding@w3.org) 
(fielding@ics.uci.edu) 
