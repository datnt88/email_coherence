I would like to repreat my appeal that we revisit the SDATA decision. 
I'm sure that no extended rationale was presented for the decision, and I've been unable to find a record of it at all. 
As XML stands we have the private use character codes, which provide no resolution mechanism for 
determining which non-unicode character is included in an instance. 
I am asking only that we repalce the numerical values provided by private-use, with string values. 
We will still not have a resolution mechanism, but we will have a foundation on which one can be built. 
I'll also remind people: + in DSSSL (at least the near-final draft which I read) characters are identified primarily by strings, and not chracter codes. 
+ since the ISO entities are no longer pre-defined, we will have to define XML substitutes for them, unless we allow SDATA. 
+ since some of the characters in ISO math (and more importantly, TeX math) are not in Unicode, we may have to assign them private-use code points, if we don't allow SDATA. 
In concrete, I propose that we allow SDATA entities, and define that they are _only_ to be used to represent undefined characters by a descriptive string. 
We should also reserve SDATA entities of the form "[XML:" Character* "]" for a future glyph/character resolution mechanism, if one should be devised. 
-- David I would also invite some of the new list members that I know have character set expertise to comment on the alternative of informally assigned numerical codes versus informally assigned character strings. 
I am not a number. 
I am an undefined character. 
David Durand dgd@cs.bu.edu \ david@dynamicDiagrams.com 
Boston University Computer Science \ Sr. Analyst --------------------------------------------\ http://dynamicDiagrams.com/ MAPA: mapping for the WWW \__________________________ 
From: Tim Bray tbray@textuality.com - this was not what SDATA was meant for, says Charles among others, and 
As I understand 8879 and ESIS as currently described, I think it fair to say: Internal SDATA, when encountered, should be passed to the application marked as such and with internal-to-the-document entity name attached. 
Then the application is free to do with it what it wishes. 
By definition, the text of the entity is system dependent. 
If XML wishes to consider all XML implementations one system for this purpose and prescribe the appropriate content and behaviour, this is not inconsistent with 8879. 
- James pointed out that if what you really need is a string associated with a particular character, then there should be a facility for this, e.g. an attributed character reference, rather than kludging our way through with SDATA, and furthermore 
This might as well be implemented by SDATA, given that SDATA is already used that way, and given that we don't otherwise need SDATA (agreed by all I think). 
I've not heard directly from James this "pointing out", but it sounds like he means one of two things: o If he means to bind the character to an unused code point in the document character set, thereby adding the character to the document's character repertoire, this will not work for XML since XML intends to prescribe one universal document character set--one universal character repertoire and one universal interpretation of numeric character references as characters in that repertoire. 
o If he means to create a new form of character reference, other than the existing numeric and named references (e.g., "&amp;#123;" and "&amp;#RE;"), in which an abstract "character" is tied to the reference via some kind of declaration that associates a description of the character with an internal name, then that sounds like an SDATA entity by another name, with a more closely circumscribed interpretation than SDATA currently has. 
A "CHAR" entity type has been proposed in one forum or another, but not discussed to any great length yet. 
Hope this helps. 
Dave Peterson SGMLWorks! 
davep@acm.org 
On Mon, 9 Dec 1996 10:36:14 -0500 David G. Durand said: 
The second half of October was, if I remember correctly, given over largely though not exclusively to the discussion of this question. 
There seems little point in my contributing to this discussion now, since what I contributed then (I thought they were extended discussions, and they certainly described the rationale for the ERB decision) seems not only not to have persuaded David, but to have been invisible to him. 
So I'll just ask David to follow the obvious guideline: if you failed to persuade everyone that SDATA is worth having in the spec the first time around, and now want to raise the question again, can you please provide some new arguments? 
The old arguments have been read, and understood, and discussed. 
David thinks, I suspect, that I didn't understand his arguments, but understanding is not the same as agreement. 
His arguments didn't persuade me then, and I for one have enough other things on my plate not to want to discuss an issue for the third time, when nothing new has been added to the discussion. 
In all the cases I know of where SDATA entities now work without user intervention, the SDATA entities are known characters which occur in Unicode. 
In cases where non-Unicode characters are successfully handled, all the cases I know of involve user intervention in the application's character tables. 
Removing SDATA entities does not change this state of affairs one whit: known characters will work, and others will require user intervention. 
The problem of characters not known to an application is a real and serious one. 
I'd like to see some discussion of how to solve it, rather than further special pleading for SDATA, which seems to me to be a band-aid for the problem, not a solution to it. 
We need a real solution, not a band-aid, and I am not convinced that SDATA is even a part of a real solution. 
Michael Sperberg-McQueen 
[Michael Sperberg-McQueen:] 
Agreed, but I hasten to point out that this W3C working group is not the place to develop such a solution. 
People who are serious about helping to fix this are urged to join the appropriate working group within their national standards body, which in the U.S. is ANSI X3V1. 
I'm sure that your participation would be happily accepted. 
Jon 
