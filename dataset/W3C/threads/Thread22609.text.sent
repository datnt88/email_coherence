This is an update for the Content Models module: Philippe PS: I included a CVS diff from the XML sources. 
Let me know if you find it useful. 
Index: content-models.xml 
RCS file: /w3ccvs/WWW/DOM/Group/drafts/level-3-src/xml/cm-ls/content-models.xml,v retrieving revision 1.19 retrieving revision 1.35 diff -r1.19 -r1.35 2c2 !-- $Id: content-models.xml,v 
1.35 2001/04/18 21:29:56 plehegar Exp $ -- 11c11 head Content Models and Validation /head 28c28 EARLY DRAFT! 
Last known edit 02/02/2001 EARLY DRAFT! 
Last known edit 04/11/2001 30c30 proposed revisions already marked up as per spec.dtd! 
proposed revisions already marked up as per spec.dtd! 
35c35 | OVERVIEW | | OVERVIEW | 46,50c46,48 including Namespace well-formedness. 
A DOM application can use the code hasFeature /code method of the code DOMImplementation /code interface to determine whether a given DOM supports these capabilities or not. 
One feature string for the CM-editing interfaces listed in this section is "CM-EDIT" and another feature string for document-editing interfaces is including Namespace well-formedness. 
A DOM application can use the code hasFeature /code method of the code DOMImplementation /code interface to determine whether a given DOM supports these capabilities or not. 
One feature string for the CM-editing interfaces listed in this section is "CM-EDIT" and another feature string for document-editing interfaces is 128c126,127 p CR5. Associate a CM with a document and make it the active CM. /p 231,236c230,231 the former will report the element's code QName /code , e.g., code foo:bar /code , whereas the latter will report its namespace and local name, e.g., code {http://my.namespace}bar 
/code . 
We have added the code isNamespaceAware /code attribute to the generic CM object to help applications determine which of these fields are important, but we are still the former will report the element's code QName /code , e.g., code foo:bar /code , whereas the latter will report its namespace and local name, e.g., code {http://my.namespace}bar 
/code . 
We have added the code isNamespaceAware /code attribute to the generic CM object to help applications determine which of these fields are important, but we are still analyzing this challenge. 
/p 274c269,270 follow, starting off with the data structures and "CM-editing" methods. 
/p definitions 283,289c279,287 p code CMModel /code is an abstract object that could map to a DTD, an XML Schema, a database schema, etc. 
It's a generalized content model object, that has both an internal and external subset. 
The internal subset would always exist, even if empty, with the external subset (if present) being represented as a link to one or more code CMExternalModel /code s. 
It is possible, however, that none of these code CMExternalModel /code s are p code CMModel /code is an abstract object that could map to a DTD, an XML Schema, a database schema, etc. 
It's a generalized content model object, that has both an internal and external subset. 
The internal subset would always exist, even if empty, with the external subset (if present) being represented as by an "active" code CMExternalModel /code . 
Many code CMExternalModel /code s could exist, but only one can be specified as "active"; it is also possible that none are "active". 
The issue of multiple content models is misleading since in this architecture, only one code CMModel /code exists, with an internal subset that references the external subset. 
If the external subset changes to another "acitve" code CMExternalModel /code , the internal subset is "fixed up." 
The CMModel also contains the factory methods needed to create a various types of CMNodes like code CMElementDeclaration /code , code CMAttributeDeclaration /code , etc. /p 295,296c293,294 terms of namespaces and local names; false if the document structure is defined terms of namespaces and local names; false if the document structure is defined only in terms of code QNames /code . 
/p 299,300c297,298 302c300,309 p The root element declaration for the content model. 
Although a root element is specified in the document instance, when a content model is generated, a user should be able to chose the root element for editing purpose. 
This is just a placeholder for that element. 
It could also be null. 
For validating an XML document, root element must be defined in its active content model. 
CMModel.rootElementDecl provides access to that root element declaration. 
This recommendation does not say how to fill in the rootElementdecl. 
It could be manually done by the user before validating a document, in some cases where possible, the CMModle loader may be able to fill it in etc. /p 306,307c313,314 p Location of the document describing the content model p Location of the document describing the content model defined in this CMModel. 
/p 313,314c320,321 p This method returns a DOMString defining the absolute p This method returns a DOMString defining the absolute location from which this document is retrieved including the document name. 
/p 319c326 /method 337,338c344 p Returns code CMNode /code list of all the constituent p Returns code CMNode /code list of all the constituent nodes in the content model. 
/p 396,397c402,403 i.e., confirming that it's well-formed and valid per its own formal grammar. 
i.e., confirming that it's well-formed and valid per its own formal grammar. 
Note that within a CMModel, a pointer to a CMExternalModel can exist. 
/p 408a415,565 !--=================================================== == Factory Methods == =======================================================-- descr p Creates an element declaration for the element type specified. 
The returned object implements CMElementDeclaration interface. 
/p /descr parameters descr p /p /descr /param descr p The qualified name of the element type being declared. 
/p /descr /param descr p Constant for MIXED, EMPTY, ANY and CHILDREN. 
/p p /p /descr /param /parameters returns type="CMElementDeclaration" descr p A new CMElementDeclaration object with code name /code attribute set to qualifiedElementName and the code contentType /code set to contentSpec. 
Other attributes of the element declaration are set through CMElementDeclaration interface methods. 
/p descr p INVALID_CHARACTER_ERR: Raised if the specified name contains an illegal character. 
/p p DUPLICATE_NAME_ERR:Raised if an element declaration already exists with the same name for a given CMModel. 
/p /descr /exception /raises /method descr p Creates an attribute declaration. 
The returned object implements CMAttributeDeclaration interface. 
/p /descr parameters descr p /p /descr /param descr p The name of the attribute being declared. 
/p /descr /param /parameters returns type="CMAttributeDeclaration" descr p A new CMAttributeDeclaration object with code attributeName /code attribute set to input qualifiedname parameter. 
/p descr p INVALID_CHARACTER_ERR: Raised if the specified name contains an illegal character. 
/p /descr /exception /raises /method descr p Creates a new notation declaration. 
The returned object implements CMNotationDeclaration interface. 
/p /descr parameters descr p The name of the notation being declared. 
/p /descr /param descr p The system identifier for the notation declaration. 
/p /descr /param descr p The public identifier for the notation declaraiton. 
/p /descr /param /parameters returns type="CMNotationDeclaration" descr p A new CMNotationDeclaration object with code notationName /code attribute set to name. 
/p descr p INVALID_CHARACTER_ERR: Raised if the specified name contains an illegal character. 
/p p DUPLICATE_NAME_ERR:Raised if a notation declaration already exists with the same name for a given CMModel. 
/p /descr /exception /raises /method descr p Creates a new entity declaration. 
The returned object implements CMEntityDeclaration interface. 
/p /descr parameters descr p The name of the entity being declared. 
/p /descr /param /parameters returns type="CMEntityDeclaration" descr p A new CMNotationDeclaration object with code entityName /code attribute set to name. 
/p descr p INVALID_CHARACTER_ERR: Raised if the specified name contains an illegal character. 
/p /descr /exception /raises /method descr p Creates a new CMChildren object. 
The subModels of the CMChildren is build using CMChildren interface methods. 
/p /descr parameters descr p The minimum occurance for the subModels of this CMChildren. 
/p /descr /param descr p The maximum occurance for the subModels of this CMChildren. 
/p /descr /param descr p operator of type CHOICE, SEQ or NONE /p /descr /param /parameters returns type="CMChildren" descr p A new CMChildren object. 
/p descr p INVALID_CHARACTER_ERR: Raised if the specified name contains an illegal character. 
/p /descr /exception /raises /method 420,422c577,579 p code CMExternalModel /code is an abstract object that could map to a DTD, an XML Schema, a database schema, etc. 
It's a generalized content p code CMExternalModel /code is an abstract object that could map to a DTD, an XML Schema, a database schema, etc. 
It's a generalized content model object that is not bound to a particular XML document. 
/p 432,460c589,608 p code CMNode /code is analogous to a code Node /code in the Core DOM, e.g., an element declaration. 
This can exist for both code CMExternalModel /code (include/ignore must be handled here) and p code interface CommentsPIsDeclaration { attribute ProcessingInstruction pis; attribute Comment comments; }; interface Conditional /descr /constant constant id='CMNode-ATTRIBUTE_DECLARATION' id='CMNode-NOTATION_DECLARATION' id='CMNode-ENTITY_DECLARATION' p code CMNode /code is analogous to a code Node /code in the Core DOM, e.g., an element declaration. 
This can exist for both code CMExternalModel /code and code CMModel /code . 
It should be able to handle constructs such as comments and processing instructions. 
/p p Opaque. /p /descr descr p The node is an code CMElementDeclaration /code . 
/p descr p The node is an code CMAttributeDeclaration /code . 
/p descr p The node is a code CMNotationDeclaration /code . 
/p descr p The node is an code CMEntityDeclaration /code . 
/p 462,469c610,616 id='CMNode-CM_CHILDREN' descr p The node is a code CMChildren /code . 
/p type="unsigned short" value="6" descr p The node is a code CMModel /code . 
/p 471,474c618,620 id='CMNode-CM_EXTERNALMODEL' descr p The node is a code CMExternalModel /code . 
/p 476,480c622 482,496c624,645 p Creates a copy of code CMModel /code . 
No document refers p A code representing the underlying object as defined above. 
/p /descr /attribute descr p The code CMModel /code object associated with this CMNode. 
For a node of type code CM_MODEL /code , this is code null /code . 
/p /descr /attribute descr p The code qualified name /code of this CMNode depending on the CMNode type. 
/p /descr /attribute descr p The namespace prefix of this node, or null if it is unspecified. 
/p descr p Returns the local part of the code qualified name /code of this CMNode. 
/p 498,500c647,652 p Creates a copy of code CMExternalModel /code . 
It is p The namespace URI of this node, or null if it is unspecified. 
/p /descr /attribute descr p Creates a copy of code CMNode /code . 
/p 521,522c673 NodeList /code ; the document order is meaningful, as opposed to NodeList /code ; the document order is meaningful, as opposed to code CMNamedNodeMap /code . 
/p 541c692,693 543,545c695,696 p The primitive datatypes supported currently are: code string /code , code boolean /code , code float /code , p The primitive datatypes supported by base DOM CM implementation is: code string /code type only. 
/p 550,552c701,703 p code representing the code string /code data type as defined in loc p code representing the code string /code data type as defined in loc href="&amp;xml-schema-2;/#string" XML Schema Datatypes /loc . 
/p 555,556c706,736 descr p Returns one of the enumerated code representing the primitive data type. 
/p /descr parameters /parameters returns type="short" descr p code representing the primitive type of the attached data item. 
/p /descr /returns raises /raises /method /interface !--===================================================================== = CMPrimitiveType = ======================================================================-- descr p The primitive types supported by optional DOM CM implelementations. 
A DOM application can use the hasFeature method of the DOMImplementation interface to determine whether this interface is supported or not. 
The feature string for all the interfaces listed in this section is "CMPTYPES" and the version is "3.0". 
/p 558,559c738,740 p code representing the code boolean /code data p code representing the code boolean /code data type as defined in loc href="&amp;xml-schema-2;/#boolean" XML Schema Datatypes /loc . 
/p 565,566c746,748 p code representing the code float /code data p code representing the code float /code data type as defined in loc href="&amp;xml-schema-2;/#float" XML Schema Datatypes /loc . 
/p 572,573c754,756 p code representing the code double /code data p code representing the code double /code data type as defined in loc href="&amp;xml-schema-2;/#double" XML Schema Datatypes /loc . 
/p 576,585c759,760 p code representing an code integer /code data 587,592c762,841 /descr /constant attribute readonly="no" type="int" p code representing a code decimal /code data type as defined in loc href="&amp;xml-schema-2;/#decimal" XML Schema Datatypes /loc . 
/p descr p code representing a code hexbinary /code data type as defined in loc href="&amp;xml-schema-2;" XML Schema Datatypes /loc . 
/p /descr descr p code representing a code base64binary /code data type as defined in loc href="&amp;xml-schema-2;" XML Schema Datatypes /loc . 
/p descr p code representing an code uri reference /code data type as defined in XML Schema Datatypes. 
/p note role='editor' p @@uriReference is no longer part of the XML Schema PR draft. 
/p /note descr p code representing an code XML qualified name /code data type as defined in loc href="&amp;xml-schema-2;/#QName" XML Schema Datatypes /loc . 
/p descr p code representing a code duration /code data type as defined in loc href="&amp;xml-schema-2;" XML Schema Datatypes /loc . 
/p descr p code representing a code datetime /code data type as defined in loc href="&amp;xml-schema-2;" XML Schema Datatypes /loc . 
/p descr p code representing a code date /code data type as defined in loc href="&amp;xml-schema-2;" XML Schema Datatypes /loc . 
/p descr p code representing a code time /code data type as defined in loc href="&amp;xml-schema-2;" XML Schema Datatypes /loc . 
/p descr p code representing a code yearmonth /code data type as defined in loc href="&amp;xml-schema-2;" XML Schema Datatypes /loc . 
/p descr p code representing a code year /code data type as defined in loc href="&amp;xml-schema-2;" XML Schema Datatypes /loc . 
/p descr p code representing a code monthday /code data type as defined in loc href="&amp;xml-schema-2;" XML Schema Datatypes /loc . 
/p descr p code representing a code day /code data type as defined in loc href="&amp;xml-schema-2;" XML Schema Datatypes /loc . 
/p descr p code representing a code month /code data type as defined in loc href="&amp;xml-schema-2;" XML Schema Datatypes /loc . 
/p descr p code representing a code NOTATION /code data type as defined in loc href="&amp;xml-schema-2;" XML Schema Datatypes /loc . 
/p /descr /constant attribute readonly="no" type="decimal" 595c844,845 p The low value for a primitive DECIMAL_DATATYPE in the value range. 
/p 598c848 601c851,852 p The high value for a primitive DECIMAL_DATATYPE in the value range. 
/p 604,620c855 p Returns one of the enumerated code representing the p code representing the primitive type of the attached data /interface 624c859 = ElementDeclaration = = CMElementDeclaration = 627,628c862,863 631c866 context of a code CMNode /code . 
/p 632a868,886 descr p Datatype of the element. 
/p /descr /attribute descr p Boolean defining whether the element type contains child elements and PCDATA or PCDATA only for mixed element types. 
True if the element is of type PCDATA only. 
Relevant only for mixed content type elements. 
/p /descr /attribute descr p tagName of the element being declared. 
/p /descr /attribute 636,637c890,891 p Gets content type, e.g., empty, any, mixed, elements, p Gets content type, e.g., empty, any, mixed, elements, PCDATA, of an element. 
/p 667,669c921 p Returns a code CMNamedNodeMap /code containing code AttributeDeclarations /code for all the attributes that can appear on p Returns a code CMNamedNodeMap /code containing code CMAttributeDeclarations /code for all the attributes that can appear on this type of element. 
/p 684,687c936,937 p Returns a code CMNamedNodeMap /code containing code ElementDeclarations /code for all the code Element /code s that can appear as children of this type of element. 
Note that which ones can actually p Returns a code CMNamedNodeMap /code containing code CMElementDeclarations /code for all the code Element /code s that can appear as children of this type of element. 
Note that which ones can actually appear, and in what order, is defined by the code CMChildren /code . 
/p 706c956,957 inherits="CMNode" 708c959 p The content model of a declared element. 
/p 710,711c961,968 descr p Signifies unbounded upper limit. 
The MAX_LONG value is the maximum value of an unsigned long integer for a given language binding. 
/p /descr /constant constant value="0" 713c970,988 p No operators defined on the code subModels /code . 
This is usually the case where the subModels contain a single element declaration. 
/p /descr /constant constant type="unsigned short" value="1" descr p This constant value signifies a sequence operator ",". 
/p /descr /constant constant type="unsigned short" value="2" descr p This constant value signifies a choice operator "|". 
/p /descr /constant attribute readonly="no" type="unsigned short" descr p One of CHOICE or SEQUENCE. 
The operator is applied to all the components(CMNodes) in the the code subModels /code . 
For example, if the list operator is CHOICE and the components in subModels are a, b and c then the content model for the element being declared is (a|b|c) /p 716,717c991,992 719c994,995 p min occurrence for this content particle. 
Valid values are from 0 to UNBOUNDED. 
/p 722,723c998,1004 descr p maximum occurrence for this content particle. 
Valid values are from 0 to UNBOUNDED. 
/p /descr /attribute attribute readonly="no" type="CMNodeList" 725c1006 p Additional code CMNode /code s in which the element can be defined. 
/p 728,729c1009,1010 731,732c1012,1013 p Additional code CMNode /code s in which the element can be p Removes the CMNode at the indicated index position in the submodel. 
/p 734,736c1015,1028 parameters descr p Index of the node being removed. 
/p /descr /param /parameters returns type="CMNode" descr p The node removed is returned as a result of this method call. 
The method returns code null /code if the index is outside the bounds of the code subModels /code list. 
/p /descr /returns raises /raises /method 738,742c1030,1031 p Boolean defining whether the element type contains child elements and PCDATA or PCDATA only for mixed element types. 
True if the element is of type PCDATA only. 
Relevant only for mixed content type elements. 
p Inserts a new node at a position in the submodel referred to by the nodeIndex. 
Node already exisiting in the list is moved as needed. 
/p 744c1033,1065 parameters descr p The position of where the newNode is inserted. 
/p /descr /param descr p The new node to be inserted. 
/p /descr /param /parameters returns type="int" descr p The index value at which it is inserted. 
If the nodeIndex is outside the bound of the code subModels /code list, the item is inserted at the back of the list. 
/p /descr /returns raises /raises /method descr p Appends a new node to the end of the list representing the code subModels /code . 
/p /descr parameters descr p The new node to be appended. 
/p /descr /param /parameters returns type="int" descr p the length of the code subModels /code . 
/p /descr /returns raises /raises /method 748c1069 = AttributeDeclaration = = CMAttributeDeclaration = 751,752c1072,1073 754c1075 p An attribute declaration in the context of a code CMNode /code . 
/p 757c1078 760c1081 constraint. 
/p 762,763c1083 767,768c1087 771,772c1090,1091 /descr /constant attribute readonly="yes" type="DOMString" attribute. 
/p /descr /constant attribute readonly="no" type="DOMString" 775c1094 p Name of the attribute. 
/p 806c1125,1126 /descr /attribute /interface 809c1129 = EntityDeclaration = = CMEntityDeclaration = 812,813c1132,1133 815c1135,1139 p Models a general entity declaration in a content model. 
ednote edtext The content model does not handle any parameter entity. 
It is assumed that the parameter entiites are expanded by the implementation as the content model is built. 
/edtext /ednote /p 816a1141,1180 constant descr p constant defining an internal entity. 
/p /descr /constant constant descr p constant defining an external entity. 
/p descr p One of the INTERNAL_ENTITY or EXTERNAL_ENTITY. 
/p descr p The name of the declared general entity. 
/p descr p The replacement text for the internal entity. 
The entity references within the replacement text is kept intact. 
For entity of type EXTERNAL_ENTITY this is code null /code . 
/p descr p The system identifier associated with the entity, if specified. 
If the system identifier was not specified, this is code null /code . 
/p descr p The public identifier associated with the entity, if specified. 
If the public identifier was not specified, this is code null /code . 
/p descr p For unparsed entities, the name of the notation declaration for the entity. 
For parsed entities, this is code null /code . 
/p /descr /attribute 824c1188 828,829c1192,1197 descr p The name of this notation declaration. 
/p 832,838c1200,1207 p The string representing the public identifier for this declaration, if present, null otherwise. 
/p descr p The string representing the public identifier for this notation declaration. 
/p /descr /attribute /interface 842,844c1211,1213 p This section contains "Validation and Other" methods common to both the document-editing and CM-editing worlds (includes code Document /code , p This section contains "Validation and Other" methods common to both the document-editing and CM-editing worlds (includes code Document /code , code DOMImplementation /code , and code DOMErrorHandler /code methods). 
/p definitions 853,854c1222 p The code setErrorHandler /code method is off of the p The code setErrorHandler /code method is off of the code Document /code interface. 
/p 859,860c1227 p Allow an application to register an error event handler. 
p Allow an application to register an error event handler. 
/p 885,886c1252,1253 p This interface extends the code Document /code interface p This interface extends the code Document /code interface with additional methods for both document and CM editing. 
/p 887a1255,1301 type="short" value="1" descr p Check for well-formedness of the document. 
/p /descr /constant constant type="short" value="2" descr p Check for namespace well-formedness includes WF_CHECK. 
/p /descr /constant constant descr p Checks for whether the document is partially valid. 
It includes NS_WF_CHECK. 
/p p elments/attributes for which an element/attribute declaration has not been made in the active content model. 
However, if the element or the attribute has a declaration in the content model, it must be valid with respect to those declarations. 
/termdef /p /descr /constant constant descr p Checks for strict validity of the document with respect to active CM which by defiition includes NS_WF_CHECK. 
/p descr p An attribute specifying whether continuous checking for the validity of the document is enforced or not. 
When set to true the implementation is free to raise the VALIDATION_ERR exception on DOM operations that would make the document invalid with respect to "partial validity". 
This attribute is false by default. 
/p ednote edtext Add VALIDATION_ERR code to the list of constants in DOMException. 
/edtext /ednote descr p This attribute defines the level at which the validity and welformedness testing is done by the code isValid /code method. 
/p /descr /attribute 890,893c1304 p Determines number of code CMExternalModel /code s associated with the document. 
Only one code CMModel /code can be associated with the document, but it may point to a list of p Determines number of code CMExternalModel /code s associated with the document. 
Only one code CMModel /code can be associated with the document, but it may point to a list of code CMExternalModel /code s. /p 907,908c1318 p Find the sole code CMModel /code of a document. 
Only one p Find the sole code CMModel /code of a document. 
Only one code CMModel /code may be associated with the document. 
/p 922,924c1332 p Obtains a list of code CMExternalModel /code s associated with a document from the code CMModel /code . 
This list arises when p Obtains list of code CMNodes /code of type code CM_EXTERNALMODEL /code s associated with the document.This 
list arises when code addCM() /code is invoked. 
/p 928c1336 returns type="CMNodeList" 930,931c1338 p A list of code CMExternalModel /code s associated with a p A list of code CMExternalModel /code s associated with a document. 
/p 939,940c1346 p Find the active code CMExternalModel /code for a p Find the active code CMExternalModel /code for a document. 
/p 946,947c1352 p code CMModel /code with a pointer to the active p code CMModel /code with a pointer to the active code CMExternalModel /code of document. 
/p 955,959c1360,1361 p Associate a code CMModel /code with a document. 
Can be invoked multiple times to result in a list of code CMExternalModel /code s. 
Note that only one sole internal code CMModel /code is associated with the document, however, and that only one of the possible list of p Associate a code CMModel /code with a document. 
Can be invoked multiple times to result in a list of code CMExternalModel /code s. 
Note that only one sole internal code CMModel /code is associated with the document, however, and that only one of the possible list of code CMExternalModel /code s is active at any one time. 
/p 977,979c1379,1380 p Removes a CM associated with a document; actually removes a code CMExternalModel /code . 
Can be invoked multiple times to remove a number p Removes a CM associated with a document; actually removes a code CMExternalModel /code . 
Can be invoked multiple times to remove a number of these in the list of code CMExternalModel /code s. /p 997,1000c1398,1402 p Make the given code CMModel /code active. 
Note that if a user wants to activate one CM to get default attribute values and then activate another to do validation, a user can do that; however, only one CM is active at p Make the given code CMModel /code active. 
Note that if a user wants to activate one CM to get default attribute values and then activate another to do validation, a user can do that; however, only one CM is active at a time. 
In case where an attribute is declared in an internal subset and corresponding code ownerElement /code points to code CMElementDeclaration /code defined in an external subset, changing active CM will cause the code ownerElement /code to be re-computed. 
If the owner element is not defined in the newly active CM, the code ownerElement /code will be an empty node list. 
/p 1005,1007c1407 p CM to be active for the document. 
The code CMModel /code points to a list of code CMExternalModel /code s; with p CM to be active for the document. 
The code CMModel /code points to a list of code CMExternalModel /code s; with this call, only the specified CM will be active. 
/p 1013,1014c1413 p True if the code CMModel /code has already been p True if the code CMModel /code has already been associated with the document using code addCM() /code ; false if not. 
/p 1029,1030c1428 p This interface extends the code DOMImplementation /code interface with additional methods. 
/p 1065,1067c1463,1464 p This section contains "Document-editing" methods (includes code Node /code , code Element /code , code Text /code and p This section contains "Document-editing" methods (includes code Node /code , code Element /code , code Text /code and code Document /code methods). 
/p definitions 1075,1076c1472 p This interface extends the code Node /code interface with p This interface extends the code Node /code interface with additional methods for guided document editing. 
/p 1081,1084c1477,1479 operation would make this document invalid with respect to the currently active CM. ISSUE: Describe "valid" when referring to partially completed p Determines whether the code Node::InsertBefore /code operation would make this document invalid with respect to the currently active CM. ISSUE: Describe "valid" when referring to partially completed documents. 
/p 1100,1101c1495 p A boolean that is true if the p A boolean that is true if the code Node::InsertBefore /code operation is allowed. 
/p 1195c1589 CM. /p 1201,1202c1595,1596 p True if the node is valid in the current context, false if p True if the node is valid/well-formed in the current context and check level defined by wfValidityCheckLevel, false if not. 
/p 1206c1600,1605 descr p NO_CM_AVAILABLE: Exception is raised if the DocumentCM related to this node does not have any activeCM and wfValidityCheckLevel is set to STRICT_VALIDITY_CHECK. 
/p /descr /exception /raises 1214c1613 1217,1218c1616 p This interface extends the code Element /code interface with p This interface extends the code Element /code interface with additional methods for guided document editing. 
/p 1242c1640 returns type="CMElementDeclaration" 1244c1642 p CMElementDeclaration object /p 1258c1656 p Determines if the value for specified attribute can be set. 
/p 1274c1672 p true or false. 
/p 1283c1681 p Determines if attribute node can be added. 
/p 1288,1289c1686 p code Node /code in which the attribute can possibly be p code Node /code in which the attribute can possibly be set. 
/p 1304c1701,1702 p Determines if the attribute node with the given namespace can be added. 
/p 1309,1310c1707,1736 p Attribute's code Node /code in which to set the p The code Attr /code to be added to the attribute list. 
/p /descr /param /parameters returns type="boolean" descr p Success or failure. 
/p /descr /returns raises /raises /method descr p Determines if the attribute with given namespace and local name can be created if not already present in the attribute list of the element. 
If the attribute with same local name and namespaceURI is already present in the elements attribute list it sets the value of the attribute and its prefix to the new value. 
See DOM core code setAttributeNS /code . 
/p /descr parameters descr p Name of attribute. 
/p /descr /param descr p Value to be assigned to the attribute. 
/p 1332,1333c1758,1759 1335c1761 p Verifies if an attribute by the given name can be removed. 
/p 1343c1769,1785 /parameters returns type="boolean" descr p true or false. 
/p /descr /returns raises /raises /method descr p Verifies if an attribute by the given name and namespace can be removed. 
/p /descr parameters 1345c1787 p Qualified name of the attribute to be removed. 
/p 1348c1790 1350c1792 p The namespace URI of the attribute to remove. 
/p 1353c1795,1810 /parameters returns type="boolean" descr p true or false. 
/p /descr /returns raises /raises /method descr p Determines if an attribute node can be removed. 
/p /descr parameters 1355c1812 p The code Attr /code node to remove from the attribute list. 
/p 1361c1818 p true or false. 
/p 1373c1830 1376,1377c1833 p This interface extends the code CharacterData /code interface with additional methods for document editing. 
/p 1388,1389c1844,1845 p True if content only whitespace; false for non-whitespace p True if content only whitespace; false for non-whitespace if it is a text node in element content. 
/p 1551c2007 1554,1555c2010 p This interface extends the code DocumentType /code interface p This interface extends the code DocumentType /code interface with additional methods for document editing. 
/p 1559,1560c2014,2015 p Determines if this element is defined in the currently p Determines if this element is defined in the currently active CM. /p 1581c2036 currently active CM. /p 1611,1612c2066,2067 p Determines if this attribute is defined for this element in p Determines if this attribute is defined for this element in the currently active CM. /p 1617c2072 p Name of the element. 
/p 1622c2077 p Name of the attribute. 
/p 1638c2093 currently active CM. /p 1674,1676c2129,2131 complete list of defined elements and for a particular element type, the complete list of defined attributes. 
These two methods might return a list of complete list of defined elements and for a particular element type, the complete list of defined attributes. 
These two methods might return a list of strings which is a type not yet described in the DOM spec. 
/p 1699c2154,2155 inherits="Attr,NodeCM" 1701,1702c2157 p This interface extends code Attr /code to provide guided p This interface extends code Attr /code to provide guided editing of an XML document. 
/p 1707,1708c2162,2163 p returns the corresponding attribute declaration in the p returns the corresponding attribute declaration in the content model. 
/p 1712c2167 returns type="CMAttributeDeclaration" 1714,1715c2169 p The attribute declaration corresponding to this p The attribute declaration corresponding to this attribute /p 1723,1724c2177,2178 p Returns the notation declaration for the attributes defined p Returns the notation declaration for the attributes defined of type NOTATION. 
/p 1731c2185 type is of notation type, null otherwise. 
/p 1746c2200,2201 p This section contains DOM error handling interfaces. 
/p definitions !--===================================================================== p This section contains DOM error handling interfaces. 
/p definitions !--===================================================================== 1753,1758c2208,2212 p Basic interface for DOM error handlers. 
If an application needs to implement customized error handling for DOM such as CM or Load/Save, it must implement this interface and then register an instance using the code setErrorHandler /code method. 
All errors and warnings will then be reported through this interface. 
Application writers can override the methods p Basic interface for DOM error handlers. 
If an application needs to implement customized error handling for DOM such as CM or Load/Save, it must implement this interface and then register an instance using the code setErrorHandler /code method. 
All errors and warnings will then be reported through this interface. 
Application writers can override the methods in a subclass to take user-specified actions. 
/p 1763,1765c2217,2219 recommendation. 
The default behavior if the user doesn't register a handler is to report conditions that are not errors or fatal errors, and then allow the recommendation. 
The default behavior if the user doesn't register a handler is to report conditions that are not errors or fatal errors, and then allow the calling application to continue even after invoking this method. 
/p 1771,1773c2225,2227 position in the case of loading, or a node reference for later validation. 
The public ID and system ID for the error location could be some of the position in the case of loading, or a node reference for later validation. 
The public ID and system ID for the error location could be some of the information. 
/p 1802,1804c2256,2258 section 1.2 of the W3C XML 1.0 recommendation. 
The default behavior if the user doesn't register a handler is to throw a DOMSystemException and stop all section 1.2 of the W3C XML 1.0 recommendation. 
The default behavior if the user doesn't register a handler is to throw a DOMSystemException and stop all further processing. 
/p 1809,1812c2263,2266 p Location of the fatal error, which could be either a source position in the case of loading, or a node reference for later validation. 
The public ID and system ID for the error location could be some of p Location of the fatal error, which could be either a source position in the case of loading, or a node reference for later validation. 
The public ID and system ID for the error location could be some of the information. 
/p 1840,1843c2294,2297 p Receive notification of a recoverable error per section 1.2 of the W3C XML 1.0 recommendation. 
The default behavior if the user doesn't register a handler is to report conditions that are not fatal errors, and allow p Receive notification of a recoverable error per section 1.2 of the W3C XML 1.0 recommendation. 
The default behavior if the user doesn't register a handler is to report conditions that are not fatal errors, and allow the calling application to continue processing. 
/p 1849,1851c2303,2305 position in the case of loading, or a node reference for later validation. 
The public ID and system ID for the error location could be some of the position in the case of loading, or a node reference for later validation. 
The public ID and system ID for the error location could be some of the information. 
/p 1887c2341 similar to a SAX locator object. 
/p 1925,1926c2379,2380 p A string containing the public identifier, or null if none p A string containing the public identifier, or null if none is available. 
/p 1940,1941c2394,2395 p A string containing the system identifier, or null if none p A string containing the system identifier, or null if none is available. 
/p 1966,1985c2420,2439 p Editing and generating a content model falls in the CM-editing world. 
The most obvious requirement for this set of requirements is for tools that author content models, either under user control, i.e., explicitly designed document types, or generated from other representations. 
The latter class includes transcoding tools, e.g., synthesizing an XML representation to p It's important to note here that a DTD's "internal subset" is part of the Content Model, yet is loaded, stored, and maintained as part of the individual document instance. 
This implies that even tools which do not want to let users change the definition of the Document Type may need to support editing operations upon this portion of the CM. 
It also means that our representation of the CM must be aware of where each portion of its content resides, so that when the serializer processes this document it can write out just the internal subset. 
A similar issue may arise with external parsed entities, or if schemas introduce the ability to reference other schemas. 
Finally, the internal-subset case suggests that we may want at least a two-level representation of content models, so a single DOM representation of a DTD can be shared among several documents, each potentially also having its own internal subset; it's possible that entity layering may be represented the same p Editing and generating a content model falls in the CM-editing world. 
The most obvious requirement for this set of requirements is for tools that author content models, either under user control, i.e., explicitly designed document types, or generated from other representations. 
The latter class includes transcoding tools, e.g., synthesizing an XML representation to match a database schema. 
/p p It's important to note here that a DTD's "internal subset" is part of the Content Model, yet is loaded, stored, and maintained as part of the individual document instance. 
This implies that even tools which do not want to let users change the definition of the Document Type may need to support editing operations upon this portion of the CM. 
It also means that our representation of the CM must be aware of where each portion of its content resides, so that when the serializer processes this document it can write out just the internal subset. 
A similar issue may arise with external parsed entities, or if schemas introduce the ability to reference other schemas. 
Finally, the internal-subset case suggests that we may want at least a two-level representation of content models, so a single DOM representation of a DTD can be shared among several documents, each potentially also having its own internal subset; it's possible that entity layering may be represented the same way. 
/p 1987,2008c2441,2462 interface with parsers. 
One of the ongoing problems in the DOM is that there is some information which must currently be created via completely undocumented mechanisms, which limits the ability to mix and match DOMs and parsers. 
Given that specialized DOMs are going to become more common (sub-classed, or wrappers around other kinds of storage, or optimized for specific tasks), we must avoid that situation and provide a "builder" API. 
Particular pairs of DOMs and p Note that several of these applications require that a CM be able to be created, loaded, and manipulated without/before being bound to a specific Document. 
A related issue is that we'd want to be able to share a single representation of a CM among several documents, both for storage efficiency and so that changes in the CM can quickly be tested by validating it against a set of known-good documents. 
Similarly, there is a known problem in DOM Level 2 where we assume that the DocumentType will be created before the Document, which is fine for newly-constructed documents but not a good match for the order in which an XML parser encounters this data; being able to "rebind" a p As noted earlier, questions about whether one can alter the content of the CM via its syntax, via higher-level abstractions, or both, exist. 
It's also worth noting that many of the editing concepts from the Document tree still apply; users should probably be able to clone part of a CM, remove and interface with parsers. 
One of the ongoing problems in the DOM is that there is some information which must currently be created via completely undocumented mechanisms, which limits the ability to mix and match DOMs and parsers. 
Given that specialized DOMs are going to become more common (sub-classed, or wrappers around other kinds of storage, or optimized for specific tasks), we must avoid that situation and provide a "builder" API. 
Particular pairs of DOMs and parsers may bypass it, but it's required as a portability mechanism. 
/p p Note that several of these applications require that a CM be able to be created, loaded, and manipulated without/before being bound to a specific Document. 
A related issue is that we'd want to be able to share a single representation of a CM among several documents, both for storage efficiency and so that changes in the CM can quickly be tested by validating it against a set of known-good documents. 
Similarly, there is a known problem in DOM Level 2 where we assume that the DocumentType will be created before the Document, which is fine for newly-constructed documents but not a good match for the order in which an XML parser encounters this data; being able to "rebind" a Document to a new CM, after it has been created may be desirable. 
/p p As noted earlier, questions about whether one can alter the content of the CM via its syntax, via higher-level abstractions, or both, exist. 
It's also worth noting that many of the editing concepts from the Document tree still apply; users should probably be able to clone part of a CM, remove and re-insert parts, and so on. 
/p 2012,2026c2466,2480 p In addition to using the content model to validate a document instance, applications would like to be able to use it to guide construction and editing of documents, which falls into the document-editing world. 
Examples of this sort of guided editing already exist, and are becoming more common. 
The necessary queries can be phrased in several ways, the most useful of which may be a combination of "what does the DTD allow me to insert here" and "if I insert this here, will the document still be valid". 
The former is better suited to presentation to humans via a user interface, and when taken together p It has been proposed that in addition to asking questions about specific parts of the content model, there should be a reasonable way to obtain a list of all the defined symbols of a given type (element, attribute, entity) independent of whether they're valid in a given location; that might be useful in building a list in a user-interface, which could then be updated to reflect p In addition to using the content model to validate a document instance, applications would like to be able to use it to guide construction and editing of documents, which falls into the document-editing world. 
Examples of this sort of guided editing already exist, and are becoming more common. 
The necessary queries can be phrased in several ways, the most useful of which may be a combination of "what does the DTD allow me to insert here" and "if I insert this here, will the document still be valid". 
The former is better suited to presentation to humans via a user interface, and when taken together with sub-tree validation may subsume the latter. 
/p p It has been proposed that in addition to asking questions about specific parts of the content model, there should be a reasonable way to obtain a list of all the defined symbols of a given type (element, attribute, entity) independent of whether they're valid in a given location; that might be useful in building a list in a user-interface, which could then be updated to reflect which of these are relevant for the program's current state. 
/p 2028,2031c2482,2485 attributes, a "can-this-go-there" may prompt a namespace-well-formedness check and warn you if you're about to conflict with or overwrite another attribute with the same namespaceURI/localName but different prefix... or same nodeName but attributes, a "can-this-go-there" may prompt a namespace-well-formedness check and warn you if you're about to conflict with or overwrite another attribute with the same namespaceURI/localName but different prefix... or same nodeName but different namespaceURI. 
/p 2033,2038c2487,2492 distance between two valid documents may be through an invalid one. 
Users may want to know several levels of detail (all the possible children, those which would be valid given what precedes this point, those which would be valid given both preceding and following siblings). 
Also, once XML Schemas introduce context sensitive validity, we may have to consider the effect of children as distance between two valid documents may be through an invalid one. 
Users may want to know several levels of detail (all the possible children, those which would be valid given what precedes this point, those which would be valid given both preceding and following siblings). 
Also, once XML Schemas introduce context sensitive validity, we may have to consider the effect of children as well as the individual node being inserted. 
/p 2043,2069c2497,2523 Content Model) is to use it to validate that a given XML document is in fact a properly constructed instance of the document type described by this CM. 
This again falls into the document-editing world. 
The XML spec only discusses performing this test at the time the document is loaded into the "processor", which most of us have taken to mean that this check should be performed at parse time. 
But it is obviously desirable to be able to validate again a document -- or selected subtrees -- at other times. 
One such case would be validating an edited or newly constructed document before serializing it or otherwise passing it to other users. 
This issue also arises if the "internal subset" is altered p In the past, the DOM has allowed users to create invalid documents, and assumed the serializer would accept the task of detecting problems and announcing/repairing them when the document was written out in XML syntax... or that they would be checked for validity when read back in. 
We considered adding validity checks to the DOM's existing editing operations to prevent creation of invalid documents, but are currently inclined against this for several reasons. 
First, it would impose a significant amount of computational overhead to the DOM, which might be unnecessary in many situations, e.g., if the change is occurring in a context where we know the result will be valid. 
Second, "the shortest distance between two good documents may be through a bad document". 
Preventing a document from becoming temporarily invalid may impose a considerable amount of additional work on higher-level code and users Hence our current plan is to continue to permit editing to produce invalid DOMs, but provide operations which permit a user to check the validity of a node on p Note that validation includes checking that ID attributes are Content Model) is to use it to validate that a given XML document is in fact a properly constructed instance of the document type described by this CM. 
This again falls into the document-editing world. 
The XML spec only discusses performing this test at the time the document is loaded into the "processor", which most of us have taken to mean that this check should be performed at parse time. 
But it is obviously desirable to be able to validate again a document -- or selected subtrees -- at other times. 
One such case would be validating an edited or newly constructed document before serializing it or otherwise passing it to other users. 
This issue also arises if the "internal subset" is altered -- or if the whole Content Model changes. 
/p p In the past, the DOM has allowed users to create invalid documents, and assumed the serializer would accept the task of detecting problems and announcing/repairing them when the document was written out in XML syntax... or that they would be checked for validity when read back in. 
We considered adding validity checks to the DOM's existing editing operations to prevent creation of invalid documents, but are currently inclined against this for several reasons. 
First, it would impose a significant amount of computational overhead to the DOM, which might be unnecessary in many situations, e.g., if the change is occurring in a context where we know the result will be valid. 
Second, "the shortest distance between two good documents may be through a bad document". 
Preventing a document from becoming temporarily invalid may impose a considerable amount of additional work on higher-level code and users Hence our current plan is to continue to permit editing to produce invalid DOMs, but provide operations which permit a user to check the validity of a node on demand. 
/p p Note that validation includes checking that ID attributes are unique, and that IDREFs point to IDs which actually exist. 
/p 2073,2080c2527,2534 which are parsed without reference to their DTDs. 
Knowing that a document is well-formed may be useful by itself even when a DTD is available. 
For example, users may wish to deliberately save an invalid document, perhaps as a checkpoint before further editing. 
Hence, the CM feature will permit both full validity checking (see next section) and "lightweight" WF checking, as requested by the caller, as well as processing entity declarations in the CM even if validation is not turned on. 
This falls within the document-editing which are parsed without reference to their DTDs. 
Knowing that a document is well-formed may be useful by itself even when a DTD is available. 
For example, users may wish to deliberately save an invalid document, perhaps as a checkpoint before further editing. 
Hence, the CM feature will permit both full validity checking (see previous section) and "lightweight" WF checking, as requested by the caller, as well as processing entity declarations in the CM even if validation is not turned on. 
This falls within the document-editing world. 
/p 2082,2084c2536,2538 conditions (proper nesting of elements, constraints on which children may be placed within each node), there are some checks that are not yet performed. 
conditions (proper nesting of elements, constraints on which children may be placed within each node), there are some checks that are not yet performed. 
These include: /p 2087,2089c2541,2543 p Character restrictions for text content and attribute values. 
Some characters aren't permitted even when expressed as numeric character p Character restrictions for text content and attribute values. 
Some characters aren't permitted even when expressed as numeric character entities /p 2095,2096c2549,2550 p The two-character sequence "--" in comments. 
(Which, be it p The two-character sequence "--" in comments. 
(Which, be it noted, some XML validators don't currently remember to test...) /p 2099,2100c2553,2554 p In addition, Namespaces introduce their own concepts of p In addition, Namespaces introduce their own concepts of well-formedness. 
Specifically: /p 2103,2105c2557,2559 p No two attributes on a single Element may have the same combination of namespaceURI and localName, even if their prefixes are different p No two attributes on a single Element may have the same combination of namespaceURI and localName, even if their prefixes are different and hence they don't conflict under XML 1.0 rules. 
/p 2108,2110c2562,2564 p NamespaceURIs must be legal URI syntax. 
(Note that once we have this code, it may be reusable for the URI "datatype" in document content; see p NamespaceURIs must be legal URI syntax. 
(Note that once we have this code, it may be reusable for the URI "datatype" in document content; see discussion of datatypes.) /p 2113,2124c2567,2576 p The mapping of namespace prefixes to their URIs must be declared and consistent. 
That isn't required during normal DOM operation, since we perform "early binding" and thereafter refer to nodes primarily via their namespaceURIs and localName. 
But it does become an issue when we want to serialize the DOM to XML syntax, and may be an issue if an application is assuming that all the declarations are present and correct. 
This may imply that we should provide a code namespaceNormalize /code operation, which would create the implied declarations and reconcile conflicts in some reasonably standardized manner. 
This may be a major undertaking, since some DOMs may be using the namespace to direct subclassing of the nodes or similar special treatment; as with the existing code normalize /code method, you may be left with a p The mapping of namespace prefixes to their URIs must be declared and consistent. 
That isn't required during normal DOM operation, since we perform "early binding" and thereafter refer to nodes primarily via their namespaceURIs and localName. 
But it does become an issue when we want to serialize the DOM to XML syntax, and may be an issue if an application is assuming that all the declarations are present and correct. 
This may imply that we should provide a code namespaceNormalize /code operation, which would create the implied declarations and reconcile conflicts in some reasonably standardized manner. 
This may be a major undertaking, since some DOMs may be using the namespace to direct subclassing of the nodes or similar special treatment; as with the existing code normalize /code method, you may be left with a different-but-equivalent set of node objects. 
/p 2128,2145c2580,2598 violate these rules, and assumed the serializer would accept the task of detecting problems and announcing/repairing them when the document was written out in XML syntax. 
We considered adding WF checks to the DOM's existing editing operations to prevent WF violations from arising, but are currently inclined against this for two reasons. 
First, it would impose a significant amount of computational overhead to the DOM, which might be unnecessary in many situations (for example, if the change is occurring in a context where we know the illegal characters have already been prevented from arising). 
Second, "the shortest distance between two good documents may be through a bad document" -- preventing a document from becoming temporarily ill-formed may impose a considerable amount of additional work on higher-level code and users. 
(Note possible issue for Serialization: In some applications, being able to save and reload marginally poorly-formed DOMs might be useful -- editor checkpoint files, for example.) Hence our current plan is to continue to permit editing to produce ill-formed DOMs, but provide operations which permit a user to check the well-formedness of a node on demand, and possibly provide some of the /div2 /div1 !-- violate these rules, and assumed the serializer would accept the task of detecting problems and announcing/repairing them when the document was written out in XML syntax. 
We considered adding WF checks to the DOM's existing editing operations to prevent WF violations from arising, but are currently inclined against this for two reasons. 
First, it would impose a significant amount of computational overhead to the DOM, which might be unnecessary in many situations (for example, if the change is occurring in a context where we know the illegal characters have already been prevented from arising). 
Second, "the shortest distance between two good documents may be through a bad document" -- preventing a document from becoming temporarily ill-formed may impose a considerable amount of additional work on higher-level code and users. 
(Note possible issue for Serialization: In some applications, being able to save and reload marginally poorly-formed DOMs might be useful -- editor checkpoint files, for example.) Hence our current plan is to continue to permit editing to produce ill-formed DOMs, but provide operations which permit a user to check the well-formedness of a node on demand, and possibly provide some of the primitive (e.g., string-checking) functions directly. 
/p /div2 /div1 !-- 
I might be a better idea to put the diffs on the web site in the future, instead of sending 100 kb emails :=) Ari. 
Noted. 
Here is the diff on the web site: Philippe 
