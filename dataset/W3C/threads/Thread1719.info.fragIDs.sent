Hi, A working-collection can have non-versioned-resources as its members. 
And when the working-collection is checked in, these non-versioned-members are automatically version-controlled. 
If the working-collection has a non-empty DAV:activity-set, then would it not make sense to copy this activity-set to each of the non-versioned-members which have been automatically version-controlled? 
This is especially meaningful when we consider the activity as a 'change set'. 
Surely the newly added resources are part of the same 'logical change' as their parent collection. 
Regards, Girish 
Yes, I agree that this would make sense. 
Cheers, Geoff Hi, A working-collection can have non-versioned-resources as its members. 
And when the working-collection is checked in, these non-versioned-members are automatically version-controlled. 
If the working-collection has a non-empty DAV:activity-set, then would it not make sense to copy this activity-set to each of the non-versioned-members which have been automatically version-controlled? 
This is especially meaningful when we consider the activity as a 'change set'. 
Surely the newly added resources are part of the same 'logical change' as their parent collection. 
Regards, Girish 
Hi, considering: - a versioned controlled checked-in collection /a - a version controlled resource /a/b with a version history resource of /vhr/123 - a server that handles deletion of version histories as request to un-version-control the VCR What should happen upon a DELETE on /vhr/123? 
- this would be considered to change the state of /a/b from being version-controlled to not being version-controlled, however the parent collection isn't checked out - returning Conflict with error condition DAV:cannot-modify-checked-in-parent seems to be a valid approach, however doesn't fit optimally (because the request was sent to /vhr/123, and /a -- which causes the error as not bein checked out -- isn't a parent collection of the request URI). 
Julian 
