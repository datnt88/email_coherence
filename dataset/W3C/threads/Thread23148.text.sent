From:David Brownell [SMTP:david-b@pacbell.net] 
We changed the specification following a comment from Ralph Levien during the CR phase: That shows that several folk raised the issue of that change introducing an asymmetry with respect to addEventListener(), which should have been dealt with at the same time. 
I think the corresponding change on the addEventListener side is a guarantee that a listener added to the current node _will_ be invoked as appropriate. 
So , you mean that adding an event listener to a list currently being processed should be invoked? 
If so, I don't see why this is "appropriate". 
This is not about symmetry, it's about potentially provoking code that may not longer be valid due to dangling pointers, inconsistent state, etc. 
I think when an event is dispatched, it should try to appear as an atomic operation, meaning a copy of the listener list is used. 
This was probably the reasoning behind the original proposal. 
But it was not suitable in practice for removing listeners because data and state associated with the listener may no longer be valid. 
Mike That shows that several folk raised the issue of that change introducing an asymmetry with respect to addEventListener(), which should have been dealt with at the same time. 
I think the corresponding change on the addEventListener side is a guarantee that a listener added to the current node _will_ be invoked as appropriate. 
Keeping an API model self-consistent is _always_ appropriate. 
So you deny that the resolution of that issue created an inconsistency in the API model? 
Atomic != "use a copy". 
The change I identified is as atomic as the current text, but it's got the same model for the add and remove tasks. 
- Dave From:David Brownell [SMTP:david-b@pacbell.net] 
That's a pretty broad generalisation don't you think? 
Yes. 
It is an exceptional thing to do. 
But I believe it is a necessary for exactly the reasons Phillipe pointed out. 
That's why I said "_appear_ as an atomic operation". 
This is aesthetic reasoning with no practical merit. 
In an ideal system, the operations would trigger all event listeners in parallel as an atomic operation on a snapshot of the DOM's state in which case this whole issue would be moot because one listener could not remove another and see the effects. 
Unfortunately, until we start using quantum computers we'll have to continue to trigger listeners synchronously in which case this removal of an event listener must be dealt with for the reasons outlined. 
IMHO, Mike You seem to think that's a bad thing; why? 
There's cognitive science behind that principle, as well as years of practical experience. 
Self-inconsistent models are error prone; special cases tend to make bugs happen. 
More people trip over the pavement that's raised an extra few inches (say, by a root) than over the flat stuff. 
I don't seem to have a message from Phillipe with any reasons. 
The archive discussion doesn't address that issue (that is, it was raised a couple times but ignored). 
... "meaning a copy ... is used". 
Sure looks to me like you said the two concepts are one and the same. 
You lost me there. 
"Atomic" has clear technical meaning, "same model" has one that seems clear in context. 
You did not respond to either aspect. 
Were you responding to some other post, which used a "fighting word" like "ugly"? 
And that's irrelevant to the consistency issue, which was raised along with the original proposal yet which is still unresolved. 
- Dave Folks, what Philippe has pointed out is that a decision actually was made; the spec says what we meant to say, and there were legitimate reasons behind that decision. 
I agree it's a bit ugly, but it isn't an Erratum and we really can't change it without a better reason than aesthetics. 
A FAQ entry might be called for. 
I'm probably not the best person to write this one, but if folks think it's needed and nobody else steps up I'll take a stab at it. 
Joe Kesselman / IBM Research I realise this is a little OT but I thought some people might like to know that I have found the implementation details of the "ugly" exception discussed in this thread to be Not That Bad. 
In fact it is _less_ code than I posted before. 
Here's an excerpt: /* Trigger capturers evt- eventPhase = DOM_EVENT_CAPTURING_PHASE; for (i = 0; i  tcount &amp;&amp; evt- sp == 0; i++) { DOM_EventListener cpy_of_listener_fns[targets[i]- listeners_len]; /* use stack ok? */ t = targets[i]; lcount = t- listeners_len; for (j = 0; j  lcount; j++) { /* copy functions */ e = t- listeners[j]; cpy_of_listener_fns[j] = e ? 
e- listener_fn : NULL; evt- currentTarget = t; for (j = 0; j  lcount; j++) { e = t- listeners[j]; /* if NULL, listener has been removed -- skip it */ if (e &amp;&amp; cpy_of_listener_fns[j] &amp;&amp; e- useCapture &amp;&amp; DOM_String_cmp(e- type, evt- type) == 0) { cpy_of_listener_fns[j](evt); The key here is checking both the listener directly _and_ a copy made before events are dispatched for a given set of listeners on a node. 
As you can see this is pretty simple if arrays are used that can have NULL entries (holes are created in the array if listeners are removed). 
The first check will fail if the listener has been removed and the second will fail if there was no listener when the copy was made (whereas it will not be null if a listener was _added_ after a copy was made). 
I have not tested this but as soon as I do you can view the whole implementation when I upload domc-0.4.1 (http://auditorymodels.org/domc/). 
Mike 
