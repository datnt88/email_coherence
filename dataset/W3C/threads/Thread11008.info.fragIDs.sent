But wouldn't anything else be a query and thus have to go after a "?". 
Queries _always_ invoke a server-side process. 
#-strings invoke a client-side process, that depends on the MIME-type of the resource deisgnated by the URL the #-string is attached to. 
I hadn't realized that distinction. 
Given that, it does make sense, I 
think, to allow TEI extended pointers or something like them after the #. 
If understand the implications, we'd be saying that for the mime type "xml" (or x-xml, I suppose), that stuff following the "#" is interpreted as 
either a single ID reference or as some more complicated address (at least for TEI, you can distinguish the two as TEI locators would always be enclosed in parens--right? 
Cheers, E. W. Eliot Kimber (eliot@isogen.com) 
Senior SGML Consulting Engineer, Highland Consulting 2200 North Lamar Street, Suite 230, Dallas, Texas 75202 "Rats in the morning, rats in the afternoon...if they don't go away, I'll be re-educated soon..." --Austin Lounge Lizards, "1984 Blues" 
Eliot: 
But wouldn't anything else be a query and thus have to go after a "?". 

Queries _always_ invoke a server-side process. 
#-strings invoke a client-side process, that depends on the MIME-type of the resource deisgnated by the URL the #-string is attached to. 
I believe this does not necessarily apply to URLs in general (see below). 
As I understand it, the addressing of the fragment is separate from the semantics of the request for the object identified by the URL (the part before the #). 
The HTTP URL defines these semantics wrt #. 
From the notoriously ill-written RFC 1630 on URLs: HASH FOR FRAGMENT IDENTIFIERS The hash ("#", ASCII 23 hex) character is reserved as a delimiter to separate the URI of an object from a fragment identifier . 
Fragment-id This represents a part of, fragment of, or a sub-function within, an object. 
Its syntax and semantics are defined by the application responsible for the object, or the specification of the content type of the object. 
The only definition here is of the allowed characters by which it may be represented in a URL. 
Specific syntaxes for representing fragments in text documents by line and character range, or in graphics by coordinates, or in structured documents using ladders, are suitable for standardization but not defined here. 
The fragment-id follows the URL of the whole object from which it is separated by a hash sign (#). 
If the fragment-id is void, the hash sign may be omitted: A void fragment-id with or without the hash sign means that the URL refers to the whole object. 
While this hook is allowed for identification of fragments, the question of addressing of parts of objects, or of the grouping of objects and relationship between continued and containing objects, is not addressed by this document. 
Fragment identifiers do NOT address the question of objects which are different versions of a "living" object, nor of expressing the relationships between different versions and the living object. 
There is no implication that a fragment identifier refers to anything which can be extracted as an object in its own right. 
It may, for example, refer to an indivisible point within an object. 
... [from HTTP-specific portion, now obsolete but perhaps not in this detail:] No fragmentid part of a WWW URI (the hash sign and following) is sent with the request. 
Spaces and control characters in URLs must be escaped for transmission in HTTP, as must other disallowed characters. 
... [from nonnormative examples for HTTP:] A reference to a particular part of a document may, including the fragment identifier, look like in which case the string "#andy" is not sent to the server, but is retained by the client and used when the whole object had been retrieved. 
Regards, Terry Allen Fujitsu Software Corp. tallen@fsc.fujitsu.com 
"In going on with these experiments, how many pretty systems do we build, which we soon find outselves obliged to destroy?" - Benjamin Franklin A Davenport Group Sponsor: http://www.ora.com/davenport/index.html 
[Eliot Kimber, in passing:] 
I've been informed by Reliable Sources that the latest recommendations (it seems that I was one edition behind) say that you should *not* use x-whatever for MIME types that are intended to be standardized at some time in the future. 
I've fallen behind on getting the MIME registration straightened out, but the best information that I have right now is that we should be using a MIME type of text/xml (or application/xml -- I've gotten mixed opinions on this) from the beginning, not x-xml. 
Jon 
