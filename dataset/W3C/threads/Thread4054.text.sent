It would be very useful if the value of an XPath predicate expression could be *a sequence of values* of a numeric type. 
Use: Since xsl:copy-of can now be used to copy a sequence of items, it would be excellent if one could write instead of the more long-winded Note you could (and can, even in xslt1) do to get this effect, which isn't so much more verbose than the to syntax (which I agree would be nice to have if it could be done without further complicating the interaction between numeric and boolean valued predicates) David (note this is an external comment, I'm not a WG member) This was proposed at one stage, but when you look at the actual semantics, they become very complicated. 
Remember that a numeric predicate [$n] is defined in terms of the boolean predicate [position()=$n]. 
$n does not have to be constant for all items in the sequence; you can write, for example, $seq[string-length(.)] and get all the items whose position in the sequence is equal to their string length. 
The other problem is that because static typing is optional, the semantics have to be defined in terms of the dynamic type of the predicate. 
One of the nice things about the "effective boolean value" rule is that when you supply a sequence, you don't have to read the whole sequence in order to decide what its EBV is. 
But if we handle a sequence of integers differently from any other sequence, then we do (in the absence of static type analysis) have to read the whole sequence to find out if it consists entirely of integers. 
We decided that this was overloading the [] operator one step too far, and that it wasn't a great hardship to write: for $i in 1 to 20 return $seq[$i] Michael Kay Or $seq[position() = 1 to 20] if you prefer. 
Cheers, Jeni Jeni Tennison I should also have mentioned that your example is incorrect. 
"." within a predicate applied to a node-set always selects a node, so its effective boolean value is true. 
You meant to write: But of course you can also do this as: or you can use the subsequence() function if you prefer. 
Michael Kay Nice one, Jeni. 
Michael Kay (reaching for his optimizer...) 
