One function we added to our XQuery implementation is eval(), which takes a string and evaluates it as an XQuery expression. 
I'm wondering if the working group has considered adding such a function. 
The most obvious use case is a query that needs to be marked up and executed later. 
For example, in the NIST test suite, a test looks like: {fn:boolean(xs:double("-1.7976931348623157E308"))} So an implementor is somehow expected to read in the whole file and execute it as XQuery. 
If eval is supported, the same file can become fn:boolean(xs:double("-1.7976931348623157E308")) 
And the test may be evaluated with XQuery itself: eval(doc("test.xml")/results/string()) 
There are, of course, many other uses. 
The is not merely a "convenience method" as it could never be written as a user-defined function. 
Any comments are appreciated. 
--Sarah We have looked at the function eval(). 
However, we felt that such a function adds too much dynamic behaviour, that we cannot request from every implementation. 
It is also a function that has security issues (such as code insertion) and does not work well with statically typed systems. 
Best regards Michael like: "convenience I'm also in favor of an eval() function, and expect most of the better XQuery implementations to provide one. 
Statically, you'd type it as item()*. 
Static typing hasn't prevented the introduction of the data() function, which extracts the typed value of a sequence without having the most specific static type. 
Also, the security issue is moot; eval() doesn't have permission to do anything the user couldn't already do. 
Javascript and Perl both have eval. 
Code injection is only an issue if eval() takes only a string. 
If it also takes variable bindings (possibly the ones already in scope), then one could use parameterized queries and avoid injection. 
But code injection is already an issue for XQuery in general, just as it is for SQL. 
It's inconsistent that the committee long resisted external parameters -- which are critical in avoiding query injection -- and now uses injection as an argument against eval. 
And finally, I fail to see how eval() is any burden to implementers at all. 
In its simplest form, eval() simply recursively calls their own implementation to compile and execute the query string with the same static and dynamic environment as the original. 
If we're talking implementation burdens, let's discuss static typing, arbitrary-precision numerics, formal semantics, and the PSVI data model. 
Eval() is the tiniest fleck in the XQuery universe of features. 
If it's really such an obstacle, add it to a non-normative list of suggested functions (and put half of the existing F&amp;O there with it). 
Cheers, michael [mailto:public-qt-comments-request@w3.org] 
On Behalf Of Michael Rys We have looked at the function eval(). 
However, we felt that such a function adds too much dynamic behaviour, that we cannot request from every implementation. 
It is also a function that has security issues (such as code insertion) and does not work well with statically typed systems. 
Best regards Michael like: "convenience I expect some XQuery functions to provide an eval() function. 
However, I (and others) have not considered it a feature that all implementations can or have to provide. 
As to fn:data(): the static result type of fn:data() is actually quite precise (the static type is determined based on the static type of the input argument). 
As to the security issues: There will be XQuery implementations that will have to worry about that (one of the reason why we should not require the standard to require this function. 
As to the inconsistency argument: I don't quite follow you why the position on not wanting external variables somehow should be tied to this discussion. 
Finally, I did not use the argument of it being a burden to implementers. 
Although as you should know, there is more to the cost of implementing than to code it... Best regards Michael the a also which an implementation formal it's insertion) wondering You may be aware that a number of XSLT implementations have a function like this, and that it is included in the EXSLT library (www.exslt.org) 
under the name dyn:evaluate(). 
The XSLT working group decided not to include such a function in the standard. 
This is a shame in some ways because the function can indeed be very useful. 
The reasons for the decision were: it is quite difficult to specify it well, especially to define the static and dynamic context for the function; it makes it difficult to separate the language compiler from the run-time; it introduces significant complexities for typing. 
Also, I think some people felt that it was likely to be used for situations where the correct solution was higher-order functions (which are also not in this version of the spec, and which some people feel are a higher priority than dynamic evaluation). 
Clearly there is nothing to stop implementors adding such functions under their own namespace, or under a third-party namespace such as the one allocated by the EXSLT group. 
Michael Kay 
