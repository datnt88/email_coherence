I've got a question to do with preserving the location in a namespace of the root of a baseline. 
Section 12 has the following discussion of subbaselines and components: As a configuration gets large, it is often useful to break it up into a set of smaller configurations that form the logical "components" of that configuration. 
In order to capture the fact that a baseline of a configuration is logically extended by a component configuration baseline, the component configuration baseline is captured as a "subbaseline" of the baseline. 
The root collection of a configuration is unconstrained with respect to its relationship to the root collection of any ofits components. 
In particular, the root collection of a configuration can have a member that is the root collection of one of its components (e.g. configuration /sys/x can have a component /sys/x/foo), can be a member of the root collection of one of its components (e.g. configuration /sys/y/z can have a component /sys/y), or neither (e.g. configuration /sys/x can have a component /comp/bar). 
My understanding of the protocol is that a baseline does not record where in a namespace the root of the baseline should be located. 
The baseline records the versions and relative names of members of the baseline, i.e. it preserves a namespace where the baseline-collection is the root of the namespace. 
I also thought that while a baseline can have subbaselines, this set of baselines does not define where in a namespace each baseline should be placed. 
Given the DAV:baseline-controlled-collection-set property of a workspace, I had assumed that the workspace acted as a namespace that preserved the relative name of the root of each baseline. 
So, for example, to populate a new workspace from a workspace that publishes a set of baselines, the client would issue MKCOL and BASELINE_CONTROL requests to populate the new workspace with baselines chosen from, &amp; as named in, the publishing workspace. 
Have I understood this right? 
Or is there something in the structure of a baseline itself, that preserves the relative name of another baseline? 
I wondered if it was expected that a baseline implementation should 
record a "baseline-binding", where a baseline-binding is a (name, baseline-history) pair. 
The baseline-collection, or any collection which is a member of the baseline-collection, would retain a baseline-binding if at the time the baseline was created the collection had an internal member which was baseline-controlled. 
Then, on BASELINE-CONTROL of a collection in the new workspace from a baseline, the server could restore a subbaseline if the baseline contains a baseline-binding for the baseline-history of the subbaseline. 
The BASELINE-CONTROL method does not include a postcondition for 
subbaselines, so I'm not sure if this would be compliant behaviour or not. 
Finally, the cases where a subbaseline is located outside of the namespace of the baseline (examples /sys/y/z +/sys/y and /sys/x + /comp/bar from above), would seem to rely on baseline-bindings being preserved in some other baseline (if the intention is to automate this), and being present in the target namespace of the operation. 
Thanks, Alison. 
The statements and opinions expressed here are my own and do not necessarily represent those of Oracle Corporation. 
From: Alison Macmillan [mailto:alison.macmillan@oracle.com] 
I've got a question to do with preserving the location in a namespace of the root of a baseline. 
Section 12 has the following discussion of subbaselines and components: As a configuration gets large, it is often useful to break it up into a set of smaller configurations that form the logical "components" of that configuration. 
In order to capture the fact that a baseline of a configuration is logically extended by a component configuration baseline, the component configuration baseline is captured as a "subbaseline" of the baseline. 
The root collection of a configuration is unconstrained with respect to its relationship to the root collection of any of its components. 
In particular, the root collection of a configuration can have a member that is the root collection of one of its components (e.g. configuration /sys/x can have a component /sys/x/foo), can be a member of the root collection of one of its components (e.g. configuration /sys/y/z can have a component /sys/y), or neither (e.g. configuration /sys/x can have a component /comp/bar). 
My understanding of the protocol is that a baseline does not record where in a namespace the root of the baseline should be located. 
Correct. 
The baseline records the versions and relative names of members of the baseline, i.e. it preserves a namespace where the baseline-collection is the root of the namespace. 
Correct. 
I also thought that while a baseline can have subbaselines, this set of baselines does not define where in a namespace each baseline should be placed. 
Correct. 
Given the DAV:baseline-controlled-collection-set property of a workspace, I had assumed that the workspace acted as a namespace that preserved the relative name of the root of each baseline. 
So, for example, to populate a new workspace from a workspace that publishes a set of baselines, the client would issue MKCOL and BASELINE_CONTROL requests to populate the new workspace with baselines chosen from, &amp; as named in, the publishing workspace. 
Have I understood this right? 
Or is there something in the structure of a baseline itself, that preserves the relative name of another baseline? 
If a server supports version-controlled collections, and if a version-controlled collection gave a name to a version history, and that version history is the root of a subbaseline, then that subbaseline is restored at that location. 
But otherwise, no, the protocol does not require a server to preserve anything about the relative locations of subbaselines. 
I wondered if it was expected that a baseline implementation should 
record a "baseline-binding", where a baseline-binding is a (name, baseline-history) pair. 
The baseline-collection, or any collection which is a member of the baseline-collection, would retain a baseline-binding if at the time the baseline was created the collection had an internal member which was baseline-controlled. 
This is automatically captured by version-controlled collections, but it certainly would be reasonable (although not required) for a server to support this even if it does not support version-controlled collections (clients that expect version-controlled collections will 
expect this kind of behavior). 
Then, on BASELINE-CONTROL of a collection in the new workspace from a baseline, the server could restore a subbaseline if the baseline 
contains a baseline-binding for the baseline-history of the subbaseline. 
The BASELINE-CONTROL method does not include a postcondition for subbaselines, so I'm not sure if this would be compliant behaviour or not. 
It is not required behavior unless the server supports version-controlled collections, but it is certainly legal for a server to do so. 
Finally, the cases where a subbaseline is located outside of the namespace of the baseline (examples /sys/y/z +/sys/y and /sys/x + /comp/bar from above), would seem to rely on baseline-bindings being 
preserved in some other baseline (if the intention is to automate this), and being present in the target namespace of the operation. 
Yes. 
Cheers, Geoff 
Thanks for the reply. 
I hadn't understood from the spec that the (collection) version-history should imply a baseline, and so had not seen how the version-controlled-binding could behave as a "baseline-binding". 
So, is the model that there is an association between a baseline and a version-history, or between a baseline-history and a version-history, or something else? 
If there is an association between a baseline-history and a version-history, is it constrained to be 1:1 (i.e. the baseline-history and version-history are two aspects of the same collection - a collection that is both versioned, and the root of a configuration)? 
Do any additional pre- or post- conditions arise from the association? 
For example, if /ws/col1 is a non-empty version-controlled collection, that is 
baseline-controlled to create baseline /bl/1. 
Is it illegal to baseline-control /ws/col2, an _empty_ version-controlled collection, from baseline /bl/1? 
Or does /ws/col2 simply become another name for /ws/col1? 
Thanks, Alison The statements and opinions expressed here are my own and do not necessarily represent those of Oracle Corporation. 
From: Alison Macmillan [mailto:alison.macmillan@oracle.com] 
I hadn't understood from the spec that the (collection) version-history should imply a baseline, and so had not seen how the version-controlled-binding could behave as a "baseline-binding". 
A collection version history definitely does not imply a baseline. 
But if a server supports both version-controlled collections and baselines, then if a baseline B1 selects collection version CV2 (say with name "x/y" relative to the root of B1), and if CV2 has a version-controlled binding named "z" to the collection version history CVH3, and if B1 has a subbaseline B2, and if the root of B2 is a version of CVH3, then subbaseline B2 will be located at "x/y/z" relative to the root of B1. 
So, is the model that there is an association between a baseline and a version-history, or between a baseline-history and a version-history, or something else? 
There is an association, but it is the: baseline (selects) collection version (has binding to) collection version history (has version) collection version (root of) subbaseline If there is an association between a baseline-history and a version-history, is it constrained to be 1:1 (i.e. the baseline-history and version-history are two aspects of the same collection - a collection that is both versioned, and the root of a configuration)? 
This is not required by the protocol. 
Do any additional pre- or post- conditions arise from the association? 
For example, if /ws/col1 is a non-empty version-controlled collection, that is baseline-controlled to create baseline /bl/1. 
Is it illegal to baseline-control /ws/col2, an _empty_ version-controlled collection, from baseline /bl/1? 
Or does /ws/col2 simply become another name for /ws/col1? 
Your server could do it either way. 
We could constrain it to be one way or the other, but I think that might intrude on issues that might conflict with alternative implementation techniques. 
Cheers, Geoff 
So, is it right that the DAV:baseline-collection can _itself_ be a VCR (for the above example, with DAV:checked-in a version of CVH3)? 
Thanks, Alison. 
The statements and opinions expressed here are my own and do not necessarily represent those of Oracle Corporation. 
From: Alison Macmillan [mailto:alison.macmillan@oracle.com] 
So, is it right that the DAV:baseline-collection can _itself_ be a VCR (for the above example, with DAV:checked-in a version of CVH3)? 
That's correct. 
Cheers, Geoff 
Please try it again (the link was pointing to the collection instead of to the .mdl 
file). 
Cheers, Geoff Hi, I tried to get the Web Versioning Model from the deltaV web server at http://www.webdav.org/deltav/ 
I can access it in the browser version only, but I don't get the permission to download the corresponding mdl file. 
Is there a way to get a copy of this model ? 
thanks and regards Matthias 
Consider the following situation: we have version-controlled-directory /x placed under baseline control and version-controlled-directory /x/y belonging to the different configuration. 
Now if we extract baseline (without subbaselines) from version-controlled-configuration for /x in some workspace, how we should handle /x/y belonging to the other configuration and all it's members ? 
Should created version-controlled-resource /x contain binding to "y"? 
Should we create version-controlled-resource for /x/y? 
If so, which version should it select? 
Server dependent (initial, latest, random,...) Should it also be done for members of /x/y? 
Thanks in advance Konstantin 
From: Konstantin Knizhnik [mailto:KKnizhnik@togetherlab.com] 
Consider the following situation: we have version-controlled-directory /x placed under baseline control and version-controlled-directory /x/y belonging to the different configuration. 
Now if we extract baseline (without subbaselines) from version-controlled-configuration for /x in some workspace, how we should handle /x/y belonging to the other configuration and all it's members ? 
To make this more concrete: let's assume that "some workspace" is /ws/kk, and that /ws/kk/x is under baseline control, and version-controlled configuration associated with /ws/kk/x selects a baseline from the baseline history /repo/bh/8. 
Now a new baseline (/repo/bl/22) for /repo/bh/8 is created in some other workspace, and we decide to MERGE /repo/bl/22 into /ws/kk. 
Should created version-controlled-resource /x contain binding to "y"? 
Yes. 
Although it is not a binding "to" y, but rather a binding "named" y. 
Should we create version-controlled-resource for /x/y? 
It depends. 
Let /repo/vh/12 be the version-history that is identified by the version-controlled binding named "y" in the version of /x selected by /repo/bl/22. 
If before the MERGE, there was a VCR that selected a version of /repo/vh/12, then /ws/kk/x/y is just a binding to that VCR. 
If there was no such VCR, then the server creates a new VCR at /ws/kk/x/y. 
If so, which version should it select? 
Server dependent (initial, latest, random,...) If a new VCR was created, the DAV:checked-in version of that VCR is an arbitrary version of /repo/vh/12. 
I tried to require that it select the root version in this case, but a couple members of the design team insisted this this choice had to be left up to the server. 
Should it also be done for members of /x/y? 
Yes. 
One of the advantages of picking the "root" version is that if it is a collection, it is common for the "root" version to be empty, so you don't have to traverse down the tree picking random versions all the way down. 
Cheers, Geoff h 
Postcondition for DELETE in section 5.6 DAV:delete-version-set says that it is possible to delete version-history. 
By what should I do with bindings to this version-history from parent versions? 
There is nothing about it in specification. 
Is it possible for server to prohibit DELETE of VERSION-HISTORY? 
(as it is allowed for VERSION) 
Yes, a server is allowed to prohibit DELETE of a version history. 
If a server does support DELETE of a version history, it is faced with two unpleasant alternatives: either delete all references to that version history from collection versions, or to leave those references dangling, with undefined results when that collection version is selected as the DAV:checked-in version of a version controlled collection. 
Cheers, Geoff Postcondition for DELETE in section 5.6 DAV:delete-version-set says that it is possible to delete version-history. 
By what should I do with bindings to this version-history from parent versions? 
There is nothing about it in specification. 
Is it possible for server to prohibit DELETE of VERSION-HISTORY? 
(as it is allowed for VERSION) 
