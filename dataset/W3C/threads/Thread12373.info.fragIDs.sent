In yesterday's conference call it was decided to define the technique categories as tool functionality types rather than tool types. 
The following includes this change as well as proposed re-wordings of the category descriptions. 
Pay special attention to my attempt to split Multimedia editors from markup editors according to the human readability of the formats they produce. 
Does this work? 
I would welcome more examples for the different categories. 
Categories of Authoring Tool Functionality The Authoring Tools Accessibility Guidelines (ATAG) have been formulated to apply across a diverse range of software products that produce Web content. 
To accomplish this, the guidelines and checkpoints have been stated fairly generally. 
To offset this generality, the implementation techniques (in this document) have been formulated to be more specific, at the cost of reducing the applicability of individual techniques to all authoring tools. 
In order to simplify the task of determining which techniques are applicable to a particular authoring tool, five categories of authoring functionality have been defined. 
It is important to note that the categories refer to authoring functionality rather than complete authoring tools. 
This allows different aspects of a given tool to fall within different functionality categories. 
For example, an HTML authoring tool may feature a WYSIWYG markup editor (Category 1: Markup editing functionality), a javascript editor (Category 4: Programming functionality), and the ability to import word-processed documents (Category 5: Conversion functionality). 
Each category has an associated icon that will label those techniques that are likely to apply to products that include functionality in that category. 
Keep in mind, however, that the categories are intended as a guide, rather than a last word in compliance. 
Some techniques that are flagged by a category icon might not be relevant to a tool with functionality in that category, while other unflagged techniques, may in fact be relevant. 
To avoid missing relevant techniques, it is recommended that developers take the time to, at least briefly, consider all the techniques in this document. 
Category 1: Markup Editing Functionality These are tool functions that authors use to specify content and its presentation. 
These include: - Direct (text-based.) and indirect (WYSIWYG, object-based, etc.) editing of documents in markup formats (i.e. HTML, XHTML, etc.). 
This includes indirect editing by word processors that are capable of saving as markup formats (i.e. HTML, XHTML, etc.). 
- Direct and indirect editing of multimedia (images, animation, sound, video, haptics) content in human-readable formats (i.e. SVG, SMIL, etc.). 
Category 2: Multimedia Creation Functionality These are tool functions that authors use to create Web content in non-human-readable multimedia formats. 
These include - Indirect editing of multimedia (images, animation, sound, video, haptics) content in non-human-readable formats (i.e. JPEG, PNG, Quicktime, Flash, etc.). 
Category 3: Content Management Functionality These are tool functions that create and organize Web content on the basis of high-level author input. 
These include: - Database driven Web applications that prompt the author for information that is then displayed in a generic (or semi-generic) manner (i.e. courseware). 
Note that any direct or indirect authoring of the final markup (i.e. editing presentation templates) is considered to be markup editing functionality (see category 1). 
Category 4: Programming Functionality These are tool functions that authors use to create Web application code. 
These include: - Direct or indirect editing of program code (i.e. Java applets, Flash action script, server and client-side scripts, etc.). 
- Direct or indirect editing of markup languages grammars (i.e. XML languages). 
- Direct and indirect editing of style sheets (i.e. CSS). 
Category 5: Conversion Functionality These are tool functions that convert content in one format into another format. 
These include: - Converting word processor-formatted content into a markup format as it is imported into an editor. 
Note that any direct or indirect authoring of the converted markup, image, etc. is considered to be markup editing functionality (see category 1). - Saving multimedia content in other formats (i.e. bitmap saved as a jpeg, etc.). 
Cheers, Jan Jan Richards UI Design Specialist Adaptive Technology Resource Centre (ATRC) University of Toronto jan.richards@utoronto.ca 
this is much more helpful, I think - well done. 
Yep, I think this is pretty cool. 
Couple of comments: 
The 'direct' and indirect' editing bit seemed confusing to me, and I think that talking about "WYSIWYG" editing modes makes more sense. 
I also think that what we currently call "markup editing tools" are more obviously "document editing tools" (for example Front Page, Word, Dreamweaver, Amaya) or in some cases code editing tools (e.g. HomeSite, Dreamweaver 4, asWedit, Hotdog). 
Are the code editing tools in the same class as programming tools? 
I think that the essential difference is that programming tools create something dynamic, but I am not sure if that is important - it only applies as a criterion in a handful of WCAG checkpoints and for 7.2 So I propose that we consider changing the way we use these two categories (markup/document editing and programming/code editing). 
cheers Charles this is much more helpful, I think - well done. 
Location: 21 Mitchell street FOOTSCRAY Vic 3011, Australia (or W3C INRIA, Route des Lucioles, BP 93, 06902 Sophia Antipolis Cedex, France) 
re: "direct" &amp; "indirect" editing I debated with myself about introducing new terminology. 
But "indirect" seems cover some cases that WYSIWYG does not: 1. Programming environments that make heavy use of graphic objects rather than raw code during editing (ex. 
IShell) 2. Multimedia sound and haptic editors that have visual representations that differ substantially from the final sonic or haptic version. 
re: markup/document editing and programming/code editing functionality This is quite sticky. 
At the implementation level it is difficult to separate editing of markup from editing of code, but I keep coming back to one thought - "surely, the techniques we want to provide tools that help the author create markup are different from the techniques we want to provide tools that help the author create code which, in turn, is capable of producing content". 
Let's put this on the agenda of a conference call. 
Cheers, Jan 
Jan Richards UI Design Specialist Adaptive Technology Resource Centre (ATRC) University of Toronto jan.richards@utoronto.ca 
I am not sure if the techniques for editing markup and the techniques for editing code are different or not - I agree that this should be explored a bit before we decide on it. 
But I think that the techniques for an author who is editing in a WYSIWYG environment tend to be pretty different from those for an author who is editing the underlying markup. 
Initially I was going to propose just splitting what we currently call markup editing (and I confess that I think of as document editing) techniques into two, but then I wondered about the relationship to code editing techniques. 
I can see your point about the "direct/indirect" thing. 
Maybe at some stage we will come up with a really obvious way to describe it, so I guess we can leave it in for now. 
cheers Chaals re: "direct" &amp; "indirect" editing I debated with myself about introducing new terminology. 
But "indirect" seems cover some cases that WYSIWYG does not: 1. Programming environments that make heavy use of graphic objects rather than raw code during editing (ex. 
IShell) 2. Multimedia sound and haptic editors that have visual representations that differ substantially from the final sonic or haptic version. 
re: markup/document editing and programming/code editing functionality This is quite sticky. 
At the implementation level it is difficult to separate editing of markup from editing of code, but I keep coming back to one thought - "surely, the techniques we want to provide tools that help the author create markup are different from the techniques we want to provide tools that help the author create code which, in turn, is capable of producing content". 
Let's put this on the agenda of a conference call. 
Cheers, Jan 
I think the distinction between editing code and content editing in a WYSIWYG editor is a bit artificial because in many cases we have a WYSIWYG editor with the code visible and flip between the two - I think we should recognise that DreamWeaver, for one, has a huge market and this will therefore be a VERY common practice -.... 
I am not sure of the best way to do this either.... but i still think the functionality approach is a good one Liddy 
Actually Dreamweaver is one of the few editors that has a serious WYSIWYG adn Code editing tool, and that only really in the latest version. 
Many code editing tools have no WYSIWYG editing facility - just a browser preview. 
In plenty of cases, of course, there will be tools that do more than one functionality. 
But I am not sure how many... chaals I think the distinction between editing code and content editing in a WYSIWYG editor is a bit artificial because in many cases we have a WYSIWYG editor with the code visible and flip between the two - I think we should recognise that DreamWeaver, for one, has a huge market and this will therefore be a VERY common practice -.... 
I am not sure of the best way to do this either.... but i still think the functionality approach is a good one Liddy Location: 21 Mitchell street FOOTSCRAY Vic 3011, Australia (or W3C INRIA, Route des Lucioles, BP 93, 06902 Sophia Antipolis Cedex, France) 
Hi Jan, I believe that addressing the techniques by functionality is a good decision, although you have seen is tricky. 
I have some comments. 
1) "Direct and direct" as pointed by Charles, are not common terms. 
I would name the category "Document markup creation". 
I would split the categories in WYSIWYG editors and direct editors. 
I also would include here: HTML, xHTML, XML, XSL, XSLT and CSS editors, and remove XML from 5. Also, I think that the inclusion here of multimedia, just because of editing directly the code is kind of artificial. 
I would leave that in the second category. 
2) Here I would include any multimedia, also SMIL, SVG, etc. 3) As examples in 3, you might include Portal tools, for example. 
4) In 4 I would include Javascript, PHP, ASP, VBscript (any script in general), Java (applets), etc. and move X()ML to 1). 
Like you point out, here shall go any proprietary format: Flash, Director, etc. Regards, carlos 
Dr Carlos A Velasco Fraunhofer-Institut f?r Angewandte Informationstechnik (FIT.HEB) [Fraunhofer Institute for Applied Information Technology (FIT.HEB)] 
Schloss Birlinghoven, D53757 Sankt Augustin (Germany) 
Hi all, I think that part of the problem that we are having with the authoring functionality categories is that we are trying to stretch them over two sets of guidelines: ATAG and WCAG which are barely concealed as ATAG "quasi-techniques" for Relative Priority ATAG checkpoints. 
Quasi-techniques are just WCAG checkpoint with "Generate markup that" or "Ensure template have" tacked on the front. 
There are several problems with this: 1. 
The original WCAG checkpoints are modified. 
2. Nothing by the modification that is not in the original ATAG checkpoint (i.e. "Generate markup that complies with WCAG" or "Ensure template comply with WCAG"). 
3. Although we may categorize these quasi-techniques as relevant to programming tools, etc. they often do not quite fit. 
For example, when applied to prog. 
tools T0023 ("Generate documents that validate to published formal grammars") should read "Generate code that *generates* documents that validate to published formal grammars". 
The difference is small on the surface but the implications are very different. 
Therefore, I think we should: 1. Replace the ATAG quasi-techniques with the *relevant* subset of WCAG checkpoints. 
2. Move the categorizations from the WCAG checkpoints to higher level techniques that address the specifics of the different types of tools. 
Afterall, what techniques are we really going to write to tell authoring tools how to generate documents that validate to published formal grammars? 
It's really up to them. 
3. 
Where we really do have techniques (i.e. as we do for many of the WCAG checkpoints) under 3.2, we should categorize the technique, not the WCAG checkpoint. 
4. 
Where techniques will apply in different ways to our different authoring functionality categories, we should write multiple versions of the technique (each applicable to one or two categories). 
Perhaps this should allow us to keep the 5 category system that we have now. 
Looking down the road, I would like to see more "break-out" technique modules (such as the one we have now on prompting at might include: "Checking and Repairing", "Building in Structure", etc. 
These could be sub-divided into text-based, WYSIWYG and object-based sections in order to take into account those important distinctions. 
Cheers, Jan Jan Richards UI Design Specialist Adaptive Technology Resource Centre (ATRC) University of Toronto jan.richards@utoronto.ca 
I was trying to draw attention to the situation in which the content developer probably doesn't see a difference in the functionality - you are alerting me to the fact that is is not relevant, in as much as the techniques are for the developer of the tools, not the content developer - and that might be the answer. 
So maybe it doesn't matter.... 
