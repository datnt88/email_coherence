Here is the proposed resolution to this issue for the general mailing list, per the discussion at the working group meeting. 
I'll update the issues list with a pointer to this mail when I get a chance... - Jim From: "Roy T. Fielding" fielding@kiwi.ics.uci.edu 
Date: Fri, 21 Aug 1998 16:36:12 -0700 Paul Leach paulle@microsoft.com , jg@w3.org, frystyk@w3.org, 
josh@microsoft.com, 
luotonen@netscape.com, 
Scott Lawrence lawrence@agranat.com , Richard Gray rlgray@us.ibm.com 
Subject: Re: Analysis of "chunking, trailers, and buffering" problem 
I really really really dislike the continuing use of TE to indicate anything about trailers. 
In order for trailers to be usable, the entire response path must be willing to forward them or be willing to buffer the entire message or be allowed to discard them. 
TE cannot indicate that because it is a hop-by-hop field, so we'd be better off removing the exception entirely and leaving that functionality to be specified properly in the future. 
Likewise, making specific exceptions for Content-MD5 and Authentication-Info is unnecessary if we just make a general statement for the condition where trailer fields can be included if it is permissible to ignore them. 
In other words, I believe the following is substantially better: In section 3.6.1 
(Chunked Transfer Coding), change this paragraph: A server using chunked transfer-coding in a response MUST NOT use the trailer for other header fields than Content-MD5 and Authentication-Info unless the "chunked" transfer-coding is present in the request as an accepted transfer-coding in the TE field (section 14.39). 
The Authentication-Info header is defined by RFC 2069 [32] or its successor [43]. 
to read A server using chunked transfer-coding in a response MUST NOT use the trailer for any header fields unless at least one of the following are true: a) there is no Via header field (indicating a connection without intermediary proxies); b) all of the protocols listed in the Via header field are HTTP/1.1 or later; or, c) the server grants the recipient(s) the right and ability to discard those trailer fields without forwarding them to any downstream recipient of the remaining message. 
This is only possible if the trailer fields consist entirely of optional metadata that is not necessary for the recipient to understand in order to use the message. 
The above requirement exists to avoid an interoperabilty paradox when the message is being received by an HTTP/1.1 (or later) proxy and forwarded to an HTTP/1.0 recipient. 
It avoids a situation where compliance with the protocol would have necessitated an infinite buffer on the proxy. 
In section 14.40 (Trailer), change this paragraph If no Trailer header field is present, the trailer SHOULD NOT include any header fields other than Content-MD5 and Authentication-Info. 
A server MUST NOT include any other header fields unless the "chunked" transfer-coding is present in the request as an accepted transfer-coding in the TE field. 
to If no Trailer header field is present, the trailer SHOULD NOT include any header fields. 
See section 3.6.1 for restrictions on the use of trailer fields in a "chunked" transfer-coding. 
....Roy I really really really dislike the continuing use of TE to indicate anything about trailers. 
In order for trailers to be usable, the entire response path must be willing to forward them or be willing to buffer the entire message or be allowed to discard them. 
TE cannot indicate that because it is a hop-by-hop field, so we'd be better off removing the exception entirely and leaving that functionality to be specified properly in the future. 
Likewise, making specific exceptions for Content-MD5 and Authentication-Info is unnecessary if we just make a general statement for the condition where trailer fields can be included if it is permissible to ignore them. 
In other words, I believe the following is substantially better: In section 3.6.1 
(Chunked Transfer Coding), change this paragraph: A server using chunked transfer-coding in a response MUST NOT use the trailer for other header fields than Content-MD5 and Authentication-Info unless the "chunked" transfer-coding is present in the request as an accepted transfer-coding in the TE field (section 14.39). 
The Authentication-Info header is defined by RFC 2069 [32] or its successor [43]. 
to read A server using chunked transfer-coding in a response MUST NOT use the trailer for any header fields unless at least one of the following are true: a) there is no Via header field (indicating a connection without intermediary proxies); b) all of the protocols listed in the Via header field are HTTP/1.1 or later; or, c) the server grants the recipient(s) the right and ability to discard those trailer fields without forwarding them to any downstream recipient of the remaining message. 
This is only possible if the trailer fields consist entirely of optional metadata that is not necessary for the recipient to understand in order to use the message. 
The above requirement exists to avoid an interoperabilty paradox when the message is being received by an HTTP/1.1 (or later) proxy and forwarded to an HTTP/1.0 recipient. 
It avoids a situation where compliance with the protocol would have necessitated an infinite buffer on the proxy. 
In section 14.40 (Trailer), change this paragraph If no Trailer header field is present, the trailer SHOULD NOT include any header fields other than Content-MD5 and Authentication-Info. 
A server MUST NOT include any other header fields unless the "chunked" transfer-coding is present in the request as an accepted transfer-coding in the TE field. 
to If no Trailer header field is present, the trailer SHOULD NOT include any header fields. 
See section 3.6.1 for restrictions on the use of trailer fields in a "chunked" transfer-coding. 
....Roy 
Regardless of the solution chosen, I would like to point out that TE indeed can be used for this and indeed it was (at least by me, intended) for this purpose. 
Trailers must be dealt with on a hop-by-hop basis by all the parties down the chain. 
That is, it is a "repeated hop-by-hop" because each step has to agree and not only the "end". 
A "TE: chunked" header field means for any particular hop that "I accept full featured chunked encoding with trailers and not just the boiled down version without trailers". 
This was a compromise necessary to do was existing implementations only support non-trailered chunked encoding. 
If a client is willing to accept data in the trailer, it indicates this using the "TE: chunked" header field. 
This works in all cases - regardless of whether there are HTTP/1.0 proxies, existing limited HTTP/1.1 chunking proxies or HTTP/1.1 chunking proxies that understand trailers. 
For example, if a proxy doesn't see this in a request then it can either say: 1) I don't want to risk having to buffer so I don't send TE: chunked 2) I don't mind buffering and include a TE: chunked. 
and if it sees it and understands trailers then it can just repeat the "TE: chunked" in its request to the next server. 
The other part of TE was Trailer which the server uses to indicate which header fields are included in the response or not. 
This makes it very easy for a proxy to see up front whether it has to buffer or not (if it indicated that it was willing to buffer). 
This also works for arbitrary header fields *except* content-md5 and authentication-info which were already in the spec at the time, TE was introduced. 
*Removing* the special case for these two header fields will solve the problem and does not require any additional checks in the server like looking for the via field. 
Henrik Henrik Frystyk Nielsen, World Wide Web Consortium 
It does not say that in the definition of TE in the spec, nor should it say such a thing. 
Creating a special-case definition within an unimplemented header field is not an appropriate design. 
TE was added to the spec to fix one and only one bug -- the desire to add deflate as a transfer coding without breaking deployed systems. 
If that is not its purpose, then I want TE removed from the spec right now. 
There are multiple bugs in the definition of the TE header field. 
The current definition says that: If an TE field is present in a request, and if a server cannot send a response which is acceptable according to the TE header field, then the server SHOULD send an error response with the 406 (Not Acceptable) status code. 
which is wrong because the 406 response code indicates a failure in content negotiation on the origin server, not an unacceptable transfer coding at any particular hop. 
If you want that functionality it must be defined as a new 5xx status code. 
Furthermore, the above adds a requirement to HTTP/1.1 that is not implemented in deployed systems and is not necessary for interoperability. 
The reality, however, is that no server worth deploying will ever obey such a requirement. 
From the server's point of view, assuming that the client is broken is preferable to dealing with user complaints about the inability to get anything but errors with no body content. 
TE should not be able to change the acceptability of the identity and chunked encodings. 
There are multiple ways that we could design an EXTENSION to HTTP/1.1 that provided a hop-by-hop method of allowing a maximum buffer size for chunked content that includes a trailer. 
It is not necessary for us to do it with TE, nor is it appropriate to do so as a last minute change before moving to draft standard. 
....Roy 
Henrik and I sat down and discussed the various options and meaning behind the existing sections. 
As a result, here is a proposed fix that better fits current practice and allows for future improvements. 
Much of the confusion of TE is in the use of "chunked" to indicate that trailers are okay (it serves no other purpose in TE). 
If we replace that token with "trailers", much of the confusion goes away and we can ensure that the client sending it does fully understand what it is saying when it says it agrees to accept trailers. 
The other part is we both agree that the use of 406 is wrong. 
Since it is only used when identity;q=0 is present, and there has yet to be any real need for that with transfer codings, the easiest solution is to just remove it instead of replacing it with a new 5xx code. 
So, here is another proposed solution: In section 3.6.1 
(Chunked Transfer Coding), change this paragraph: A server using chunked transfer-coding in a response MUST NOT use the trailer for other header fields than Content-MD5 and Authentication-Info unless the "chunked" transfer-coding is present in the request as an accepted transfer-coding in the TE field (section 14.39). 
The Authentication-Info header is defined by RFC 2069 [32] or its successor [43]. 
to read A server using chunked transfer-coding in a response MUST NOT use the trailer for any header fields unless at least one of the following is true: a) the request included a TE header field that indicates "trailers" is acceptable in the transfer-coding of the response, as described in section 14.39; or, b) the server grants the recipient(s) the right and ability to discard those trailer fields without forwarding them to any downstream recipient of the remaining message. 
This is only possible if the trailer fields consist entirely of optional metadata that is not necessary for the recipient to understand in order to use the message. 
The above requirement exists to avoid an interoperabilty paradox when the message is being received by an HTTP/1.1 (or later) proxy and forwarded to an HTTP/1.0 recipient. 
It avoids a situation where compliance with the protocol would have necessitated an infinite buffer on the proxy. 
In section 14.40 (Trailer), change this paragraph If no Trailer header field is present, the trailer SHOULD NOT include any header fields other than Content-MD5 and Authentication-Info. 
A server MUST NOT include any other header fields unless the "chunked" transfer-coding is present in the request as an accepted transfer-coding in the TE field. 
to If no Trailer header field is present, the trailer SHOULD NOT include any header fields. 
See section 3.6.1 for restrictions on the use of trailer fields in a "chunked" transfer-coding. 
In section 3.6, replace Whenever a transfer-coding other than "identity" is applied to a message-body, the set of transfer-codings MUST include "chunked", unless the message is terminated by closing the connection. 
When the "chunked" transfer-coding is used, it MUST be the last transfer-coding applied to the message-body. 
The "chunked" transfer-coding MUST NOT be applied more than once to a message-body. 
These rules allow the recipient to determine the transfer-length of the message (section 4.4). 
with Whenever a transfer-coding is applied to a message-body, the set of transfer-codings MUST include "chunked", unless the message is terminated by closing the connection. 
When the "chunked" transfer-coding is used, it MUST be the last transfer-coding applied to the message-body. 
The "chunked" transfer-coding MUST NOT be applied more than once to a message-body. 
These rules allow the recipient to determine the transfer-length of the message (section 4.4). 
Delete section 3.6.2: 
3.6.2 
Identity Transfer-Coding The identity transfer-encoding is the default (identity) encoding; the use of no transformation whatsoever. 
The identity transfer-coding is used only in the TE header field, and SHOULD NOT be used in any Transfer-Encoding header field. 
In section 14.39 (TE), replace as follows: 14.39 TE The TE request-header field indicates what extension transfer-codings it is willing to accept in the response and whether or not it is willing to accept trailer fields in a chunked transfer-coding. 
Its value may consist of the keyword "trailers" and/or a comma-separated list of extension transfer-coding names with optional accept parameters (as described in section 3.9). 
TE = "TE" ":" #( t-codings ) t-codings = "trailers" | ( transfer-extension [ accept-params ] ) The presence of the keyword "trailers" indicates that the client is willing to accept trailer fields in a chunked transfer-coding, as defined in section 3.9.1. 
This keyword is reserved for use with transfer-coding values even though it does not itself represent a transfer-coding. 
Examples of the use of the TE field: TE: deflate TE: TE: trailers, deflate;q=0.5 
The TE header field only applies to the immediate connection. 
Therefore, the keyword MUST be supplied within a Connection header field (section 14.10) whenever TE is present in an HTTP/1.1 message. 
A server tests whether a transfer-coding is acceptable, according to a TE field, using these rules: 1. 
The "chunked" transfer-coding is always acceptable. 
If the keyword "trailers" is listed, the client indicates that it is willing to accept trailer fields in the chunked response on behalf of itself and any downstream clients. 
The implication is that, if given, the client is stating that either all downstream clients are willing to accept trailer fields in the forwarded response, or that it will attempt to buffer the response on behalf of downstream recipients. 
Note: HTTP/1.1 does not define any means to limit the size of a chunked response such that a client can be assured of buffering the entire response. 
2. If the transfer-coding being tested is one of the transfer-codings listed in the TE field, then it is acceptable unless it is accompanied by a qvalue of 0. (As defined in section 3.9, a qvalue of 0 means "not acceptable.") 3. If multiple transfer-codings are acceptable, then the acceptable transfer-coding with the highest non-zero qvalue is preferred. 
The "chunked" transfer-coding always has a qvalue of 1. 4. If the TE field-value is empty or if no TE field is present, the only transfer-coding is "chunked". 
A message with no transfer-coding is always acceptable. 
[end of section] In 19.6.3 (Changes from RFC 2068), delete A content-coding of "identity" was introduced, to solve problems discovered in caching. 
(section 3.5) In 19.7.1 (Transfer-coding Values), replace This document defines a new class of registry for its transfer-coding values as part of the solution to solve problems discovered in RFC 2068 with the caching of transfer encoded documents. 
Initially, the registry should contain the following tokens: "chunked" (section 3.6.1), 
"identity" (section 3.6.2), 
"gzip" (section 3.5), "compress" (section 3.5), and "deflate" (section 3.5). 
... with This document defines a new class of registry for its transfer-coding values as part of the solution to solve problems discovered in RFC 2068 with the caching of transfer encoded documents. 
Initially, the registry should contain the following tokens: "chunked" (section 3.6.1), 
"gzip" (section 3.5), "compress" (section 3.5), "deflate" (section 3.5), and the special keyword "trailers" (section 14.39). 
... ....Roy and Henrik 
In the interest of not equating silence with agreement: This seems a reasonable and workable compromise. 
I'm comfortable with Roy &amp; Henrik's proposal, but I have a small qualm about this wording: A server using chunked transfer-coding in a response MUST NOT use the trailer for any header fields unless at least one of the following is true: a) .... b) the server grants the recipient(s) the right and ability to discard those trailer fields without forwarding them to any downstream recipient of the remaining message. 
This is only possible if the trailer fields consist entirely of optional metadata that is not necessary for the recipient to understand in order to use the message. 
The use of the verb "grants" here implies some sort of specific action on the part of the server, which of course is not the case. 
In fact, the second sentence does a better job of specifying the conditions under which an exception can be made ... the phrase "this is only possible if" is a good tip-off. 
Also, the use of the term "server" instead of "origin server" improperly (I think) allows an intervening proxy to "grant" the right to drop metadata that the actual origin server might consider "mandatory." 
I would suggest using something more like: b) The server is the origin server for the response, the trailer fields consist entirely of optional metadata, and the recipient could use the message (in a manner acceptable to the origin server) without receiving this metadata. 
In other words, the origin server is willing to accept the possibility that the trailer fields might be silently discarded along the path to the client. 
Also, two minor nits about the explanatory paragraph that follows: The above requirement exists to avoid an interoperabilty paradox when the message is being received by an HTTP/1.1 (or later) proxy and forwarded to an HTTP/1.0 recipient. 
It avoids a situation where compliance with the protocol would have necessitated an infinite buffer on the proxy. 
There's a spelling error, and the use of "paradox" here doesn't match any of the definitions in my dictionary. 
I'd suggest: This requirement prevents an interoperability failure when the message is being received by an HTTP/1.1 (or later) proxy and forwarded to an HTTP/1.0 recipient. 
It avoids a situation where compliance with the protocol would have necessitated an infinite buffer on the proxy. 
-Jeff 
Just to add a real data point to the discussion: In handling Digest, my server decides whether to send qop="auth" or qop="auth,auth-int" in a challenge based on whether it knows that the client can handle chunked+trailers, since I send Authentication-Info as a chunked trailer always. 
If you think it through, you see the message sequence is 1) C- S Get resource R 2) S- C 401 Authentication Required send qop="auth" or qop="auth,auth-int" based on client's ability to handle chunked+trailers 3) C- S Get resource R WWW-Authenticate ... qop=auth or qop=auth-int 4) S- C 200 OK send R, possibly chunked and with trailers for qop=auth-int Therefore, if the server can decide at step (2) whether it's safe to send trailers, there shouldn't be a problem. 
I can live with Roy's Via proposal or the TE: trailers proposal. 
Both should let me tell whether it's safe to send trailers. 
Dave Kristol 
This solution works for me. 
(I _am_ paying attention even though I could not make it to Chicago...) 
Jeff's suggested tweaks are very good -- let's go with that. 
.....Roy 
