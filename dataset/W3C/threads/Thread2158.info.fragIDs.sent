A suggestion for a new Header field to support partial file transfer. 
In the normal use of HTTP with HTML, many (most?) transfer activities are aborted. 
This makes a cache much less efficient, as it have to re-start the file transfer from its beginning. 
The suggestion is to add a header field "Starting-Position:" to define the requested position in the file. 
The server reply header will also hold this entry, but only for requests that used it. 
The absence of the Starting-Position implies that the entire file is returned. 
The Content-Length: field is left unchanged, as the entire file size. 
The client program should validate that the Date and Content-Length fields didn't change from the original file, to make sure that the partial transfer is indeed of the same file. 
The usage of "Starting-Position" should be limited to client application (not cache servers), and are valid for the same session only. 
Client program can safely use this option with any server, as it is simply ignored by older (current) servers, and by returning the entire file. 
I like the notion of partial entity transfer. 
However, I would prefer that content-length always refer to the transmitted length of the content, for all requests. 
Siince you're intorducing new header fields, why not add one for the total-length of the entity? 
The proposal allows fetch of the tail of a file. 
If we go down this path, why not generalize it to an arbitrary slice? 
Is this makes caches more efficient, why forbid its use by cache servers? 
Paul ] From: Dror Tirosh dror@vocaltec.com ] Subject: Suggestion: Partial file transfer. 
] Date: Saturday, August 24, 1901 10:37PM ] A suggestion for a new Header field to support partial file transfer. 
In the normal ] use of HTTP with HTML, many (most?) transfer activities are aborted. 
This makes a ] cache much less efficient, as it have to re-start the file transfer from its ] beginning. 
[ excised stuff] 
I'd be more comfortable with this and other proposals if the original data were delivered with a 'content-ID' that was unique to the particular content being delievered, and any follow-up request for partial delivery were indexed not by the original URL but by the content-ID itself. 
(The lack of a content-ID would be a signal that the object wasn't suitable for partial transmission or that the server didn't support such.) The content-ID could also be used as a GET IF-DIFFERENT key, since the content-ID would change when the content changed. 
Content-ID is required to be globally unique. 
(It might even be a URN, but who knows?) 
I'd be more comfortable with this and other proposals if the original data were delivered with a 'content-ID' that was unique to the particular content being delievered, and any follow-up request for partial delivery were indexed not by the original URL but by the content-ID itself. 
(The lack of a content-ID would be a signal that the object wasn't suitable for partial transmission or that the server didn't support such.) The content-ID could also be used as a GET IF-DIFFERENT key, since the content-ID would change when the content changed. 
Content-ID is required to be globally unique. 
(It might even be a URN, but who knows?) This sounds quite like the "Cache-Validator:" unique-ID that I proposed to replace IF-MODIFIED-SInce (sorry for the weird typing, I'm on a really slow link). 
Once you have a way for the server to explicitly control caching on an object-by-object basis, lots of problems solve themselves. 
-Jeff 
The cache validator for deciding whether to update the cache for an entire document might be different than the cache validator you need to decide whether you can reuse the first 400 bytes you got the first time before you dropped the connection. 
I'm willing to forego the looser usage, but unless you tighten it up, you might not be able to use the same identifier for both purposes. 
