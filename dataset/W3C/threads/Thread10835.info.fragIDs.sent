I think that the rules for RS/RE processing in SGML are confusing. 
I prefer Dan Connolly's "phase-of-the-moon" characterisation, myself:-) 
I'd like to make sure that they are _never_ invoked. 
Aside the (religious) issue of 8879-compliance, can anybody explain why they are necessary? 
For instance, exactly what are RS and RE in a byte stream over TCP? 
Sorry, RS/RE has "fuddy-duddy" written all over it (can you say "punch card is all I grok"?) 
The basic problem has always been to allow relatively "free-form" markup, mainly for neatness and readability. 
If RS/RE had really been an issue (as opposed to grandfathering ante-diluvian kludgery) the solution was to allow only *one tag per record*, at the beginning (modulo leading WS?): this would have given relevant if not functional meaning to the term "record". 
But all we have now is a bunch of rules just getting in the way. 
May I propose a focus on relevant concepts rather than rules. 
In the context of essentially free-form text and markup, exactly what does a record-end/end-of-line/whatchamacallit mean? 
1. Is it part of the instance text? 
2. Is it (processable) markup? 
3. Is it an artifact of the storage strategy the environment was too brain-dead not to have encapsulated? 
In some ways, #3 is a special case of (in the sense of imposition on) #2. 
And #1 is clearly unworkable. 
So, if we want simple and strong rules (the kind that establish a two-way relation between ease of programming and ease of understanding) the rational approach IMHO is to treat these animals as markup always. 
When needed as instance text, an inline escape mechanism should suffice (how about '\' as MSSCHAR?). 
The problem is reduced to one 
of lexical tokenization, which is where I believe it always belonged. 
Regards, Arjun My thought 
for SGML is that we could assign them codes (in the delcaration) that the entity manager would _never_ see or produce. 
For instance an 8-bit entity manager would assing RS to code 256 and RE to code 257. 
The codes for CR and LF would be declared to be the same class as TAB and SPACE. 
For SGML this fits the letter of the standard, but parsers will currently choke, or assume that a wider character set is in use. 
For XML we can simplify things by just treating LF and CR (well, actually their 10646 equivalents) as whitespace. 
We can simply skip the entire notion of non-significant and significant RS/RE entirely. 
-- David 
I'd like to make sure that they are _never_ invoked. 
Well, if you want to be SGML-parsable, you want the content of your elements to be the same whether the document is interpreted as SGML or XML. 
You therefore need either to preserve the RS/RE rules, or find a way that they not be invoked. 
Fuddy-duddy or not, the definition in 8879 is a real issue, and gratuitous incompatibility, especially in the matter of what is element content, is a problem we should avoid. 
Funny, I think #1 is clearly correct. 
Treat CR, LF, and their kin as SGML has always treated tab and space (ignored in element content, parsed as data elsewhere). 
We may need to amend stylesheets to allow a stylesheet to 
recognize CR, LF, or CRLF as special formatting in some contexts. 
This would simplify entity management and parsing both. 
It would mean that line-ending convention transformations would no longer be no-ops, as they change the byte stream, but this is not such a bad idea. 
The worst problem would be dealing with old IBM iron. 
You could do OK by a couple of methods, but none of them would be completely natural with the standard tools (as far as my old mainframe memories go, at any rate). 
And you gain character-stream address stability. 
I think that the byte-stream file has won, and we should just treat CR and LF as more whitespace bytes. 
People who are creating "example" or 
"verbatim" tags, just need to use the stylesheet to declare what's up, or leave it to the application to decide which whitespace differences are significant. 
Note that this is how tabs are already treated, and despite a little pain, the world manages to muddle on. 
-- David David Durand dgd@cs.bu.edu | david@dynamicDiagrams.com 
Boston University Computer Science | Dynamic Diagrams 
There's no elsewhere without a DTD: something that tells the parser what "mode" to be in. 
The issue here is lexical tokenization per se. 
Treating these as data will require a lexer to *report* a different sequence of tokens for foo bar blah as opposed to bar blah which would defeat the purpose of freeform in markup entirely. 
OTOH, my intuitive view of what "freeform" means is that all whitespace between tags should not be significant *unless explicitly indicated*. 
(There's also an issue of leading and trailing ws in data that I elide just now.) Since most of the time such whitespace will be a &amp;newline-indicator;, it makes sense to treat them as markup, apply a canonical rule that transforms it to ws, and then apply some commonsense rules regarding whitespace. 
Agreed, whole-heartedly. 
So the point is to have simple and strong treatment of "free-standing" whitespace -- between tags, before and after text data. 
(I'm sorta coming around to the view that all whitespace is better viewed as markup rather than data:-)) But how all this interacts with RS/RE gotchas and the mixed content problem I confess I'm still confused. 
(SGML is the only system I've seen where innocent cosmetic whitespace could lead one off the Path of Sufficient Virtue.) Regards, Arjun 
