This documents discussions on the implementation list that shows a new protocol issue (IMS_INM_MISMATCH). 
Now added to the issues list. 
- Jim Gettys Is there a consensus on the correct behavior for a server when it receives a request with conflicting If-None-Match and If-Modified-Since headers, for instance where the I-N-M ETag is outdated but the I-M-S date is good? 
For example, take the following sequence GET /foo.txt 
HTTP/1.1 Host: server.company.com 
HTTP/1.1 200 OK Last-Modified: Wed, 05 Nov 1997 22:10:48 GMT ETag: "12345" Content-Length: ... GET /foo.txt 
HTTP/1.1 Host: server.company.com 
If-None-Match: "12344" If-Modified-Since: Wed, 05 Nov 1997 22:10:48 GMT Assuming the Last-Modified date hasn't changed, what should the server send back as a response to the 2nd request, 304 or 200? 
I would have thought 200 is correct, since the ETag is invalid or out of date. 
However the spec indicates that the I-N-M header is to be treated as if it isn't present if the ETag doesn't match, and then the I-M-S would lead to a 304 response. 
Also the paragraph about I-N-M being ignored if the request would otherwise generate a non-2xx response would indicate that a 304 is correct. 
But there would seem to be a window here, where /foo.txt is modified twice in less than a second, the ETag is updated but the L-M date isn't, and a client using an out of date ETag gets a 304 anyway. 
Or am I missing something here? 
Henry Is there a consensus on the correct behavior for a server when it receives a request with conflicting If-None-Match and If-Modified-Since headers, for instance where the I-N-M ETag is outdated but the I-M-S date is good? 
Hmmm, I don't know about consensus, but I implemented it using the principle that an ETag test always overrides IMS. 
I mentioned it as an issue on http-wg a long time ago, since the RFC fails to specify the ordering. 
The Apache code (and comments) are below. 
For example, take the following sequence GET /foo.txt 
HTTP/1.1 Host: server.company.com 
HTTP/1.1 200 OK Last-Modified: Wed, 05 Nov 1997 22:10:48 GMT ETag: "12345" Content-Length: ... data GET /foo.txt 
HTTP/1.1 Host: server.company.com 
If-None-Match: "12344" If-Modified-Since: Wed, 05 Nov 1997 22:10:48 GMT Assuming the Last-Modified date hasn't changed, what should the server send back as a response to the 2nd request, 304 or 200? 
200. 
I would have thought 200 is correct, since the ETag is invalid or out of date. 
However the spec indicates that the I-N-M header is to be treated as if it isn't present if the ETag doesn't match, and then the I-M-S would lead to a 304 response. 
Also the paragraph about I-N-M being ignored if the request would otherwise generate a non-2xx response would indicate that a 304 is correct. 
But there would seem to be a window here, where /foo.txt is modified twice in less than a second, the ETag is updated but the L-M date isn't, and a client using an out of date ETag gets a 304 anyway. 
Or am I missing something here? 
Nope, that about sums it up. 
200 is what the response should be, but the RFC is less than clear. 
....Roy API_EXPORT(int) meets_conditions(request_rec *r) char *etag = table_get(r- headers_out, "ETag"); char *if_match, *if_modified_since, *if_unmodified, *if_nonematch; time_t mtime; /* Check for conditional requests --- note that we only want to do * this if we are successful so far and we are not processing a * subrequest or an ErrorDocument. 
* The order of the checks is important, since ETag checks are supposed * to be more accurate than checks relative to the modification time. 
* However, not all documents are guaranteed to *have* ETags, and some * might have Last-Modified values w/o ETags, so this gets a little * complicated. 
if (!is_HTTP_SUCCESS(r- status) || r- no_local_copy) { return OK; mtime = (r- mtime != 0) ? 
r- mtime : time(NULL); /* If an If-Match request-header field was given * AND if our ETag does not match any of the entity tags in that field * AND the field value is not "*" (meaning match anything), then * respond with a status of 412 (Precondition Failed). 
if ((if_match = table_get(r- headers_in, "If-Match")) != NULL) { if ((etag == NULL) || ((if_match[0] != '*') &amp;&amp; !find_token(r- pool, if_match, etag))) { return HTTP_PRECONDITION_FAILED; else { /* Else if a valid If-Unmodified-Since request-header field was given * AND the requested resource has been modified since the time * specified in this field, then the server MUST * respond with a status of 412 (Precondition Failed). 
if_unmodified = table_get(r- headers_in, "If-Unmodified-Since"); if (if_unmodified != NULL) { time_t ius = parseHTTPdate(if_unmodified); if ((ius != BAD_DATE) &amp;&amp; (mtime  ius)) { return HTTP_PRECONDITION_FAILED; /* If an If-None-Match request-header field was given * AND if our ETag matches any of the entity tags in that field * OR if the field value is "*" (meaning match anything), then * if the request method was GET or HEAD, the server SHOULD * respond with a 304 (Not Modified) response. 
* For all other request methods, the server MUST * respond with a status of 412 (Precondition Failed). 
if_nonematch = table_get(r- headers_in, "If-None-Match"); if (if_nonematch != NULL) { int rstatus; if ((if_nonematch[0] == '*') || ((etag != NULL) &amp;&amp; find_token(r- pool, if_nonematch, etag))) { rstatus = (r- method_number == M_GET) ? 
HTTP_NOT_MODIFIED : HTTP_PRECONDITION_FAILED; return rstatus; /* Else if a valid If-Modified-Since request-header field was given * AND it is a GET or HEAD request * AND the requested resource has not been modified since the time * specified in this field, then the server MUST * respond with a status of 304 (Not Modified). 
* A date later than the server's current request time is invalid. 
else if ((r- method_number == M_GET) &amp;&amp; ((if_modified_since = table_get(r- headers_in, "If-Modified-Since")) != NULL)) { time_t ims = parseHTTPdate(if_modified_since); if ((ims  = mtime) &amp;&amp; (ims = r- request_time)) { return HTTP_NOT_MODIFIED; return OK; Just what you wanted to see, another HTTP/1.1 issue.... 
This is something I sent out to the HTTP implementors list about a week ago. 
Looks like the spec says to send a 304 when a 200 response would be better. 
Any comments? 
Henry From:Henry Sanders (Exchange) Sent:Wednesday, November 05, 1997 4:26 PM Subject:If-None-Match and IMS Is there a consensus on the correct behavior for a server when it receives a request with conflicting If-None-Match and If-Modified-Since headers, for instance where the I-N-M ETag is outdated but the I-M-S date is good? 
For example, take the following sequence GET /foo.txt 
HTTP/1.1 Host: server.company.com 
HTTP/1.1 200 OK Last-Modified: Wed, 05 Nov 1997 22:10:48 GMT ETag: "12345" Content-Length: ... data GET /foo.txt 
HTTP/1.1 Host: server.company.com 
If-None-Match: "12344" If-Modified-Since: Wed, 05 Nov 1997 22:10:48 GMT Assuming the Last-Modified date hasn't changed, what should the server send back as a response to the 2nd request, 304 or 200? 
I would have thought 200 is correct, since the ETag is invalid or out of date. 
However the spec indicates that the I-N-M header is to be treated as if it isn't present if the ETag doesn't match, and then the I-M-S would lead to a 304 response. 
Also the paragraph about I-N-M being ignored if the request would otherwise generate a non-2xx response would indicate that a 304 is correct. 
But there would seem to be a window here, where /foo.txt is modified twice in less than a second, the ETag is updated but the L-M date isn't, and a client using an out of date ETag gets a 304 anyway. 
Or am I missing something here? 
Henry that a 304 is correct. 
But there would seem to be a window here, where /foo.txt is modified twice in less than a second, the ETag is updated but the L-M date isn't, and a client using an out of date ETag gets a 304 anyway. 
Or am I missing something here? 
Nope, that about sums it up. 
200 is what the response should be, but the RFC is less than clear. 
I agree that 200 is what the response should be, but saying the RFC is unclear is an understatement. 
I think the RFC actually contradicts this view, twice. 
I'll pass this on to the HTTP group, maybe we can get it fixed in the update. 
Henry My recollection of intent matches the implementation Roy described. 
If-None-Match supercedes IMS when both are present. 
Dave Morris The question was: Is there a consensus on the correct behavior for a server when it receives a request with conflicting If-None-Match and If-Modified-Since headers, for instance where the I-N-M ETag is outdated but the I-M-S date is good? 
This is specifically answered for proxy servers in section 13.3.4 
(Rules for When to Use Entity Tags and Last-modified Dates). 
The text there says: An HTTP/1.1 cache, upon receiving a request, MUST use the most restrictive validator when deciding whether the client's cache entry matches the cache's own cache entry. 
This is only an issue when the request contains both an entity tag and a last-modified-date validator (If-Modified-Since or If-Unmodified-Since). (Several uses of the word "cache" in that paragraph should probably be "caching proxy", since end-client caches presumably do not receive cache-conditional request messages.) 
This is followed by: A note on rationale: The general principle behind these rules is that HTTP/1.1 servers and clients should transmit as much non- redundant information as is available in their responses and requests. 
HTTP/1.1 systems receiving this information will make the most conservative assumptions about the validators they receive. 
I think the most straightforward extension of "these rules" to the correct behavior for an origin server is to do the same: use the most restrictive validator. 
But, as Roy implied when he wrote "the RFC is less than clear", the term "most restrictive" isn't really defined. 
So I would replace the first paragraph quoted above with these two paragraphs: An HTTP/1.1 origin server, upon receiving a conditional request that includes both a Last-modified date (e.g., in an If-Modified-Since or If-Unmodified-Since header field) and one or more entity tags (e.g., in an If-Match, If-None-Match, or If-Range header field) as cache validators, MUST NOT return a response status of 304 (Not Modified) unless doing so is consistent with all of the conditional header fields in the request. 
An HTTP/1.1 caching proxy, upon receiving a conditional request that includes both a Last-modified date and one or more entity tags as cache validators, MUST NOT return a locally cached response to the client unless that cached response is consistent with all of the conditional header fields in the request. 
My recollection of intent matches the implementation Roy described. 
If-None-Match supercedes IMS when both are present. 
This is not quite the same thing; allowing INM to supersede IMS unconditionally might be wrong if the INM contained a "weak" entity tag. 
However, with a strong entity tag, there should be no practical difference between Dave's interpretation and the more conservative one ... except in those rare cases where a resource's modification date changes, but its value does not. 
Henry's question continues: For example, take the following sequence GET /foo.txt 
HTTP/1.1 Host: server.company.com 
HTTP/1.1 200 OK Last-Modified: Wed, 05 Nov 1997 22:10:48 GMT ETag: "12345" Content-Length: ... GET /foo.txt 
HTTP/1.1 Host: server.company.com 
If-None-Match: "12344" If-Modified-Since: Wed, 05 Nov 1997 22:10:48 GMT Assuming the Last-Modified date hasn't changed, what should the server send back as a response to the 2nd request, 304 or 200? 
I would have thought 200 is correct, since the ETag is invalid or out of date. 
However the spec indicates that the I-N-M header is to be treated as if it isn't present if the ETag doesn't match, and then the I-M-S would lead to a 304 response. 
Section 14.26 (If-None-Match) doesn't exactly say "ignored"; it contains an apparent contradiction, because it says both: If any of the entity tags match the entity tag of the entity that would have been returned in the response to a similar GET request (without the If-None-Match header) on that resource, or if "*" is given and any current entity exists for that resource, then the server MUST NOT perform the requested method. 
[...] and If the request would, without the If-None-Match header field, result in anything other than a 2xx status, then the If-None-Match header MUST be ignored. 
These excerpts both contradict the existing language in 13.3.4 
(as it applies to caching proxies) and the revised language I proposed above. 
I.e., if the entity tags don't match, but the dates do match, 13.3.4 
says "return 200", but the latter of these two excerpts implies "return 304". 
I think that's a real bug. 
If the entity tags do match, but the dates don't match, 13.3.4 
also says "return 200", but the former of these two excerpts implies "return 304". 
I think that's also a bug, but this one is probably not of much practical consequence unless the server is using weak entity tags. 
I would change the first sentence quoted above to: If any of the entity tags match the entity tag of the entity that would have been returned in the response to a similar GET request (without the If-None-Match header) on that resource, or if "*" is given and any current entity exists for that resource, then the server MUST NOT perform the requested method, unless required to do so because the resource's modification date fails to match that supplied in an If-Modified-Since header field in the request. 
[...] and the second sentence to: If the request would, without the If-None-Match header field, result in anything other than a 2xx or 304 status, then the If-None-Match header MUST be ignored. 
(See section 13.3.4 
for a discussion of server behavior when both If-Modified-Since and If-None-Match appear in the same request.) 
-Jeff Actually the case where the resource's modification date changes without its value changing is more common than you'd think, because of how people implement dns-load balancing to improve performance. 
From what I've seen, it's common for changes to be made on one machine and those changes propogated to the other machines in the response group. 
Unless you're very careful with that propogation, it's easy for the modification time to change as a result of the movement. 
Since there is no guarantee that a client checking back on a resource will get the same member of the response group as it originally got, you can pretty easily run into this case. 
Good implementation advice on the issue would, however, solve the problem in most cases. 
I don't think that changes the logic you've applied to the situation; I do believe, however, you'll get a non-trivial number of cases where that conservative approach will result in the transmission of a resource that is the same as the one the client has. 
regards, Ted Hardie NASA NIC There's also the sentence If none of the entity tags match, or if "*" is given and no current entity exists, then the server MAY perform the requested method as if the If-None-Match header field did not exist. 
Which is what I was referring to when I mentioned treating the header as if it didn't exist. 
I like your proposed alterations, we just need to strike this sentence too. 
Henry There's also the sentence If none of the entity tags match, or if "*" is given and no current entity exists, then the server MAY perform the requested method as if the If-None-Match header field did not exist. 
Which is what I was referring to when I mentioned treating the header as if it didn't exist. 
I like your proposed alterations, we just need to strike this sentence too. 
Yes, the quoted sentence is also wrong, but striking it would be a mistake. 
The problem is that this sentence combines two different cases, and the appropriate action is different in each one. 
I suggest replacing it with If none of the entity tags match, then the server MAY perform the requested method as if the If-None-Match header field did not exist, but MUST also ignore any If-Modified-Since header field(s) in the request. 
That is, if no entity tags match, then the server MUST not return a 304 (Not Modified) response. 
If "*" is given and no current entity exists, then the server MAY perform the requested method as if the If-None-Match header field did not exist. 
The latter paragraph doesn't depend on whether or not an I-M-S field is included, since an entity that does not exist cannot have a modification date. 
Also, this next paragraph: If the request would, without the If-None-Match header field, result in anything other than a 2xx status, then the If-None-Match header MUST be ignored. is also wrong; it should be If the request would, without the If-None-Match header field, result in anything other than a 2xx or 304 status, then the If-None-Match header MUST be ignored. 
I.e., don't ignore If-None-Match just because the I-M-S value matches the current modification date. 
-Jeff 
