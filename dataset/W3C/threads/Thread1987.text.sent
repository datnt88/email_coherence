Based on the discussion during the past hours, it appears that a better way to do byte ranges is indeed via an additional header, and with a 206 partial content response code. 
Doing it via a header will still make it work through existing proxies, and 206 status code will prevent them from caching it, unless they understand what's going on. 
Roy, could you allocate 206 (or whatever) for Partial Content in HTTP, please? 
An additional feature is to say "give me a range if the document hasn't changed, but if it has, send me the entire document". 
Similar to If-modified-since, but still quite different... What would you call such a header? 
I will re-vamp a new version of the byterange draft reflecting these changes, and will submit it for review in http-wg shortly. 
Cheers, Ari Luotonenari@netscape.com Netscape Communications Corp.http://home.netscape.com/people/ari/ 
501 East Middlefield Road Mountain View, CA 94043, USANetscape Server Development Team I'd use "last-modified", since what you're essentially saying is "the document I received part of claimed to have been last-modified on date , and now I want another piece of this document, unless it has changed since that date." 
Since we want some specific behavior in both cases -- in one case the whole document is returned, and in the other case only a range -- it isn't quite right to use "if-not-modified-since. 
(i.e. something happens if it *is* modified, too). 
Last-modified would reasonably encapsulate everything you need to say. 
But I'd like to request that we break with tradition slightly, and as an option allow something other than (or in addition to) last-modified here: a checksum field, the rule being that you return in the request the checksum received with the original fragment of the document. 
--Shel Kaphan You wouldn't want to use If-modified-since itself, since that would cause incorrect behavior with non-byte range compatible servers. 
Me, I would incorporate it into the range request header, since it's part of that function. 
Something like: Request-Range: Sun, 06 Nov 1994 08:49:37 GMT; bytes=0-499 That would seem to make sense to me, since you're saying "send me the first 500 bytes of the document if it hasn't been modified since this date, otherwise send it all."Of 
course, you'd still want to be able to say Request-Range: bytes=0-499 For those cases where you really just want a certain byte range from a document, even if it's changed (or if you've never seen it before). 
I'd assume servers are smart enough to tell the difference. 
Great! 
--/ Alexei Kosut akosut@nueva.pvt.k12.ca.us /--------/ Lefler on IRC ----------------------------/ http://www.nueva.pvt.k12.ca.us/~akosut/ 
The viewpoints expressed above are entirely false, and in no way represent Alexei Kosut nor any other person or entity. 
/-------------- I did this yesterday. 
I have also defined Request-Range: for specifying the desired range on a request and Range: for specifying the actual range returned on the 206 response Both headers use the syntax for Range given in Ari and John's current draft: The following HTTP response header is sent back to provide verification and information about the range and total size of the document: Range: bytes X-Y/Z where: X is the number of the first byte returned (the first byte is byte number zero). 
Y is the number of the last byte returned (in case of the end of the document this is one smaller than the size of the document in bytes). 
Z is the total size of the document in bytes. 
But, I haven't included the text yet, so now would be a good time to say whether or not that syntax is acceptable. 
If-Modified-Since (for the current case) Unless (for the generic case) I am willing to proceed with this in the main HTTP/1.1 spec, since the changes required are interwoven with the description of GET and caching. 
However, I am not willing to support multiple ranges within a single request at the current time, so no multipart/x-byteranges. 
...Roy T. Fielding Department of Information &amp; Computer Science (fielding@ics.uci.edu) 
According to Ari Luotonen: I would agree with this. 
"Unless-modified-since" (send the byte range) John Franks Discussion? 
Usually people have to listen to each other and value each other's opinions for a discussion. 
Or have I just brought up another red herring? 
:-) Glad to see that some movement was made. 
Two things here: - I question the value of a "Byterange-even-if-changed" header or action. 
It seems too dangerous and unlikely to be used by anyone if there is a safer alternative (which there will certainly be). 
- It seems to me that we need two headers to work: "Byterange" coupled with "Unless-modified-since". 
There may be a more elegant solution using "If-modified-since", but I'd hate to make that header try to act like both "if" and "unless" just to prevent creating one more header. 
Let's remember that these headers will only be seen by .1% of users, and clarity of wording will help server, client, and proxy implementors. 
--Paul Hoffman --Proper Publishing Unless could work, if it's implemented in the same spec as byte ranges. 
If-Modified-Since will not work, though, because it's already in use for something different. 
Namely, one of the points of using a header instead of a URL extension or new HTTP method is so that non-byte range serverss will ignore it and send a 200 response and the entire document. 
Using If-Modified-Since defeats this, since non-byte range servers will return a 304. 
I think either as I said in a previous message, or as Lou Montulli said, putting it in with the Request-Range header, would be best, because the behavior with respect to byte ranges really is quite different than the behavior with respect to entire documnets, in that if it has changed, it should send a 200 and the entire document, as opposed to the normal case, where a 304 is sent with no content. 
--/ Alexei Kosut akosut@nueva.pvt.k12.ca.us /--------/ Lefler on IRC ----------------------------/ http://www.nueva.pvt.k12.ca.us/~akosut/ 
The viewpoints expressed above are entirely false, and in no way represent Alexei Kosut nor any other person or entity. 
/-------------- Could we use extra parameters in Request-Range as Shel Kaphan suggested instead of having interactions between headers? 
rom Shel: Request-range: bytes=X-Y; validator= xxxxx ; other-parameter= yyyy I think it provides a cleaner implementation. 
The value of the validator (or whatever we call it) can be interpreted by the server returning the object. 
One thing I'm not clear on is which header this identifier would be passed in when delivering the original object? 
One downside to this would be that mirrored objects would have to have consistent values for the validator. 
When using URNs in something like the path scheme there is no guarantee that the request will return to the original server. 
So servers would have to cooperate when mirrorring documents. 
Another thing I like about Shel's suggestion is the idea of being able to use an opaque string to uniquely identify an object which could be used instead of the last modification date and URL. 
We are looking at the possibility of using internal identifiers for each object for other reasons, but they could also be used for the opaque string. 
It would rapidily indicate to our server if the requested URL and the previously identified object are identical or not. 
Again, we'd have to keep track of which documents are mirrored and treat the validator differently for mirrorred documents and non-mirrored documents. 
Elizabeth(Beth) Frank NCSA Server Development Team efrank@ncsa.uiuc.edu 
