Here is the list of DOM Level 2 key codes [1] that are not part of the DOM Level 3 key codes and that we might want to add again. 
I didn't take the time to sort them yet (or look for their definition in the Java documentation). 
Martin, can you have a quick look at them and tell me which ones are already present in Unicode? 
Thanks - Philippe. 
DOM_VK_ACCEPT DOM_VK_ADD (this key is not the '+' sign...) DOM_VK_AGAIN DOM_VK_ALL_CANDIDATES DOM_VK_ALPHANUMERIC DOM_VK_ALT_GRAPH Constant for the AltGraph modifier key. 
DOM_VK_BACK_SPACE DOM_VK_CANCEL DOM_VK_CLEAR DOM_VK_CODE_INPUT DOM_VK_COMPOSE DOM_VK_CONVERT DOM_VK_COPY DOM_VK_CUT DOM_VK_DECIMAL DOM_VK_FINAL DOM_VK_FIND DOM_VK_FULL_WIDTH Constant for the Full-Width Characters function key. 
DOM_VK_HALF_WIDTH Constant for the Half-Width Characters function key. 
DOM_VK_HELP DOM_VK_HIRAGANA Constant for the Hiragana function key. 
DOM_VK_JAPANESE_HIRAGANA Constant for the Japanese-Hiragana function key. 
DOM_VK_JAPANESE_KATAKANA Constant for the Japanese-Katakana function key. 
DOM_VK_JAPANESE_ROMAN Constant for the Japanese-Roman function key. 
DOM_VK_KANA DOM_VK_KANJI DOM_VK_KATAKANA Constant for the Katakana function key. 
DOM_VK_LESS DOM_VK_MODECHANGE DOM_VK_NONCONVERT DOM_VK_NUM_LOCK DOM_VK_PASTE DOM_VK_PREVIOUS_CANDIDATE Constant for the Previous Candidate function key. 
DOM_VK_PROPS DOM_VK_ROMAN_CHARACTERS Constant for the Roman Characters function key. 
DOM_VK_STOP DOM_VK_UNDO [1] I question whether it's appropriate for DOM to define as many virtual keys as it already does. 
Many of these keys are very device- or platform-specific. 
Also, you mention Unicode, which seems orthogonal to the discussion of virtual key codes. 
Aren't VK_ codes intended for key events and not character events? 
For example, there are not separate VK codes for '3' and '#' because they occupy the same key on the qwerty keyboard. 
--Brad Here is the list of DOM Level 2 key codes [1] that are not part of the DOM Level 3 key codes and that we might want to add again. 
I didn't take the time to sort them yet (or look for their definition in the Java documentation). 
Martin, can you have a quick look at them and tell me which ones are already present in Unicode? 
Thanks - Philippe. 
DOM_VK_ACCEPT DOM_VK_ADD (this key is not the '+' sign...) DOM_VK_AGAIN DOM_VK_ALL_CANDIDATES DOM_VK_ALPHANUMERIC DOM_VK_ALT_GRAPH Constant for the AltGraph modifier key. 
DOM_VK_BACK_SPACE DOM_VK_CANCEL DOM_VK_CLEAR DOM_VK_CODE_INPUT DOM_VK_COMPOSE DOM_VK_CONVERT DOM_VK_COPY DOM_VK_CUT DOM_VK_DECIMAL DOM_VK_FINAL DOM_VK_FIND DOM_VK_FULL_WIDTH Constant for the Full-Width Characters function key. 
DOM_VK_HALF_WIDTH Constant for the Half-Width Characters function key. 
DOM_VK_HELP DOM_VK_HIRAGANA Constant for the Hiragana function key. 
DOM_VK_JAPANESE_HIRAGANA Constant for the Japanese-Hiragana function key. 
DOM_VK_JAPANESE_KATAKANA Constant for the Japanese-Katakana function key. 
DOM_VK_JAPANESE_ROMAN Constant for the Japanese-Roman function key. 
DOM_VK_KANA DOM_VK_KANJI DOM_VK_KATAKANA Constant for the Katakana function key. 
DOM_VK_LESS DOM_VK_MODECHANGE DOM_VK_NONCONVERT DOM_VK_NUM_LOCK DOM_VK_PASTE DOM_VK_PREVIOUS_CANDIDATE Constant for the Previous Candidate function key. 
DOM_VK_PROPS DOM_VK_ROMAN_CHARACTERS Constant for the Roman Characters function key. 
DOM_VK_STOP DOM_VK_UNDO [1] Keycodes are device specific in any case so relying on them for keydown/keyup would be inappropriate imho. 
Instead we rely on the character that would be generated by pressing the key. 
The specification is unclear however on which character should be generated, i.e. with or without the modifier: - A generates a 'a' on keydown/up, shift+A generates 'A'. 
- 3 generates a 'a' on keydown/up, shift+3 generates '3' (and not '#'). 
Yet another inconsistency in the keyboard character system... Philippe Philippe Le Hegaret [mailto:plh@w3.org] 
wrote... 
In my opinion, the only sensible way, is that always the generated character would be generated. 
So in my case, shift+'3' will generate '?'. 
I think it's important that the users' locales are abstracted sufficiently so that we don't have to think, "ah yes, shift+3 is a currency symbol, so that's OK" In turn, this suggests to me that the best method is to return the (Unicode) character -- which a few virtual keys left over for non printing keys (for example, cursor, f-keys, esc, etc.) correction: - A generates a 'A' (and not 'a') on keydown/up, shift+A generates 'A'. 
- 3 generates a '3' on keydown/up, shift+3 generates '3' (and not '#'). 
(using a Linux system and Mozilla 1.1. 
I need to try with other OS/navigators as soon as I am back home) (I stole an example page on the web and improved it slightly in order to test different OS/keyboards [1]) Agree. 
This was indeed the intent: virtual keys are for keys without unicode character representation. 
If we reintroduce the keyCode, it will be possible again to rely on the device specific layout btw, but we'll make clear in the specification that its use should be avoided as much as possible. 
Philippe [1] http://www.w3.org/2002/09/tests/keys.html From: Philippe Le Hegaret [mailto:plh@w3.org] 
So use of keyDown/keyUp should be discouraged for every key except VK_ keys, which should have no unicode equivalent. 
One might justifiably use keyDown/keyUp of the 'A' key in a game, for example, just as one might use the left arrow key -- as an on/off switch rather than as a means of text input. 
In that case, there should be some definition of what code will be in the keyCode ('a' or 'A'). 
Platforms generally have conventions for that. 
DOM should recognize that if it is going to specify virtual key codes and key events. 
--Brad Pettit Yes. 
The question is whether to try to do something that includes a wide range of keys on a lot of keyboards, or something that only includes the keys on most keyboards. 
My tendency is for the former, with the clear addition that a DOM implementation is only required to support equivalents for those keys that are actually present. 
"On some querty keyboards" is probably slightly more precise. 
regards, Martin. 
