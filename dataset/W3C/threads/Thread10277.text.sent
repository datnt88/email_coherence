3. For the common use case, where applications embed a literal in an XML document, it is preferable to distinguish,in the graph, between plain and XML literals, so that e.g. different escaping conventions can be applied. 
By this, do you mean, that the reason why we have special treatment of XML literals at all, in addition to fully generic support for plain and typed literals, is simply because RDF uses XML for its serialization. 
If RDF used some other serialization as standard, such as N3, then the need for the special datatype would not exist (insofar as the need for the RDF specs to define it)? 
If so, I agree. 
Thus, XML literals are not singled out because XML is by itself more special than some other lexicalization, but because it simply intersects with RDF's own serialization and it's very useful to keep track of that in a standardized manner. 
I couldn't think of anything else you didn't cover. 
Patrick From: ext Jeremy Carroll [mailto:jjc@hplb.hpl.hp.com] Sent: 07 July, 2003 00:04 Subject: Re: [Fwd: Re: Summary of strings, markup, and language tagging in RDF (resend)] building an XML specific mechanism into its core model is architecturaly inappropriate - it mixes things that should be independent. 
Accepting this implies that parseType="Literal" values must use one of the existing mechanisms - i.e. either plain literals or typed literals, or a new more general mechanism must be invented, e.g. a new triple structure. 
An XML specific mechanism is undesirable. 
4. Taking the datatype approach creates the opportunity to subclass the datatype XMLLiteral, so that the value of a property may be restricted to a specific form of XML Literal, possibly specified using XML Schema. 
This would be a future extension ... could I suggest adding the word 'future' into this point, on its next iteration. 
I think 'future application' would be better, since it would not require any actual extension to RDF, either syntax or semantics. 
The present specification of RDF datatyping appears to completely support such usage as equally well as for simple types. 
Sorry if I seem to be splitting hairs here... Patrick 3. For the common use case, where applications embed a literal in an XML document, it is preferable to distinguish,in the graph, between plain and XML literals, so that e.g. different escaping conventions can be applied. 
I largely agree with what you said there, but that isn't what I was trying to say. 
I was trying to suggest that for the typical use case of embedding a literal in an XML document, then the following code fragment is typical: if (literal instanceof XmlLiteral) { write(literal); } else { write(escapeReservedXMLChars(literal)); This of course is not the only way to do things. 
My attempt, to make in part the point you make Patrick, was in the section about it being architecturaly inappropriate to put XML specific stuff in the core RDF model. 
Brian 
