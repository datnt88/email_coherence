Thanks for Tidy! 
It's proving invaluable. 
I have some apparent bugs to report (in this and subsequent messages). 
The HTML document below has a b outside of an li rather than inside it. 
I think this is causing 7-Jul-99 Tidy to dereference a bad pointer in istack.c, 
InsertedToken(), line 235: istack = lexer- insert; Symptoms seem to vary depending on the contents of memory. 
One (much longer) incarnation of this example document caused Tidy to generate the invalid start tag " \0x18\0x0d\0x0a\0x30 " along with the corresponding end tag. 
Also, Andy Quick's 7-Jul-99 Java Tidy throws an ArrayIndexOutOfBoundsException every time (which is what leads me to suspect the above mentioned line). 
-------- Example HTML document -------- Randy I can confirm on another platform (Mac OS) that there is a bug here (still in the 26th July 99 version). 
In my case, it appears that infinite recursion is probably occurring, and would have likely crashed had I not stopped it. 
I was getting the following error output on the above test case Tidy (vers 26th July 1999) Parsing " b inside li .html" 
line 8 column 7 - Warning: missing li line 8 column 10 - Warning: missing /b before li line 8 column 10 - Warning: trimming empty b line 8 column 10 - Warning: trimming empty li line 8 column 14 - Warning: inserting implicit b line 8 column 25 - Warning: discarding unexpected /b line 8 column 25 - Warning: discarding unexpected /b line 8 column 25 - Warning: discarding unexpected /b ... ad infinitum ... I haven't done any debugging on it yet. 
Regards, Terry The fix is to insert the following code snippet into parser.c 
at line 1179 in ParseList() if (node- tag &amp;&amp; node- tag- model &amp; CM_INLINE) ReportWarning(lexer, list, node, DISCARDING_UNEXPECTED); PopInline(lexer, node); FreeNode(node); continue; The code should then look lik: if this is the end tag for an ancestor element then infer end tag for this element if (node- type == EndTag) if (node- tag == tag_form) lexer- badForm = yes; ReportWarning(lexer, list, node, DISCARDING_UNEXPECTED); continue; if (node- tag &amp;&amp; node- tag- model &amp; CM_INLINE) ReportWarning(lexer, list, node, DISCARDING_UNEXPECTED); PopInline(lexer, node); FreeNode(node); continue; for (parent = list- parent; parent != 
null; parent = parent- parent) The new code makes sure that the inline stack is popped and the endtag ignored. 
I will include this in the next release. 
Regards, -- Dave Raggett dsr@w3.org 
http://www.w3.org/People/Raggett World Wide Web Consortium (on assignment from HP Labs) 
