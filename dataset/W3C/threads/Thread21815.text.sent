1/ http://www.w3.org/2000/10/swap/doc/Rules.html is showing up nicely, but using IE6 we're getting The XML page cannot be displayed Cannot view XML input using XSL style sheet. 
Please correct the error and then click the Refresh button, or try again later. 
Parameter entity must be defined before it is used. 
Error processing resource 'http://www.w3.org/TR/MathML2/dtd/xhtml-math11-f.dtd'. 
Line 148, Position 2 %xhtml-prefw-redecl.mod; 2/ w.r.t. easter.n3 
we were implementing log:quotient as if when integers were given (i.e. when we have no dots in the numbers) we make an integer division, but I now see that you have a log:integerQuotient so I guess we maybe should use that? 
Jos De Roo, AGFA http://www.agfa.com/w3c/jdroo/ 
My feeling is that integer division should, in an ideal world, give a rational, but failing that the best fallback is a float. 
Cwm doesn't currently distinguish between different classes of number, except through whatever happens with python. 
It Integer division thowing away the remainder seems to me to be something separate - but maybe I am out of sync with common uses of numbers Tim, what I was taking was the testcase in which math:quotient is used and running this formula (actually the one we cloned in we have to have integer division throwing away the remainder, otherwise asking the query we wouldn't get @prefix log: http://www.w3.org/2000/10/swap/log# . 
@prefix math: http://www.w3.org/2000/10/swap/math# . 
@prefix str: http://www.w3.org/2000/10/swap/string# . 
@prefix owl: http://www.w3.org/2002/07/owl# . 
@prefix rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns# . 
@prefix : easterP# . 
@prefix xsd: http://www.w3.org/2001/XMLSchema# . 
@prefix rdfs: http://www.w3.org/2000/01/rdf-schema# . 
{?j = "8". 
("2003" "19") math:remainder ?j} 
log:implies {("2003" "19") math:remainder "8"} . 
{?k = "20". 
("2003" "100") math:quotient ?k} 
log:implies {("2003" "100") math:quotient "20"} . 
{?h = "3". 
("2003" "100") math:remainder ?h} 
log:implies {("2003" "100") math:remainder "3"} . 
{?m = "5". 
("20" "4") math:quotient ?m} 
log:implies {("20" "4") math:quotient "5"} . 
{?n = "0". 
("20" "4") math:remainder ?n} 
log:implies {("20" "4") math:remainder "0"} . 
{?p = "1". 
(("20" "8").math:sum "25") math:quotient ?p} 
log:implies {(("20" "8").math:sum "25") math:quotient "1"} . 
{?q = "6". 
((("20" "1").math:difference "1").math:sum "3") math:quotient ?q} 
log:implies {((("20" "1").math:difference "1").math:sum "3") math:quotient "6"} . 
{?r = "26". 
(((((("19" "8").math:product "20").math:sum 
"5").math:difference "6").math:difference "15").math:sum 
"30") math:remainder ?r} 
log:implies {(((((("19" "8").math:product "20").math:sum 
"5").math:difference "6").math:difference "15").math:sum 
"30") math:remainder "26"} . 
{?s = "0". 
("3" "4") math:quotient ?s} 
log:implies {("3" "4") math:quotient "0"} . 
{?u = "3". 
("3" "4") math:remainder ?u} 
log:implies {("3" "4") math:remainder "3"} . 
{?v = "3". 
(("32" ("2" "0").math:product ("2" "0").math:product "26".math:negation "3".math:negation).math:sum 
"7") math:remainder ?v} 
log:implies {(("32" ("2" "0").math:product ("2" "0").math:product "26".math:negation "3".math:negation).math:sum 
"7") math:remainder "3"} . 
{?w = "0". 
(("8" ("11" "26").math:product 
("22" "3").math:product).math:sum 
"451") math:quotient ?w} 
log:implies {(("8" ("11" "26").math:product 
("22" "3").math:product).math:sum 
"451") math:quotient "0"} . 
{?x = "4". 
(("26" "3" ("7" "0").math:product.math:negation "114").math:sum 
"31") math:quotient ?x} 
log:implies {(("26" "3" ("7" "0").math:product.math:negation "114").math:sum 
"31") math:quotient "4"} . 
{?z = "19". 
(("26" "3" ("7" "0").math:product.math:negation "114").math:sum 
"31") math:remainder ?z} 
log:implies {(("26" "3" ("7" "0").math:product.math:negation "114").math:sum 
"31") math:remainder "19"} {?day = "20". 
("19" "1") math:sum ?day} 
log:implies {("19" "1") math:sum "20"} . 
?x = "20". 
"2003" :hasEasterOnDay ?x} 
log:implies {"2003" :hasEasterOnDay "20"} . 
{?j = "8". 
("2003" "19") math:remainder ?j} 
log:implies {("2003" "19") math:remainder "8"} . 
{?k = "20". 
("2003" "100") math:quotient ?k} 
log:implies {("2003" "100") math:quotient "20"} . 
{?h = "3". 
("2003" "100") math:remainder ?h} 
log:implies {("2003" "100") math:remainder "3"} . 
{?m = "5". 
("20" "4") math:quotient ?m} 
log:implies {("20" "4") math:quotient "5"} . 
{?n = "0". 
("20" "4") math:remainder ?n} 
log:implies {("20" "4") math:remainder "0"} . 
{?p = "1". 
(("20" "8").math:sum "25") math:quotient ?p} 
log:implies {(("20" "8").math:sum "25") math:quotient "1"} . 
{?q = "6". 
((("20" "1").math:difference "1").math:sum "3") math:quotient ?q} 
log:implies {((("20" "1").math:difference "1").math:sum "3") math:quotient "6"} . 
{?r = "26". 
(((((("19" "8").math:product "20").math:sum 
"5").math:difference "6").math:difference "15").math:sum 
"30") math:remainder ?r} 
log:implies {(((((("19" "8").math:product "20").math:sum 
"5").math:difference "6").math:difference "15").math:sum 
"30") math:remainder "26"} . 
{?s = "0". 
("3" "4") math:quotient ?s} 
log:implies {("3" "4") math:quotient "0"} . 
{?u = "3". 
("3" "4") math:remainder ?u} 
log:implies {("3" "4") math:remainder "3"} . 
{?v = "3". 
(("32" ("2" "0").math:product ("2" "0").math:product "26".math:negation "3".math:negation).math:sum 
"7") math:remainder ?v} 
log:implies {(("32" ("2" "0").math:product ("2" "0").math:product "26".math:negation "3".math:negation).math:sum 
"7") math:remainder "3"} . 
{?w = "0". 
(("8" ("11" "26").math:product 
("22" "3").math:product).math:sum 
"451") math:quotient ?w} 
log:implies {(("8" ("11" "26").math:product 
("22" "3").math:product).math:sum 
"451") math:quotient "0"} . 
{?x = "4". 
(("26" "3" ("7" "0").math:product.math:negation "114").math:sum 
"31") math:quotient ?x} 
log:implies {(("26" "3" ("7" "0").math:product.math:negation "114").math:sum 
"31") math:quotient "4"} . 
{?z = "19". 
(("26" "3" ("7" "0").math:product.math:negation "114").math:sum 
"31") math:remainder ?z} 
log:implies {(("26" "3" ("7" "0").math:product.math:negation "114").math:sum 
"31") math:remainder "19"} {?day = "20". 
("19" "1") math:sum ?day} 
log:implies {("19" "1") math:sum "20"} . 
?y = "4". 
"2003" :hasEasterOnMonth ?y} 
log:implies {"2003" :hasEasterOnMonth "4"} . 
and easter would not be on April 20 this year :-) On the other hand, for a testcase like implying we have math:quotient with double objects as in or as in your where I guess it are float objects (which is fine). 
And then I was not sure what math:integerQuotient meant, but I now see that it is fine with your My feeling is that integer division should, in an ideal world, give a rational, but failing that the best fallback is a float. 
Jos De Roo, AGFA http://www.agfa.com/w3c/jdroo/ 
Tim timbl@w3.org 
cc: www-archive@w3.org 
Subject: Re: swap questions 2003-03-21 07:47 PM My feeling is that integer division should, in an ideal world, give a rational, but failing that the best fallback is a float. 
Cwm doesn't currently distinguish between different classes of number, except through whatever happens with python. 
It Integer division thowing away the remainder seems to me to be something separate - but maybe I am out of sync with common uses of numbers 
