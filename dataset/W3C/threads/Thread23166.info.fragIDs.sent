DOM 2 allowed the creation of a document root element only at the time the element it created. 
However, there are *many* instances when one wants to construct the root element in the same manner as the other elements. 
(After all, the root element is only different from the other elements in its location in the tree.) Take, for instance, serializing a Java object to some XML representation by using the DOM: main Object object; //object to serialize Document doc=DOMImplementation.createDocument(); 
Element root=createElement(object); doc.setRoot(root); Element createElement(Document doc, Object object) Element element=doc.createElement(object.name); for each element attribute Element child=createElement(object.property[i]); element.appendChild(child); 
return element; Without the ability to set the document root, the elegant code above is forced to special-case creation of the root element. 
What's the status of this capability, and where can I go to find out more? 
Thanks, Garret 
DOM Level 3 has been looking at this. 
There are some slightly ugly issues regarding the fact that some DOMs may want to subclass themselves based on the DTD and/or the root element's namespace, so there are definitely cases where you do _not_ want to allow the document to be created before the root element is known... but there are also cases where it's more reasonable, so the DOM may be able to permit it for _some_ implementations. 
Still being researched, as far as I know. 
Meanwhile, all I can suggest is buffering the incoming data -- or otherwise looking ahead -- to obtain the information required by createDocument before it's needed. 
Joe Kesselman / IBM Research 
I think the approach taken so far is correct. 
The root node belongs only to 
the document object and this one has to manage it. 
Even if any node cannot live outside the Document node, i don't think that an element should be allowed to modify the structure of the document in 
which resides. 
I think this is a good separation, even if the coding gets 
somehow ugly following this approach (i agree to that). 
A compromise approach would be to introduce a special node object in the DOM, called RootElement, or something like that, but i don't think it is worthing to go that way. 
--Razvan 
Razvan Costea-Barlutiu Department of Radiology, The University of Chicago 5841 South Maryland Avenue Chicago, Illinois 60637 E-Mail: cbrazvan@baltan.bsd.uchicago.edu 
Thanks for the comment, Razvan. 
See my reply below. 
to 
I agree that the Document owns the root note and has to manage it. 
Why can't the document *change* its root node, just like an element can change *its* children? 
I'm not asking for an element to be allowed to modify the structure of the document in which it resides. 
I'm asking for the ability for a document to change its own structure. 
Again, an element can change its structure -- why not a document? 
I don't see why. 
An element is an element is an element -- the only difference with the document element is that it happens to be at the top of the hierarchy. 
(OK, it has to have the same name as the doctype, but that's negligible.) 
And that wouldn't address the problem I raised. 
To better see what ugly code the current architecture forces, consider a russianDoll element allows child RussianDoll elements. 
How would we convert a Java object tree into a DOM tree? 
Here's how one must currently do it: main RussianDoll russianDoll; //object to serialize Document doc=createRussianDollDoc(russianDoll); Document createRussianDollDoc(RussianDoll russianDoll) Document doc=DOMImplementation.createDocument("russianDoll"); 
Element root=doc.getDocumentElement(); 
//add all the attributes to the russianDoll element Element child=createRussianDollElement(russianDoll.getChild()); root.appendChild(child); return doc; Element createRussianDollElement(Document doc, RussianDoll russianDoll) Element element=doc.createElement("russianDoll"); 
//add all the attributes to the russianDoll element Element child=createRussianDollElement(russianDoll.getChild()); element.appendChild(child); 
return element; Notice that we now have to have two duplicate methods to create and populate russianDoll elements, based upon whether the element is the document element. 
Yet the content of all russianDoll elements are identical, wherever they are located. 
...even if the coding gets somehow ugly following this approach (i agree 
to that). 
Yep. 
So, if anyone knows how I can contribute to something better getting into DOM Level 3, let me know. 
If I were to join the WG, would that help? 
Cheers, Garret Wilson GlobalMentor, Inc. 
DOM Level 1 didn't specify how the root element was created, but I believe it did say it couldn't be removed. 
DOM Level 2 said the root element could be created only at the time the document was created, and still didn't permit removing it. 
The rationalle has to do with potentially using information about the root element's namespace and localname, along with the document type information, to select among different DOM implementations/subclasses. 
Last I checked, DOM Level 3 was considering adding the ability to set the root element after the Document had been created, and as a result was considering allowing folks to return to that state by removing the root element. 
This does cause some problems for folks who want to subclass, but the Embedded DOM capability appeared to offer an alternative solution for those users. 
I'm not sure of the current status; check the Level 3 Working Draft. 
Joe Kesselman / IBM Research 
