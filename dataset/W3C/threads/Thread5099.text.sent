Mark, That was nifty stuff you presented last week. 
I think one of the names you offered was RDF/XHTML. 
That works for me, at least for now... 
I saw you chatting with Jos and a few others about an XSLT transformation from that syntax to triples. 
Dom brought up an issue about XSLT and Qnames I'm curious how that's handled too. 
Do you have details to share? 
Dan Connolly, W3C http://www.w3.org/People/Connolly/ see you at the WWW2004 in NY 17-22 May? 
Hi Dan, Sorry for the delay in replying. 
Yes, it seems that everyone is concerned about QNames! 
I must admit, I wasn't worrying about it in my proposal, since it seems pretty trivial to crack a string open and get out a namespace and local name. 
From a purpose-built parser point of view it's easy, and from a GRDDL point of view there are a few ways to do it, but the one I favour would involve just adding two functions to an XSLT stylesheet. 
When I have a minute I'll extend the demo that I did in Cannes to incorporate the two required functions, and also change it so that the output is not N3. 
Just whilst I'm here, I'll touch briefly on how I was planning to do these functions, and that is to use the same names and parameter signatures as a couple of the new QName manipulation functions in the proposed XPath 2.0 [1] [2]. 
Note that although the functions mentioned actually take xs:QNames as their parameters - a type which obviously doesn't exist in XPath 1.0/XSLT 1.0 - this is not a problem, since an xs:string can be cast to an xs:QName [3], which effectively hides the problem for us. 
So, if we had the RDF/XHTML mark-up: in 'real' XPath 2.0 we would do the following to get the namespace URI that corresponds to the prefix 'dc': fn:get-namespace-uri-from-Qname(@property); If we had not loaded any schemas, then @property would only be a string value, not a QName, but this is covered by promoting the string to a QName, and is therefore equivalent to this: fn:get-namespace-uri-from-QName(xs:QName(@property)); The QName is created by taking the string "dc:creator" and looking at the prefixes that are 'in-scope', so the QName would have a URI part made up of the namespace obtained from 'dc', and a local name part of 'creator'. 
However, since we don't have objects of type QName in our current XPath/XSLT set-ups anyway, then our functions will only operate on strings. 
In which case our usage will 'look' exactly the same as the 'correct' usage in a full XPath 2.0 implementation: fn:get-namespace-uri-from-QName(@property); Regards, Mark [1] [2] [3] http://www.w3.org/TR/xquery-operators/#casting-to-QName Mark Birbeck CEO and CTO x-port.net Ltd. Download our XForms processor from Hi Mark, This does seem to fix up much of the potential for problems, though I'd be interested to hear whether you've got a way around the situation where the XHTML gets passed through XML processing (minimal case - XML indent pretty printing) where the prefix/namespace mapping within attributes can get lost. 
Just a thought - in most cases there won't be too much risk of naming clashes within XHTML+RDF docs, so perhaps there might be an another route where the terms used are exhaustively listed, something like: link href="http://purl.org/*dc*/elements/1.1/description" rel="description" / Once upon a time there lived three very conventional bears, item property="description" Mummy Bear, Daddy Bear and Baby Bear /item ... Cheers, Danny. 
