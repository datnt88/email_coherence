I've been re-implementing my URI parser based very closely on the latest RFC2396bis document. 
Here are my comments. 
The syntax has been taken from the very latest work-in-progress version of the document (CVS revision 1.64, from Overall, I think it's looking pretty good. 
Test case: "http://example.org/aaa/bbb#ccc" 
This parses as a valid relative-URI, because the syntax for hier-part - rel-path - segments allows the first segment to contain a ':' character. 
Later: I see this is covered by text in section 4.1. 
I suggest also adding a note to the paragraph in section 3 following the rel-path production: "The first segment in a rel-path may not match the 'scheme' and ':' syntax". 
Test case: "http://example.123./aaa/bbb#ccc" 
I'd like to confirm that this is now regarded as a valid URI. 
In previous versions of this specification, it was not (according to my interpretation and implementation). 
I note that getting the parsing (look-ahead) logic for this just right has turned out to be a bit tricky. 
When parsing a 'qualified' production, if a leading '.' is not followed by a domainlabel, it must be re-interpreted as a trailing '.'. 
I think this production might be easier as a basis for implementation: qualified = [ "." [ domainlabel qualified ] ] (I can't see how to express this using repetition rather than recursion.) Derivation of above: qualified = *( "." domainlabel ) [ "." ] ... [ 1*( "." domainlabel ) / "." / 1*( "." domainlabel ) "." ] ... [ "." domainlabel *( "." domainlabel ) / "." domainlabel *( "." domainlabel ) "." ] ... [ "." [ domainlabel *( "." domainlabel ) / domainlabel *( "." domainlabel ) "." ] ] ... [ "." [ domainlabel *( "." domainlabel ) [ "." ] ] ... [ "." [ domainlabel qualified ] I note that getting the parsing (look-ahead) logic for the ipv6literal just right has been quite tricky, mainly when parsing phrases of the form (h4 ":"), it is important to ensure that the following character is not another #g Graham Klyne The discussion and resolution can be found in the issues doc: You can see there that the productions were changed at your request, so it's probably safe to assume that the elimination of toplabel was deliberate, in order to fully accomodate unqualified hostnames. 
Issue 016 also touches on this. 
If you have any more test cases to share (aside from the ones in the spec), I'd like to see them, just so I can further verify my own implementation. 
My implementation in Python with regular expressions has presented no problems so far. 
If anyone wants to see, it's open source: implementation: (in particular, have a look at the Absolutize, _eliminateDotSegments, and _initUriValidationRegex functions) test suite: (this module expects to be imported and run in a custom testing framework, but the source and comments should be clear enough for inspection) -Mike That particular change didn't change the status of the test case mentioned (i.e. with a trailing '.') -- I noticed that my earlier implementation, based on didn't accept that. 
But rather than discuss such minutiae, the point of my post was simply to draw attention to the change, which surprised me, so that folks would have a chance to say whether or not that's what they expected. 
My test suite can be seen at: (At this time, my code is being rewritten and doesn't pass all of the normalization tests.) #g Graham Klyne 
