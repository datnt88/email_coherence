kboone wrote, on the public list: 
Assuming the following Java statements are executed: attr.setValue("foo"); element.setAttributeNodeNS(attr); 
element.setAttributeNS(attr.getNamespaceURI(), attr.getName(), "bar"); What will be returned by attr.getValue()? 
If I'm reading this correctly, this has some serious concerns. 
He didn't say how the attr node was created. 
Two scenarios: 1) createAttribute -- prefix/localname/namespaceURI are all null. 
2) createAttributeNS -- attr has the localname and namespaceURI specified It may have a prefix. 
When we issue setAttributeNodeNS, this Attr replaces any existing Attr with the same {nsuri}localname. 
Problem: If it's a non-namespaced Attr, that means it replaces a non-namespaced Attr but we don't know which, since they all have null for both values. 
The results are implementation dependent. 
Ugh. 
When we issue setAttributeNS()... 
As written, the line doesn't work; he probably intended to use getLocalName(). 
But if it's a non-namespaced node, this still results in our setting the value for {null}null, which matches any single non-namespaced Attr on this element. 
And again, the results are implementation dependent. 
Ugh ugh. 
Is my analysis in error? 
If so, do we still believe this is an acceptable answer? 
Note that if we had gone with localname=nodename for non-namespaced nodes, this particular scenario wouldn't arise; the NS methods would be replacing {null}localname, and everything would work correctly. 
Joe Kesselman / IBM Research 
First of all, I'm fairly sure I meant attr.getName(), because setAttributeNS() requires a qualified name, which is what getName() is supposed to return -- yes? 
Secondly, you can assume the attr in my example is created using the createAttributeNS() method, as the DOM 2 is clear that mixing NS-aware and NS-unaware calls may be flakey. 
Finally, why isn't localName = qualifiedName when a node is created using the non-namespace aware methods. 
Keith keshlam@us.ibm.com kboone wrote, on the public list: 
Assuming the following Java statements are executed: attr.setValue("foo"); element.setAttributeNodeNS(attr); 
element.setAttributeNS(attr.getNamespaceURI(), attr.getName(), "bar"); What will be returned by attr.getValue()? 
If I'm reading this correctly, this has some serious concerns. 
He didn't say how the attr node was created. 
Two scenarios: 1) createAttribute -- prefix/localname/namespaceURI are all null. 
2) createAttributeNS -- attr has the localname and namespaceURI specified It may have a prefix. 
When we issue setAttributeNodeNS, this Attr replaces any existing Attr with the same {nsuri}localname. 
Problem: If it's a non-namespaced Attr, that means it replaces a non-namespaced Attr but we don't know which, since they all have null for both values. 
The results are implementation dependent. 
Ugh. 
When we issue setAttributeNS()... 
As written, the line doesn't work; he probably intended to use getLocalName(). 
But if it's a non-namespaced node, this still results in our setting the value for {null}null, which matches any single non-namespaced Attr on this element. 
And again, the results are implementation dependent. 
Ugh ugh. 
Is my analysis in error? 
If so, do we still believe this is an acceptable answer? 
Note that if we had gone with localname=nodename for non-namespaced nodes, this particular scenario wouldn't arise; the NS methods would be replacing {null}localname, and everything would work correctly. 
Joe Kesselman / IBM Research 
One reason is that names with colons were used by by users of namespaces throughout level one. 
This would produce localnames that have colons in them, which seems wrong. 
This mixing situation is bound to produce errors in any case with the application using NS methods. 
I like an obvious error more than a less-obvious one, that just causes the program to malfunction for less-obvious reasons. 
So I like a null localname. 
Ray Whitmer ray@xmission.com 
Apologies, everyone -- that commentary was intended for the IG list, not the public list. 
Please hang loose while folks determine whether I'm confused or not. 
I've got half an idea, but half an hour from now I may look like a halfwit. 
Joe Kesselman / IBM Research 
