Hi, [I didn't realise that the email address for XSLT 2.0 comments had changed as well...] This is a follow-on from my last message about indeterminate comparisons between durations and date/times in the F&amp;O WD and sorting. 
Currently the XSLT 2.0 WD says: The items in the initial sequence are ordered into a sorted sequence by comparing their sort keys. 
The relative position of two items A and B in the sorted sequence is determined as follows. 
The first sort key of A is compared with the first sort key of B, according to the rules of the first sort key definition. 
If, under these rules, A is less than B, then A will precede B in the sorted sequence, unless the order attribute of this sort key definition specifies descending, in which case B will precede A in the sorted sequence. 
If, however, the relevant sort keys compare equal, then the second sort key of A is compared with the second sort key of B, according to the rules of the second sort key definition. 
This continues until two sort keys are found that compare unequal. 
If all the sort keys compare equal, then A will precede B in the sorted sequence if A preceded B in the initial sequence, and vice versa. 
In general, comparison of two values is performed according to the rules of the XPath lt operator. 
However, special rules apply to certain data types, as described below. 
[ERR069] It is a dynamic error if, for any sort key definition, the set of sort keys evaluated for all the items in the initial sequence, after any type conversion requested, contains a pair of values for which the result of the XPath lt operator is an error or an empty sequence. 
The processor must either signal the error, or must recover by assigning an arbitrary ordering to any such pair of values. 
Given that indeterminate comparisons were allowed, I think that it would be much more helpful if the comparisons between pairs of values were described in terms of only lt rather than lt and eq. 
The second part of the first paragraph would be: If, however, B is not less than A, then the second sort key of A is compared with the second sort key of B, according to the rules of the second sort key definition. 
This continues until two sort keys are found for which A is less than B or B is less than A. If all the sort keys compare equal, then A will precede B in the sorted sequence if A preceded B in the initial sequence, and vice versa. 
For totally ordered data types, this makes no difference. 
For partially ordered data types, this will create an intuitive ordering, and not require an error to be raised. 
For example, with the source: it would be possible to sort them with: in order to get: without getting an error of any kind. 
Cheers, Jeni Jeni Tennison 
Jeni: We are trying to get away from indeterminate comparisons. 
Our attempt is to deprecate 'duration' and have users use two totally ordered subtypes of duration called 'yearMonthDuration' 
and 'dayTimeDuration'. 
For the date/time types we say that for purposes of comparison and arithmetic all date/time values have an implementation specific timezone This makes them totally ordered. 
Take a look at the latest Functions and Operators document: This does not contain the changes for the date/time datatypes mentioned above. 
These will appear in the next version. 
All the best, Ashok Ashok Malhotra mailto: ashokma@microsoft.com 
Microsoft Corporation 212 Hessian Hills Road Croton-On-Hudson, NY 10520 USA Redmond: 425-703-9462 New York: 914-271-6477 Hi, [I didn't realise that the email address for XSLT 2.0 comments had changed as well...] This is a follow-on from my last message about indeterminate comparisons between durations and date/times in the F&amp;O WD and sorting. 
Currently the XSLT 2.0 WD says: The items in the initial sequence are ordered into a sorted sequence by comparing their sort keys. 
The relative position of two items A and B in the sorted sequence is determined as follows. 
The first sort key of A is compared with the first sort key of B, according to the rules of the first sort key definition. 
If, under these rules, A is less than B, then A will precede B in the sorted sequence, unless the order attribute of this sort key definition specifies descending, in which case B will precede A in the sorted sequence. 
If, however, the relevant sort keys compare equal, then the second sort key of A is compared with the second sort key of B, according to the rules of the second sort key definition. 
This continues until two sort keys are found that compare unequal. 
If all the sort keys compare equal, then A will precede B in the sorted sequence if A preceded B in the initial sequence, and vice versa. 
In general, comparison of two values is performed according to the rules of the XPath lt operator. 
However, special rules apply to certain data types, as described below. 
[ERR069] It is a dynamic error if, for any sort key definition, the set of sort keys evaluated for all the items in the initial sequence, after any type conversion requested, contains a pair of values for which the result of the XPath lt operator is an error or an empty sequence. 
The processor must either signal the error, or must recover by assigning an arbitrary ordering to any such pair of values. 
Given that indeterminate comparisons were allowed, I think that it would be much more helpful if the comparisons between pairs of values were described in terms of only lt rather than lt and eq. 
The second part of the first paragraph would be: If, however, B is not less than A, then the second sort key of A is compared with the second sort key of B, according to the rules of the second sort key definition. 
This continues until two sort keys are found for which A is less than B or B is less than A. If all the sort keys compare equal, then A will precede B in the sorted sequence if A preceded B in the initial sequence, and vice versa. 
For totally ordered data types, this makes no difference. 
For partially ordered data types, this will create an intuitive ordering, and not require an error to be raised. 
For example, with the source: it would be possible to sort them with: in order to get: without getting an error of any kind. 
Cheers, Jeni Jeni Tennison 
Ashok, 
Yes, I understand that and I've read that part of the F&amp;O WD. 
I think that decision is completely wrong-headed -- absolutely horrendous, actually -- which is why I'm commenting on it. 
I thought that was the point of making working drafts public and inviting people to review them. 
I don't think that it's XQuery/XPath's job to dictate what data types people use in their schemas, and I think that attempts to do so are likely end in failure and frustration, mostly for those people who are unfortunate enough to have to work with it. 
I think more effort should be made thinking about what people *do* want to do or *might* want to do, and less trying to dictate what they *should* want to do. 
Cheers, Jeni Jeni Tennison 
Echoing Ashok's response, the current situation is that the "lt" operator, if it is defined at all for a given data type, always returns a determinate boolean answer. 
Defining sorting in terms of "lt" and "eq" therefore works. 
I agree that if we allowed an indeterminate result of "lt" we could treat it for sorting purposes as if the items were equal. 
Currently, the value of P29D lt P1M is not indeterminate, it is an error. 
I expect that in a future draft we may list the data types that can be used in xsl:sort. 
These are likely to include dayTimeDuration and yearMonthDuration but not xsd:duration. 
Michael Kay 
