I was unimpressed by the reaction at the IETF meeting to the need to omit
Location and Transforms from the SignedInfo. Unimpressed because the
opinions seemed to be based on fear, either of complicating matters or of
creating security problems. I would prefer reasons grounded in fact rather
than fears. At the meeting it was insisted that this standard be applied
when deciding whether to reorder the elements in our signatures, and I would
like to insist that we do the same here.
The points recently made by Rich Himes and Daniel LaLiberte are absolutely
correct and mirror my own thoughts on these issues. To sharpen the point,
let's begin with this question: Suppose we have an XML signature in which
the SignedInfo contained no ObjectReference descendants? What is the value
of such a signature? Nil.
The signing of SignedInfo is an intermediary step that *we* have added for
some reason (perhaps the most compelling being that the method is quite
clean about signing multiple objects with the same signature). The fact
that the Location and Transforms are signed by *our* artificial process is a
usually harmless and often desirable side effect. However, THE MESSAGE THAT
THE SIGNER WANTS TO BE AUTHENTICATED BY A SIGNATURE IS THAT WHICH IS
INDICATED BY OBJECTREFERENCE.
Our process of signature generation creates a digest not only of the message
intended by the signer, but some additional information, namely SignedInfo,
whose subsequent invariance may harm the signer or prevent the use of core
signature behavior. Signing SignedInfo is an imprecise method of achieving
our actual goal, which is to achieve security by signing the DigestMethod
and DigestValue of each ObjectReference (along with other bits of info
outside of ObjectReference elements).
No matter how loud the opposition sounds, the fact is that we have inserted
an unintended and sometimes unwanted additional assertion in the message
being signed by the signer. Specifically, we assert that the referenced
object can be obtained by a particular sequence of steps (given by Location
and Transforms). Further, this assertion is not eliminated by simply
changing the name of Location to something like Target.
It was acrimoniously asserted that the Location is required because the
signer may want the signature to break if the data at the given location is
changed. I disagree, and it should be obvious to the reader that 'required'
and 'may' do not belong together in the same sentence. However, I do agree
with the spirit of the acrimony, which is that the signer will often benefit
from the inclusion of this assertion in the message being authenticated.
Always including the Location and Transforms in the signature is unclean and
borne of imprecision, but always omitting them is also problematic. One
might be inclined to say that the signature should include an
ObjectReference to a Location that must be invariant after signing. However,
from a security standpoint, this solution has no bottom turtle. We could
take the position that all assertions must be carried by the signed message
and hence this problem of associating the signed data with its location and
transforms should be pushed off to the application. Although, this is a
more defendable position than the one taken by those who want to always
include Location and Transforms in the signature, I do not agree with this
either because we would be requiring an application to put assertions about
*our* markup into its markup.
In the end, it is best if there is *some* way to indicate whether or not the
Location and Transforms of an ObjectReference should be included in the
signature over SignedInfo. Obviously, this could also be accomplished by
applying Transforms to SignedInfo that would omit Location and Transforms.
Some have strong feelings that this will introduce the possibility of
security holes. Of course it will. We have security holes that can result
from the fact that we are signing markup rather than a bitmap of what the
user actually sees. We have security holes that can result from poorly
constructed transforms in ObjectReferences. As I presented at the IETF
meeting, it would be easy for someone to write a transform that omits the
DigestMethod and DigestValue descendants of SignedInfo. The Signedinfo
Transforms element could even cause its own omission from the SignedInfo.
It does not matter because we ultimately create a digest using a "secure"
hash algorithm, and only the digested data can be used to assess the
security of the signature.
The point is that this is not a security hole in our spec but rather a
security problem with the software that creates an insecure signature. It
is not logically different from using the results of our specs with 256-bit
RSA keys. People can do it with software based on our spec, but that
doesn't mean it is secure.
To some extent, signing SignedInfo is like a first implicit ObjectReference,
which is why it makes sense to apply Transforms to it. Nonetheless, if
full-blown Transforms on SignedInfo are just too much for fear of complexity
or security, then how about a simple 'OmitXXX' attribute in ObjectReference
to specify whether or not the Location and Transforms should be omitted? It
is not as flexible for the future, but it at least solves the problems we
know about now.
John Boyer
Software Development Manager
UWI.Com -- The Internet Forms Company
Mary,
An XSL transform could restructure the document in countless ways, so it
wouldn't help to name it, I don't think. Perhaps your industry (and others)
will have to restrict the types of transform that can be done. The key to me is
whether the transformed document is closer to the "signature context" (see
below).
It probably depends on the problem being addressed. These transforms could
conceivably themselves be signed by a trusted application. Seems likely to me,
though, that these transforms would generally be part of the document rather
than separate transforms. I believe John Boyer has good arguments for keeping
transforms separate for XFDL, where different pieces of the document are signed
by different individuals.
It is the opinion of John Boyer, Todd Vincent, myself, and others that (where
applicable) the signature should be applied to a format of the document as close
as possible to the presentation format, so that users essentially sign what they
see. For example, it makes more sense (to me) to sign a PDF document than to
sign the base64-encoded PDF document. Thus, the original PDF would be signed in
its native format. If that PDF were base64-encoded for inclusion in an XML
document, the "required" transform would be to base64-decode it before
authentication. Note that we can only push so far toward the presentation
layer. It probably doesn't make sense to sign the pixels on the display screen
(not saying nobody will try this.)
Rich
Rich has suggested naming a transform. This prompts my comment.
If we have a transform which says "if and only if the document is base64
encoded, decode it", I believe we should have a standard way of identifying
state of the document as base64-encoded (outside SignedInfo). Otherwise, I
believe transforms belong outside SignedInfo, and the transform should be just
"base64-decode".
snip
It seems to me that the basic issue here is that we're using Transforms for
two things:
1. To refine the definition of what is being signed in the document
2. To assist in retrieving the document in the appropriate form
An example of the first is using XSLT (or XPath) to define which part of a
given document the signature is over; an example of the second is base64
decoding.
It is critical that the first type of transform be signed. It seems equally
critical that the latter type not be signed if the location is to not be
signed, since different locations fairly naturally will have different
encoding.
At first I was thinking, well, why don't we just put all transforms outside
SignedInfo? You can't actually tamper with what is signed anyway, that is
the entire point of digest algorithms. But particularly with XSLT the
possibilities for misrepresentation are vast.
For example, I might sign a document declaring that green is my favorite
colour. Mallory (my unscrupulous interior decorator) might create a
contract that say I agree to pay him $100,000 for services rendered, and
then write XSLT to transform that document into my assertion of colour
preference. Place that XSLT in a Transform outside of SignedInfo and the
signature will happily verify. Now, I doubt it would stand up in court, but
I don't want to have to go to court. In automated business-to-business
scenarios this would be particularly frightening, because the transactions
might not be put in front of human eyes.
Proposal 1:
* allow Transforms both inside and outside SignedInfo
* allow Location either inside or outside SignedInfo
* specify that applications are to limit Transforms outside of SignedInfo to
the set of algorithms that they trust
I don?t like this. I think it is complicated, and there is bound to be
either trust or interoperability problems with the "set of algorithms that
they trust" part.
Proposal 2:
* Transforms are in SignedInfo
* Location is in SignedInfo
* view Location only as a hint
* applications can use non-signature information to find the object and
transform it into something appropriate to feed into the Transforms
I prefer this. The assumption is that if the application knows how to find
the object without using Location, it can also know or determine what format
it is in (possibly from extra markup passed along with the signature).
Perhaps if we are taking the "Location is only a hint" view, we should
rename the element to LocationHint. Otherwise people *will* get confused.
Basically I've just rephrased arguments other people have made into a form
that is more clear to me.
-Mark Bartel
JetForm Corporation
Mary,
An XSL transform could restructure the document in countless ways, so it
wouldn't help to name it, I don't think. Perhaps your industry (and
others)
will have to restrict the types of transform that can be done. The key
to me is
whether the transformed document is closer to the "signature context"
(see
below).
It probably depends on the problem being addressed. These transforms
could
conceivably themselves be signed by a trusted application. Seems likely
to me,
though, that these transforms would generally be part of the document
rather
than separate transforms. I believe John Boyer has good arguments for
keeping
transforms separate for XFDL, where different pieces of the document are
signed
by different individuals.
It is the opinion of John Boyer, Todd Vincent, myself, and others that
(where
applicable) the signature should be applied to a format of the document
as close
as possible to the presentation format, so that users essentially sign
what they
see. For example, it makes more sense (to me) to sign a PDF document
than to
sign the base64-encoded PDF document. Thus, the original PDF would be
signed in
its native format. If that PDF were base64-encoded for inclusion in an
XML
document, the "required" transform would be to base64-decode it before
authentication. Note that we can only push so far toward the
presentation
layer. It probably doesn't make sense to sign the pixels on the display
screen
(not saying nobody will try this.)
Rich
____________________Reply Separator____________________
Rich has suggested naming a transform. This prompts my comment.
If we have a transform which says "if and only if the document is
base64
encoded, decode it", I believe we should have a standard way of
identifying
the
state of the document as base64-encoded (outside SignedInfo).
Otherwise, I
believe transforms belong outside SignedInfo, and the transform should
be just
I have had some audit experience in banking as well as information
security. I
approach the issue by asking: "How will I describe to the business,
auditor, and
information security specialists exactly what is being signed?"
I view transforms as a type of "macro" with full computational powers.
Thus the
business (signer) is signing an algorithm to act on data. If any
transform can
be
placed in signed data, how will the business signer or relying party be
able to
determine exactly what the effects of the transform are to the
satisfaction of
their
auditors? I think this will be difficult to explain at best.
At the DC IETF WG meeting, several example transforms were suggested. I
could
see
the business need for many of the examples. I was just uncomfortable
with
having
arbitrarily constructed transforms.
Admittedly, "base64 encoding" is an algorithm (transform) operating on
the data,
but
the algorithm/concept has been fully vetted and reviewed by many parties
in the
standards and security community. I have been able to explain "base64
encode/decode"
to auditors and business with success relying on the existing extensive
review
literature.
Following the example of "base64", I believe that transforms must be
"named,"
well
known algorithms with review by standards bodies. If this is the case, I
can see
explaining to auditors and business that the transforms need to be part
of the
signedinfo, and they are fixed, well defined, named, and vetted
transforms.
Mack Hicks, SVP mack.hicks@bankofamerica.com
Bank of America +1-415-436-5809
Hi Mark,
It seems to me that the basic issue here is that we're using Transforms for
two things:
1. To refine the definition of what is being signed in the document
2. To assist in retrieving the document in the appropriate form
An example of the first is using XSLT (or XPath) to define which part of a
given document the signature is over; an example of the second is base64
decoding.
It is critical that the first type of transform be signed. It seems equally
critical that the latter type not be signed if the location is to not be
signed, since different locations fairly naturally will have different
encoding.
I agree here. Signing the XPath type transforms allows one to achieve
'document closure'.
This is part of why I liked the ability to apply a transform to signed info.
One could
then select precisely which transforms should be omitted. I would like to
omit
transforms that call for base64, but keep the rest. This would allow those
who
want to change Location and base64 encoding to still accomplish document
closure.
At first I was thinking, well, why don't we just put all transforms outside
SignedInfo? You can't actually tamper with what is signed anyway, that is
the entire point of digest algorithms. But particularly with XSLT the
possibilities for misrepresentation are vast.
For example, I might sign a document declaring that green is my favorite
colour. Mallory (my unscrupulous interior decorator) might create a
contract that say I agree to pay him $100,000 for services rendered, and
then write XSLT to transform that document into my assertion of colour
preference. Place that XSLT in a Transform outside of SignedInfo and the
signature will happily verify. Now, I doubt it would stand up in court, but
I don't want to have to go to court. In automated business-to-business
scenarios this would be particularly frightening, because the transactions
might not be put in front of human eyes.
This is a great example of why leaving out ObjectReference transforms can
cause troubles unless we can be very specific about the nature of the
transforms that got omitted. I.e. yes a transform was left out, but it MUST
have been a base 64 transform because we add all others to the SignedInfo
digest message.
Proposal 1:
* allow Transforms both inside and outside SignedInfo
* allow Location either inside or outside SignedInfo
* specify that applications are to limit Transforms outside of SignedInfo to
the set of algorithms that they trust
I don?t like this. I think it is complicated, and there is bound to be
either trust or interoperability problems with the "set of algorithms that
they trust" part.
I don't either
Proposal 2:
* Transforms are in SignedInfo
* Location is in SignedInfo
* view Location only as a hint
* applications can use non-signature information to find the object and
transform it into something appropriate to feed into the Transforms
This part I don't like because it means that every signature is
application-specific and noone can validate anyone else's signatures.
Everyone needs that application-specific plugin that tells how to
dereference the Location. Yuck!
