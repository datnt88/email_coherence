The following HTML document causes an infinite loop in both Tidy and
JTidy, 8-Jul-2000 and 4-Aug-2000. View the document in IE or Netscape
to see how they interpret it.
The middle four li's contain an illegal element, each of which triggers
an infinite loop. Of course, only the first infinite loop is actually
executed. To verify that each one causes an infinite loop, delete three
of the four illegal elements; all four variations should loop.
This appears to encompass the problem reported last June by Franco
Crivellari and partially diagnosed by Terry Teague:
I think the following patch to ParseBlock() in parser.c fixes the
problem. I'm actually working with JTidy so please forgive any
translation errors. The comments explain what I think is happening.
@@ -713,28 +713,55 @@
Allow CM_INLINE elements here.
Allow CM_BLOCK elements here unless
lexer- excludeBlocks is yes.
LI and DD are special cased.
Otherwise infer end tag for this element.
if (!(node- tag- model &amp; CM_INLINE))
if (node- type != StartTag &amp;&amp; node- type != StartEndTag)
ReportWarning(lexer, element, node, DISCARDING_UNEXPECTED);
continue;
+ If an LI contains an illegal FRAME, FRAMESET, OPTGROUP, or OPTION
+ start tag, discard the start tag and let the subsequent content get
+ parsed as content of the enclosing LI. This seems to mimic IE and
+ Netscape, and avoids an infinite loop: without this check,
+ ParseBlock (which is parsing the LI's content) and ParseList (which
+ is parsing the LI's parent's content) repeatedly defer to each
+ other to parse the illegal start tag, each time inferring a missing
+ /li or li respectively.
+ NOTE: This check is a bit fragile. It specifically checks for the
+ four tags that happen to weave their way through the current series
+ of tests performed by ParseBlock and ParseList to trigger the
+ infinite loop.
+ if (element- tag == tag_li)
+ if (node- tag == tag_frame ||
+ node- tag == tag_frameset ||
+ node- tag == tag_optgroup ||
+ node- tag == tag_option)
+ ReportWarning(lexer, element, node, DISCARDING_UNEXPECTED);
+ continue;
if (element- tag == tag_td || element- tag == tag_th)
/* if parent is a table cell, avoid inferring the end of the cell */
if (node- tag- model &amp; CM_HEAD)
MoveToHead(lexer, element, node);
continue;
------------------------ Example HTML document -------------------------
Randy
The following line of code leads to a segmentation fault with Tidy (vers
4th August 2000):
(The closing quote are missing.)
Here is my test-file:
With default options I get the following output:
Tidy (vers 4th August 2000) Parsing "test.html"
line 7 column 1 - Warning: a unknown attribute value "Segmentation
fault
Is this a bug that is already known? Has anybody posted a fix, yet?
Achim
I think we had something comparable about 2 weeks ago, with similar effects.
While my Linux Tidy gives...
Tidy (vers 4th August 2000) Parsing console input (stdin)
line 7 column 1 - Warning: a unknown attribute value "(null)"
... the SunOS/Solaris version of Tidy gives a segmentation fault in pleace
of "(null)".
sebastian
Sebastian Lange
Maybe the first chat site that validates as HTML
4.0 even though user input may contain HTML codes.
Courtesy to Dave Raggett's HTML Tidy:
Tidy your documents ONLINE:
Yes, I believe this is a known bug (or a variation on a known bug) :
Reported by Scott Davis 19 Jul 00, in the 08 Jul 00 version.
Mismatched quotes for an element's attribute causes a NULL pointer to be
dereferenced when reporting the error, which causes a crash/segmentation
fault on some platforms.
Note the odd quoting on the HREF element.
This seems to be caused by the value of the sattribute being null if an
unexpected quote is found. It may be related to the break at line 2541 of
lexer.c. Removing that line seems to produce a reasonable result of
Proposed solution (tabs removed by me) :
original code : 30 Apr 00
lexer.c - line 2541 ParseValue()
if (c == '"' || c == '\'')
ReportAttrError(lexer, lexer- token, null, UNEXPECTED_QUOTEMARK);
break;
fixed code :
if (c == '"' || c == '\'')
ReportAttrError(lexer, lexer- token, null, UNEXPECTED_QUOTEMARK);
// *** REMOVE *** break;
Note, I haven't tested this fix.
Regards, Terry
The proposed solution (see below) indeed fixes the problem for the code
and produces the desired output.
However, it does not change tidy's behaviour for code like
This still leads to a segmentation fault (on SunOS/Solaris or a null
pointer on other systems).
This seems to be a different bug, though it looks very similar. Maybe
someone can find a similar solution.
Regards, Achim
with Tidy (vers 4th August 2000):
Thanks for the reports. I have modified ParseAttrs() to improve
how it handles missing trailing quotemarks, and added a new
warning to make it clear what is going on. The changes effected
lexer.c, localize.c and html.h. I will include the fixes in the
next release.
Regards,
-- Dave Raggett dsr@w3.org http://www.w3.org/People/Raggett
World Wide Web Consortium (on assignment from HP Labs)
My fix avoids this problem, and produces the following output
for your example:
line 4 column 1 - Warning: a attribute with missing trailing
quote mark
It would be better to make a retroactive guess that the first
in the attribute is the end of the tag, and to push back the
rest of the text. I will need to spend more time to understand
how to do that.
Regards,
-- Dave Raggett dsr@w3.org http://www.w3.org/People/Raggett
World Wide Web Consortium (on assignment from HP Labs)
