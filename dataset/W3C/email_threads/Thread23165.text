interface CharacterData : Node {
void deleteData(in unsigned long offset,
in unsigned long count)
raises(DOMException);
Exceptions
DOMException
INDEX_SIZE_ERR: Raised if the specified offset is negative or greater than
the number of 16-bit units in data, or if the specified count is negative.
How can the count be negative if the count parameter is an unsigned long?
The DOM Level 1 NIST conformance tests actually test on this by passing a
negative value.
Isn't this an error in the specification or is this just added to actually
give a hint
to bindings that don't support unsigned numbers (like Java (?)) ?
To examplify:
We have made an interface in C++ that of course uses an unsigned number,
and we have made a JNI interface on top of this to actually "conformance"
test
the C++ implementation with the NIST Java conformance tests.
If Java passes a negative number, this will be translated to a large
unsigned number in C++
and the behaviour of these two different possibilities are specified to be
different.
Because the DOM Level 2 spec says:
"If the sum of offset and count exceeds length then all 16-bit units from
offset to the end of the data are deleted."
Could somebody clarify this to me?
Jan-Arve S?ther, System Developer
Birdstep Technology ASA
Remember the distinction between the IDL specification and the
implementation. Not all languages support unsigned integers. In those which
don't, a negative parameter is possible.
Joe Kesselman / IBM Research
In the DOM Test Suite effort currently underway, tests that depend on
support for signed numbers can be declared as such and can be supressed for
bindings that use unsigned numbers.
