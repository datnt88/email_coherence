Here is a heads-up on where Bill and I have got to.
ACTION: 2001-09-07#5: Jeremy Caroll
Collaborate with Bill dehOra to produce analysis of the literal
problem, options, pros/cons for WG consideration.
We are expecting to continue this action into next week.
The issues we are addressing are:
1: The Representation of Literals
e.g. a pair of a Unicode String and an RFC 3066 language tag.
2: Equality
a complete equality rule for literals, correcting para 217-219 and
para 220, which currently leave parts of equality as undefined.
3: Preferred Mappings under rdf:parseType="Literal"
(of xml document fragments into the representation of [1]).
- Currently para 203 and para 220 are explicitly vague about this mapping.
- We wish to specify one or more preferred mappings.
- We may wish to specify more than one conformance level
+ motivation
there are two significantly different use cases
+ quoting simply xhtml
+ quoting arbitrary XML fragments
4: Cases in which applications may expect problems.
- Older RDF parsers will not be using the preferred mappings,
we should indicate to document writers which XML fragments are likely to
be problematic.
A less ambitious approach would be to not specify a preferred mapping and
simply specify a minimal requirement about some markup that should work
(e.g. embedded xhtml without namespaces and without references). This would
be consistent with M&amp;S and put off the work M&amp;S defers until RDF 2.0.
Questions for WG for tomorrow:
+ Does the WG agree that a Literal is a Unicode String,RFC 3066 pair?
+ Does the WG agree that Literal equality should be defined?
+ Does the WG agree that the new specs should descibe a specific Unicode
string to be delivered by rdf:parseType="Literal"?
Our current working text for the literal representation is:
An RDF Literal is* a Unicode string, optionally** paired with a
language tag (as defined in RFC3066).
When comparing two RDF Literals, their Unicode strings must be
equal for the RDF Literals to compare as equal. If both Literals
have language tags, these tags must be equal for the Literals to
be considered equal. If two Literals are found equal but only
one has a language tag, the Literals should not*** be considered
equal.
The equality of Unicode strings is specified by W3C I18N WG;
see [fixme:url]. Language tag equality is defined by RFC3066
and is case insensitive.
* is represented as, or is a? Do we pass by reference or value :)
** equivalently we could delete 'optionally' and allow the language tag to
be null, or default to "und" the ISO-639-2 undetermined language. Note, the
following from RFC 3066, suggests 'Omitting'.
5. You SHOULD NOT use the UND (Undetermined) code unless the protocol
in use forces you to give a value for the language tag, even if
the language is unknown. Omitting the tag is preferred.
***the purpose of 'should not' is to allow applications some flexibility
on dealing with language tags. That is, when a literal is equal to
another but only one has a lag tag, they can be considered equivalent,
which might be sufficient for some applications to make a match.
The truth table corresponding to that notion of equality is:
Truth table for equality (s1,t1) == string1, tag1; f* means should not
be true; assume s1!=s t1!=t according to the specs in question.
(s,_) (s,t) (s1,_) (s1,t1)
(s,_) t f* f f
(s,t) f* t f f
(s1,_) f f t f*
(s1,t1) f f f* t (s,t1) (s1,t)
(s,t1) f* f f f t f
(s1,t) f f f* f f t
I am about to summarise some discussion between Bill and I on the
rdf:parseType="Literal" question.
Feedback welcome
Jeremy
e.g. which ntriples doc corresponds to
rdf:RDF xmlns:rdf="..."
xmlns:ns="http://example.org/"
In our discussions we noted:
- M&amp;S is deliberately vague about quite what unicode string corresponds to
the "well-formed" XML [fragment].
- Particular problems are exhibited by XML fragments with non-local effects
(e.g. namespaces, character or entity references)
- In practive the user community is not crying out for a fix. This vagueness
is a theoretical defect with the specs.
- We expect current conforming implementations to represent
rdf:parseType="Literal" values with different strings (different from one
implementation to the next).
- Mandating any specific string value will probably break all
implementations.
- It is desirable to not prohibit old implementations but allow them as a
"lower" quality implementation.
- One way of having two quality-of-service for literals would be to have a
new parseType e.g.
rdf:parseType="Canonical" that forces the use of XML Canonicalization. This
would then be optional.
- rdf:parseType="Canonical" is feature creep and hence out-of-scope.
So maybe, we need to express some words that capture a minimum level of
conformance that is intended to make almost all implementations legal; and
then in the primer we note to document creators that lots of XML Fragments
are likely to be problematic and non-portable.
Jeremy
I find this odd. Why not let them be equal in this case? Omitting the
language tag presumably means that no language information is being
supplied. But in that case, there is no need to reject a match with
an identical literal which does have a language tag, is there?
Or is the idea that omitting the language tag is a way of indicating
that ANY language tag would be inappropriate?
(A rational way to make sense of this would be to assume that UND
means 'not any known language' and a missing tag simply indicates no
information; but that rational interpretation seems to be ruled out
by the above quote from RFC 3066, unfortunately.)
Seems to me all the f* could be t. Why not have (Smith, English)
match (Smith,_) ? It has to be an English word or the first literal
wouldn't be well-formed. If we reject this, why do we accept
(Smith,_) matching (Smith,_)? After all, "Smith" might mean Sailor in
Catalan.
Pat
IHMC(850)434 8903 home
40 South Alcaniz St.(850)202 4416 office
phayes@ai.uwf.edu
A thought: why not a Unicode string,URI pair? RFC 3066 tags could be
embedded in URI space using (say)
This would provide a mapping for xml:lang attributes, but would also leave
a possible route forward for qualifying a literal with (say) XML schema
datatype URIs.
I'm not sure about this. If the model theory needs this idea, then
yes. The mapping
XL : qLiteral - LV
suggests to me that some concept of equality is required by the MT
(otherwise the idea of a fixed interpretation doesn't make sense to
me). Other than that, it's not clear to me that a notion of equality
defined by RDF will necessarily be useful to all RDF applications.
For this purpose, I think your notion of equality is about right:
When comparing two RDF Literals, their Unicode strings must be
equal for the RDF Literals to compare as equal. If both Literals
have language tags, these tags must be equal for the Literals to
be considered equal. If two Literals are found equal but only
one has a language tag, the Literals should not*** be considered
equal.
The equality of Unicode strings is specified by W3C I18N WG;
see [fixme:url]. Language tag equality is defined by RFC3066
and is case insensitive.
I must confess I'm not very clear what this means.
#g
Graham Klyne MIMEsweeper Group
Strategic Research http://www.mimesweeper.com
That's my preference at this point.
I can confirm that all the XML Schema simple/scalar datatype
values can be represented as (unicode-string, uri) pairs
using URIs from the XML Schema datatypes spec.
The complex type values can, in theory, be represented that
way, but (a) the XML Schema WG hasn't provided the relevant
URIs, and (b) it looks like a hack/kludge to re-serialize
XML values this way.
For primitive/scalar datatypes, yes.
For other stuff...
nor am I.
Dan Connolly, W3C http://www.w3.org/People/Connolly/
As this has relevance to other issues, and so that the Working
Group is not misled, I believe you mean URI-references, not
URIs. Is that correct?
[ "Aaron Swartz" ; mailto:me@aaronsw.com ; http://www.aaronsw.com/ ]
phpht. cursed RFC2396...
I mean absolute-URIs-with-optional-fragment-identifier-s, yes.
cf.
For each built-in datatype in this schema (both primitive and
derived) can be uniquely addressed via a URI constructed
as follows:
1) the base URI is the URI of the XML Schema namespace
2) the fragment identifier is the name of the datatype
For example, to address the int datatype, the URI is:
-- http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/#schema
Dan Connolly, W3C http://www.w3.org/People/Connolly/
Hi Pat,
flexibility
Pat Hayes:
I find this odd. Why not let them be equal in this case? Omitting the
language tag presumably means that no language information is being
supplied. But in that case, there is no need to reject a match with
an identical literal which does have a language tag, is there?
Or is the idea that omitting the language tag is a way of indicating
that ANY language tag would be inappropriate?
(A rational way to make sense of this would be to assume that UND
means 'not any known language' and a missing tag simply indicates no
information; but that rational interpretation seems to be ruled out
by the above quote from RFC 3066, unfortunately.)
The bit you highlight is my doing :)
I should say that Jeremy and I spoke about this today. I mentioned I
wasn't sure whether the lang tag would affect equality so I threw in
equivalence. Null makes a match for me, but I'm not sure about 3066 und.
That is, I wasn't sure, whether this is true:
('Ciao Benny', und) == ('Ciao Benny', fr) : T
Pat Hayes:
Seems to me all the f* could be t. Why not have (Smith, English)
match (Smith,_) ?
I can't think of a good reason. I'm happy to mark it up to equals,
unless anyone has strong objections.
(s,_) (s,t) (s1,_) (s1,t1)
(s,_) t t f f
(s,t) t t f f
(s1,_) f f t t
(s1,t1) f f t t (s,t1) (s1,t)
(s,t1) t f f f t f
(s1,t) f f t f f t
which makes it a truth table instead of a maybe table :)
Bill
As far as my original comments are concerned, I agree I should have said
URI-reference. Or, more precisely, what Dan
said: absolute-URIs-with-optional-fragment-identifier-s.
#g
Graham Klyne MIMEsweeper Group
Strategic Research http://www.mimesweeper.com
