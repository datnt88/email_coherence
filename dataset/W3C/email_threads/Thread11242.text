The ERB yesterday discussed the issue of datatypes (among others). I was
foolish enough to toss out a strawman proposal, so was granted the task of
tuning it up (into a flaxman, perhaps?) for the WG to discuss.
There seem to be two main axes along which we can differentiate approaches:
1) The range of datatypes we choose to support.
2) The place where datatypes get defined, and then where they get associated
with particular data (individual element instance; elements that provide
meta-information; or the DTD).
NOTE: There is a third axis, namely whether datatypes can be applied to
attributes, to content, or both; but I think a solution that only applies to
one would look fairly silly so I show all examples in a way that can work
for both.
Along the first axis, there are several obvious points we can choose:
a) Do nothing: have no types for #PCDATA, and only the existing attribute
declared values.
b) Define a small, fixed number of atomic types.
c) Define a language for defining datatypes: regex (say, per POSIX), or
perhaps HyLex.
d) Define a way to access *any* programming, scripting, or other language at
all.
For example, consider a datatype like DATETIME, and assume for the moment
one of the ISO-standard forms, such as "1997-05-21 22:45:00". The four
points just described enable different degrees of validation
(well-formedness is not at issue; and we are talking here about validation
*within* the purview of the system we are standardizing; individual
applications can do any post-processing and checking they want). For the 4
approaches above, respectively:
a) No validation is provided; "foo" is a perfectly valid value for a
DATETIME, since DATETIME has no standing in SGML (it's either a CDATA
attribute or CDATA/RCDATA/#PCDATA content). If you make a separate element
(not attribute) that contains only a DATETIME value, you could still
associate a NOTATION attribute which could, in some implementation, invoke a
validation processor outside SGML.
b) If and only if we provide this DATETIME type, implementors of validating
XML parsers would build it just as they build support for IDREFS now.
c) Validation of the lexical form can be defined by users who need it, but
as MSM pointed out regexes can't catch February 29 of non-leap years (except
via a *really* hideously long expression).
d) Since in (d) you can access a complete language (like C or Java), of
course you can implement the whole leap-year algorithm and invoke it.
Of course, (c) or (d) could *also* provide predefined forms as in (b), and
(d) could still provide one particular language as in (c). Regexes are so
ubiquitous, and buy an essentially infinite mechanism for only slightly more
(possibly less) effort than (b), so I think they should be included. I
wouldn't mind (d), so long as we require support for regexes as an
interoperable choice.
NOTE: In following examples I include a NOTATION name as would be needed for
(d). With (c) these could of course be deleted, since the constraint
language would be a constant.
Along the second axis, possible approaches are shown below. In any of these
cases we could use entities or hyperlink references to keep the constraint
definitions outside the actual physical document stream, which may be
desirable so WF parsers need not waste time to parse past constructs they
won't need.
a) Associate datatypes with data via attributes. Provide a place to define
the datatypes elsewhere (header, referenced file, etc). This is a lot like
HyTime "lextypes", which do this rather nicely.
This has the advantage that nothing in SGML has to be touched. It has the
disadvantages of considerable indirection, reliance on DTDs, verbosity, and
requiring internal structure for attributes (or in attribute lists if you
split up XML-LEXTYPE into, say, XML-LEXTYPE-.PCDATA and XML-LEXTYPE-TYPE --
like HyTime LINKENDS and the TC). It does make it possible to apply entirely
different constraints to different instances of the same attribute, but this
might be considered a liability as well as a benefit.
Obviously the definitions could be expressed in elements, in new declaration
types added by an amendment, or in PIs. There is also a variation where the
*entire* datatype definition goes on the attributes, but that is more
verbose, less clear, and obviates mnemonic names for datatypes.
b) State the relationships between datatypes and attributes or content right
with the definitions, for example in header elements that apply for the rest
of the document. This reduces clutter:
expr="[0-9]+" notation="regex"
expr="[a-z][0-9]" notation="regex"
c) In the DTD itself, via an amendment. Since SGML already has declarations
for the objects we want to constrain, and those declarations already provide
similar kinds of constraints (such as attribute declared values), this seems
the conceptually appropriate place. It would also require the least
complicated indirection and would be a near-trivial change technically. One
way to do it is simply to adopt HyTime's lexical typing mechanism into SGML
proper (that mechanism also becomes simpler in the process). For example:
!-- like entity dcls, one could allow the value to be an external ID, not
just a literal --
!ATTLIST p
type CDATA(letdig)
This requires only a few, backward-compatible additions:
i) A new DATATYPE declaration patterned after HyTime's lexical type
definition AF (this does not introduce any broad dependency on HyTime, since
the lexical typing is well modularized).
ii) An optional (lextype-name) suffix on attribute declared values (at least
CDATA) and on the keyword #PCDATA. I believe there is no syntax conflict
with () in either place; if I missed one, some other delimiter could of
course be substituted. The declared value name and/or #PCDATA keywords could
of course be replaced rather than suffixed by the lexical type name, for
example by #DATATYPE(name).
I think this approach can get the full capability of HyTime's lextype,
including the ability to hook to any external constraint language for
arbitrarily complex constraints. It does not complicate *parsing* of XML
document instances, since WFedness is unaffected (in just the same way that
HyTime lexical types, which are managed entirely separate from SGML parsing,
do not affect SGML validity or parsed results). *Validation* in this
scenario is harder only by exactly as much as it take to support the new
capability. So far as I can see, its sole relative disadvantage is that it
requires an enhancement to SGML itself.
So, that's a structuring of basic options. I favor providing one specific,
powerful though not total constraint language, namely regular expressions,
and a hook for getting to any others via NOTATION like SGML and HyTime
provide for many other cases. I also favor proposing an amendment to move
this compatibly into SGML proper, since it is a very small, backward
compatible, but highly leveragable change, and is far cleaner than having to
attach it indirectly somewhere else.
Hope I've at least been clear.
Steven J. DeRose, Ph.D., Chief Scientist
Inso Electronic Publishing Solutions
(formerly EBT)
There's a fourth axis: Which software module should be in charge of data
type validation, the XML processor or an application? A number of people
were pointing out the work involved in implementing some such validation
schemes, and it may put us far outside XML-Lang's "development budget." If
we make XML-Type a separate spec, the existence of a type-validation
application would be implied, the way XML-Link implies the existence of a
link-processing application.
Eve
I vote for (c) and (d), using HyLex for (c) and NOTATIONs
to declare (but not necessarily define) support for (d).
HyLex is not as familiar to most people as Perl or POSIX regexps,
but it's equally powerful. It's also more verbose, but is
less cryptic to the uninitiated.
Or (d), in the DTD itself via (GASP!) processing instructions.
Something like:
?LEXMODEL url( (scheme, "://", host, (":", port)?, "/")?,
path,
("#", fragment)?,
("?", query)? )
!-- ?LEXTYPE ...  PI associates a lexical model
with an attribute or content: --
!-- Possibility: defining a NOTATION with the same name
as a lexical model declares semantics for that type: --
!NOTATION url PUBLIC
"-//IETF//NOTATION RFC 1738 Uniform Resource Locators"
All this stuff can go in the DTD, or possibly at the front of
the document (except for !NOTATION... decls).
--Joe English
jenglish@crl.com
I am against adding data typing as another XML-lang validation issue.
I'd prefer "validating XML-lang" and "validating data types" to be separate
(orthogonal) issues/features/modules/whatever so that an "XML-datatyping"
spec (misleadingly named, since it would be data typing for all SGML) could
be used (or not) independently for XML or SGML applications.
I'd entertain some sort of "datatyping=yes" attribute on our introductory
?XML ... version="1.0" ... ? PI, but the default handling of XML should
not require datatyping. It just isn't necessary to require that of all
XML processors.
paul
I support this. I know it's dangerous to start specifying how software
should behave, but there are now so many different axes to XML that it's
critical that we modularise them into components. It may not be a universal
view, but I find software helps to define the spec. As far as I can see
a type-validation processor would only validate - not transform - and would
be required to pass error indications to the next component (perhaps a link
processor). Apart from different platforms I don't see the need for a
large number of these validators, and it would be valuable to have an
XML library where one could be picked off the shelf.
P.
Peter Murray-Rust, domestic net connection
Virtual School of Molecular Sciences
I support Steven's separation of the "data type" problem into several
issues. In fact, I think it is appropriate to divide it further, and
this may help to separate the work into the parts that need to be done
now versus those that can be deferred.
1.How is the type of an element identified. That is, the specific
syntax that says "this element is of type x". This needs to address the
fact that several types are further qualified (such as the number of
digits for the proposed DECIMAL type).
2.From what namespace do types come? Is it a closed set, or an
extensible one? If extensible, how and by whom?
3.If a set is defined by us, is it part of the language
specification, or a standard library?
4.Are data types the same as element types? Notations? Some new
beast?
Answering the questions above solves the problem of unambiguously
attaching a data type to an element.
We could go further and ask How do we validate that the element contains
the claimed type? In what language are the validations expressed? How
do we distribute the parsers and validators? How does validation
interact with the issue of element sub-classing? (Strongly, in my
opinion.)
The immediate needs I am hearing from customers is only to solve the
first set. That is, they simply need a way for an author of an element
to communicate a subtype of PCDATA and a notation. They will have
parsers for the notations they care about. They are not presently
interested in any general-purpose validation, enforcement, or parsing
language.
I hope this is helpful.
--Andrew Layman
AndrewL@microsoft.com
Not an option - users are screaming for datatyping
Too limiting
A possibility
The SGML solution - but could be dangerous in a Web environment unless
supported by a starter-set of useful notations
This I like
This ignores the real problem - how to data type attribute values.
The element would have to be one with an XML reserved name, such as
XML-datatype. In your examples they are presumably empty tags as the
expressions are entered as attribute values, but for notations such as
JavaScript and other programming type languages you would probably want it
as content.
Why use an amendment - why not use the existing lextype attribute from the
SGML Extended Facilities annex?
You don't need a new markup declaration for datatypes - we can use LEXTYPE.
The SGML Extended Facilities annex already shows how lexical types can be
declared in a reusable document instance that can be referred to by many DTDs
using a ?IS10744 LEXUSE processing instruction. (XML should not invent its
own set of cogs - it should find more efficient ways of using existing SGML
ones!)
You don't need a new construct for identifying the lextype of attributes in
declared values (this would require a change to SGML before becoming valid).
Simply adopt the lextype attribute of HyTime. This allows you to associate
different lexical types with different attributes and with content, e.g.
!ATTLIST element-x
a CDATA #REQUIRED
b CDATA #IMPLIED
c CDATA "default"
lextype CDATA #FIXED
"#CONTENT lextype-x
a lextype-a
b lextype-b
c` lextype-c"
You also need a way for users to override the default lextype in certain
circumstances. Hence my earlier suggestion to allow PI's with notation (or
lexical type) names to element-x a=" ?XML-LEX my-lex? value" .
Martin Bryan, The SGML Centre, Churchdown, Glos. GL3 2PU, UK
This is my favourite. It is in the spirit of XML (the 95% solution with
5% of the effort). C and d add a lot of complexity and I can see very
little gain.
As programming languages and SQL show, you don't need more than half a
dozen types. Something close to this set is enough: boolean, integer,
real, character, string, and date/time. XML already has ways to make
arrays, records and pointers.
Bert
Steve's analysis is sensible and I agree with most of it.
It is totally undeniable that a general typing mechanism, whether
based on regex or hylex or whatever, gives a degree of flexibility
and fine control that is unbeatable.
[snip]
One point - count me as one vote *against* wiring this into either
XML-lang or WG8, and *for* doing it in a separate doc, using
vanilla attribute/notation mechanisms, for now. That way everybody
gets to use it now, and people who don't care don't have to
build the machinery into the parser... let's try and defend
that grad-student-week, it's one of our proudest achievements. -Tim
Usually, I'm on the "leave the application developers to their own
devices"
side, but I agree with Tim. At least from the database perspective
I'm getting right now, a separate document that provides a set
of data types based on the SQL set appears to be a very sensible
and immediately useful product. ONE For.
len
One point - count me as one vote *against* wiring this into either
XML-lang or WG8, and *for* doing it in a separate doc, using
vanilla attribute/notation mechanisms, for now. That way everybody
gets to use it now, and people who don't care don't have to
build the machinery into the parser... let's try and defend
that grad-student-week, it's one of our proudest achievements. -Tim
I agree completely with this. Don't forget that XML-lang *as at present*
is an extremely powerful tool that 99% of potential users have never seen
and it will take time to get used to. Except for a few very minor tweaks as
are occasionally reported it works. People are developing DTDs using it.
XML-TYPE is functionally completely independent of XML-lang and can be
managed by a post-parser module. I may have missed it in the draft, but
I'd suggest adding the following phrase in 3.3 or appropriate place:
"the use of attribute names beginning "XML-" in any way other that those
described in this specification and [reference to other XML specs] is
[some form of error]"
And to advise as an annexe that the following attribute names are currently
reserved:
XML-TYPE
XML-LINK
XML-SPACE
XML-STYLE
It might be appropriate to add something like "some of these attributes
may be processed and/or validated in dedicated modules"
For the SD5 debate, I was only asking for a convenient character that
current parser technology could pass through unaltered. If necessary
I can always use the colonic approach with a string like 'CML___...MOL'
(work that one out :-)
For the XML-LINK discussions, I think it's important to decide whether the
spec is implementable by a CS grad student *without previous HyTime
experience* and purely from the spec. I think it should be. I also think
those implementations should have a communality of function [I understand,
but I'm worried by, simply defining the terms and leaving the rest up to
the implementation. Implementers need more guidance than that.]
P.
Peter Murray-Rust, domestic net connection
Virtual School of Molecular Sciences
Steve's analysis is sensible and I agree with most of it.
It is totally undeniable that a general typing mechanism, whether
based on regex or hylex or whatever, gives a degree of flexibility
and fine control that is unbeatable.
My SQL proposal offers only two bits of added functionality:
- the MIN and MAX values that can be used to constrain data ranges, and
- the fact that the DATE and TIME values carry validation
semantics that cannot reasonably be expressed in regexps, yet
are not that hard to implement and are generally implemented by
library functions all over the place.
My analysis based only on personal experience is that what people
really de facto want out there in the MIS world is those few basic
SQL types; thus if we got a general-purpose regexp-based facility, I
would go ahead and package up a set of pre-cooked forumlations that
would give people those SQL types. I expect that's what people would
use mostly... which makes me wonder where the regexp solution sits
on the cost-benefit curve.
There is one other problem, I have no idea how serious it is, but
it needs to be addressed: the implementation of general pattern-based
typing in the wide-character environment. Naive implementations of
automata for regexps become nonviable when the table has to have
64k columns. Doable, of course, but...
From my point of view, I *know* that there are some people who
need those SQL types, and I know validators for them are no sweat -
from here they look like another one of the 80/20 points we seem
to have had some success in hitting.
On the other hand, it seems pretty obvious that if there was
a general pattern-based typing facility, it would find lots of
uses - I know I'd use it. Don't know if I'd be able to
build it, though.
One point - count me as one vote *against* wiring this into either
XML-lang or WG8, and *for* doing it in a separate doc, using
vanilla attribute/notation mechanisms, for now. That way everybody
gets to use it now, and people who don't care don't have to
build the machinery into the parser... let's try and defend
that grad-student-week, it's one of our proudest achievements. -Tim
Yes. Under the current terms and relationships, that is the best goal.
This is true, but harder. Implementation guidance in VRML
specifications
is being decided after the fact of language specification
in the process of conformance testing design.
However, VRML is a single application language. Is XML? What
levels of conformance are tested for XML and how is that related
to implementation certification? I think deciding that will make
it easier to decide where the lines are.
len
[C Blullard]
Right. I have asked more than once on this list what "conformance"
will mean for XML "processors". I have yet to hear anything back
which furthers my torment that I am missing something:-(
Sean
Sean Mc Grath
sean@digitome.com
Digitome Electronic Publishing
