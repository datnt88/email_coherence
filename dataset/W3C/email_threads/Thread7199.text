4.9. Versioning
In the following discussion, "versioned resource" means a resource that
has the structure of a directed acyclic graph, each node of which is
a version. "Version" means a node in this structure, which is itself
a resource. Each version typically stands in a "derived from"
relationship to its predecessor(s).
We also need to express the concept that a versioned resource is
immutable, except for deletion. I know this is covered in detail in
section 4.9.1.1. but I still think it is worth including in the
introduction. If only to flag the repository people that we aren't
talking about their type of versioning. I would suggest something like:
Once a resource is versioned it becomes immutable and may only be
retrieved or deleted.
4.9.1.1. Stableness of versions. Most versioning systems are intended
to
provide an accurate record of the history of evolution of a document.
This accuracy is ensured by the fact that a version eventually becomes
"frozen" and immutable. Once a version is frozen, further changes will
create new versions rather than modifying the original. In order for
caching and persistent references to be properly maintained, a client
must be able to determine that a version has been frozen. We require
that unlocked resource versions be frozen. This enables the common
practice of keeping unfrozen "working versions". Any successful attempt
to retrieve a frozen version of a resource will always retrieve exactly
the same content, or return an error if that version (or the resource
itself) are no longer available. Since URLs may be reassigned at a
server's discretion this requirement applies only for that period of
time during which a URL identifies the same resource. HTTP 1.1's Entity
tags will need to be integrated into the versioning strategy in order
for caching to work properly.
***Judy - Does the specification support this?
I'm not sure. The sentence "We require that unlocked resource versions
be frozen." sets off a lot of bells. I thought we were going to support
lock free versioning?
4.9.1.2. Policy-free Versioning. Haake and Hicks [5] have identified
the notion of versioning styles (referred to here as versioning
policies, to reflect the nature of client/server interaction) as one
way to think about the different policies that versioning systems
implement. Versioning policies include decisions on the shape of
version histories (linear or branched), the granularity of change
tracking, locking requirements made by a server, etc. The protocol
should not unnecessarily restrict version management policies to any
one paradigm. For instance, locking and version number assignment
should be inter-operable across servers and clients, even if there are
some differences in their preferred models.
I believe this requirement and section 4.9.1.3 are no longer possible.
The logical result of this requirement is non-interoperability. The
current spec is proof of this. If we want interoperability we are going
to have to choose a basic versioning systems w/extremely few axis of
variability in order to allow for interoperability. I move that 4.9.1.3
be deleted and 4.9.1.2 be rewritten to read:
4.9.1.2. Interoperability. In order to meet the previously stated goal
of interoperability between any WebDAV compliant client and server it is
necessary for the working group to identify a versioning style which
will be codified in the final specification. This versioning style may
have several axis of variability to allow for some variation, for
example lock based and lock free versioning, but these axis's must be
kept to an absolute minimum in order to allow for interoperability.
4.9.2.6. A way to determine whether a given URL points to a version
of a versioned resource.
***Judy - Are we requiring that you be able to tell this just by
examining the URL?
Absolutely not. This really codifies the ability to use linksearch on a
resource to determine if the resource is versioned or not.
4.9.2.7. A way to distinguish, given a URL of a version, the part of
the URL that identifies the version from the part that identifies the
versioned resource.
***Judy - Do we really have to (want to) require that you be able to
find out the URL of the versioned resource by examining the URL of the
version? Is the requirement really just that there be some way to find
out, for any version, the URL of its versioned resource?
I move that either this requirement be removed or this group be moved
out of the HTTP working group to the URL working group.
It also supports some comparison operations: It makes it possible to
determine whether two URLs designate versions of the same versioned
resource. However, given the phenomenon of URL aliasing, it
is insufficient to determine that they are not versions of the same
resource.
This is what entity-tags and history lists are for.
***Judy - If 4.9.2.8 - 14 are intended to require separate operations
for each of these functions, they conflict with the approach taken in
the WEBDAV specification.
This goes under the heading of axis's of variability. If we want
interoperability we must cut down on variability.
4.9.2.10. A way for a client to declare an intention to modify a
resource (Reserve). (See Section 4.4 "Notification of Intent to Edit"
above.)
This operation is required before any versioned update. Its effects may
vary depending on server policy, from locking a resource, to forking a
new variant, to a NOOP on servers that do not track sessions or
restrict
updates. If this operation returns a version number, the client is
required to make sure that it uses a copy of the data associated with
that version number of the resource for any update operations it
carries out. Servers that wish to enforce a mandatory GET operation
before update, should simply use a fresh version identifier on the
return from this operation.
Any time an action may have any of a number of unrelated results we must
provide discoverability. As we do not wish to provide discoverability
because of the complexity it introduces we must not provide for a
notification of edit that is complex as the above.
***Judy - Uncheckout is neither in the requirements nor in the
specification. Do we need it?
I would strongly argue that we do. The scenario of a user checking out a
document and then changing their mind and wanting to Uncheckout the
document is so common that just about every single versioning system in
existence supports it.
Well, taking the risk of another flame, let me explain this sentence. If
you think we were stepping over the work of the spec builder, say so...
only, gentler, please. :-)
In order for a multi-author system to work, it must handle consistency for
multiple check-ins. This can either be through a strong lock, or by
providing a different mechanism (e.g. branching version trees, and so on).
So asking for an unlocked version to be frozen simply means that only
locked versions can be substituted with a fresher copy, while unlocked
versions either require a lock before being modified, or, for lock-free
systems, always create a new version, and thus can never be modified
directly.
There are thousands of other (possibly better) ways to put it. In my
proposal for section 4.9 I deleted it altogether.
I believe this functionality was given with a "release". I believe
"uncheckout" is the opposite of the "intention to edit". It should not e
assumed to imply also an "unlock", though, since I believe it is possible
that I change my idea about modifying a resource, but still I don't want
the resource to be freely modifiable.
Fabio
Regarding 4.9.1.1 I believe that a requirements document should discuss
the concept of frozen and unfrozen versions and the need for the
protocol to distinguish between the two. It should not, however, specify
how that distinction is made.
As for uncheckout, I suspect I will eventually convince myself that you
are right so I will drop the subject. =)
Yaron
From:Fabio Vitali [SMTP:fabio@CS.UniBO.IT]
Sent:Friday, February 14, 1997 2:55 AM
Subject:Re: Comments on section 4.9 of the requirements specification
Sorry for the late reply on this thread. I would like to make sure that the
concepts promoted by Document Management Systems (DMS) be supported
as well. Basically, a "version" in a DMS is just a previous version (or revision)
of the document and CAN be altered any time in the future. That is why
we make the distinction between the CHECKOUT/IN and (UN)LOCK methods
in the specification.
-src
Yaron Goland yarong@microsoft.com 02/17/97 01:43AM
Regarding 4.9.1.1 I believe that a requirements document should discuss
the concept of frozen and unfrozen versions and the need for the
protocol to distinguish between the two. It should not, however, specify
how that distinction is made.
As for uncheckout, I suspect I will eventually convince myself that you
are right so I will drop the subject. =)
Yaron
From: Fabio Vitali [SMTP:fabio@CS.UniBO.IT]
Sent: Friday, February 14, 1997 2:55 AM
Subject: Re: Comments on section 4.9 of the requirements specification
