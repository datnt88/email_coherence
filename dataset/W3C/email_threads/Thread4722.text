I have developed an independent C++ implementation of the XML 1.0 and
Xpath 1.0 standards and during this time I noticed some deficiencies
with the current Xpath specifications.
Primarily there is a lack of ability to combine one or more axes in a
location step. Though this is not a language limiting feature, it does
make statementes where bi-directional functionality is required very
cumbersome.
This deficiency deviates somewhat from the obvious goal of the location
path, which is too progressively filter a selection of nodes. With each
"/" in the location step representing a new filter, it makes sense to
focus not on "axes" but on a "selection" of nodes.
For example, in the current Xpath expresssions the following is
cumbersome:
"parent::a/following-sibling::*//text() |
parent::a/preceding-sibling::*//text()"
An obvious solution to the problem which I would like to propose is to
allow Xpath filter expressions to occur as location steps. This is easy
to implement and does not deviate from the purpose of the filter
expression which is to take a function or an expression which returns a
node-set and filter it by optional predicates, just like a location
step.
It should be noted that the grammar (in Xpath 1.0) atleast for the
filter expression is very poor, and fails to force the intended
behaviour of the filter expression.
So the above example would become:
"parent::a/(following-sibling::* | preceding-sibling::*)//text()"
Which in my opinion is logically much more concise...
Regards,
Emerson
It could be that I am missing something, but I believe your proposal
is possible in XPath 2.0.
Check out the third item *before* 3.3 Sequence Expression (in reverse
document order ;-) ) for an example.
The parse tree for that is a little bit lengthy, but basically you can
reduce a StepExpr - PrimaryExpr - ParenthesizedExpr - ...
- '(' OrExpr ')' - ... (many steps using always the first non terminal) ...
- '(' UnionExpr ')'
- ... - '(' PathExpr '|' PathExpr ')'
There you are!
Cheers,
Oliver
(not a WG member)
ob|do Dipl.Inf. Oliver Becker |
--+-- E-Mail: obecker@informatik.hu-berlin.de |
op|qo WWW: http://www.informatik.hu-berlin.de/~obecker |
Correct, this expression is valid in XPath 2.0.
Michael Kay
Michael, could you point me to the grammar where this is allowable in
Xpath 2.0
I can see no such derivation:
I think the part that you are missing is that we are dealing with
location step's not sequences.
As you can plainly see from (http://www.w3.org/TR/xpath20/#doc-StepExpr)
the Xpath 2.0 specification does
Not allow anything other than axis/node-test specifiers within a
location step.
The good news is ive added the filter expression support to my Xpath 1.0
implementation and it works a treat. Ive also taken the liberty to
convert literals and functions which return strings into node-tests and
numbers into abreviated child::*[n] type step expressions (as is done in
Xpointer)
emerson
easy
a
It could be that I am missing something, but I believe your proposal
is possible in XPath 2.0.
Check out the third item *before* 3.3 Sequence Expression (in reverse
document order ;-) ) for an example.
The parse tree for that is a little bit lengthy, but basically you can
reduce a StepExpr - PrimaryExpr - ParenthesizedExpr - ...
- '(' OrExpr ')' - ... (many steps using always the first non
terminal) ...
- '(' UnionExpr ')'
- ... - '(' PathExpr '|' PathExpr ')'
There you are!
Cheers,
Oliver
(not a WG member)
| ob|do Dipl.Inf. Oliver Becker |
| --+-- E-Mail: obecker@informatik.hu-berlin.de |
| op|qo WWW: http://www.informatik.hu-berlin.de/~obecker |
A StepExpr could be a FilterStep which in turn could be a PrimaryExpr
with empty Predicates etc ...
Oliver
This doesn't sound like XPath to me, perhaps I have misunderstood.
Michael Kay
A StepExpr can be a FilterStep, a FilterStep can be a PrimaryExpr, and a
PrimaryExpr can be a ParenthesizedExpr, which can have anything inside it.
In effect, you can now use any expression (subject to operator precedence
rules) as an operand of "/", though the type rules require the expression to
deliver node()*.
Michael Kay
