Many of the new methods being defined for WebDAV versioning have
an XML document as the value of their request and/or response body.
While designing the protocol, I am continually faced with the question:
Should an input parameter to the method be represented as a new XML
element in the request body or as a new request header? Similarly,
should an output parameter to the method be represented as a new XML
element in the response body or as a new respose header?
In each case, there is backward compatibility, since downlevel clients
would just not generate the header/element, and downlevel servers
would just ignore the unknown header/element.
An argument for the XML element is that the contents of the XML element
can hold a much wider range of data, and can have its structure defined,
at least in a coarse syntactic fashion, with a DTD.
Another argument for the XML element is that you don't have to worry
about proxies stripping off headers they don't recognize.
The only argument I can think of for using a header is that it is
the only technique applicable when the body is being used for some
other purpose (such as GET/PUT).
One possible rule of thumb:
If the request/response body is an XML document, then the request/response
parameters should be specified as XML elements. Only if the body is not an
XML document should parameters be specified as headers.
Comments?
Cheers,
Geoff
Geoffrey M. Clemm
Chief Engineer, Configuration Management Business Unit
Rational Software Corporation
(781) 676-2684 geoffrey.clemm@rational.com http://www.rational.com
The body of an HTTP request/response is payload. If it contains anything
significant to the semantics of the operation or result, aside from a
representation of data as defined by those semantics, then it isn't HTTP.
It is something else tunneling inside HTTP, which is a waste of bytes.
In general, if you find yourself with many new methods and request
header fields, then it means there is something fundamentally wrong
with the protocol design. Usually the fix is to do the same thing
with far fewer extensions simply by using a redirect to a different
resource rather than using new methods/fields to act indirectly.
This is from experience -- I haven't looked at the WebDAV versioning
stuff at all.
....Roy
I discussed some of these marshalling issues in a workshop paper I wrote for
the HTTP Future workshop held at WWW7 last year -- it complements Yaron's
header/body rationale post. The paper is titled, "Lessons from WebDAV for
the Next Generation Web Infrastructure", and covers the topics of parameter
marshalling, multi-resource operations, operations on resource hierarchies,
status reporting, and built-in lock support. The paper was written to try
and separate out the "take-home" lessons from WebDAV which would be of
interest to future protocol authors, specifically for HTTP-NG.
The position paper is available at:
- Jim
Roy already responded to this from an HTTP protocol point of view, based on
hs rules of thumb for extension design. I'd like to make a few points based
on XML document and DTD design. Roy and I both think that Geoff's proposed
bundling is a bad idea, but we have different reasons for thinking it.
I haven't had a chance to read Jim's paper, so apologies if I'm duplicating
any of his points.
AS Roy says, the body is "payload". For some of our operations we treat
some parameters as "payload". He might not like that part of the protocol
design but it's at least logical I think. However, there are some other
reasons to use headers (that I'll get to).
This rule of thumb might bo OK, but should _never apply_ to methods like
GET/PUT, since the document being modified should not have parameters added
into it, even if it were an XML document.
For other messages that _already_ need to take XML encoded request bodies,
your hand is also not as free as it might be. You must use a header for any
information that could make sense for a GET/PUT (now, and probably also if
it could ever make sense in any future extension of these methods). In
general since Headers are part HTTP (the base protocol) protocol
information should use headers unless it's very obviously _method
specific_. If it might not always be method specific, putting it in an XML
request body is dangerous, as some future method might need it in a header
because the method's body is pure "payload" in an arbitrary media-type.
Of course a new header (potentially) interacts with _all_ other methods,
and that increases spec complexity, and (even if the effects are very local
and simple) increases the time for an implementor to comprehend the spec.
and implement it.
So Roy is also right that minimizing the use of headers is a good idea.
Of course,the versioning spec. must inherently deal with a lot of complex
data objects like revision histories, and configuration specifications, and
so forth. These need to be expressed in XML, but where they must be
referred to in methods they should probably have URIs or some other names
that can fit sensibly in headers.
The Property mechanism is one way to deal with some of these, but as Yaron
has pointed out, properties should not be abused as a way to create new
HTTP methods...
Still, I think there actually needs to be a presumptive preference for
headers, unless data format, character-encoding, or protocol complexity
prevent it. As Roy says, a profusion of new headers (and thus header/method
interactions) is probably telling you something important that should not
be ignored.
-- David
David Durand dgd@cs.bu.edu \ david@dynamicDiagrams.com
Boston University Computer Science \ Sr. Analyst
--------------------------------------------\ http://www.dynamicDiagrams.com/
MAPA: mapping for the WWW \__________________________
