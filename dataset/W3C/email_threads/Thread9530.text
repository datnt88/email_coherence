I have been working on updating the document - the intention is to
hopefully have something for the Friday telecon which the WG can then
review for a week and then maybe publish.
I have writen some words to address syntax issues after we triaged
them into the syntax doc at our telecon, plus a couple of ones we
missed, and words proposed from some emails, which I responded to.
Please review
CVS Revision: 1.63 or later
and let me know.
These are strawman answers, where there are any, and my intention is
that if you have better / other words, put them in your email reply.
I have also added the RelaxNG schema into an appendix and I want to
also add Jeremy's XSLT mapping to the document. Please comment on
structure too; should the section 3 issues move to an appendix also,
or a later section? Should appendix A, B go entirely?
Next, I am going to work on section 4, try to write down the mappings
to N-Triples, tweak the grammar notation to be take the Infoset and
add RDF information items. For example. I will probably add [subject
URI] for the URI of the node generated by the rdf:ID or rdf:about
values etc. And so on.
See the CVS log for detailed list of changes at
Dave
wow... nifty...
editorial/structural suggestions:
* the "3. RDF Core WG Issues affecting RDF/XML Syntax" section
doesn't seem like part of the specification. I suggest moving
it to an appendix.
* on the other hand, the references (at least the normative ones)
are not appendixes: lopping them off changes what's specified.
I like the "Infoset Notation"; especially the way it's
quite sax-like. Please make the connection to SAX explicit,
at least by saying something like "this notation loosely
follows the structure of the [SAX] API".
Dan Connolly, W3C http://www.w3.org/People/Connolly/
Dan Connolly said:
mmar-changes
OK, I've moved it to Appendix A
Moved be last section before Appendices.
Noted.
That is the idea, since it matches what most parsers are written in,
is very familiar to programmers and shows the multi-token context
that is needed for RDF/XML.
Above changes in CVS 1.64 or later.
Dave
Of the issue resolutions currently in the draft 1.67 I am only uneasy
with:
rdfms-not-id-and-resource-attr
Action: The grammar has[will be] been modified to forbid the
use of an rdf:ID attribute
when a rdf:resource attribute is also given. This removes an
ambiguity of which
statement is reified but is relatively harmless since the
statement can be precisely reified
using the non-empty version of the property element with an
rdf:Description block
I prefer to go other way, to allow an rdf:ID on any propertyElt
production and to uniformly understand it as reifying the triple created
by that propertyElt. (Personally I don't see the ambiguity referred to
in your text).
Is the intent of your text to delete para 232, i.e. we forbid reading
the rdf:ID on some propertyElt's as something other than a reification?
Should your text (the intent) read:
when a rdf:resource attribute is also *possible*. ...
Jeremy
I have had a look over revision 1.67 and wanted to make a few points
about the syntactic rules.
Left-to-right priority A | B | ...
In the one case where I think you're relying on this, it doesn't work.
I suggest dropping it; such procedural readings are usually asking for
trouble.
I'll give an example of how it doesn't work and then give two different
solutions (that do? ;) ).
e.g. (without namespaces)
The propertyElt ' rdf:value rdf:parseType="Resource" String /rdf:value '
does match parseTypeOtherPropertyElt and does not match
parseTypeResourcePropertyElt.
It makes no difference that parseTypeResourcePropertyElt comes first, it
doesn't match.
Solution 1 (my preference)
Drop parseTypeOther altogether.
It won't make any difference in practice to what implementations do.
It is not the job of a spec to specify how implementations should
handle bad input unless it specifically gives future compatibility. I do
not believe that specifying rdf:parseType="foo bar" gives that.
Solution 2 (probably also helpful anyway)
Text like:
"The productions propertyAttr and parseOther which match attributes
with arbitrary values (CDATA) do not match any attribute which is more
specifically matched by any other production in the grammar."
I note that without this text the perverted could have a reading of
emptyNode matching
rdf:Description rdf:ID="foo" rdf:about="#bar" rdf:aboutEach="#fooBar"
/
where we have one specific attribute (I don't know which one) and two
propertyAttr's.
That is deliberately misreading the spec. and I don't think it's
important.
Merging of empty property elt productions
It is unclear which way we're going with triple production.
If we leave it completely out of a schema which specifies legal RDF/XML
then the three productions emptyPropertyElt,
emptyParseTypeLiteralPropertyElt and emptyParseTypeResourcePropertyElt
can be merged into:
start_element([namespace_name]=any,
[local_name]=any,
[attribtues]=set(idAttr?,parseLiteral?,parseResource?)
end_element()
parseType=Resource of course does produce rather different triples ...
Jeremy
Jeremy Carroll said:
Which I wrote just so people could argue / support. Plus I own this
issue and want to close it. :)
There has patently been plenty of implementer and WG confusion given
previous long threads discussing this artifact, lack of coherent
implementation and use, so I was proposing a clarification by
removing it, since it can be done another way.
In addition, it is consistent with the recent rdf:ID="attr"
abbreviates rdf:about="#attr" near-decision; since this rdf:ID
doesn't do that, it is an alternative for rdf:resource
The existing grammar says very complex things near
"r2 is the resource named by the resource attribute if present or
a new resource. If the ID attribute is given it is the identifier
of this new resource."
so the following example is illegal in RDF/XML M&amp;S 1.0
rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns:ex="http://example.org/schema#"
since rdf:ID and rdf:resource are alternatives.
I am not doing any deletion on old text, but constructing a new one.
However, I was proposing not allowing rdf:ID in the new grammar in
this place, to ease the confusion and consistent with the
rdf:ID/rdf:about choice.
The rdf:ID above is on a property that introduces 2 statements (in my
example; can be more with extra property attributes) so can't reify
both. It could reify one, but this abbreviated form still seems
rather odd.
I'd rather you proposed this as change rather than ask me to justify
why you want it!
Replacing your proposed change
Action: The grammar has[will be] been modified to forbid the use
of an rdf:ID attribute when a rdf:resource attribute is also
possible. This removes an ambiguity of which statement is reified
but is relatively harmless since the statement can be precisely
reified using the non-empty version of the property element with
an rdf:Description block
Hmm, I don't like that at all actually. Maybe:
Action: The grammar has[will be] been modified to forbid the use
of an rdf:ID attribute on an empty property element. This is
consistent with using rdf:ID="attr" as an abbreviation for
rdf:about="#attr" and removes the suggestion that it reifys a
statement, which it never did in the original grammar form.
Dave
Jeremy Carroll said:
I said I hadn't started hacking that section so, I'm answering quickly
In short: I'm deleting this. It was a last minute pre-WD change that
I did and regretted, confirmed with subsequent emails on www-rdf-comments.
Yeah; the words here should be more of a hint - qnames thing that
came up recently, might appear.
Yeah, maybe I'll merge that in.
There are plenty of silly things that could be done, I'm not sure
whether to ban rdf:Description as a property etc. or just not provide
a meaning for them. Going for latter at present.
I was going to remove the empty* terms into the, for example,
parseTypeLiteralPropertyElt and then have words saying if [children]
is empty then A else B.
Yeah, really a very different thing
Thanks
Dave
Very nice Dave! I just have a few comments from version 1.69.
WRT the issues in Appendix A, some issues that have not had
a WG decision have an Action that implies (to me) a WG decision
has been made (e.g. rdfms-replace-value). I realize you consider
this your "strawman" but all WG memebers should realize that the
doc implies more decisions have been made than really have.
Instead of Action, perhaps it would be useful to use Status
and then to assign a status value such as: Decided - Change,
Decided - No Change, Undecided (instead of '?'). In the case
where a decision was made, supporting text would be added.
As I've stated before I like the apparent simplicity and clarity
of the RelaxNG non-XML schema. I do wonder, however, how we verify
this schema or any other schemas that may be added to Appendix D
(the document says XML Schema and Schematron are TODOs). It seems
like the schemas in Appendix D should explicitly state whether or
not they are normative. Also, do we really need to provide more
than one schema; what about just pointing to the work of James and
Rick instead of including their work in the document?
Since a lot of the text in section 6 of the M&amp;S specifies
triple creations, it seems like extreme care will be needed to
assure all of the relevant text in that section is transfered to
the new doc. Also, what do you expect to document wrt triple
generation versus what do you expect to get from the Snail work?
I prefer a pointer.
I think it's great work, but when I looked at it, I found
at least one bug in the relax-ng thingy; I haven't even
found time to report it.
I'm happy to have it copied into our WD only if, say,
three members of this WG are willing to vouch for it;
i.e. to say "yes, I've looked at it and it agrees
with the rest of the spec".
I could live with copying it into the WD only with
a strong disclaimer ala "this may have bugs. We're
pretty sure it does have bugs. But it's nifty, so
we're including it here so folks can help us work
out the bugs." Of course, that's pretty close
to a commitment to address any comments made
on this relax-NG schema. Dave, are you prepared
to address such comments?
Dan Connolly, W3C http://www.w3.org/People/Connolly/
Dan Connolly said:
Two votes for a pointer - I'm changing it and adding links to
the schematron one too, adding non normative words.
I can't vouch for it at this time.
No. I also have to ask James' permission to include it.
Change made to
as of CVS version 1.72 or later
Dave
Art Barstow said:
It would need more than that. There are issues with WG decisions to
change, not change, issues not considered. WG decisions have words.
The action is the action that was beholden on this document in order
to address the issue. I think all the WG decisions are recorded as
such. The WG may decide that the actions I give are suitable to
address the issue in which case a "On date, the WG decided
URI-of-action addressed the issue" text could be added.
[RelaxNG inclusion gone, see other reply]
I'm going to try careful prose and n-triples, see how it goes. I
suggested to Jeremy to maybe include the snail rules work (non-XSLT
part) in a separate section and ask for implementor feedback. My
worry is slight disconnect between stream of sax events and the
actual ntriples out, using Jeremys approach. On the other hand,
gives very precise, complete, coherent answers which my prose may
not, which was the main problem we were addressing with a new syntax
formalism.
Dave
Dave,
As you requested yesterday I have had a look at some of the issues
remaining unresolved in revision 1.88.
I've had a go at three of them, and attach my proposals.
The issues I address are:
#rdfms-abouteach
#rdfms-reification-required
#rdfms-nested-bagIDs
I continue to duck xml:base. Personally I would allow it everywhere!
But I believe that is out of kilter with WG consensus. I certainly feel
that we cannot prohibit it outside RDF content: for example, on an xhtml
document with embedded metadata. In such a case, we should honour it.
Also xml:base is legal within an embedded XML Literal. Given this, it
seems natural to allow it on the rdf:RDF element. Requiring conformant
implementations to handle all of that we might as well go the whole hog
and be completely permissive.
This would make up for deficiencies in the syntax of not having
uri-reference versions of reification and rdf:bagID by
wait for it ...
rdf:Description rdf:bagID="BagID"
xml:base="http://example.org/bagID/URI#"
OK, OK, I know that I'll lose this one.
Jeremy
Hi Dave
With the danger of rushing in before you've reached anything like a
stable point ...
I have had a look at version 1.88 and I am decidedly nervous about the
direction you're going with the triple production stuff.
I fear you're heading for a rerun of M&amp;S section 6 with:
+ too many words
+ that are self-contradictory
and
+ too unclear
I am also less than taken with the view that the text describing the
production should be associated with a particular processing model.
For instance in the subsection "Production node" you say
The following processing is performed before handling any
propertyEltList children and in this order.
That is presumably intended in an abstract processing model.
It is in my view, perfectly legal to process the property attribtues
after the property elements, and the resulting n-triple file is an
acceptable rendition of the RDF/XML.
I would go further and say that the property attributes and property
elements can be processed in any order with the single exception that
rdf:li is converted into rdf:_NNN in document order.
I also dislike the "in this order" part since many of the steps you then
list are, in fact, interchangeable.
I fear we have a stylistic clash brewing.
I feel that it is better if a specification does not over-specify by
indicating superfluous things; whereas you appear to want a
specification that would have helped you write the particular
implementation of RDF/XML that you have in mind.
I do not feel that it is the job of a specification to assist a parser
writer. The job of a specification is to specify what needs specifying
(and no more or less). If at any point there is a conflict between the
task of assisting the reader in their task (e.g. writing a parser), and
the principle aim of specifying I am clear that the reader should be
left to seek assistance elsewhere. The reader should expect clarity from
a spec, if they want a howto then they may need a different document.
Jeremy
Jeremy Carroll said:
Yes, very much so.
I asked you to produce an order.
While waiting I typed ol and li for things I thought of.
My feeling is we ought to list ordering dependencies for our target
audience who are parser writers, and produce something that is
directed from the syntax = triples as quickly as possible.
Dave
Sorry
Dave:
I attach some text ...
It's really intended as an overview of what processing is needed to unpack
the full RDF/XML syntax. As such I try to give some explanation of what each
step is, and their interdependencies. I have underlined bits that directly
relate to the order of processing.
I note that my rule 17 is stricter than this text, I think that it is a bug
with my rules.
Also my rules aren't quite as liberal with bagID numbering as the attached
text.
Jeremy
I strongly agree with this. Specs should inform, but not constrain
any more than absolutely required. If there is a neat way to help a
newbie get a parser (or whatever ) written, then put that in a primer
or expert-guide document, but not in the spec itself.
Pat
IHMC(850)434 8903 home
40 South Alcaniz St.(850)202 4416 office
phayes@ai.uwf.edu
snip
I agree as well, but with the caveat that those other documents need to
be written too! They don't necessarily have to be products of the WG
(although they can be), but if the folks that know the specs best (which
we hope at least *include* those that write them!) also know things
about pitfalls (in either meaning or implementation) that readers/users
of the specs are likely to fall into (typically because the writers have
fallen into them themselves), or have other useful guidance that could
be provided, ideally that *should* be provided (in clearly separate
material).
--Frank
Frank Manola The MITRE Corporation
202 Burlington Road, MS A345 Bedford, MA 01730-1420
Now's the time to be writing for WWW 2002
Jeremy
