I know that this was probably deferred to DOM Level 3 for reasons having to
do with DocumentTypes being read-only, but I believe that there either:
Should be a createEntity() method on Document or, the comments on
importNode() regarding importing Entities should be changed to indicate that
an attempt to import an entity is not supported.
Here's my rational for this change:
At present, there is no way to create an Entity node using current DOM
API's, however, a DOM 2 Compliant implementation must support the
importNode() method, which is a back door method for creating an Entity.
There should either be a way to create Entities that is directly supported
from Document, or the ability to Import entities should not be allowed in
DOM Level 2.
Keith
BTW: The same reasoning and changes would also apply to Notation Nodes.
Keith W. Boone
I know that this was probably deferred to DOM Level 3 for reasons having to
do with DocumentTypes being read-only, but I believe that there either:
Should be a createEntity() method on Document or, the comments on
importNode() regarding importing Entities should be changed to indicate that
an attempt to import an entity is not supported.
Here's my rational for this change:
At present, there is no way to create an Entity node using current DOM
API's, however, a DOM 2 Compliant implementation must support the
importNode() method, which is a back door method for creating an Entity.
There should either be a way to create Entities that is directly supported
from Document, or the ability to Import entities should not be allowed in
DOM Level 2.
Keith
When deeply importing a Node from another DOM Implementation, it is possible
in a multi-threaded environment for children to change while the import is
going on. The only way that I can correctly implement a deep importNode()
is to first perform a deep clone of the imported node, which will give me a
copy that I control, and then perform the recursive import. This
implementation creates a bunch of short-lived temporary objects in a Java
programming environment.
I do not believe that a conforming implementation should be required to
attempt this. Instead, I think that this sort of use should not be
attempted by applications. Applications that attempt to modify nodes in one
thread while importing them in another should get implementation dependent
behavior, and this should be clearly stated in the specification.
Keith
You're not going to like this answer:
Neither DOM Level 1 nor Level 2 makes any promises about supporting
multithreading, and it isn't on the list of high priority items for Level
3. Some individual DOM implementations may provide custom features for this
purpose, or you can implement something at the application layer.
This is recorded on the Open Issues List. But our conclusion so far has
been that we don't understand enough about common usage patterns in the DOM
-- if in fact there are any sufficiently general ones -- to make a
realistic attempt to support the required locking. If we tried to do it
today, we would probably over-serialize the DOM (which could impact
performance), and probably do so on too small a granularity to be useful
(which would mean you'd probably need application-level locking anyway).
Joe Kesselman / IBM Research
I actually do like this answer, I just want it to be explicitly stated in
the DOM Specification, and if it already is, can someone point me to it?
keshlam@us.ibm.com
You're not going to like this answer:
Neither DOM Level 1 nor Level 2 makes any promises about supporting
multithreading, and it isn't on the list of high priority items for Level
3. Some individual DOM implementations may provide custom features for this
purpose, or you can implement something at the application layer.
This is recorded on the Open Issues List. But our conclusion so far has
been that we don't understand enough about common usage patterns in the DOM
-- if in fact there are any sufficiently general ones -- to make a
realistic attempt to support the required locking. If we tried to do it
today, we would probably over-serialize the DOM (which could impact
performance), and probably do so on too small a granularity to be useful
(which would mean you'd probably need application-level locking anyway).
Joe Kesselman / IBM Research
The following sentence has been added in the introduction:
DOM Level 2 does not specify multithreading mechanisms.
Philippe
