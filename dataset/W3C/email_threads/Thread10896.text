I've been trying to assimilate the last few days of discussion on the
question originally raised by Steve Newcomb:
"Does an anchor know that it is an anchor?"
My first conclusion is that this is an unfortunate way to phrase the
question (sorry, Steve). If I understand correctly, no HyTime anchor
can be assumed to be self-aware even in the metaphorical sense because
in the general case there may be nothing attached to the anchor to
identify it as such. If a link addresses an unmarked span of
characters somewhere in hyperspace then *something* is aware that the
span is a HyTime anchor, but that something is surely not the unmarked
character string but rather a HyTime application. If we are to
attribute awareness in a metaphorical sense to something other than a
program, then that awareness must belong to the link itself, not to
the things it's addressing. So I suggest that we drop the whole
self-awareness trope; it just gets in the way.
If I ignore the issues that seem to have been created by this
metaphor, and I ignore the other issues that seem to have been created
by HyTime's idiosyncratic use of the word "anchor", then what stands
out for me in this discussion is this statement by Steve:
One of the problems with implementing anchor awareness is how to
limit the number of links whose anchors the application is
responsible for knowing about. HyTime's "bounded object set"
notion is one way to do that. It's obviously impossible for any
application to be aware of all the anchors of all the links that
exist on the Web.
A little later, in replying to a couple of questions from Tim Bray,
Eliot Kimber amplified on this by saying
[I]t's important when discussing these issues to distinguish
scenarios where the system is closed or mostly closed (as in
Hyper-G) or is completely open (as in the general Internet Web
case). I personally think XML's greatest benefit will be in
Intranets, where it is potentially possible to manage all the
links and know all the anchors (at least those not addressed by
pathalogical queries). Certainly within Internets there will be
significant information management and analysis benefit to being
able to apply new webs of links to existing documents (imagine an
MS Project schedule as a web of hyperlinks anchored to a
time-based coordinate space).
[...] If you want to make the link available to the Internet
masses, at least one anchor must be completely and irrevocably
self aware, i.e., the link must be one of its own anchors (a
"contextual link" in HyTime terms). When you are in an Intranet
environment, it need not be.
What I'm hearing -- please correct me if I'm wrong -- is that we can
implement contextual links for the open case (the Internet as a
whole), thus modestly but usefully expanding the range of capabilities
of the HTML A HREF , and then we have the further option of defining
independent links that will work only in closed environments, AKA
intranets. (Eliot goes on to suggest a method for wrapping an
"invisible linking element architectural form" around anchors to
"enable the conversion of independent links into contextual ones", but
pending a fuller description, this sounds over-engineered to me.)
A third option that doesn't seem to have been discussed much is that
we can define ilinks whose scope is the same as the SGML ID space, or
to put it loosely, ilinks that are used in the same document in which
they are defined. I'm not sure how useful this would be.
If we set aside the last possibility and Eliot's invisible wrapper
scheme, then what we seem to be left with is a clear reason to define
a contextual link mechanism for general Internet use in our first link
specification document and a possible case to be made for defining an
independent link mechanism for intranets that we may want to put in a
first link specification document or may want to defer for a later
version.
Is that right?
Jon
We need independent links for link management in a multihub hypermedia
system where a hub language is any handled type that is hyperlink
capable (multimedia). E.g, an Illustrated Parts Breakdown and the
supporting
graphic sequence (called a Figure, but multiple sheets) contain
bi-directional content relationships which are more easily managed
with independent links. We do it now with clinks. Hard to maintain.
IMO&amp;D, independent links are address records; clinks are controls
with local address records. Confusion starts there.
Self-awareness is not a good metaphor. Some contributions form
the object-oriented community would help here (Derek? Gavin?)
HyTime, TEI, FPI, URN, I don't care: ease of management of n-way links
is
what is needed. What would really help this discussion more than
abstractions on linking would be set of IDLs for an XML handler.
Define the XML handler public services.
For object oriented programmers to build what we
say we want, we have to tell them how much the XML spec
defines the behavior of the system that handles it?
What services do we want from that .dll? What is
the XML handler interface to the framework?
Location resolution is a framework feature. It's a protocol issue.
Protocol implementation is a system implementation. Engineers
know this and so demand that a proposal for a protocol always
be backed up with the code that runs it. Fact of life these days.
o Will XML hyperlinks be designed ad hoc? I have mine, you have yours,
etc. That is the current situation with respect to SGML hypertext
systems. We all have hyperlinks.
o Are we to define minimum interoperability of hyperlink types?
o Are we defining types of hyperlinks
which are extensible semantically (attribute, GI, whatever)
o Are we to develop a set of element types which are
XML hyperlinks? (i hope not but it's the easiest punt)
Given: If XML wants to define hyperlinks, XML has to provide an
implementation of the protocols required to support the
hyperlinks or ensure the hyperlinks fit within the constraints
of existing protocols.
OTH, hyperlinks are not locators. Do we have to design a protocol?
Do we need a stateless or a stateful protocol? Both?
WWW Today: URL with sub-file target parameters (e.g, #targetname, string
du jour) or URL as address type for semantic, e.g, object, img,
thingieDuJour). For comparison, here is a VRML anchor:
Anchor {
eventIn MFNode addChildren #tree operations
eventIn MFNode removeChildren
exposedField MFNode children
exposedField SFString children [ ] #geometry, materials, lights, etc.
exposedField SFString description "" #displayed text
exposedField MFString parameter [] #value-pairs, eg, frame targets
exposedField MFString url [] #get this, target, move-to-viewpoint
field bboxCenter 0 0 0 #local space origin
field bboxSize -1 -1 -1 #max size local space
We use a similar mechanism in IDE/AS where the link has goodies such as
targetname (file), system handler (who gets this), system arguments
(commands and command parameters (byte offsets, pixel positions,
named objects) all used in the DDE dance).
In some cases, (e.g., graphics) all documents of that content
type are being handled by a single system (e.g., ImageMaster).
Look's like a helper app but not really. It is actually a peer
in the sense that it also handles a hub-capable data type
where a hub-capable type has hyperlinks.
Hub: any notation that is hyperlink capable.
How does XML represent hyperlinking services to the
other notation handlers? Other hubs?
Could we just say, object handlers?
o Is this an XML-definable content relationship?
o Is this a Java or Active-X interface?
Services of objects are defined by the framework.
Are we offering an abstraction of that?
One way to look at this is to ask, for n-way links
what is as the minimal service set available to all
hubs in the system?
o What are the services of the objects of the framework
in which XML handlers operate?
o What are the services of the XML handler?
o What are the requirements of the XML user that must
be implemented in the XML handler services?
Requirement: easier management of linked relations
(e.g, independent links)
Requirement: declare relations among content types
without needing to know the handler type at the
hyperlink or at least, where that is prioritized
and/or negotiated (e.g, location ladders)
Uni-directional links are hard to build and maintain
for some content types. For example,
the relationships between an IPB and the figure
sequence to illustrate it are bi-directional.
We end up coding every link twice in a domain whose
range is bounded by topic, task, part, script, etc.
On a good day, twice the maintenance, twice the
headaches.
The relationships to the procedures which use the
IPB/graphic are indexed to the key numbers of the
IPB/graphic where the key number names the
relationship by local unique id (number list),
not logical name.
From any content node in this system, there
may be collections of nodes which support this with
topics (description, task-direction, policy, e-mail,
task recording (e.g, collaborative)).
o An XML hyperlink designer might want a way to validate a
referenced content type.
o An XML hyperlink designer might want to say, in this IPB, this
table always has a set of view types (graphic primitives in CGM,
camera positions in VRML, bitmaps in whatever), or in this
procedure, a collection is returned by a query whose parameters
are output conditions of the last procedure
o An XML hyperlink author might want to say, here is a list of
URLs, (priority, aggregate, etc.)
XML has to be able to support all of that because
XML users need all of that. XML has to support
not just the Web, but what the Web is becoming:
a business for authoring to the street in
one straight no-nonsense publishing path.
When books emerged, it was not from academic
struggle or desire. It was when certain merchants found
it necessary to smuggle records in carts of linen
across borders. Then the academics and the merchants
had all the books they could have ever wanted.
len bullard
dec 25, 1996
TEI or HyTime and HyTime is a standard which Eliot assures us
is able to express TEI comfortably.
Just to be pedantic: HyTime is a standard with which TEI can be integrated
comfortably. TEI expresses itself and the interface between a HyTime
engine and a TEI engine is well defined in terms of the property sets,
groves, and grove plans both act on.
Without reference to Tim's original post, I think the issues are:
1. What syntax(es) to use for representing addresses?
1.A HyTime location addresses (some or all) only (must include
URLs as a query notation that must be supported, in addition
to being used for entity external identifiers.).
1.B TEI locators only
1.C Some combination of 1.A and 1.B
1.D Only in style sheets
2. How to bind addresses to links
2.A direct only
2.B Indirect only
2.C Direct and indirect
3. Whether or not to define links that can be completely independent.
4. What syntax to use to represent links (probably separate from
addresses). Here the choices seem to be:
4.A SGML elements of the HyTime model without trickery (ID/IDREF
primary addressing method plus indirection)
4.B SGML elements of the HyTime model with refloc/queryloc
stuff to make use of non-HyTime addresses easier for authors.
4.C SGML elements of some other model that can't be reconciled
with HyTime (I don't think such a thing can be made, but
I won't rule it out).
4.D Define only in style specifications
5. What formalism to use in defining links and link types:
5.A Strict requirement of HyTime's linktype/anchor role model
5.B No required model (no need to define link types or anchor
roles)
5.C Both 5.A and 5.B (be formal or not, we don't care). Note this
is HyTime as of the TC.
5.D Some other model that I'm not aware of
6. What base behaviors to define for links or link types, if any.
7. How to allow authors or users to define or modify link behaviors,
if allowed at all:
7.A Style sheets only (e.g., DSSSL language for describing link
behavior.
7.B Attributes on link elements
7.C Some other mechanism
Cheers,
E.
W. Eliot Kimber (eliot@isogen.com)
Senior SGML Consulting Engineer, Highland Consulting
2200 North Lamar Street, Suite 230, Dallas, Texas 75202
"Rats in the morning, rats in the afternoon...if they don't go away, I'll be
re-educated soon..." --Austin Lounge Lizards, "1984 Blues"
This is good. If (for example only), one wants to create the
object-oriented implementation of these engines would one create:
o A class(es) of TEI objects including a TEI engine
o A class(es) of HyTime objects (including property sets)
The idea, I think, is to specify an interface as what
a programmer thinks of it as: a virtual or real method
interface.
No, this is not the XML standard; it is a way to discuss
the XML standard for hyperlinking in examples that a
programmer would find clear. I plead for help from
the object programmers on the list.
Please note the URL is under revision. It includes it's own
notion of querying so, does this imply that to the Hytime view,
a URL is simply a system for querying? IOW, others are
possible but any sensible implementor uses the URL. For the WWW, the
URL
is the lynchpin. Also note, at this time, URN definitions
conflict with URL definitions (per Roy Fielding's post to
uri.bunyip). Prepending the prefix appears to be illegal.
Someone more familiar with theseissues should investigate if
this has implications for use of URNs and FPIs in XML.
We pick victims. TEI implementations go on (what there
are of them), the majority of SGML hypertext implementations
fall. It may be the best choice, but it is not without
consequence.
This appears to me to be best. TEI goes on at
current pace; other apps have room. Now, what
happens to interoperation?
See below.
2.C
It appears that everyone wants this. Please advise if that is
an erroneous assumption. If so, we assume that it is a goal.
Pardon if I hash this: I've not time to review the
new HyTime work. If I understand, using 4.a:
Id points to Idref of target. Target classes may be actual
nodes (e.g, an element with a valid SGML ID), or to a locator
which in turn by convention indicates a semantic for locating
the target (e.g, relloc, dataloc, etc.) and the needed property
values to be passed to the locator resolver.
Ok. Depending on what is "trickery" this seems to be 4.A. What
is the difference?
If no example is presented, take the position it is absurd
so not worth considering.
4.D contravenes existing widely adopted practice. "only" is a
non-starter.
I have no opinion that use of stylesheets is "good or bad" for
defining links. It does make sense but it is not what the
user knows. I agree we should not bind XML to existing practice,
but neither should we get so advanced we "drop the dancers on their
posteriors" as we say in the music business when a tune is too
progressive to work in performance. There is always a way
out of the "no win" scenarios. I also don't believe in
the Kobayashi Moru.
How does an XML application designer inform an XML user that
an XML element type is a link or an ilink?
Absurd.
6. is convenient. If no base behaviors are defined, then XML should
if only in an informative appendix, show how base behaviors can be
defined and
used interoperably. Users of existing systems do understand the
meaning of a, etc. It is convenient to define and share among
a collection of XML document types, a set of recognizable and
predictable link types.
If by an XML author, we mean the traditional author, I think this
is an application issue. An XML implementor may choose to forgo
DSSSL, CSS, whatever, and hardwire behavior in the class methods.
OTH, using such means to modify behaviors is certainly an
established practice in other web languages such as VRML.
Ralph mentioned the SMSL project in another post. SMSL is an
ISO project. XML is a W3C project. Should we establish
scopes that enable these projects to be mutually reinforcing?
Can we?
len
