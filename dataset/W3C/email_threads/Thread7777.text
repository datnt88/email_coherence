Judy, I've collected your scenarios and inserted them into a draft doc. I'll
read through them more carefully later.
KW In case 9 and 10 I had arguments that the resource R, and not the
namespace should be locked. This contradicts infinity locks a little, as
they lose and gain members on movement in the namespace. So I guess I am
saying locks should LOCK the resource, but should be namespace aware :)
It took a while to read it all, but I think I agree with everything you
said for scenarios 1 - 8. It's difficult to express succinctly. I
think it is after we get some vocabulary.
Lets call the URI at which the LOCK was placed the "lock URI".
The LOCK URI has special properties. First of all, it is "protected". These
scenarios don't cover that prroperty, but the Adv. Collection spec does. It
means that among other things, that it's parent nodes (Is that what we call
them?) can not go through name space manipulations that would cause the locked
URI to disappear. That is...
if /a/b/c is locked, then /a/'s 'b' binding is not allowed to change and to
therefore take the URI "/a/b/c" out of existance. I'll leave that fuzzy for
now. If we dig further, I'm sure we can find some complications in there. The
idea behind protection is that we protect the URI so that someone that doesn't
have a lock can't make the LOCK URI mapping go away. The thinking is that we
are locking that URI because we're going to be using that URI to perform some
operation on the resource. If some other principal can make that URI go away or
map to something else, then we aren't happy. (A URI is our only way of address
resources right now.)
In addition, the lock binds most tightly to the LOCK URI. Then secondarily to
the resource at the LOCK URI. That means if you change the resource at that
URI, the new resource gets the lock that was set to the LOCK URI. (This what
your scenarios seem to suggest and it sounds like it might be what users want.)
Next... if the lock has depth... various descendent (vocab?) URI's are locked.
(We need vocabulary to distinguish this "locked" from what we are talking about
at the LOCK URI.) And the resources at those URI's are locked.
The fact that these resources are locked also means that they are locked if
accessed through other URI's too... but that those URI's aren't necessarily
"protected".
Yes, this is a totally fuzzy definition. I'll come up with a detailed boring
one later if this one shows promise. Anyway, I think this is the definition
that you used for scenarios 1-8. Now let me move on to 9 and 10....
Firstly, unless I misunderstand you, I think I disagree with what you've said
above about 9 and 10. This seems to be in disagreement with 1-8. I believe
that in the first scenarios, the LOCK URI is the primary location of the lock...
not necessarily the resource at that URI. (Yes, this is in conflict with what
we've been thinking with AdvCollections, but I want to run with your proposal
which you demonstrated with scenarios 1 - 8...) The resource IS locked, but
only by virtue of it's current relationship to the LOCK URI. The fact that the
resource is locked does mean it (the resource itself) is locked at other
mappings too.
9. The source resource was locked through one mapping, and a MOVE is
attempted through a different mapping.
9a. /a/b and /c/d map to R. /a/ is locked. MOVE /c/d to /x/y.
KW Since the resource R is locked, if the correct lock token for /c/d is
given (the lock token for the lock holding R), then the move occurs. Since
/a/b still points to R, /x/y is still locked via /a's lock. /KW
I agree.
9b. /a/b and /c/d map to R. /a/ is not locked, but /a/b is. MOVE /c/d to
/x/y.
KW Again the MOVE succeeds if the token for R is given, the resource is
still locked by /a/b /KW
I don't see why a token is necessary.. Yes R is locked, but the move is an
operation on the state of it's parent, not it. (I assume that /a/ and /c/
aren't the same resource.) That means the /c/d URI is not protected. The /a/b
URI is, but the MOVE isn't threatening that mapping. -- Besides the token
issue, I agree.
10. The destination resource was locked through one mapping, and a MOVE is
attempted through a different mapping.
10a. /w/x and /y/z map to R. /w/ is locked. MOVE /a/b to /y/z.
KW If correct lock token for R is given (If header with a tagged list of
/y/z and the correct token) the move completes. Since /w is locking the
resource R, it continues to do so /KW
I disagree about the lock token for the same reason as above... unless we're
possibly talking about a depth lock token. Let's first assume we're not.
Moving /a/b to /y/z is changing the state of the collections /a/ and /y/. (At
least that's how we have been thinking about it in the AdvColl discussions.)
Since neither of them is locked, the lock is irrelevant in the example. (BTW,
I assume /w/ and /y/ are not two mappings for the same collection.)
Now if it's a depth lock.... which I think you assumed... In that case, R is
locked by virtue of being accessable via /w/x. But I assert that that lock
remains irrelevant. When all the operations are through, resource R remains
accessible via /w/x and R remains locked. Nothing attempted threatens to break
the lock. It just becomes accessible through different mappings, but the
mappings that were lost were not PROTECTED by that particular lock since the
LOCK URI was not involved.
I agree about everything else besides the token.
10b. /w/x and /y/z map to R. /w/ is not locked, but /w/x is. MOVE /a/b to
/y/z.
KW Given the correct lock tokens (See above), the move succeeds. The lock
is then lost according to number 2 above. Again I would argue that the lock
on /w/x would still be there with the same logic as in number 2 above /KW
Once again, I say the lock tokens aren't relevant here. Nor is the lock. R
continues to exist. It's state hasn't changed. And the LOCK URI wasn't
threatend by the move.
11) - One thing I want to point out is a combination of 9 and 10. Both the
source and the destination are locked. By different locks. Exclusive locks.
/a/b and /c/d map to R. /a/ is depth locked.
/x/ is depth locked.
move /c/d to /x/y
In all the similar cases above, I believe we said it succeeded. But in this
combination, I believe it fails. Why? Because if it succeeded, R would be
accessable via /a/b and /x/y. but both /a/ and /x/ are depth locked.
Exclusively. That means R somehow would have inherited two exclusive
locks.. That sounds like something we have to disallow. :-) (Well, maybe.
I'll make another post on a twist on this in a sec.)
Anyway, Kevin, I think you have a viable proposal. I think most of us were
expecting a resource to be the primary holder of a lock. That seems like
something that would be easy to understand and would seem like what one would
want on first blush. But I think you've suggested is that what clients might
prefer is that the LOCK-URI own the lock... and whether a resource is locked is
determined if the resource that has a mapping the is or descends from that URI.
As resources are moved around they might be added or removed from the lock as
their mappings change. And even the resource mapped to the LOCK-URI itself can
change... and thus be added or removed from the lock.
I think we should keep your proposal on the table. And probably define it more
rigorously.
J.
See jra tags below...
"Slein, Judith A" JSlein@crt.xerox.com on 08/05/99 04:54:57 PM
Subject: LOCK Scenarios
We've been concerned about interactions between MOVE and locks. Logically
speaking, I think we have to consider the following cases. (They are not
all equally realistic, but they all are possible.) The question to answer
about each one is whether it seems right for the resource to be locked after
the MOVE, and if so, which lock should apply to it after the MOVE.
Considering these cases *may* help us decide whether the design principles
applied in RFC 2518 were the right ones. Speaking for myself, I find that I
don't have clear and consistent reactions to these cases, so I find myself
relying on other considerations like what our underlying models imply, and
implementation considerations.
Anyhow, here are the cases:
In all cases, we assume that the agent requesting the MOVE owns all the
locks in question.
A resource is being MOVEd. The locks are on that resource and / or its
destination, not the collections that contain them.
1. The source resource is locked, but the destination is not.
MOVE /a/b to /x/y, where /a/b is locked but /a/ is not and /x/y is not.
Lock token is required on source for MOVE, but not COPY. /x/y is not locked
after the MOVE or COPY.
2. The source resource is not locked, but the destination is.
MOVE /a/b to /x/y, where /a/b is not locked and /x/ is not locked, but /x/y
is locked
The lock token for the destination is required in the If header for both MOVE
and COPY, and overwrite must be "T". The destination is not locked after the
MOVE or COPY.
Although at first, this seems to loose the lock, but the destination is a
different resource, so it's not clear it should be locked after the MOVE or
COPY.
3. Both are locked, but with separate locks.
MOVE /a/b to /x/y, where /a/b has lock L1 and /x/y has lock L2, but neither
/a/ nor /x/ is locked.
Both lock tokens are required in the If header for MOVE, only the destination
for COPY. The destination is not locked after the MOVE operation.
A resource is being MOVEd. The locks are Depth: infinity locks on the
collections that contain either the source or the destination location.
4. The source collection is locked, but the destination collection is not
MOVE /a/b to /x/y, where /a/ is locked, but /x/ is not and /x/y is not.
The source lock token is required in the If header. /x/y is not locked after the
MOVE.
5. The source collection is not locked, but the destination collection is.
MOVE /a/b to /x/y, where /a/ is not locked and /a/b is not locked, but /x/
is locked.
No lock token is required. /x/y will be added to /a's write lock if it is a
depth infinity lock. Otherwise, /x/y is not locked after the MOVE operation.
6. Both are locked, but with separate locks.
MOVE /a/b to /x/y, where /a/ has lock L1 and /b/ has lock L2.
The source lock token is required in the If header. /x/y will be added to /a's
write lock if it is a depth infinity lock. Otherwise, /x/y is not locked after
the MOVE operation.
One lock is at the collection level, the other at the resource level.
7. The source resource is locked, and the destination collection is locked
with a different token
MOVE /a/b to /x/y, where /a/b has lock L1, /a/ is not locked, and /x/ has
lock L2.
L1 is required in the If header. /x/y will be locked with lock L2 if it is a
depth infinity lock.
8. The source collection is locked, the destination resource (not its
collection) is locked with a different token
MOVE /a/b ro /x/y, where /a/ has lock L1, /x/ is not locked, and /x/y has
lock L2.
Both lock tokens L1 and L2 are required in the If header, and overwrite must be
"T".
For the following cases, should the MOVE succeed or fail? If it succeeds,
what should the lock state be afterwards?
9. The source resource was locked through one mapping, and a MOVE is
attempted through a different mapping.
9a. /a/b and /c/d map to R. /a/ is locked. MOVE /c/d to /x/y.
The question here is, do we lock URLs or do we lock resources. If we lock
resources, then we don't have enough information. We need to know what /a/ maps
to.
9b. /a/b and /c/d map to R. /a/ is not locked, but /a/b is. MOVE /c/d to
/x/y.
10. The destination resource was locked through one mapping, and a MOVE is
attempted through a different mapping.
10a. /w/x and /y/z map to R. /w/ is locked. MOVE /a/b to /y/z.
if the locks are on the resources, not the URLs that map to them, then it
wouldn't matter which mapping was used to access the resource.
10b. /w/x and /y/z map to R. /w/ is not locked, but /w/x is. MOVE /a/b to
/y/z.
--Judy
Judith A. Slein
Xerox Corporation
jslein@crt.xerox.com
(716)422-5169
800 Phillips Road 105/50C
Webster, NY 14580
KW tags.... Thanks for bringing up COPY, we should be making it a priority
as well in all of this..
I am OK with 1-3. I might argue that locks on the destination should
remain, but I could be convinced otherwise.
A resource is being MOVEd. The locks are Depth: infinity locks on the
collections that contain either the source or the destination location.
4. The source collection is locked, but the destination collection is not
MOVE /a/b to /x/y, where /a/ is locked, but /x/ is not and /x/y is not.
The source lock token is required in the If header. /x/y is not locked after
the
MOVE.
5. The source collection is not locked, but the destination collection is.
MOVE /a/b to /x/y, where /a/ is not locked and /a/b is not locked, but /x/
is locked.
No lock token is required. /x/y will be added to /a's write lock if it is a
depth infinity lock. Otherwise, /x/y is not locked after the MOVE operation.
KW Disagree with the part about No lock token required. Since you are
changing /x's contents, you need /x's LOCK. /a/b is moved to /x and added
to its LOCK /KW
6. Both are locked, but with separate locks.
MOVE /a/b to /x/y, where /a/ has lock L1 and /b/ has lock L2.
The source lock token is required in the If header. /x/y will be added to
/a's
write lock if it is a depth infinity lock. Otherwise, /x/y is not locked
after
the MOVE operation.
/jra KW Same arguement as above. 2 Lock token's required, /a loses /a/b
as a resource and loses it from its lock. /x/y now exists as a new resource
(/a/b) but is still locked by L2. /KW
One lock is at the collection level, the other at the resource level.
7. The source resource is locked, and the destination collection is locked
with a different token
MOVE /a/b to /x/y, where /a/b has lock L1, /a/ is not locked, and /x/ has
lock L2.
L1 is required in the If header. /x/y will be locked with lock L2 if it is a
depth infinity lock.
/jra KW Both locks are required in IF header for reasons above. L1 is
removed from system (nothing left to lock?) while new /x/y is in L2 due to
infinity lock /KW
I agree that some mention must be made of the Depth header on the collection
locks. We need to add it and COPY to the use cases that are being argued..
Kevin
I agree with all of Kevin's observations below. In particular, if you MOVE a
resource to a destination where the (new) parent collection is locked, you need
the lock token for that parent collection in order to add the new member. Sorry,
I wasn't careful enough in my response. It's easy to get all these rules mixed
up or forget one - ample justification for keeping things simple and regular.
"Kevin Wiggen" wiggs@wiggenout.com on 08/16/99 03:46:42 PM
Subject: RE: LOCK Scenarios
KW tags.... Thanks for bringing up COPY, we should be making it a priority
as well in all of this..
I am OK with 1-3. I might argue that locks on the destination should
remain, but I could be convinced otherwise.
A resource is being MOVEd. The locks are Depth: infinity locks on the
collections that contain either the source or the destination location.
4. The source collection is locked, but the destination collection is not
MOVE /a/b to /x/y, where /a/ is locked, but /x/ is not and /x/y is not.
The source lock token is required in the If header. /x/y is not locked after
the
MOVE.
5. The source collection is not locked, but the destination collection is.
MOVE /a/b to /x/y, where /a/ is not locked and /a/b is not locked, but /x/
is locked.
No lock token is required. /x/y will be added to /a's write lock if it is a
depth infinity lock. Otherwise, /x/y is not locked after the MOVE operation.
KW Disagree with the part about No lock token required. Since you are
changing /x's contents, you need /x's LOCK. /a/b is moved to /x and added
to its LOCK /KW
6. Both are locked, but with separate locks.
MOVE /a/b to /x/y, where /a/ has lock L1 and /b/ has lock L2.
The source lock token is required in the If header. /x/y will be added to
/a's
write lock if it is a depth infinity lock. Otherwise, /x/y is not locked
after
the MOVE operation.
/jra KW Same arguement as above. 2 Lock token's required, /a loses /a/b
as a resource and loses it from its lock. /x/y now exists as a new resource
(/a/b) but is still locked by L2. /KW
One lock is at the collection level, the other at the resource level.
7. The source resource is locked, and the destination collection is locked
with a different token
MOVE /a/b to /x/y, where /a/b has lock L1, /a/ is not locked, and /x/ has
lock L2.
L1 is required in the If header. /x/y will be locked with lock L2 if it is a
depth infinity lock.
/jra KW Both locks are required in IF header for reasons above. L1 is
removed from system (nothing left to lock?) while new /x/y is in L2 due to
infinity lock /KW
I agree that some mention must be made of the Depth header on the collection
locks. We need to add it and COPY to the use cases that are being argued..
Kevin
Two people have now taken a careful look at the lock / MOVE scenarios.
Kevin's intuitions are consistent: It is always the lock at the destination
that survives after a MOVE, whether that lock is inherited from a collection
or is directly on the resource at the destination.
Jim Whitehead confirmed that this was the intended behavior specified in
section 7.7 of rfc 2518.
As Kevin points out, the language in 8.8.4 and 8.10.5 together seems to
contradict this, so the inconsistency in rfc 2518 needs to be straightened
out. Section 8.10.5 says that if Overwrite is "T", the resource at the
destination will be deleted, and section 8.8.4 says that if a resource is
deleted, all its locks are removed. So the upshot seems to be that after
the MOVE, any singleton lock at the destination will be gone.
Jim Amsden's intuitions about the scenarios were different: No singleton
lock ever survives a MOVE, but a resource that is moved into a locked
collection does inherit the collection's lock. So Jim's intuitions agree
with sections 8.8.4 and 8.10.5, and with interpreting section 7.7 to be only
about inheriting collection locks, and not about singleton locks.
Cases 9 and 10 poke at the complexities added by multiple URI mappings to
the same resource.
Kevin's intuitions say that there is really no added difficulty about
resolving these cases. It's the resource that gets locked, as rfc 2518
says, and it's still true that any lock, inherited or singleton, at the
destination, survives the move.
--Judy
Judith A. Slein
Xerox Corporation
jslein@crt.xerox.com
(716)422-5169
800 Phillips Road 105/50C
Webster, NY 14580
It appears to me that Jim Amsden's intuition and the current wording of
the spec is more consistent than the "intended behavior". In particular,
suppose you had three locks, on:
/x
/x/y
/x/y/z.html
Now suppose you MOVE'd a new collection to /x/y.
I think we all agree that the lock on /x is unaffected.
But what about the locks on /x/y and /x/y/z.html?
It is consistent to say that all locks on deleted resources at
the destination are removed (i.e. consistent with the fact that
deleting a resource deletes its locks).
It is also consistent (although somewhat more complicated) to say
that the "delete" performed as a side effect of a MOVE is a special
kind of delete that does not remove locks. But then neither the
lock on /x/y *nor* the lock on /x/y/z.html should be affected,
which means that if /x/y/z.html is not mapped to any resource
following the MOVE, then a lock-null resource must auto-magically
be created at /x/y/z.html after the MOVE.
In my opinion, the complexity of special casing delete for MOVE, and
creating these lock-null resources as a side effect of the MOVE,
significantly outweigh any benefits that might be achieved.
Cheers,
Geoff
From: "Slein, Judith A" JSlein@crt.xerox.com
Date: Tue, 17 Aug 1999 10:46:15 -0400
Mime-Version: 1.0
X-Mailer: Internet Mail Service (5.5.2448.0)
Resent-From: w3c-dist-auth@w3.org
X-Mailing-List: w3c-dist-auth@w3.org archive/latest/3159
X-Loop: w3c-dist-auth@w3.org
Sender: w3c-dist-auth-request@w3.org
Resent-Sender: w3c-dist-auth-request@w3.org
Precedence: list
X-Lines: 42
Content-Length: 1640
Two people have now taken a careful look at the lock / MOVE scenarios.
Kevin's intuitions are consistent: It is always the lock at the destination
that survives after a MOVE, whether that lock is inherited from a collection
or is directly on the resource at the destination.
Jim Whitehead confirmed that this was the intended behavior specified in
section 7.7 of rfc 2518.
As Kevin points out, the language in 8.8.4 and 8.10.5 together seems to
contradict this, so the inconsistency in rfc 2518 needs to be straightened
out. Section 8.10.5 says that if Overwrite is "T", the resource at the
destination will be deleted, and section 8.8.4 says that if a resource is
deleted, all its locks are removed. So the upshot seems to be that after
the MOVE, any singleton lock at the destination will be gone.
Jim Amsden's intuitions about the scenarios were different: No singleton
lock ever survives a MOVE, but a resource that is moved into a locked
collection does inherit the collection's lock. So Jim's intuitions agree
with sections 8.8.4 and 8.10.5, and with interpreting section 7.7 to be only
about inheriting collection locks, and not about singleton locks.
Cases 9 and 10 poke at the complexities added by multiple URI mappings to
the same resource.
Kevin's intuitions say that there is really no added difficulty about
resolving these cases. It's the resource that gets locked, as rfc 2518
says, and it's still true that any lock, inherited or singleton, at the
destination, survives the move.
--Judy
Judith,
At least three people. You overlooked my note.
Kevin's intuitions are consistent: It is always the lock at the destination
that survives after a MOVE, whether that lock is inherited from a collection
or is directly on the resource at the destination.
Agreed. They seem consistant and your interpretation of what he's said sounds
right. As my note pointed out, I think he had some trouble on whether lock
tokens are required though in scenarios 9/10. It seemed to be based on his
assumption that changing the membership of a collection isn't an operation on
the collection. Just on the resource already at the URI. In subsequent notes
in response to Jim, Kevin seemed to recognize the role of the parent though.
Jim Amsden's intuitions about the scenarios were different: No singleton
lock ever survives a MOVE, but a resource that is moved into a locked
collection does inherit the collection's lock.
Just for the sake of consistancy, I prefer the singleton and depth locks
to be treated the same. Just as Kevin apparently does.
Cases 9 and 10 poke at the complexities added by multiple URI mappings to
the same resource.
Kevin's intuitions say that there is really no added difficulty about
resolving these cases. It's the resource that gets locked, as rfc 2518
says, and it's still true that any lock, inherited or singleton, at the
destination, survives the move.
I disagree somewhat with "it's the resource that gets locked" as sumarizing
Kevin's interpretation. If the resouce moves and doesn't carry the lock with it
at times, then I don't think it's correct to say it's the resource that
is locked. At least not without further explanation. That's what my
note pointed out. But yes, if a resource is locked at one mapping, it is
locked at all. But only the original URI mapping is "protected"... using
the AdvColl definition of "protected". At least that was my proposal... based
on AdvColl discussions.
J.
Section 7.7 makes no mention of locks on the destination, only depth infinity
locks inherited from new parent collections. If the destination resource falls
within the scope of a depth infinity lock, then it inherits the lock, just like
PUT or MKCOL. I don't think the spec is inconsistent with regard to locks and
MOVE and COPY. It may not be the semantics everyone would want, but it is not
inconsistent. I'm not convinced that destination locks should be retained after
MOVE and COPY anyway as the destination is a new resource with new properties.
The lock was on the old resource which was deleted. However, I don't feel
strongly about these semantics as long as whatever we come up with is simple,
consistent, and predictable.
"Slein, Judith A" JSlein@crt.xerox.com on 08/17/99 10:46:15 AM
Subject: Re: LOCK Scenarios
Two people have now taken a careful look at the lock / MOVE scenarios.
Kevin's intuitions are consistent: It is always the lock at the destination
that survives after a MOVE, whether that lock is inherited from a collection
or is directly on the resource at the destination.
Jim Whitehead confirmed that this was the intended behavior specified in
section 7.7 of rfc 2518.
As Kevin points out, the language in 8.8.4 and 8.10.5 together seems to
contradict this, so the inconsistency in rfc 2518 needs to be straightened
out. Section 8.10.5 says that if Overwrite is "T", the resource at the
destination will be deleted, and section 8.8.4 says that if a resource is
deleted, all its locks are removed. So the upshot seems to be that after
the MOVE, any singleton lock at the destination will be gone.
Jim Amsden's intuitions about the scenarios were different: No singleton
lock ever survives a MOVE, but a resource that is moved into a locked
collection does inherit the collection's lock. So Jim's intuitions agree
with sections 8.8.4 and 8.10.5, and with interpreting section 7.7 to be only
about inheriting collection locks, and not about singleton locks.
Cases 9 and 10 poke at the complexities added by multiple URI mappings to
the same resource.
Kevin's intuitions say that there is really no added difficulty about
resolving these cases. It's the resource that gets locked, as rfc 2518
says, and it's still true that any lock, inherited or singleton, at the
destination, survives the move.
--Judy
Judith A. Slein
Xerox Corporation
jslein@crt.xerox.com
(716)422-5169
800 Phillips Road 105/50C
Webster, NY 14580
Jason says:
Just for the sake of consistancy, I prefer the singleton and depth locks
to be treated the same. Just as Kevin apparently does.
I'm not sure this treating these locks the same is consistent. They are
different locks on different resources playing different roles in the methods.
As Geoff pointed out, to have a (singleton) destination lock retained on COPY or
MOVE requires a significant number of special cases.
As Geoff pointed out, to have a (singleton) destination lock retained on COPY or
MOVE requires a significant number of special cases.
Maybe I misinterpretted what it was that he Geoff felt was inconsistant. He
didn't mention singleton, depth or even exclusive locks. For this reason, the
inconsistancy that I thought he depicted applies to singleton and depth locks
equally... and exclusive and shared... and that's what I addressed in my
response to his note.
I missed something in my previous response to Geoff's note...
It appears to me that Jim Amsden's intuition and the current wording of
the spec is more consistent than the "intended behavior". In particular,
suppose you had three locks, on:
/x
/x/y
/x/y/z.html
Now suppose you MOVE'd a new collection to /x/y.
I think we all agree that the lock on /x is unaffected.
But what about the locks on /x/y and /x/y/z.html?
It is consistent to say that all locks on deleted resources at
the destination are removed (i.e. consistent with the fact that
deleting a resource deletes its locks).
It is also consistent (although somewhat more complicated) to say
that the "delete" performed as a side effect of a MOVE is a special
kind of delete that does not remove locks. But then neither the
lock on /x/y *nor* the lock on /x/y/z.html should be affected,
which means that if /x/y/z.html is not mapped to any resource
following the MOVE, then a lock-null resource must auto-magically
be created at /x/y/z.html after the MOVE.
In my previous response I voted against retaining a lock for /x/y/z.html.
One other thing I'd like to check... Is it possible to do a MOVE
operation that replaces a binding to a collection with a binding to a
non-collection? (This relates to your discussions with JimW over
/x/y/ and /x/y being interchangeable.)
If so... there might not even be a collection at /x/y after the move
which makes keeping a null lock at /x/y/z.html even odder. To date,
all null locks have had collection resources at their PARENT URI.
I'd vote that for now we limit the things so that the only lock that we'd
consider retaining is at the DELETE's request URI. Any ancestor lock
will be retained. Any descendent lock will not.
Note: all of our discussion retaining destination locks also applies
to an overwrit'ing BIND.
In my previous response I voted against retaining a lock for /x/y/z.html.
One other thing I'd like to check... Is it possible to do a MOVE
operation that replaces a binding to a collection with a binding to a
non-collection? (This relates to your discussions with JimW over
/x/y/ and /x/y being interchangeable.)
You can MOVE a resource over a collection or the other way around. The semantics
are that the overwrite header must be "T", and if so the destination is deleted
before the MOVE.
If so... there might not even be a collection at /x/y after the move
which makes keeping a null lock at /x/y/z.html even odder. To date,
all null locks have had collection resources at their PARENT URI.
All DAV resources have collection resources at the PARENT URI.
I'd vote that for now we limit the things so that the only lock that we'd
consider retaining is at the DELETE's request URI. Any ancestor lock
will be retained. Any descendent lock will not.
Yet another special case. The current spec has no such special cases. Inheriting
a depth infinity lock from the destination parent collection is not a special
case, its part of what it means to be a memeber of a collection.
Note: all of our discussion retaining destination locks also applies
to an overwrit'ing BIND.
A couple misunderstandings here.
1) I think Judith suggested that you were suggesting that
depth and singleton locks at the destination be treated
differently. At least that was my initial reading. I've
not found evidence of you saying this though. As it turns
out it looks like she missed the point of the distinction
between your expectations and Kevin's. I think the
point is not singleton vs. depth... or singleton vs
inherited. The point is whether
a LOCK that is rooted (singleton or not) at the destination
URI survives.
depth only applies to the parent of the destination resource when determining if
the new destination gets the lock or not. I do not even consider the resource
type or what kind of lock it has with respect to the COPY or MOVE operation
because it doesn't matter, this lock is not retained. However, if the new parent
collection is depth infinity locked, the destination will inherit the lock
(regardless of what lock the deleted resource might have had), and if the
destination is also a collection, it will have a depth infinity lock too. Just
like it would if you had created the collection with MKCOL or a resource with
PUT.
BTW, I propose we use the phrases, "rooted at the URI"
vs "inherited at the URI/resource" when talking about
these locks. As far as vocabulary goes, there are also
a few other cases that need vocabulary. I'll save that
for a seperate note.
I don't know what either of these phrases mean. A resource is locked or
unlocked. A resource inherites any depth infinity lock of its parent collection,
no matter how it became a member of that collection.
2) It sounds like you also think that having support for
retaining a lock rooted on URI below a deleted URI is too
messy to support. If so, we agree.
That's why I made the proposal
above. It eliminates everything that I'd consider a
"special case". It does still leave the issue of if
the destination URI remains locked. And lets the client
decide that. I
think this is more of a feature than a special case to
handle. The client simply declares if he wants to retain
the lock or not when he issues the DELETE. Depending on
the implementation, the server might even find it *easier*
to support the keeping of the lock. (AKA no code at all.)
But the proposal would be for the server to support both
behaviors at the DELETE request URI.
I don't think the destination URL retains the lock of the resource that used to
be at that destination unless it just happens to have the same depth infinity
locked parent collection. But this would be a new lock with the timeout reset.
3) 8.10.5 says a DELETE destroys a lock at the destination.
I think this is not optimal. A scenario is... /a/b exists
and is a resource... not a collection. We want to replace it
with a new resource that is a collection. But the spec says
that MKCOL can not replace am existing resource (or
collection). It requires that a delete be performed first.
Now if one wants to accomplish this atomically (with
LOCKS), right now one has several choices.
a) LOCK /a/. It would probably be a depth 0 lock since
there would be no point in locking at depth except possibly
to prevent someone from tossing in another lock immediately
after in the /a/b/... tree. But if they did chose to use
a depth lock, they'd also risk being unable to get the lock
if someone for example has a conflicting lock somehwere in
a /a/c/ tree. It's a trade off. Depth or not, the other
disadvantage of it is that they are also locking out any
operations on /a/. The point is that if they decide to lock
/a/, they are locking more than they need to and may
interfere with other principles... or be blocked themselves.
b) LOCK /a/b. But unfortunately with the current spec,
the initial DELETE will destroy the lock. So this isn't
really a choice unless we want to reissue the lock... to
create a null lock which is better, but still risks problems
if another entity beats us to the punch. It's a race condition.
Now if we altered 8.10.5 to allow support for not deleting the
lock, we could act surgically to insure that we get exactly the
safe atomic behavior we want. (Ignoring a tangential caveat.)
We lock /a/b possibly at depth. Do the delete specifying that
we want the lock retained. Then do the MKCOL /a/b/ and any
other operations we require. When done, release the lock. Once
again ignoring an unspecified caveat, we know that as soon as
we get the lock that we're going to be able to acomplish what
we set out to do without another principle interfering.
If we don't want this, then I think we need to evaluate why we
support lock-null resources. I'd think the arguments for each
of these are the same.
There are a large number of situations in authoring environments where
transaction semantics are required. WebDAV doesn't (yet) support transactions,
and I don't think we should attempt to come up with a lot of special cases (like
lock-null resources) supported by the protocol to overcome this important
missing function. Rather let's propose an extension that does support
transactions. Might be pretty hard with a stateless server though.
BTW, my final comment above has prompted me to check into the
history of destination lock deletion and lock-null resources...
Here Yaron's solution to atomicity in COPY. It's not to support locks
on the destination. It's to simply change the spec to say COPY should
be implemented atomically. No explanation. Just his recomendation.
Sounds reasonable.
There was a time where deleting a resource didn't necessarily delete its lock.
Nov 96.
But deleting the destination lock was in there April 97. I could find
no explanation for the change. It looks like they/Yaron decided to start
from scratch and this was the result. -- I believe this is also where
lock-null resources came in. No earlier references to this. No documentated
rationale behind it. Yaron?
BTW, I propose we use the phrases, "rooted at the URI"
vs "inherited at the URI/resource" when talking about
these locks. As far as vocabulary goes, there are also
a few other cases that need vocabulary. I'll save that
for a seperate note.
I don't know what either of these phrases mean. A resource is locked or
unlocked. A resource inherites any depth infinity lock of its parent collection,
no matter how it became a member of that collection.
As I said, I'll save the full vocabulary and lock/resource/URI
discussion for another note. I'll
just say here that for discussing the differences between
the two proposals, we need terminology that describes
the situation where the two proposals differ. The "Rooted"
phrase refers to that situation. The situation where the
earlier LOCK request was originally (to simplify) at the
same URI that is now the destination of the MOVE.
I don't think the destination URL retains the lock of the resource that used to
be at that destination unless it just happens to have the same depth infinity
locked parent collection.
Right. That's where there is a difference of opinion.
...But this would be a new lock with the timeout reset.
New lock? Perhaps I didn't understand what you just said
above about "same.... parent". Please run that by me again.
From: Jason Crawford on 08/18/99 02:18 PM
Subject: Re: LOCK Scenarios (Document link not converted)
I don't think the destination URL retains the lock of the resource that used to
be at that destination unless it just happens to have the same depth infinity
locked parent collection.
Right. That's where there is a difference of opinion.
I hope I am expressing what is currently in the spec rather than an opinion. I'm
not opposed to changing the spec to something else, but I havn't seen anything
yet that would motivate me to retain destination locks.
...But this would be a new lock with the timeout reset.
New lock? Perhaps I didn't understand what you just said
above about "same.... parent". Please run that by me again.
Its a new lock on the destination (the new member of the parent collection), not
a new lock on the parent collection. Again, just like you would get if you did a
PUT or MKCOL to create a new resource in that collection. The new resource would
get a new (to it) lock inherited from its parent.
JC ... The point is whether
a LOCK that is rooted (singleton or not) at the destination
URI survives. /JC
I see at least two reasons in favor of deleting the lock:
- A MOVE/COPY just does a regular delete (with deletion of all locks),
rather than a "special delete" which deletes all locks except for the
one rooted at the destination URI.
- The MOVE/COPY protocol doesn't have to deal with the complexity of
applying the old lock to the new resource. I can easily imagine the
creation of certain types of locks that only apply to certain types of
resources. The MOVE/COPY protocol would then have to deal with all
the error conditions that LOCK has to deal with.
One clearly can extend the protocol to answer these questions, but it
makes for a significantly more complicated protocol.
JC ... The client simply declares if he wants to retain
the lock or not when he issues the DELETE. Depending on
the implementation, the server might even find it *easier*
to support the keeping of the lock. (AKA no code at all.)
gmc/ A server has to delete all of the LOCK's rooted at descendents
of the destination URI, so I don't see how it could be easier for it
to delete all descendent locks, but not the lock at the URI.
JC 8.10.5 says a DELETE destroys a lock at the destination.
I think this is not optimal. A scenario is... /a/b exists
and is a resource... not a collection. We want to replace it
with a new resource that is a collection. But the spec says
that MKCOL can not replace am existing resource (or
collection). It requires that a delete be performed first.
Now if one wants to accomplish this atomically (with
LOCKS), right now one has several choices. ...
gmc/ I think this is better handled by just saying (as suggested by
Yaron) that a COPY/MOVE should be performed atomically, and not bother
with trying to use locking to achieve atomicity of COPY/MOVE.
Cheers,
Geoff
OK not to make this any harder than it is.... But I have an issue on the
Webdav Issues list that a move/copy should not do the DELETE by itself,
ever. This gives the client complete control and forces them to do the
delete before placing the file there. This way my server is not making any
judgments about the existing resource for the user.
On a side note this has already been a complaint multiple times on
Sharemation, and it has only been up for 2 days. People think that a
move/copy should be merging files, not overriding them. Especially since IE
is telling them its doing a merge!!! And I quote "This folder already
contains a folder named 'pictures'. If the files in the existing folder
have the same name as files in the folder you are moving, they will be
replaced. Do you still want to move the folder?"
Now I am not saying we should do something because Microsoft does it, but
this is the behavior I would be expecting....
If you follow this train of thought, if I replace 1 file with another, I
would expect things like creation date to be left alone. I would expect
that only the bytes would change. From this I would expect that any lock I
had would still be there....
Maybe I am complicating things too much, but I just felt I should mention
it...
Kevin
It appears to me that Jim Amsden's intuition and the current wording of
the spec is more consistent than the "intended behavior". In particular,
suppose you had three locks, on:
/x
/x/y
/x/y/z.html
Now suppose you MOVE'd a new collection to /x/y.
I think we all agree that the lock on /x is unaffected.
But what about the locks on /x/y and /x/y/z.html?
KW The resource /x/y/z.html has been deleted due to the move to /x/y,
therefore the lock there was removed. This does lead to an interesting
situation where moving to /x/y can fail if you don't give the correct
lock-token to /x/y/z.html. But I think this is a good thing.
Again I note that there is no good response to the move for failures during
the delete.
The argument on /x/y is open I believe
Obviously /x and /x/y are depth 0 locks otherwise they wouldn't have been
created due to the other locks in the system.
You don't need to give the lock-token for /x as its namespace is remaining
consistent.
It is consistent to say that all locks on deleted resources at
the destination are removed (i.e. consistent with the fact that
deleting a resource deletes its locks).
It is also consistent (although somewhat more complicated) to say
that the "delete" performed as a side effect of a MOVE is a special
kind of delete that does not remove locks. But then neither the
lock on /x/y *nor* the lock on /x/y/z.html should be affected,
which means that if /x/y/z.html is not mapped to any resource
following the MOVE, then a lock-null resource must auto-magically
be created at /x/y/z.html after the MOVE.
If so... there might not even be a collection at /x/y after the move
which makes keeping a null lock at /x/y/z.html even odder. To date,
all null locks have had collection resources at their PARENT URI.
I'd vote that for now we limit the things so that the only lock that we'd
consider retaining is at the DELETE's request URI. Any ancestor lock
will be retained. Any descendent lock will not.
KW Again I believe this is consistent as descendents will be deleted and
therefore so will there locks...
I think we need to start again with the use cases from Judith. There are
now a number more. ccjason said a doc was being created. If I don't see it
soon, I will create one. I think all the use cases need to be looked at...
Again I think the major argument comes down to:
1) A lock locks a resource VRS
2) A lock locks the URL namespace
I'd like to vote we keep infinity locks, but my argument might start "It
took me a whole weekend to get that to work" :)
But there must have been reasons to put it in there in the first place.
Unfortunately I was not there for those conversations.
Kevin
JC ... The point is whether
a LOCK that is rooted (singleton or not) at the destination
URI survives. /JC
I see at least two reasons in favor of deleting the lock:
- A MOVE/COPY just does a regular delete (with deletion of all locks),
rather than a "special delete" which deletes all locks except for the
one rooted at the destination URI.
- The MOVE/COPY protocol doesn't have to deal with the complexity of
applying the old lock to the new resource. I can easily imagine the
creation of certain types of locks that only apply to certain types of
resources. The MOVE/COPY protocol would then have to deal with all
the error conditions that LOCK has to deal with.
One clearly can extend the protocol to answer these questions, but it
makes for a significantly more complicated protocol.
The first reason would not be significant if we added the
optional capability into DELETE that I suggested. I pointed out
why it would be useful to add this capability to DELETE.
The second problem would also be possible if the parent of the destination
had a depth lock that was in conflict with the new resource(s) at the
destination. If such class of locks exist, then
the checking needs to be there anyway. Just one more lock to
check. (Similar argument to what you use below... except
supporting the opposite position.)
JC ... The client simply declares if he wants to retain
the lock or not when he issues the DELETE. Depending on
the implementation, the server might even find it *easier*
to support the keeping of the lock. (AKA no code at all.)
gmc/ A server has to delete all of the LOCK's rooted at descendents
of the destination URI, so I don't see how it could be easier for it
to delete all descendent locks, but not the lock at the URI.
JC Good point. It's the nearly the same effort either way if there
are a lot of locks rooted below. I wouldn't expect that to be common,
but who knows... And the server would have to search for them anyway.
That in itself could be relatively expensive depending on
implementation and size of tree. Point well taken.
As I said, the proposal would be that it would have to be supported
either way though... so it was more importantly my point that it's
not much harder. It's just the matter of optionally one less
deleted lock.
JC 8.10.5 says a DELETE destroys a lock at the destination.
I think this is not optimal. A scenario is... /a/b exists
and is a resource... not a collection. We want to replace it
with a new resource that is a collection. But the spec says
that MKCOL can not replace am existing resource (or
collection). It requires that a delete be performed first.
Now if one wants to accomplish this atomically (with
LOCKS), right now one has several choices. ...
gmc I think this is better handled by just saying (as suggested by
Yaron) that a COPY/MOVE should be performed atomically, and not bother
with trying to use locking to achieve atomicity of COPY/MOVE.
This wouldn't be addressing the issue of atomicity of the COPY/MOVE...
although it would achieve that. It would be addressing the atomicity
of the COPY/MOVE followed by something else if the client wanted it.
The same applies to DELETE. There's something there you want to remove
and replace with something else. The same applies to BIND with
overwrite... I think. (See next note.)
This capability addresses the same
need that lock-null resources do now. Without them, you'd have to
create the resource and then lock them and then do whatever else
you had in mind. That's why I suggest that if we don't want this
capability, we have to wonder about lock-null resources.
From: ccjason@us.ibm.com
JC ... The point is whether
a LOCK that is rooted (singleton or not) at the destination
URI survives. /JC
I see at least two reasons in favor of deleting the lock:
- A MOVE/COPY just does a regular delete (with deletion of all locks),
rather than a "special delete" which deletes all locks except for the
one rooted at the destination URI.
- The MOVE/COPY protocol doesn't have to deal with the complexity of
applying the old lock to the new resource. I can easily imagine the
creation of certain types of locks that only apply to certain types of
resources. The MOVE/COPY protocol would then have to deal with all
the error conditions that LOCK has to deal with.
jc The first reason would not be significant if we added the
optional capability into DELETE that I suggested. I pointed out
why it would be useful to add this capability to DELETE.
gmc/ I agree that adding the capability to DELETE would be more
uniform than special-casing it for MOVE, but I'd prefer not having
it in either case (for simplicity).
The second problem would also be possible if the parent of the destination
had a depth lock that was in conflict with the new resource(s) at the
destination. If such class of locks exist, then
the checking needs to be there anyway. Just one more lock to
check. (Similar argument to what you use below... except
supporting the opposite position.)
gmc/ I advocate removing "depth" locking from the spec
(in the "Locking: Implementation Considerations" thread)
for other reasons.
gmc/ In general, I am against all bits of the
protocol which cause a lock to be "inherited", since this forces
all the "resource creation" methods to have to deal with all
the "LOCK" failure cases. So I'm against:
- depth locking
- lock-null resources
- keeping the lock on the destination of a MOVE/COPY
JC ... A scenario is... /a/b exists
and is a resource... not a collection. We want to replace it
with a new resource that is a collection.
Now if one wants to accomplish this atomically (with
LOCKS), right now one has several choices. ...
gmc I think this is better handled by just saying (as suggested by
Yaron) that a COPY/MOVE should be performed atomically, and not bother
with trying to use locking to achieve atomicity of COPY/MOVE. /gmc
This wouldn't be addressing the issue of atomicity of the COPY/MOVE...
although it would achieve that. It would be addressing the atomicity
of the COPY/MOVE followed by something else if the client wanted it.
I don't believe that LOCK's are a good technique for achieving
atomicity of an arbitrary set of operations following the COPY/MOVE.
The main problem is that a LOCK is a very coarse form of control, i.e.
none of the properties or bodies of any of the members of a depth infinity
lock can be modified by anyone. In a distributed authoring context,
I believe an optimistic "modify/merge" paradigm scales much better.
As long as the MOVE/COPY operations are atomic, you can perform all your
changes in a personal copy, and then MOVE/COPY the result to its final
destination.
This capability addresses the same
need that lock-null resources do now. Without them, you'd have to
create the resource and then lock them and then do whatever else
you had in mind. That's why I suggest that if we don't want this
capability, we have to wonder about lock-null resources.
I agree, and am against lock-null resources. I believe the
protocol could be simplified with very little loss of functionality
by just saying that if you want to achieve the effect of a lock-null
resource, you just create an empty resource (e.g. a resource with
an empty body) and then lock that real resource.
So to summarize, I'm in favor of:
- deleting lock-null resources from the spec
- deleting depth locking from the spec
- otherwise leaving alone the current wording in the spec
of the effect of delete/move on locks
Cheers,
Geoff
BTW when we originally discussed this in WebDAV the conclusion was that a
system like IE could handle the "merge" behavior on its own, without needing
any help from the server. That is, it could pipeline a bunch of copy's
w/overwrites. This wouldn't even hurt latency since the requests could be
pipelined.
However the reality is that things would probably be faster if there was a
way to say "Hey, merge." So why not just add a header which specifies merge
functionality? If you want to make sure it is honored then mark up with the
request with mandatory.
As for IE, sigh... I have forwarded the bug to the right folks but in the
meanwhile it might make sense to put in a detection for IE's user agent and
"do the right thing." I realize this sucks but bugs happen, especially
amongst early adopters.
Yaron
After coming back from my holidays and reading a lot of WebDAV articles
I don't want to repeat all arguments. I just want to say:
I agree with you :-)
Regards, Edgar
Edgar.Schwarz@de.bosch.com ON/EMS1, 07191/13-3382 Niklaus Wirth:
Privat kann jeder soviel C programmieren oder Videos ansehen wie er mag.
Albert Einstein: Mach es so einfach wie moeglich, aber nicht einfacher.
