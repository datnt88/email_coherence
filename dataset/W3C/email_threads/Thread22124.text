Scott Boag wrote,
Just because I have a method that is passed a node, doesn't
mean I can't cast to node to a given implementation, and be
optimized, but otherwise throw an exception if the given
implementation isn't supported.
So whose implementation will you cast to to get hold of those
optimized query hooks? Yours, obviously. But what about ours?
Jonathan and Mikes?; Suns? etc. etc.
And do you expect me to support _your_ implementation when for
all I know you'll be changing those non-public query hooks from
week to week?
Adding an XPath query API to the DOM allows optimized XPath
queries to be _portable_. That might not matter to you, but it
does to quite a few of us.
Cheers,
Miles
Miles Sabin Cromwell Media
Internet Systems Architect 5/6 Glenthorne Mews
msabin@cromwellmedia.com http://www.cromwellmedia.com/
Scott Boag wrote,
Right, using my optimizations.
Which won't be available to our XPath processor ... so we'd
never be able to recommend your DOM in conjunction with our
tools.
But what about ours? Jonathan and Mikes?; Suns? etc. etc.
In the case of my XPath implementation, I would support these
via the public DOM interfaces (yes, it would be slower).
Which means you won't be able to recommend our tools in
conjunction with yours.
No, not if you don't support generic DOMs.
Well, I'd support a generic DOM, but wouldn't expect the
results to be particularly exciting performance-wise. Running
an XPath query against a DB-based DOM via the existing public
API would be painful, to put it mildly.
I don't think having a method on the Node object vs. having a
method on an XPath object that takes a node as a context
makes one smidgen of difference in terms of optimization or
portability. On the contrary, the method with context is
more portable.
I'm afraid I have to disagree. Delegating queries to DOM
implementations allows them to be resolved using internal
information which is simply not available via the public API.
Interoperability is about more than a common API: the API has
to expose functionality in a _practically_ usable form across different
implementations. Anything else would be an invitation
to vendors to develop proprietary extensions.
According to your argument, anything that is ever optimized
must be a method on the DOM.
Where there's a significant chunk of functionality which would
be widely used and which would benefit from close integration
with a DOM implementation, then, yes, I would advocate the
development of an _optional_ DOM module to support it, tho' not
necessarily overseen by the DOM WG.
This isn't a new idea. A significant part of Level 2 could, in
principle, have been implemented externally to the DOM Level 1
API, but with unacceptable performance implications. One of the
main motivations for introducing optional modules was precisely
to avoid that problem.
Cheers,
Miles
Miles Sabin Cromwell Media
Internet Systems Architect 5/6 Glenthorne Mews
msabin@cromwellmedia.com http://www.cromwellmedia.com/
Scott Boag wrote,
Here's an argument for your side:
void foo(Node n1, Node n2)
NodeIterator n1i = ((XPath)n1).locate("name/address", ...);
// uses your implementation
NodeIterator n2i = ((XPath)n2).locate("name/address", ...);
// uses my implementation
i.e. in this case, the method didn't know or care which
implementation it was using. Using an external
implementations would make this harder, as you would have to
match the Node implemenation to the XPath implementation.
That's the sort of thing I'd been thinking about. But: the only
thing I'm committed to is delegating the query to the
_implementation_. Whether that's done by invoking a method on
Node, or via some other route is far less important.
You could have something like:
[snip: DOMImplementation based method]
Which is way ugly. As compared to:
[snip: Node based method]
How about a Document based variant,
if(node.getOwnerDocument().supports("http://www.w3.org/TR/xpath"))
DocumentXPath doc = (DocumentXPath)node.getOwnerDocument();
XPathQuery query = doc.createQuery("name/address");
NodeIterator ni1 = query.execute(node, someContext);
// etc.
// try again with a diffent root Node and context but
// same query instance (allows implementation to compile
// query and reuse).
NodeIterator ni2 = query.execute(otherNode, someOtherContext);
// etc.
Remind me what the context was supposed to be for.
I don't follow. If you have an XPath implementation you're
free to support Level 1 DOMs whatever happens in Level 3.
Equally you're free to use that XPath implementation in the
implementation of any Level 3 XPath query API. I don't think
anyone was suggesting that you'd _have_ to have an XPath
implementation which could _only_ be used with exactly one
DOM.
Or am I missing something?
Cheers,
Miles
Miles Sabin Cromwell Media
Internet Systems Architect 5/6 Glenthorne Mews
msabin@cromwellmedia.com http://www.cromwellmedia.com/
