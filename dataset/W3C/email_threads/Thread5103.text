Short reply for now: awesome :)
Excellent.
One way of doing so would be for you to join the list and add
Done.
I have also started to move the src tree over to dev.w3.org CVS where
it is easier to support additional collaboration. Re licensing, the
main thing is that code be available under the W3C Software License; I
believe we are ok with distributing stuff (c) by others, so long as
the license terms are compatible.
Sounds good to me. I just want to make it work, and have SW stuff
actually get deployed.
Damian has worked on a new Squish++ implementation that does optional
clauses, and also has some patches to the core RubyRdf stuff. I suggest
we have a chat (on the public list) about all this before you spend too
much time on the current code. My stuff was always a bit rough, but
I think there is now the basics of an interesting system falling into
place: we have query engines, SQL backends, a half-decent RDF parser,
etc. but plenty of room for improvements.
Yeah -- the code is functioning but ugly. Functioning is what other RDF
projects often lack in my experience, though.
I'm not sure as to the state of the SQL support -- I've found basicrdf's
Graph#toSQL, but dumping the entire graph from memory to SQL as fresh
insert statements seems counterproductive to me. Am I missing a greater
part of the interface?
I've not made heads nor tails of RDF4R yet -- just the basicrdf
library. I'm planning to run the whole thing through rbbr and rdoc and
browse a little more intelligently than my survey so far. All I know is
that my sixth sense for what project is most promising says "RubyRdf".
I'd be very happy to collaborate with you on this, anyway. Re alternate
backends, I've had MySQL working OK btw., but am generally more focussed
on Postgres. SQLLite would be interesting certainly.
Alright. For Ruby, using the DBI layer might make the most sense,
though I'm using SQLite directly at the moment.
Dave Beckett's redland is now quite nicely packaged with Ruby wrappers,
so there is work we could do there too. So many things to do, so little
time... ;)
There's plenty to do there. I compiled redland and the ruby module the
other day, and was less than impressed by the API. It's about as
un-ruby as one can get -- it's basically the C API wrapped into Ruby,
hardly object-oriented. It might be okay to /use/, but extending it in
Ruby isn't going to fly without some major wrapping of the core API.
I'd love to see the API reworked into a proper Ruby module, with all the
namespaces sorted out and planned support for inheritance added.
Let's move this onto the new list and see whether we can get started...
Alright!
Dan
ps. damian do you have a url for your fixed-up version?
Yes, please, Damian!
Ari
Ah, finally some traffic on this list! :)
My stuff was always a bit rough,
Yeah, that was one of the reasons I've decided to write my own RDF
storage for Samizdat instead of hacking RubyRdf for my needs: I just
couldn't force myself to lay hands on that code ;-)
but I think there is now the basics of an interesting system falling
into place: we have query engines, SQL backends, a half-decent RDF
parser, etc. but plenty of room for improvements.
Agreed. One thing in particular I would like to see is decoupling of all
these components and development of a common RDF API for Ruby. And then
have different projects such as RubyRdf, Redland, Samizdat, map to
different parts of this API.
Hm, why don't you take a look into Samizdat then? It doesn't need rbbr
to grasp: the whole storage module is less than 500 lines :)
And it is functioning (being the basis for a real project), and its SQL
support is fairly advanced (being the core of the RDF storage).
I'd be very happy to collaborate with you on this, anyway. Re
alternate backends, I've had MySQL working OK btw., but am generally
more focussed on Postgres. SQLLite would be interesting certainly.
In Samizdat, I also use DBI, although, since I develop on Postgres, I'm
using some Postgres-specific constructs. I know that it won't be
possible to port it to MySQL (triggers, transactions, and subqueries),
but I don't know enough about SQLite to check what may be missing there.
Dave Beckett's redland is now quite nicely packaged with Ruby
wrappers, so there is work we could do there too. So many things to
do, so little time... ;)
I think first we need to agree on what common RDF API for Ruby should
look like?
Dmitry Borodaenko
Yes yes! I'll be posting more in a couple days after I figure out a
technical issue with the GUI side of my project, so I can focus again on
the metadatabase parts.
My stuff was always a bit rough,
Not so bad, but then, I'm comparing to what I have to write in PHP at
times. Now /that/ is an inelegant language.
but I think there is now the basics of an interesting system falling
into place: we have query engines, SQL backends, a half-decent RDF
parser, etc. but plenty of room for improvements.
I, too, would like to see this.
The OO Graph/Statement/Node approach is a good start. Being able to say
RedlandStore.new("file.rdf").store(Samizdat.ask(nil, nil, nil))
or equivalent would be killer -- common APIs for Node and Statement
enough that perhaps only Graph is implementation specific, and even that
would have enough of a common API that pretending they're the same would
work.
Yeah, but it's postgres-only, and there's a lot of plpgsql code that I
don't quite grok yet in there.
Good deal. I'll at least watch it for ideas.
I'd be very happy to collaborate with you on this, anyway. Re
alternate backends, I've had MySQL working OK btw., but am generally
more focussed on Postgres. SQLLite would be interesting certainly.
SQLite doesn't do any stored procedures, though it does have limited
triggers. It's amazingly complete, actually. I was surprised.
Dave Beckett's redland is now quite nicely packaged with Ruby
wrappers, so there is work we could do there too. So many things to
do, so little time... ;)
Or just evolve it until some consensus is reached. Each do what makes
life easy for them, and eventually, one or two Right Ways will show up.
Then, in usual ruby fashion, do both.
* Aredridel aredridel@nbtsc.org [2003-09-11 16:47-0600]
welcome everyone!
cool, look fwd to it
My stuff was always a bit rough,
but I think there is now the basics of an interesting system falling
into place: we have query engines, SQL backends, a half-decent RDF
parser, etc. but plenty of room for improvements.
Yes, hopefully we can figure out some lightweight commonalities that
allow different RDF-based tools to communicate. When I integrated the
RDF4R parser in a big hurry I hacked the two libraries together in a
pretty rough way. That experience was one of the reasons for setting up
this list...
Good example.
Something like that should work. There are a few subtleties around Node,
eg. whether to allow a graph/datasource to be attached, how to handle
interning etc. if there is a graph, etc.
RubyRdf was my 'teach myself Ruby' project. My first RDF work was in
Java, ~1998 and what survives of that is now in Libby Miller's Inkling
package. I then made various things in Perl, mainly playing around with
Node-centric APIs to see if RDF could be made super-simple looking in
languages that allowed methods to be 'faked' at runtime. Then while dispairing
of Perl I stumbled across Ruby... When I move RubyRdf into dev.w3.org
I'll rejig things a little, as it has grown rather awkwardly during
occasional snatched hacking sessions.
(I'm interested especially in Samizdat's extensions to Squish, and will try to get a copy
installed here to play with. Also the IndyMedia connection is
interesting, but that's another story :)
FWIW RubyRdf's SQL backend works with MySQL and with PostgreSQL. Haven't
had anything else to try it on. http://www.w3.org/2001/12/rubyrdf/db/
has the respective init scripts (I couldn't find a way to initialize
databasese through DBI in a generic manner, btw).
I'd be very happy to collaborate with you on this, anyway. Re
alternate backends, I've had MySQL working OK btw., but am generally
more focussed on Postgres. SQLLite would be interesting certainly.
I've heard good things about SQLLite...
Dave Beckett's redland is now quite nicely packaged with Ruby
wrappers, so there is work we could do there too. So many things to
do, so little time... ;)
Yes, and we can't really complain to Dave -- he has 7 language
interfaces to maintain, even as Redland itself evolves. It is worth
noting that Redland's Python API was recently improved to be more
Python-friendly, and I've talked a bit to Dave about doing the same
thing w/ the Ruby version if/when consensus emerges about an appropriate
API.
Yes!
Heh, I had an idea in that fashion: a 'pastiche' module which includes
methods named after the other major / well known RDF APIs... Jena,
Redland, RdfLib, Cwm, ...
I started this w/ Cwm to learn TimBL's APIs (which have subsequently
changed), see
In general we would do well to look at the Python RDF APIs, since
the languages are reasonably close. I suggest Redland-python, Rdflib,
Cwm and TRAMP would be a good start...
There are also a few reports from our SWAD-Europe project which might be
useful background reading on APIs, query language convergence, and on
RDBMS storage:
hope this helps,
Dan
Only a short reply for now.
This PL/pgSQL stuff is not that scary :)
The only thing that is absolutely required is the "insert_resource" and
"delete_resource" triggers: since all "internal resource" table records
are resources and have their ids refer to the Resource table, I have to
insert new Resource record each time new record in some of these tables
appears, so that one id sequence is used for all resources.
Without this, I wouldn't be able to combine internal and and ordinary
triple-style properties for one resource, not to mention that Statement
table also uses the same id sequence, and that's how statements are
automatically reified.
I took a quick look at the SQLite docs, and I haven't found any mention
of triggers, and, from initial impression, it wouldn't be possible to
repeat that trick in SQLite.
The remaining proposition and rating triggers are there for performance
reasons only, I could as well compute everything that they produce on
the fly.
Dmitry Borodaenko
Late is better than never... :)
I was reading "Enabling Semantic Web Programming by Integrating RDF and
Common Lisp" by Ora Lassila and thought that similar approach should
work in Ruby. That is:
class Node
def initialize(uri=nil)
@uri = uri
end
def [](property)
node = Dictionary[property] if
property.class != Node and property =~ URI::REGEXP::URI_REF
triple = db[ Triple.new(node, self, nil) ]
triple.object
end
end
class Dictionary
include Singleton
def initialize
@dict = {}
@ns = {}
end
attr_reader :ns
def [](uri)
@dict[ ns_expand(uri) ]
end
end
class Triple
def initialize(p, s, o, source=nil)
end
attr_accessor :predicate, :subject, :object, :source
end
class DB
def initialize(db=SamizdatRDF.new(nil))
@db = db
end
def [](pattern, limit=nil)
case pattern
when Triple # single-triple pattern
when Array # multi-triple pattern
when SquishQuery # parsed Squish query
when String # non-parsed Squish query
end
end
def []=(pattern, values)
end
end
I hope there are no objections to the proposed (ab)use of square
brackets :)
Most controversial part of this proposal is the ordering of (predicate,
subject, object). It seems to be more popular to put predicate in the
middle, but I like the (p, s, o) order used in Squish better: prefix
notation is more widespread in computer languages, and it reflects that
p is more restricted than s, which in turn is more restricted than o (in
non-reified statement, p is restricted to uriref, while s can also be a
blank node, and o can also be a literal).
How to deal with extensions of RDF concepts such as Triple#source and
Dictionary#ns ? This begs for an optional part of API, but it can get
really complicated to track all possible cases of when these optional
features are or aren't implemented.
Behaviour of DB#[] and DB#[]= is not as obvious as the rest of the API.
I am in favor of following DQL (DAML Query Language) semantics as the
most consistent abstract RDF query specification out there. Are there
any other suggestions?
And I don't like Ora's use of DB class name: I would rather leave DB for
SQL databases, and have this class named RDF, or KB (knowledge base), or
something else. As Matz says in his excellent talk at OSCON, choosing
right names is very important. What name would unambiguously pin down
this concept?
Dmitry Borodaenko
