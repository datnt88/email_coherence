[This was meant for the least -- ange]
------- Forwarded Message
Date: Sat, 02 Mar 1996 18:59:36 -0500
From: hallam@w3.org
Subject: Netscape Bug or KeepAlive Feature ?
I have been looking into the action of posting forms.
POST / HTTP/1.0
Referer: http://************
Connection: Keep-Alive
User-Agent: Mozilla/2.0b6a (X11; I; OSF1 V3.2 alpha)
Host: zorch.w3.org:5000
Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
Content-type: application/x-www-form-urlencoded
Content-length: 36
action=Submit&amp;text=This+is+some+data
Now by my reconing the final CRLF is bogus. I would expect the next
transaction to start. The HTTP/1.1 spec does not require a trailing
CRLF and the entity is precisely 36 bytes:-
action=Submit&amp;text=This+is+some+data
123456789012345678901234567890123456
This is worrying me, is there a plan to permit footers on keepalive
transactions and the CRLF is simply an artifact of that. Or is there
a "feature" here that people have been writing code ?
I got the same result from Mosaic:
POST / HTTP/1.0
Accept: */*, q=0.300
Accept: text/plain
Accept: text/html
User-Agent: Spyglass_Mosaic/2.10 OSF1V2.0 Spyglass/9
Accept-Language: en
Connection: Keep-Alive
Referer: http://www.w3.org/pub/WWW/WIT/Specification/entry.html
Content-type: application/x-www-form-urlencoded
Content-length: 36
Extension: Security/Digest
Extension: Payment/FirstVirtual
text=This+is+some+data&amp;action=Submit
Is this simply me misreading the 1.1 spec or have we got an issue
here? It would be "upsetting" to discover that forms handling programs
were dependent on a bogus trailing CRLF to teminate a www-form-urlencoded
data item.
Phill
[Isn't it nice to be able to get some coding done with everyone at the
IETF :-) ]
------- End of Forwarded Message
Yes, existing form handlers were dependent on that trailing CRLF, and
that's why it was added to Netscape. I'm wondering if it would break
anything if the content-length was just incremented by two.
Cheers,
Ari Luotonenari@netscape.com
Netscape Communications Corp.http://home.netscape.com/people/ari/
501 East Middlefield Road
Mountain View, CA 94043, USANetscape Server Development Team
My vote would be to do this. We will have to resolve the problem one way or
another to make keepalive work.
After all the form encoding is a bit of a hack in any case.
Phill
The extra CRLF is sent to fix bugs in cgi programs. The
problem stems from the use of PERL to parse cgi input.
If you use a getline function it will only return data
at every CRLF boundary. If browsers don't send a final
CRLF at the end of the post data, many cgi programs will
never get the data since the post data does not normally
contain a CRLF at the end.
Perhaps we can do something to fix this for the 1.1 draft
so that we can stop sending the extra CRLF.
:lou
Lou Montulli http://www.netscape.com/people/montulli/
Netscape Communications Corp.
I think it would break binary files in weird ways. For instance
transfering an executable would cause it to gain 2 bytes on
every transfer. It would certainly break anything that contained
a checksum.
:lou
Lou Montulli http://www.netscape.com/people/montulli/
Netscape Communications Corp.
As I said to Ari, I don't really care about CRLF or not CRLF. We can add any
number of bytes at the ent of the URI and it does not much bother me.
What bothers me is that the content-length given is wrong. If we rewrite the
www-uri-encoded-form spec to allow (sounds as if we need to require) trailing
CRLF and give the size of the message as the complete chunk up to and including
the CRLF.
I know this sounds picky but that is what stards are about:-)
Phill
I wasn't suggesting this. I was suggesting that we change the
spec for www-url-encoded-form. I would not want to change the way
binary files are transmitted!
The problem is that netscape is saying it is sending a content length of 36
bytes but actually transfering 38. This is a bug IMHO. Whenever a length of 36
is stated it should mean 36.
If Netscape is sending a bogus CRLF after binary files then I would expect
problems to arise in any case.
Phill
Perl's getline (or STDIN , etc) uses both CRLF or EOF - when a server is
receiving POST data, and it has received as many bytes as the content-length
header says it should have received, doesn't the server close the stdin pipe
to the CGI script? Or is it left up to the CGI script to start responding
autonomously?
Brian
brian@organic.com brian@hyperreal.com http://www.[hyperreal,organic].com/
I agree.
By the way, I encountered this last Fall while working out the keep-alive
support in WebSite 1.1. My solution was to accept blank lines prior to the
start of the next HTTP request.
My implementations also accept blank lines before the start of the next request.
However lets be really clear. When you say Content length the data stream
must be exactelly as follows: (Note: I am making each CR and LF explicit.
Ignore line endings, they are just for convenience)
POST / HTTP/1.1
Content-Length: X CR LF
More-Headers: yyyy CR LF
GET / HTTP/1.1
etc...
NOTE: The GET is the second request.
The following is non-compliant with every current proposal (Please fix this
for HTTP 1.1 implementations!)
POST / HTTP/1.1
Content-Length: X CR LF
More-Headers: yyyy CR LF
GET / HTTP/1.1
Alex Hopmann
ResNova Software, Inc.
hopmann@holonet.net
Well, my client's staff and I have spend something between 40 and 200
person hours tracking down and resolving a problem in our server like
product caused by these two bytes which we didn't realize existed.
If only I'd been current on my e'mail ....  -:). The symptom was that
our code running on Win/95's winsock would leave the two bytes hanging
and close the connection. Since the winsock stack would know it had
two unreceived bytes, it would apparently do a RST instead of FIN.
This resulted in NETSCAPE complaining about the connection being
reset by the peer.
Interstingly, if we inserted a delay before the close, then apparently
NETSCAPE would close first and never complain. I have no idea what
stimulated the thought that it might be outstanding receive data
which caused the problem we were seeing but we tried alomst everything
else first.
In summary, I'm not sure it would be practical to change the content
length or remove the characters but their existance surely *MUST* be
documented, and if perchance we have to make more edits on 1.0 we
should add a comment there as well.
My inclination is to document the content as being followed by optional
trailers whose end is indicated by a NULL line. Current programs and CGIS
keep working and new applications which might expect such trailers
can work as well.
perl code *CAN* be written to not require trailing CR/LF but it is
more complex so new applications could be made to work.
Dave Morris
[tail* of woe deleted]
This does not work because there are still a large number of clients which
read until the close of connection. Footers can incorporate whitespace but text
characters would appear en-screen.
I would like to see footers on all messages but I think that this is only
currently practical with chunked :-(
Perhaps we simply define messages as having optional CRLF sequences for the time
being.
Phill
[*Geddit?]
