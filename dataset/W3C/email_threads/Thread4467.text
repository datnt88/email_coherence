In message
Divison of decimal numbers is not well specified. There are two aspects of
the problem:
1. How many fraction digits should be kept? For example, what is the
result of 1.0 div 3.0?
2. Should the answer be rounded or truncated?
I have been told previously that the answer is "implementation defined", but
it's hard for me to accept arithmetic that is "implementation defined".
Since I am chairman of the OASIS XSLT Conformance committee, I would like to
be able to produce a test suite that expects known answers to numerical
operations.
I have a suggestion:
For XSLT processors which are schema-aware, it is possible to specify the
number of fraction digits in the result from any operation. In this case,
my first question has a clear answer. I propose that some mechanism be
added to XSLT so that, even without schemas, the number of fraction digits
can be specified. I believe that this would solve my problem, and that,
along with a statement in the spec about rounding, it would make decimal
arithmetic precise, as it should be.
Because this is an F&amp;O comment but was raised against XSLT, we haven't
really got round to discussing it properly yet. We clearly need to do so.
Section 6.2.4 (op:numeric-divide) currently says nothing about decimal
division, not even that the results are implementation defined.
I would like to offer the following suggestion for a more interoperable
definition of decimal division:
If the types of $arg1 and $arg2 are xs:integer or xs:decimal, then the
result is of type xs:decimal. The precision of the result is
implementation-defined, but it must be not be less than min((18, max((p1,
p2)), R)) digits, where p1 is the precision of $arg1, p2 is the precision of
$arg2, and R is the number of digits (possibly infinite) required to
represent the exact mathematical result. "Precision" here means the total
number of significant decimal digits in the value; all digits are considered
significant other than leading zeros before the decimal point and trailing
zeros after the decimal point. If rounding is necessary, the value must be
rounded towards zero. Handling of overflow and underflow is defined in
section 6.2.
Michael Kay
(personal contribution)
Hi Mike,
Using the precision of the two arguments to determine the precision of
the result leads to results that I find strange. For example:
1 div 3 = 0.3
1000000 div 3000000 = 0.3333333
0.00001 div 0.00003 = 0.33333
It would make a lot more sense to me to just use min((18, R)), but any
definition here is better than none. What cases were you thinking of
that led you to suggest using the precision of the arguments to
determine the precision of the result?
Cheers,
Jeni
Jeni Tennison
You're right, the formula doesn't work in these cases. The cases I was
thinking of are where p1 or p2 are  18, which would mean the correct formula
is
min((max((18, p1, p2)), R))
Michael Kay
