For those who are interested, the latest incarnation of the
RDF Datatyping WD can be found at
Cheers,
Patrick
$Date: 2002/04/11 12:35:11 $
Hmm... on the one hand, I have been looking at each
draft saying "well, it doesn't have the use case
examples, and that's all I care about; I'll read
the next one."
But then I peeked into this one... and I mostly
like what I see.
For my money, it's good enough for 1st WD.
If they editors (Stickler/Hayes/Melnick)
are happy to publish it with their
names on it, I'm happy to see it go out.
Dan Connolly, W3C http://www.w3.org/People/Connolly/
this sounds like a union...
and I don't see that as explained in
and as I still think we should have
rdfd:range rdfs:subPropertyOf rdfs:range .
I would not recommend that. That would re-introduce all the
range-inheritance problems assocaited with datatyping. The basic idea
of the current proposal is to keep range-assignment (ie rdfs:Range)
and datatyping (rdfd:Range) quite separate, so you can have either
one without the other (or both if you choose to). That is the only
way I can see to allow the kind of Dublin-Core sloppiness in a
rational framework.
agreed, we currently have something like
and a testcase like
( http://www.agfa.com/w3c/n3/p7.nt
http://www.w3.org/2002/rdf-datatyping# )
log:entails
http://www.agfa.com/w3c/n3/p8.nt .
Jos
this sounds like a union...
and I don't see that as explained in
and as I still think we should have
rdfd:range rdfs:subPropertyOf rdfs:range .
I would not recommend that. That would re-introduce all the
range-inheritance problems assocaited with datatyping. The basic idea
of the current proposal is to keep range-assignment (ie rdfs:Range)
and datatyping (rdfd:Range) quite separate, so you can have either
one without the other (or both if you choose to). That is the only
way I can see to allow the kind of Dublin-Core sloppiness in a
rational framework.
Right. Though, not meaning to shake things up... ;-)
Rules 2, 3, 5a, and 5b in the above have been removed in
the latest draft and a new rule added (see below).
Rule 3 above follows from the rdfs:range of
rdfd:datatype defined in Rule 0, and thus is
unnecessary.
Rules 2, 5a and 5b have been removed. Both because they
are unnecessary insofar as the datatyping interpretation
is concerned and also because while all three idioms
may all identify the same datatyped literal pairing,
they do not have identical meaning.
It is similar to the well known "morning star" versus
"evening star" example, where both identify the same thing
but do not really have identical meaning. One idiom thus
does not imply another idiom as their total meaning will
not be the same.
The present rules, as defined in the current revision of
the WD are:
### rules for RDFD entailment
@prefix log: http://www.w3.org/2000/10/swap/log# .
@prefix rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns# .
@prefix rdfs: http://www.w3.org/2000/01/rdf-schema# .
@prefix rdfd: http://www.w3.org/2002/rdf-datatyping# .
@prefix : rdfd-rules# .
# :rule0 (same as before)
rdfd:Datatype a rdfs:Class;
rdfs:subClassOf rdf:Property .
rdfd:datatype a rdf:Property;
rdfs:domain rdf:Property;
rdfs:range rdfd:Datatype.
rdfd:lex a rdf:Property;
rdfs:domain rdfs:Resource;
rdfs:range rdfs:Literal .
:rule1 .
?d a rdfd:Datatype
log:implies
?d rdfs:domain ?d ;
rdfs:subPropertyOf rdfd:lex # added this
:rule2 . # in addition to above, addresses type
# inferences for blank node values
?p rdfd:datatype ?d .
?s ?p ?o .
?o rdfd:lex ?l
log:implies
?o rdf:type ?d
How do those work? ;-)
Cheers,
Patrick
this sounds like a union...
and I don't see that as explained in
and as I still think we should have
rdfd:range rdfs:subPropertyOf rdfs:range .
I would not recommend that. That would re-introduce all the
range-inheritance problems assocaited with datatyping. The basic idea
of the current proposal is to keep range-assignment (ie rdfs:Range)
and datatyping (rdfd:Range) quite separate, so you can have either
one without the other (or both if you choose to). That is the only
way I can see to allow the kind of Dublin-Core sloppiness in a
rational framework.
Oh, bad reasoning. We have an extensional language here, so we
shouldnt be invoking intensional examples to block valid inferences.
BUt since I can no longer see rules 5a/b, I don't know what the point
was here :-)
Not sure that is a good idea. I had this in an earlier version and
took it out, for a technical reason that I can now no longer
reconstruct exactly. I know it caused trouble, though. Its not
strictly valid according to the current MT, in any case (since the
semantic conditions on subProperty are not iff, just if), so I'd lean
to omitting it.
Let me get back to you on this.
Pat
IHMC(850)434 8903 home
40 South Alcaniz St.(850)202 4416 office
phayes@ai.uwf.edu
