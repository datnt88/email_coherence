I have been asked to communicate to this group the HTML Working Group's
feelings about using XPointer to index into HTML (i.e. the SGML version, not
XHTML). As I understand it, it is particularly in reference to elements such
as tbody which may or may not be in the markup.
The group discussed this topic recently. Many thanks to Masayasu Ishikawa
for his comments, many of which are echoed here.
We understand the motivation for wanting to annotate HTML. But:
Firstly a technical caveat: The abstract to XPointer says that it's for "a
resource whose Internet media type is one of text/xml, application/xml,
text/xml-external-parsed-entity, or application/xml-external-parsed-entity".
Unless we update RFC 2854, "XPointer for HTML" would be non-conformant.
(http://www.w3.org/TR/2001/CR-xptr-20010911/#abstract)
Secondly, an observation: most HTML documents are seriously broken. Trying
to create a robust mapping from broken HTML to XML is a minefield we do not
wish to step on.
Thirdly, because of the difference between XML and SGML, XHTML and HTML have
different but compatible content models. This means that an XHTML document
served as text/html will have a different parse tree to that of the
physically same document served as text/xml or application/xhtml+xml. This
means that depending on the mime type you would need different XPointers to
get to the same element.
However, if you persist, let us observe that the DTD for HTML 4.01 says of
tbody :
!ELEMENT TABLE - -
(CAPTION?, (COL*|COLGROUP*), THEAD?, TFOOT?, TBODY+)
(http://www.w3.org/TR/html401/struct/tables.html#edef-TBODY)
This says that tbody is an element with optional begin and end tags. This
means that whether or not tbody is present in the markup, it is present in
the document, and therefore in the tree.
On the other hand, the DTD for XHTML says:
!ELEMENT table (caption?, (col*|colgroup*), thead?, tfoot?,
(tbody+|tr+))
(http://www.w3.org/MarkUp/Group/2002/REC-xhtml1-20020301/dtds.html#a_dtd_XHT
ML-1.0-Strict)
This says that tbody is an optional element: if it is not in the markup it
is not in the tree.
(We had to do it this way, because XML does not give you optional tags).
Therefore the answer to the question "what should an XPointer into HTML look
like?" is a very loud "it depends".
Best wishes,
Steven Pemberton
Chair, W3C HTML Working Group
"Steven Pemberton" steven.pemberton@cwi.nl
"a
application/xml-external-parsed-entity".
So no matter about HTML documents, XHTML ones can't be annotated either?
(RFC 3236 defines application/xhtml+xml )
Trying
not
but neither is such a thing necessary to be able to use XPointer like
constructs on HTML documents, as you say, they are obviously not
XPointers because XPointers are only defined on XML documents (and even
then on a very restricted set of MIME-types.) All you need to do is be
able to indentify elements in the parse tree, XPointer like syntax is
good for this, especially if the document has id's.
There are of course other problems with XPointer, that to me have much
more serious implications than this, that of what a URI points to, is not
a particular XML representation so can't have an XPointer dangling off of
it, it's a Resource, which may contain all sorts of different things,
including non XML representations.
have
document
This
XPointers to
Well of course you would, they're different documents! However if the
Pointer is
xpointer(id('Moomin')) then it will happily point to the same element
within the Resource (assuming the resources are appropriately authored,
and content negotiation on the document returned from the URI is
logical.)
of
markup it
tags).
look
This seems very confused to me, in one part you define xpointer to only
work with the idea that a URI returns a particular document (not a
particular resource) and now you argue against xpointers in HTML
documents by comparing them with XHTML - the differences betwenn XHTML
and HTML are irrelevant to the purposes of XPointers in HTML - in HTML,
we know there's a TBODY in the parse tree, in an XHTML document we know
there's not unless it's in the source document. Those differences are
irrelevant to whether you can point to a particular part of an HTML parse
tree.
The question is not how does XPointer into HTML compare to XPointer into
XHTML, but can we point to something in an HTML document?
Jim.
XHTML may also be served as text/xml, so in that case XPointer can be used.
As Masayasu points out, XPointer needs to be updated to refer to RFC 3023.
If the document has id's then you can just use a URI, problem solved. But I
thought a more general solution was being sought.
the
No, the same document, served with different media types. It is the same
document, but the result of the media types means it gets parsed
differently.
As I said, if the document has ids, the problem is solved.
I'm sorry if I said something that upset you. I don't know what I said to
engender such rancour.
I was asked to comment on using XPointer into HTML, especially in the
context of TBODY.
If that is not the problem, I will keep quiet.
Best wishes,
Steven Pemberton
Chair, W3C HTML Working Group
"Steven Pemberton" steven.pemberton@cwi.nl
But I
Having id's makes pointing to a child of an element with an id or a range
within elements with id's more reliable, obviously if you're pointing to
just an id it's trivial as you say.
same
Can you have an xhtml1.1 document that is served as text/html ? If not
the point is of somewhat historical interest as we're talking about a
subset of xhtml 1.0 documents are we not?
authored,
No it is not, by your argument
different fragment depending on whether the resource has an xhtml or html
mime-type.
only
XHTML
HTML,
know
are
parse
into
to
You've said nothing to upset me - but your confused arguments over
XPointer and HTML have left more questions (many of which have been
raised before, and gone un-answered) than answers - A large number of
comments on XPointers have arisen in the thread, perhaps rather than
limit yourself to commenting on XPointer into HTML and the context of
TBODY you could comment on all the issues raised - those are the ones
that are actually concerning www-annotation and wai-er after all.
Jim.
Please be careful with terminology here: a URI plus fragment ID is a
URI-reference, according to the BNF and terminology used in RFC 2396
[1].
Of course. A better question is whether XHTML 1.1 served as either
text/html, text/xml, or application/xhtml+xml makes any sense; but
that's out of scope for this discussion, I feel.
Perhaps. If it's sent as text/xml (or any of the MIME types covered by
XPointer), then if there's a Moomin ID declared, then it points to
that fragment of content. If on the other hand it's sent as a MIME
type not covered by XPointer, then it's basically going to point to
something "undefined".
The URI specification [URI] notes that the semantics of a fragment
identifier (part of a URI after a "#") is a property of the data
resulting from a retrieval action, and that the format and
interpretation of fragment identifiers is dependent on the media
type
of the retrieval result.
For documents labeled as text/html, the fragment identifier
designates the correspondingly named element; any element may be
named with the "id" attribute, and A, APPLET, FRAME, IFRAME, IMG
and
MAP elements may be named with a "name" attribute. This is
described
in detail in [HTML40] section 12.
]]] - http://www.ietf.org/rfc/rfc2854.txt
If a document is served as text/html and the fragment that you wish to
identify is not named in the aforementioned manner, then you can't
point to it; it's as simple as that.
But the argument isn't as clear cut as that, as we all know. text/html
and text/xml representations can be served together as variants of a
single resource. In this case, the URI-ref:-
Is utterly broken. The semantics of the URI-ref seem to depend greatly
upon a retrieval action, and in this case, the semantics of the
XPointer change depending upon one's accept headers. Accepting
text/html means that the pointer is undefined, and accepting text/xml
means that the pointer is defined.
This is a problem with XPointer - it doesn't work very well with
conventional HTTP machinery that has been around for years. Or rather,
it only works when you necessarily limit yourself to sending a single
(and perhaps fixed) variant. Many people believe that fragments must
be persistent; in the case of XPointer, that means that your XML
document had better not change one iota. So, if you want to use
XPointer, you have to do so on a resource that has a single fixed XML
representation. That's absurd.
So, now you want to create a similar scheme for HTML. Now, since I've
been working with you on the EARL project, I certainly understand what
the rationale behind this is :-) We need to be able to refer to pieces
of HTML documents in order to say things about them - perhaps in the
context of an EARL eevaluation, or perhaps outside of it. Using some
kind of pointer mechanism would be fine if (as noted above) people
were constrained to sending their HTML document without any variants,
and without changing the document in such a way that would break the
HTML pointer.
And really I'm just clarifying for the sake of people external to this
discussion who may lack the context. Jim, I remember you saying to me
that the requirement for HTML pointer is simply of being able to
point into a *single* representation of HTML, and that the requirement
for XPointer is of being able to point into a single represenation of
XML. But many people don't seem to get it, and that's a bit of a
shame, so it needs to be underlined at every opportunity.
So the answer to your question is that, yes, the generic idea of an
HTML pointer is good, useful, and architectually sound, but that one
shouldn't abuse it in the manner that XPointer have abused theirs. In
fact, you can't abuse HTML pointer since there is no way that you can
make an amendment to the HTML media type RFC. Win-win.
As for the canonicalization issues, that's a tough one. As Steven has
pointed out, some HTML document are just so broken that even HTML tidy
throws up all over them. OTOH, some documents are valid HTML, and for
those a regular HTML pointer is certainly possible, given work.
So, I suggest that you might want to look into the following
algorithm:-
1) If the representation validates according to one of the standard
HTML DTDs, then use a standard canonicalization, and an HTML pointer.
2) If the representation doesn't validate, then you have two choices:-
2a) Attempt to canonicalize it anyway, and use an HTML pointer
2b) Point to the piece of information using a column and line number,
a regular expression, or something else based on the reduced hash
experiments that Nick started working on.
I hope that helps.
[1] http://www.ietf.org/rfc/rfc2396.txt
Kindest Regards,
Sean B. Palmer
@prefix : http://purl.org/net/swn# .
:Sean :homepage http://purl.org/net/sbp/ .
