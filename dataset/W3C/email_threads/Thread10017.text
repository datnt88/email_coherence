In one camp, that has been quite quiet of late, we have those who argue that
inline literals should be self denoting.
In another, there are those, (some of whom believe the argument has been won),
who argue that inline literals denote something else, which might be made
clear elsewhere.
Then there also a few voices, myself and Graham, at the last telecon, arguing
for minimalism.
We have seen the tidiness vs untidiness debate as one without a middle ground.
The point of this message is to propose it. (or rather to remind the group of
its existence).
Middle ground:
From datatyping part 1:
Explicit data values in the graph are self denoting.
From Valentines day MT (VMT)
Other literals are syntactically untidy.
Literal semantics depends on a function XL mapping lteral nodes to literal
values.
Nothing is said about whether XL induces a function or not on the literal
labels. i.e. this does not rule out tidy semantics.
Moreover, consider the crucial tidiness entailments.
a foo "literal" .
b bar "literal".
this does not entail
a foo _:b .
b bar _:b .
(in the VMT)
However, this is not because of untidy semantics, but merely because the first
triple by itself is not entailed.
i.e.
a foo "literal" .
does not VMT-entail
a foo _:b
(bnodes don't match literals in the Valentines day MT).
Thus, if we choose the Valentines day MT, we are not ruling out RDF2 choosing
tidy semantics.
We, are old and tired, we already have agreed enough to meet our charter. We
should postpone work on the semantics of inline literals for a new and fresh
working group.
Obviously, I have been an advocate of untidiness for a while; if the grouo has
consensus to go with untidiness, then I clearly would be in favour.
However, I would also be very surprised.
If any of the group cannot live with Part 2, but could accept some sort of
compromise of the sort outlined above, then they would get my support.
Another way to go would be for us to collectively downgrade the tidiness
issue. My take, is that with the values in the graph, the decision for tidy
or untidy is much less pointed. Although I would value the debate, I believe
my position has changed from "cannot live with tidy" to simply a preference
for untidy.
If we all can downgrade our previously strong opinions then a debate and
asimple majority decision would suffice.
Jeremy
Bravo Jeremy.
While I would myself prefer to also have untidy semantics for
inline literals, Jeremy's proposed middle ground of adopting
untidy syntax with unspecified semantics has the significant
benefits of (a) letting us postpone the decision about tidy
vs. untidy semantics, while still (b) providing an abstract
syntax that supports either interpretation.
I wholeheartedly support this proposal, whether or not we
also still decide to consider the semantics of inline literals.
(specific comments below)
[Patrick Stickler, Nokia/Finland, (+358 50) 483 9453, patrick.stickler@nokia.com]
Which I presume would actually be written
a foo _:x"literal" .
b bar _:y"literal" .
Right?
Right.
The nice thing here is that we can choose either tidy or untidy
semantics merely by adding closure rules to the MT, without
any change to the concrete or abstract syntax. Sweet.
Thus, if we want tidy semantics, then we simply assert that
each non-explicitly-typed literal denotes the
unicode string portion of its label. If the graph contains
the node (_:x, "LLL"), then I((_:x, "LLL")) = I("LLL").
And if we want untidy semantics, then we assert that the
systemID portion of a non-expliticly typed literal denotes
some datatype, typically disambiguated by a rdfs:range
assertion, e.g. if the graph contains the triples
ddd rdf:type rdfs:Datatype .
aaa bbb (_:x, "LLL") .
bbb rdfs:range ddd .
then I((_:x, "LLL")) = I((ddd, "LLL"))
Very nice indeed. And we could even pre-specify the extensions to the MT
for the tidy versus untidy interpretations, so that application developers can
have a solid basis to choose one or the other, and a place to point to that
is official, even if non-normative.
If we cannot agree on the semantics of inline literals, then
I think that Part 1 with the above addition of untidy syntax for inline
literals, and pre-defined MT extensions for tidy versus untidy semantics
would be a far more complete and reasonable solution than Part
1 alone, as presently defined.
Though I think we should still give strong consideration to untidy
semantics.
If Part 1 were extended with untidy syntax, and the semantics of
inline literals was left agnostic (allowing applications to assert either
tidy or untidy without running foul of the MT) then I would be
satisfied with that.
I am not, however, prepared to downgrade my position from "cannot
live with tidy semantics" as I feel that tidy semantics of inline (non-typed)
literals is fundamentally wrong.
Regards,
Patrick
I agree with Jeremy in the following points:
(1) At this point, we should aim for the minimum specification that we can
all agree is needed
(2) I have a slight preference for untyped literals being untidy, but that
preference is somewhat lessened by the availability of explicitly typed
literals (rationale: the use of explicit typing pushes many of the
consistency checking issues to being some form, of simple
schema-consistency computation; for the few remaining cases where
long-range typing really is required, the introduction of explicit bNodes
is not such a burden [my interpretation of an observation of Brian's]).
(3) I find very attractive the option of leaving semantics very weak for
untyped literals (in this revision of the spec).
But...
There is one point I think should be considered, though not necessarily as
part of the specification: there are existing applications that use
untyped literals -- if we leave their semantics very weak, then there is a
probable impediment to participation in a "full-strength" semantic web. I
think it might be helpful to outline possible migration paths for these
applications.
Consider CC/PP, which currently recommends constructs like:
intended to interpreted in conjunction with this schema:
rdfs:range
rdf:resource='http://www.w3.org/2001/XMLSchema-datatypes#integer'/
For raster displays, the width of the display in pixels.
and
rdfs:subClassOf
rdf:resource='http://www.w3.org/2000/01/rdf-schema#Literal'/
This class is used to represent any CC/PP attribute value that
is an integer number.
rdfs:seeAlso rdf:resource=
'http://www.w3.org/TR/xmlschema-2/xmlschema-2.html#integer'/
A weak semantics for untyped literals would mean that RDF alone does not
define all of the meaning here that would be gleaned by a specific CC/PP
application, namely that the value of property 'pix-x' is an integer. The
RDF meaning would not be wrong, but it would be incomplete. A more
complete meaning would be available by specifying something like:
ccpp-client:pix-x
rdf:dattype='http://www.w3.org/2001/XMLSchema-datatypes#integer' 1024 /ccpp-client:pix-x
but this would not be compatible with present-day UAPROF and CC/PP
specifications.
The migration path is to point out that the current UAPROF/CCPP is valid
(if complete) RDF, and to recommend that future versions recognize an
explicit datatype attribute.
#g
Graham Klyne
I applaud your efforts and second your opinions.
jan grant, ILRT, University of Bristol. http://www.ilrt.bris.ac.uk/
"No generalised law is without exception." A self-demonstrating axiom.
[Patrick Stickler, Nokia/Finland, (+358 50) 483 9453, patrick.stickler@nokia.com]
I would rather see the migration path for CC/PP and similar, where
the semantics of lexical forms is mandated by fixed property types,
to work via long range typing mechanisms.
I.e., to reflect in RDF what the intended semantics of CC/PP already
is, that every value of pix-x is an integer. Thus:
For ontologies that have strong typing, such as CC/PP, and BTW every
ontology I am aware of in use internally in Nokia, having to specify
the type for every occurrence of a value is (a) grossly redundant,
and (b) hides the fact that the datatype is fixed by property and
that one cannot or should not specify some other type locally.
If RDF cannot officially reflect such long range datatyping semantics,
then at the very least, applications should be free to augment the
RDF MT with such applications specific semantics, which should be
supported by the RDF MT by remaining silent about the meaning of
untyped inline literals.
Cheers,
Patrick
