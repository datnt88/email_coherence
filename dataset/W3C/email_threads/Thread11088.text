Some time ago, James Clark asked why the full array of tree-walking
keywords from the TEI extended-pointer notation was needed for XML
linking, and I was asked by the ERB to provide some account of why I
thought they were desirable.
I should note first that strictly speaking the 'functionality' of
extended pointers -- pointing at SGML elements or spans within SGML
documents -- is completely covered by the DESCENDANT keyword, with a
single numeric parameter. DESCENDANT 42878 refers to the 42,878th
element in the document (the one with the 42,878th start-tag), and if we
limit ourselves to pointing at elements or pointing at spans that begin
and end with elements, everything else is syntactic sugar. Byte offset
is also sufficient, as far as that goes -- in fact, byte offset is more
powerful than DESCENDANT because it handles sub-element addressing.
So no argument for *any* of the keywords can show that any of the
keywords adds new functionality; the TEI keywords that do, namely
PATTERN, TOKEN, STR, SPACE, FOREIGN, have all already been omitted.
On the other hand, no one is arguing for byte offset. Why? It's (a)
fragile, (b) opaque, and (c) given to silent failures. We want
something better than byte offset or DESCENDANT with one argument
(which suffers from the same problems), because we want pointers that
- are easy to understand / comprehensible / expressive
- survive changes to the target document as well as possible
- show signs of failure when they fail
All of the keywords in question (ID, CHILD, DESCENDANT, ANCESTOR,
PREVIOUS, NEXT, PRECEDING, FOLLOWING) serve substantially these same
purposes.
When using natural language to point at texts, we routinely use typed
and untyped counts: the third paragraph of the second chapter, or page
232. Allowing restriction of the tree-traversal keywords by means of GI
and attribute-value pairs as well as counting means that the pointer is
clearer (the second quotation in German, or the second quotation after
the beginning of page 232, is clearer than "the 82305th sentence of the
text") and more robust: a byte offset is broken if even one byte is
added or deleted before the target; a pointer to the second quotation
after the beginning of page 232 is broken only if a Q element is added
between the page boundary and the current second Q -- if the pointer
restricts by language as well, only a new quotation in German will break
the pointer.
No pointer is guaranteed safe forever when it's pointing at a changing
document. But restriction by GI and attribute value, and being able to
traverse the tree in any desired direction, from any point chosen for
its relative stability (page 232 is *not* a good choice in this regard!)
provides much more robust pointers than counters without facilities for
such restrictions.
Counters by themselves are hopelessly fragile.
Why so many ways to walk the tree, though? Well, primarily because in
general the best approach to pointing into changing read-only material
appears to be to point at some stable point and work from there. The
stable point may be the end of a section, or the beginning; it may be an
element with an ID. There is no good way to guarantee that the fixed
point will always be above the target resource in the tree, so CHILD and
DESCENDANT aren't enough; you need ANCESTOR. It's not plausible to
assume that the fixed point is always to the left of the target --
sometimes it will be to the right, so if you have NEXT, you need PREVIOUS.
Some of the keywords are conservative (CHILD, NEXT, PREVIOUS) and are
useful for catching typos (a pointer to NEXT(82) is an error if there
aren't 82 younger siblings of the current location source); I suspect
that for stable documents it might be plausible to work exclusively with
these and ANCESTOR.
But if I want to point at the material on page 23 in a transcription of
Lachmann's edition which is currently being prepared, the most reliable
way to do it is to say "find the first PB N='23' ED='La' and go till
you reach the next PB ED='La' " -- it's more convenient, as well as
more robust, not to have to know exactly how many generations down in
the tree these milestone elements are. A project I am working on
now is preparing documents in a data capture DTD and will translate
them automatically into an archival DTD later; at that time the nesting
level of virtually everything in the documents will change, since the
whole point of the data capture DTD is to have fewer levels and exploit
some regularities in the data. I think it's a strong argument *for*
the TEI keywords that
xptr xml-link='simple'
href="descendant(1,pb,n,23,ed,La)..ditto()following(1,pb,ed,La)"/
will survive that transition, whereas the obvious choice using a
smaller set of keywords
xptr xml-link="simple"
href="child(2)(1)(1)(3)..root()child(2)(1)(2)(2)"/
is almost certain to break; if we add GIs to the parameters we will
hear about the breakage, but it will still break.
To make extended pointers robust, you need keywords that are *not*
limited to single-generation jumps or sibling searches: you need
DESCENDANT, PRECEDING, and FOLLOWING. (Note to those who don't want
to have to look this up: descendant finds elements at any level of
containment; PRECEDING and FOLLOWING search left and right across the
entire tree -- unlike NEXT and PREVIOUS they are *not* limited to the
siblings of their location source. Yes, I know, there's no way to
remember which is PREVIOUS and which is PRECEDING -- better names would
be welcome.) Both functions are needed: PREVIOUS for the case of
pointing into a relatively stable document where you *want* the more
restricted method of counting, to trap errors, and PRECEDING for being
able to cross container boundaries.
I had hoped to produce more concrete examples, but I am running late and
have to curtail this message. So I'll leave it with the page-reference
example: find, at any depth, the first PB with N=23 and ED=La, then
take everything up to the next PB from that edition. Note that the next
PB is not guaranteed to have N=24: page 24 could easily be blank and
not marked with a PB. How do you do this reliably in a target document
subject to change without DESCENDANT, DITTO, and FOLLOWING?
I hope this helps clarify why I want a full set of tree-traversal
keywords. Maybe James is right, and this is sort of a poor-folk's
query language. If so, I suspect it's smaller and easier to implement
than any of the Rich Folk's query languages, and to a really
surprising degree it does get the job done.
-C. M. Sperberg-McQueen
ACH / ACL / ALLC Text Encoding Initiative
University of Illinois at Chicago
tei@uic.edu
All opinions expressed in this note (except those I have quoted from
other authors) are mine. They are not necessarily those of the Text
Encoding Initiative, its executive committee or other participants, its
sponsors, or its funders. Ditto for the Model Editions Partnership
and the University of Illinois, and the XML Editorial Review Board.
Anyone who says otherwise is itching for a fight.
Thanks, you've mostly convinced me.
This is my major concern about having both PRECEDING/FOLLOWING and
NEXT/PREVIOUS. It's going to be very hard for people to remember. This is
especially the case since the TEI meanings for PRECEDING/FOLLOWING are the
opposite of the SDQL meanings:
TEI SDQL
NEXT FOLLOW
PREVIOUS PRECED
PRECEDING BEFORE
FOLLOWING AFTER (currently used only in prose not in a function name)
I notice that the current draft actually defines the TEI terms using the
SDQL terms (was this intentional?):
PREVIOUS selects preceding sibling elements of the location source.
NEXT selects following sibling elements of the location source.
PRECEDING selects elements which appear before the location source.
FOLLOWING selects elements which appear after the location source.
This suggests to me that the TEI choice of terms is not the best. NEXT to
me suggests immediately next not any following sibling; and FOLLOWING to me
doesn't suggest looking at elements that aren't following siblings.
My concrete suggestion would be to drop the terms PRECEDING/FOLLOWING since
SDQL and TEI give them opposite meanings and use PREVIOUS/NEXT/AFTER/BEFORE.
It does. A couple of other issues:
- Why do we need to allow * for the element type name? Why can't we simply
require that all steps include the element type name or *CDATA? This
eliminates the confusion over whether * counts pseudo-elements or not. It
makes my life harder as an implementor to have to support both typed and
untyped counts: making typed and untyped counting efficient requires
different data structures.
- Why do we need * for the attribute name?
- Why do we need * for the attribute value?
- Why do we need *IMPLIED for the attribute value? This is only going to
work in the presence of the DTD.
While I have your attention, I have a couple of other open issues from
earlier messages which I think need considering:
As a footnote to this, I would say that the current rule makes sense when
you're working without a DTD. So I think the rule should be something like:
the matching is case insensitive if
- you're working with a DTD, and the attribute is declared as a case
insensitive type
- the attribute value is unquoted in the pointer (should this apply if the
attribute is declared is explicitly declared to be CDATA?), or
- (maybe) there's a #FOLD keyword present.
James
James wrote, in reply to Michael's clear exposition:
I think that's nearly very good indeed! :-)
I don't think this is any clearer -- without an explanation, I would have
no idea at all that AFTER meant only elements after this one in the same
container, and that NEXT meant the next element in the input, or the
next sibling, or whatever.
I think the right answer is to be specific:
NEXT -- the element whose opening tag occurs next in the input after
the current element's end tag
NEXT SIBLING -- NEXT restricted to the current container
PREVIOUS -- the element whose opening tag occurs most recently
in the input
PREVIOUS SIBLING -- the element whose close tag is immediately
followed by the current element's opening tag.
I can also imagine extending this to include
expr1 IN expr2
where expr1 and expr2 are TEI extended pointer expressions, to mean
expr1 provided that it occurs within the content of expr2, and an
error otherwise.
I am not proposing this feature, as I don't think it addes enough it
practice, except that it seems to me to be the generalisation of
TEI's PREVIOUS and NEXT.
Well, what about the case where it could be any of a number of elements?
For example, I want to link to the first bibliographic citation
in a note element that's inside a PART, but the note could occur either
in a chapter, a section, an appendix or a procudure...
I don't see that -- if you have typed data structures, can't you use
those for untyped links too and ignore the type?
I agree about IMPLIED. I think the other two are useful.
The second is easiest to find examples for: find the first person with
any value for the ROLE attribute. I am not sure you can also find the
first person _without_ a ROLE attribute unless you have *IMPLIED.
* for an attribute name is just as useful as * for an element type.
I can't answer your question on case folding, since I think that
case insensitivity is a bad idea anyway, and all comparisons should be
case sensitive!
Lee
For example, if I was doing only typed counting I might store in the
document for each element type an array of pointers to elements of that type
in the order they occur in the document. Then in each element I might store
the index of that element amongst all elements of is type and the index
amongst all elements in the document. That would allow be to do typed
preceding and following efficiently. But it wouldn't help me with doing
untyped preceding and following efficiently. For that I would also need an
array of pointers to all elements in the order they occur in the document.
You didn't provide any argument for this. I'm not saying you're wrong, but
I don't think it's obvious.
It's easy to implement any of these uses of * slowly, but implementing each
of them efficiently on large documents requires that additional information
be stored. One can dream up cases where one might use any of these, but
this has to be balanced against the implementation cost. Are these uses of
* really part of the "minimum required to declare victory"? Maybe for
element type names they are. But for attribute names?
James
Yikes! How did we all let that happen. Never mind. I kind of like the names
LSIBLING and RSIBLING for the ones that do that. Or, to accommodate other
writing directions, E(lder)SIBLING and Y(ounger)SIBNLING; or N(ext)SIBLING
and P(revious)SIBLING to match the others. I find the terms James proposed
an improvement, but I think it would be even clearer with "SIBLING"
blatently in the name (this may be especially true for ESL speakers who may
lack sprachgefuhl for the subtleties of other terms. Thus I like Lee's
suggestion except for the embedded blanks in the keywords, which would
require tweaking some BNF.
Interesting. TEI strongly recommends using a type, but we didn't feel we
could require it. If the users are willing, I'm fine with that.
These are largely for symmetry and completeness. If all the parameters don't
look as alike as possible, there's more to explan. I doubt people actually
use * for attr name or value. I see James' point re. optimization being
harder if you have to go cache counts of attribute values, etc.
Interesting case. If we make such a change, I should think we'd want it
symmetrically: all keywords would be able to count themselves as a
possibility. The most important case is probably ANCESTOR; I've had
customers who want to refer to the nearest containing element of type X,
whether or not it's where i started. DynaText scripting thus added a
nearest() function for that, as distinct from ancestor() which it already
had but which could never return the element itself. This could be
accomplished by doubling the number of keywords (yech) or adding a parameter
or parameter value.
steve
[... justification for keeping TEI keywords ...]
I'd like to support this - when I demonstrate this facility to people who
haven't seen XML before, and tell them it *comes free with the [draft] language*
they are impressed. It's a very strong selling point over other approaches.
[Of course they ask about regexp :-)].
P.
Peter Murray-Rust, domestic net connection
Virtual School of Molecular Sciences
