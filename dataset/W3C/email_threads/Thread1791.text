From: Julian Reschke [mailto:julian.reschke@greenbytes.de]
From: Clemm, Geoff
Julian didn't like the marshalling of this report, because it
makes it look like the properties are those of the VCR, when they
actually are properties of the version
Yes, that's the problem, and I fear the new format doesn't address
this.
If the multistatus/response format is re-used for a REPORT (basically a
good
thing), it must not break the existing semantics, in particular:
- the properties reported must actually be the properties of the resource
identified by the reported URI (DAV:href) and
- the properties reported actually must be properties (!).
If this is not the case, the response seems to indicate that there's a
DAV:labeled-version-report property, which isn't the case.
If this is a problem, it is a problem with the 3253 definition of REPORT.
In particular, section 3.6 states:
"If a Depth request header is included, the response MUST be a 207
Multi-Status. The request MUST be applied separately to the
collection itself and to all members of the collection that satisfy
the Depth value. The DAV:prop element of a DAV:response for a
given resource MUST contain the requested report for that resource."
So according to 3253, the DAV:prop elements MUST contain the requested
report (as if it were a property).
Since this was not considered a problem during any of the reviews of
3253, I'd need to hear some compelling reasons why this marshalling
has become a problem. In particular, there is no rule that I know of
that states that the interpretation of a DAV:multistatus element must
be the same in all contexts in which it appears. I know that this is
definitely not the case for other XML elements used by WebDAV (e.g.
the way the property elements are used in the request and response
bodies of a PROPPATCH differ significantly).
So how about properly extending the response element, for instance:
That would be fine with me (and arguably is cleaner than what is
defined in 3253), but it is inconsistent with 3253, so unless there
is something seriously wrong with the 3253 marshalling, I think
consistency is more important here than aesthetics.
Cheers,
Geoff
From: Clemm, Geoff
Julian didn't like the marshalling of this report, because it
makes it look like the properties are those of the VCR, when they
actually are properties of the version
good
resource
Good catch. So, taking both RFC3253 and RFC2518 in account, the requested
report must be contained inside DAV:prop, and DAV:prop must contain WebDAV
properties of the resource identified by DAV:href.
This works fine for things like DAV:version-tree, but obviously fails here,
so we need to find a resolution.
*I* didn't consider this a problem because none of the reports defined by
RFC3253 actually breaks RFC2518 semantics -- so everytime the multistatus
format is used, the contents of DAV:prop actually *are* WebDAV properties.
So if the *intent* of the text you quoted is to allow *arbitary* reports to
be marshalled *inside* DAV:prop, why wasn't this feature used by any of the
reports defined in RFC3253 (or ACL)?
That's correct, but I don't think that's the point. When people see a
multistatus response body, up until now they *always* could assume that
something that they see inside DAV:prop actually *is* a WebDAV property of
the resource identified by DAV:href. In particular, one would assume that if
it appear inside a DAV:response/DAV:propstat/DAV:prop element, you can also
query it using PROPFIND.
Besides: every time you define a report-specific element for inclusion into
DAV:prop, you basically block any usage of this name as "real" WebDAV
property. In this particular case, using DAV:labeled-version-report as
"container" element makes it impossible to actually have a property called
DAV:labeled-version-report (and to have it returned by this report). While
this may not seem to be a real-world problem here, it would mean that an
ambiguity is introduced into the namespaces of WebDAV property names --
suddenly there's an overlap with marshalling elements for specific reports.
So why not use a marshalling format that has none of these problems?
...thanks...
Why would that be inconsistent with RFC3253? The format you proposed earlier
definitively is inconsistent with RFC2518, and I'm not aware of another case
in RFC3253 that has this problem.
I think the RFC3253 marshalling as explained by you in seriously
inconsistent with RFC2518 *and* not very aesthetical. I'm happy it hasn't
been used before :-) I have the feeling I'm overseeing something, and I'm
sure you'll educate me...
Geoff,
with the currently proposed format, how does a server marshall information
about failures in retrieving the properties of the selected version (? la
DAV:propstat/DSAV:status in DAV:response)?
Julian
REQUEST
REPORT /folder/ HTTP/1.1
Host: www.webdav.org
Content-Length: xxxx
Depth: 1
?xml version="1.0" encoding="utf-8" ?
D:labeled-version xmlns:D="DAV:"
D:label-name tested /D:label-name
D:prop
D:version-name/
/D:prop
/D:labeled-version
RESPONSE
REQUEST
REPORT /folder/ HTTP/1.1
Host: www.webdav.org
Content-Length: xxxx
Depth: 1
?xml version="1.0" encoding="utf-8" ?
D:labeled-version xmlns:D="DAV:"
D:label-name tested /D:label-name
D:prop
D:version-name/
D:version/
/D:prop
/D:labeled-version
RESPONSE
- I'm unsure about other methods that are currently affected by the
header -- what were the requirements...?
The other methods are LABEL, CHECKOUT, GET, and COPY.
For Depth:0 variants of these operations, the Label header
just provided an optimization to save one roundtrip
(i.e. first getting the version URL via the DAV:labeled-version report).
I believe we can easily do without that Depth:0 optimization.
As stated before, I think that's not the single problem. Having
GET return a
(representation of a) version rather than (a representation of) the VCR
makes the version *by definition* a variant (representation) of the VCR --
and it seems that most of us want to avoid that interpretation.
For Depth:infinity (only relevant for LABEL and COPY), the savings
would be more significant, but unfortunately the semantics is broken
(since if the namespace is being versioned, you'll get the wrong
resources if you simply do a Depth operation on the current namespace).
The Depth:infinity Label header operations are really just a way of
trying to have the client fake workspaces and baselines, instead of
having the server support them directly. Since it is much more
efficient and reliable to have the server layer these constructs
above a labeling infrastructure, rather than having the client do
so, I believe the cost of maintaining these Depth:infinity Label
header operations in the protocol is not warranted.
Note though that (depth:0) labeling and baselining go very well
together. Instead of doing a Depth:infinity LABEL, you can create a
baseline (which under the hood the server may well implement with
reserved labels, but maybe not), and then LABEL that baseline. Then
when you want to do a Depth:infinity COPY, you retrieve the
DAV:baseline-collection of the labeled baseline (using the
DAV:labeled-version report), and copy that to wherever you want.
Alternatively, if you want a "modifiable" selection, you can create a
workspace (which under the hood the server may well implement with
reserved labels, but maybe not). When you want to adjust the versions
being selected, you just use UPDATE. Then when you want to do a
Depth:infinity COPY, you just copy from that workspace to wherever you
want.
- Servers that decide to implement LABEL and DAV:label-name-set,
but no not support the label header should *not* report the LABEL
feature in OPTIONS.
That's probably right. A client can find out if the LABEL operation
is supported by querying the DAV:supported-method-set property values
of a VCR.
...and also use DAV:supported-live-property-set to discover the
DAV:label-name-set property.
Currently, the server can either silently ignore the properties
it cannot retrieve, or it can fail the entire report.
If you think it is important to allow a more fine-grained error
handling in this case, we could change the marshalling to be:
Cheers,
Geoff
report
Geoff,
with the currently proposed format, how does a server marshall information
about failures in retrieving the properties of the selected version (? la
DAV:propstat/DSAV:status in DAV:response)?
Julian
REQUEST
REPORT /folder/ HTTP/1.1
Host: www.webdav.org
Content-Length: xxxx
Depth: 1
?xml version="1.0" encoding="utf-8" ?
D:labeled-version xmlns:D="DAV:"
D:label-name tested /D:label-name
D:prop
D:version-name/
/D:prop
/D:labeled-version
RESPONSE
REQUEST
REPORT /folder/ HTTP/1.1
Host: www.webdav.org
Content-Length: xxxx
Depth: 1
?xml version="1.0" encoding="utf-8" ?
D:labeled-version xmlns:D="DAV:"
D:label-name tested /D:label-name
D:prop
D:version-name/
D:version/
/D:prop
/D:labeled-version
RESPONSE
- I'm unsure about other methods that are currently affected by the
header -- what were the requirements...?
The other methods are LABEL, CHECKOUT, GET, and COPY.
For Depth:0 variants of these operations, the Label header
just provided an optimization to save one roundtrip
(i.e. first getting the version URL via the DAV:labeled-version report).
I believe we can easily do without that Depth:0 optimization.
As stated before, I think that's not the single problem. Having
GET return a
(representation of a) version rather than (a representation of) the VCR
makes the version *by definition* a variant (representation) of the VCR --
and it seems that most of us want to avoid that interpretation.
For Depth:infinity (only relevant for LABEL and COPY), the savings
would be more significant, but unfortunately the semantics is broken
(since if the namespace is being versioned, you'll get the wrong
resources if you simply do a Depth operation on the current namespace).
The Depth:infinity Label header operations are really just a way of
trying to have the client fake workspaces and baselines, instead of
having the server support them directly. Since it is much more
efficient and reliable to have the server layer these constructs
above a labeling infrastructure, rather than having the client do
so, I believe the cost of maintaining these Depth:infinity Label
header operations in the protocol is not warranted.
Note though that (depth:0) labeling and baselining go very well
together. Instead of doing a Depth:infinity LABEL, you can create a
baseline (which under the hood the server may well implement with
reserved labels, but maybe not), and then LABEL that baseline. Then
when you want to do a Depth:infinity COPY, you retrieve the
DAV:baseline-collection of the labeled baseline (using the
DAV:labeled-version report), and copy that to wherever you want.
Alternatively, if you want a "modifiable" selection, you can create a
workspace (which under the hood the server may well implement with
reserved labels, but maybe not). When you want to adjust the versions
being selected, you just use UPDATE. Then when you want to do a
Depth:infinity COPY, you just copy from that workspace to wherever you
want.
- Servers that decide to implement LABEL and DAV:label-name-set,
but no not support the label header should *not* report the LABEL
feature in OPTIONS.
That's probably right. A client can find out if the LABEL operation
is supported by querying the DAV:supported-method-set property values
of a VCR.
...and also use DAV:supported-live-property-set to discover the
DAV:label-name-set property.
From: Julian Reschke [mailto:julian.reschke@greenbytes.de]
From: Clemm, Geoff [mailto:gclemm@rational.com]
So it looks like the main remaining issue in this thread is
3.6_CLARIFY_DEPTH_MARSHALLING, i.e. whether to keep the marshalling
defined in 3253 (i.e. in a DAV:prop) or define a new element for it
(i.e. in a DAV:report). My main concern with making a change is
that until we get RFC 3253 updated, any other spec that wants to
re-use the REPORT method from 3253 would have to know about the
proposed marshalling change, and specify it in their spec (e.g. the
ACL spec). I'm concerned that this is likely to be a more
significant source of interoperability problems, than is having
DAV:prop be used both for properties and for reports.
Well, it seems that I'm the only one who feels strongly about this --
so probably RFC3253 should stay as it is (with clarifications, not
changes).
OK, I'll mark it resolved, with that as the resolution. The issue
will remain in the issues list though, so if anyone would like to
reopen it, just let me know.
Cheers,
Geoff
