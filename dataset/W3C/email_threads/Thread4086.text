Hi
Here's a request for XSLT 2, possibly also applying to XPath 2 and
related technologies.
Problem Summary:
Current drafts of XSLT 2 / XPath 2 don't provide error recovery
facilities. This current limitation results in various problems: an XSLT
application can not finish it's job, even if it could continue after the
error. The app should be able to deal with error if it can handle it, so
that the transfomation can continue.
Scenario, Problem Details:
The input document references a file, via facilities specific to the
input's language (not via generic mechanisms such as XInclude, XML
external entity references, etc).
The transformation application handles this with the unparsed-text()
function; here's a snippet:
select="resolve-uri(@fileref,base-uri(/))"/
If the path supplied by the fileref attribute doesn't point to a file,
then my XSLT processor raises a fatal error [1], and aborts the
transformation. Especially in cases where there is no human supervision,
eg when the whole thing runs on the server, this is inacceptable.
This is a very common scenario.
Solution, Request:
Please add error recovery facilities [2] to XSLT 2 / XPath 2.
The syntax for the mechanism could look like this:
XSLT 2:
An analog mechanism might also make sense as addition to XPath 2.
"An error that is not detected until a source document is being
transformed is referred to as a dynamic error. Some dynamic errors are
classed as recoverable errors. When a recoverable error occurs, this
specification allows the processor either to signal the error (by
reporting the error condition and terminating execution) or to take a
defined recovery action and continue processing. It is
implementation-defined whether the error is signaled or the recovery
action is taken. If the implementation does choose to take recovery
action, it must take the recovery action defined in this specification."
I need a way to specify the recovery action to be taken. No matter what
the processor chooses to do in the absence of this user specified
recovery action (abort or recover); when a user supplied action is
present (xsl:rescue), all processors must carry it out if the first
action failed.
Alternatives
There are various solutions specific to the problem described in the
scenario. They solve this specific problem, but don't address the
underlying general issue.
A function resource-exists() for example would solve the problem
encountered in the specific use case described above, but it would not
help in all other cases where user supplied error recovery action is
required.
Use Case:
See Scenario.
Possible Issues:
The "rollback" issue mentioned in [3] should be solvable.
AFAICS, Rollback of the result tree should not be required.
One possible solution might be:
Any action contained in xsl:try is only carried out if the complete
contents of the xsl:try succeed.
If one or more action fails, then none of them are carried out.
They are simulated/attempted/tested first, without affecting the result
tree. This can represent a performance penalty, but where reliability
and predictable program execution is of high importance, this most often
is acceptable.
Then the actions contained inside xsl:rescue are carried out.
Discussion:
Please also see
Tobi
[1]
"[ERR119] It is a dynamic error if a URI cannot be used to retrieve a
resource containing text. This is a recoverable error. The processor
must either signal the error, or must recover by treating the URI as if
it referenced a resource containing a zero-length string."
[2]
Analog to begin-rescue (eg in Ruby), try-catch, etc in other languages.
[3]
I encountered a problem of a somewhat similar nature using XSLT 1.0,
using the document function. In certain scenarios, using Java, the user
could make a "document()" reference to a document that might not be
there, or might not parse correctly, and I wanted to be able to handle
the error in the XSLT, not in the Java code.
My work-around was to always return a document via the URIResolver, just
that sometimes it would have special "error" content. I mention this in
the context of this suggestion to note that it might make more sense
with a different syntax. Two alternatives suggest themselves to me:
A) Within an "xsl:do" block, have multiple "xsl:rescue" blocks with the
appropriate "match" attributes.
B) Forgo the "xsl:do" and "xsl:rescue" altogether. Instead, the xsl:try
implicitly does an xsl:apply-templates / on the xml of the error
message, should an error occur. Note that the "mode" on the "xsl:try"
would be passed through to the xsl:apply-templates /
Actually, now that I think about it, option (B) seems like a pretty good
fit for an extension element if it doesn't end up in the spec.
Of course, it might make sense for implementations to eventually agree
on what the error info-set looks like.
-Eric.
As posted on xsl list:
From David Carlisle
It's actually an error to refer to a document that is not there. Your XSLT
system may just give up at that point and stop. If so there is nothing you
can do from within the stylesheet.
However the XSLT spec does say what the processor must do if it does not die
at that point: it has to return an empty node set, in which case if
$Description holds the file name,
both of those should work and be true if the document is there and false
otherwise.
$Descriptions will either be an empty node set or a set consisting of a
single / node, depending on whether the document is there or not.
HTH DaveP.
NOTICE: The information contained in this email and any attachments is
confidential and may be legally privileged. If you are not the
intended recipient you are hereby notified that you must not use,
disclose, distribute, copy, print or rely on this email's content. If
you are not the intended recipient, please notify the sender
immediately and then delete the email and any attachments from your
system.
RNIB has made strenuous efforts to ensure that emails and any
attachments generated by its staff are free from viruses. However, it
cannot accept any responsibility for any viruses which are
transmitted. We therefore recommend you scan all attachments.
Please note that the statements and views expressed in this email
and any attachments are those of the author and do not necessarily
represent those of RNIB.
RNIB Registered Charity Number: 226227
Website: http://www.rnib.org.uk
re
Dave, please see
"Alternatives
There are various solutions specific to the problem described in the
scenario. They solve this specific problem, but don't address the
underlying general issue."
The solution described in
does not work if the processor chooses to abort the transformation
(conformant), as David C. states in the very same text.
Tobi
The document() situation is certainly one of the main use-cases for this
capability, but it is not the only one - XSLT 2.0 and XPath 2.0 define many
more dynamic errors than 1.0 did. Most of these are preventable (this is why
we added the "castable" operator, so that you could preempt errors in
casting) but not all.
It's true that writing your own URIResolver gives you a way of handling the
document() errors, assuming you are in the Java world.
Michael Kay
I am personally sympathetic to this requirement.
We had an attempt to define try/catch functionality at the XPath level. The
attempt failed partly because people thought the language was getting too
big and complicated, and partly because XQuery has decided not to updates at
this version (there is a feeling that try/catch probably interacts with
transactions and rollback, and that it therefore needs to be designed with
update in mind).
I don't think these arguments should stop us doing a try/catch in XSLT.
Apart from deciding the precise syntax, the issues that we need to address
are:
(a) how does it interact with the option for implementations to recover from
certain errors?
(b) what information about the error is made available in the "catch" block
(and how)?
(c) what do we say about "rollback", i.e. about lasting effects of
instructions in the try block (for example, xsl:result-document).
I will ask for this to go on the WG agenda.
Michael Kay
html#00593
Tobi
[1]
"[ERR119] It is a dynamic error if a URI cannot be used to retrieve a
resource containing text. This is a recoverable error. The processor
must either signal the error, or must recover by treating the URI as if
it referenced a resource containing a zero-length string."
[2]
Analog to begin-rescue (eg in Ruby), try-catch, etc in other languages.
[3] http://www.biglist.com/lists/xsl-list/archives/200306/msg00614.html
MK said:
Another reason to re-consider the split point between
query and xslt?
I think the WG have it badly wrong.
regards DaveP
NOTICE: The information contained in this email and any attachments is
confidential and may be legally privileged. If you are not the
intended recipient you are hereby notified that you must not use,
disclose, distribute, copy, print or rely on this email's content. If
you are not the intended recipient, please notify the sender
immediately and then delete the email and any attachments from your
system.
RNIB has made strenuous efforts to ensure that emails and any
attachments generated by its staff are free from viruses. However, it
cannot accept any responsibility for any viruses which are
transmitted. We therefore recommend you scan all attachments.
Please note that the statements and views expressed in this email
and any attachments are those of the author and do not necessarily
represent those of RNIB.
RNIB Registered Charity Number: 226227
Website: http://www.rnib.org.uk
Hi Dave,
I don't understand your comment well enough to respond. Could you please
explain in a little more detail?
Jonathan
Could you explain what you mean by "it", and what you think we should do
differently?
Michael Kay
Mike quoted an example of a mismatch between xquery and xslt requirements.
Its my belief that the split point, xquery and xslt, is way too far down,
i.e. too much is lumped together as being common, too little is either
query or xslt. The architecture of that split appeared when someone
determined
that there was commonality, true, but the split point appears badly designed
IMO.
I remain totally unconvinced that the area of common need is anywhere near
as
large as is currently posited by the design.
As usual, I'll quote the typing as the most gross error.
Apparently needed in query, certainly not in XSLT.
regards DaveP.
From: Jonathan Robie
[mailto:jonathan.robie@datadirect-technologies.com]
Sent: 20 June 2003 16:39
public-qt-comments@w3.org
Subject: RE: rescue; error recovery facilities needed
NOTICE: The information contained in this email and any attachments is
confidential and may be legally privileged. If you are not the
intended recipient you are hereby notified that you must not use,
disclose, distribute, copy, print or rely on this email's content. If
you are not the intended recipient, please notify the sender
immediately and then delete the email and any attachments from your
system.
RNIB has made strenuous efforts to ensure that emails and any
attachments generated by its staff are free from viruses. However, it
cannot accept any responsibility for any viruses which are
transmitted. We therefore recommend you scan all attachments.
Please note that the statements and views expressed in this email
and any attachments are those of the author and do not necessarily
represent those of RNIB.
RNIB Registered Charity Number: 226227
Website: http://www.rnib.org.uk
I think the data typing is needed when handling structured data
applications, and is not needed (much) when handling narrative text.
Many people seem to be under the impression that XQuery is designed to
handle data and XSLT is designed to handle text. This is not the case. Both
languages have explicit requirements to handle the full spectrum of XML
applications.
Michael Kay
I completely agree.
Jonathan
MK:
JR:
Where please gentlemen?
your requirements.
regards DaveP.
NOTICE: The information contained in this email and any attachments is
confidential and may be legally privileged. If you are not the
intended recipient you are hereby notified that you must not use,
disclose, distribute, copy, print or rely on this email's content. If
you are not the intended recipient, please notify the sender
immediately and then delete the email and any attachments from your
system.
RNIB has made strenuous efforts to ensure that emails and any
attachments generated by its staff are free from viruses. However, it
cannot accept any responsibility for any viruses which are
transmitted. We therefore recommend you scan all attachments.
Please note that the statements and views expressed in this email
and any attachments are those of the author and do not necessarily
represent those of RNIB.
RNIB Registered Charity Number: 226227
Website: http://www.rnib.org.uk
The XML Query Requirements includes a Usage Scenarios section which
mentions being able to process all of "human readable documents",
"data-oriented documents" and "mixed-model documents". And Section "XML
Query Functionality" outlines the requirements to be able to operate on
both Schema types and text values.
I do not know how someone could have drawn the conclusion:
if they had actually read the XML Query Requirements as quoted above.
Maybe this perception is caused more by the implementation profile for
early XSLT 2.0 and XQuery 1.0 implementations. But this is not
something that is under our control.
/paulc
Paul Cotton, Microsoft Canada
17 Eleanor Drive, Nepean, Ontario K2E 6A3
Hi :)
Since this [1] wanders off-subject for the thread [2], perhaps you guys
want to start a new thread? It would make it much easier for people to
follow threads they're interested in, and it would increase the quality
of the archives.
TIA,
Tobi
[1]
[2]
"rescue; error recovery facilities needed"
The first two stated goals, right at the beginning of section 1 of the XSLT
requirements document that you cite, are:
* Simplify manipulation of XML Schema-typed content
* Simplify manipulation of string content
Michael Kay
It can also be very useful in the case where you're picking "fields"
out of narrative text -- e.g. where in the middle of a news story
stock ticker symbols are handled separately, with a database lookup
to insert the company name and (for online presentation) maybe a
link to their web site. Another example might be a part number
mentioned in a repair manual. Or a date in a history text.
Demand for typing in XML came from many communities, not just
(for example) database people.
Yes.
I think a lot of experimentation is needed before there's good shared
understanding of the benefits of typing, and whether they were worth the
price... "colour all headings green", "lists should be collapsible"
are attractive but maybe weak use cases. The biggest advantages that
I see, though, are (1) having a family of specs that fit together well,
and (2) having the XSLT and XML Query processors detect more errors
before they happen. Scripting languages (e.g. Perl) are also moving
in this direction.
Liam
Liam Quin, W3C XML Activity Lead, liam@w3.org, http://www.w3.org/People/Quin/
Unfortunately though there are real worries in the community that the
majority of "errors" detected by the typing in Xpath2 will be
essentially spurious errors. constructs that worked in xpath 1 will fail
to work in xpath 2 because of the smaller number of places where
implicit coercions happen. So this has all the signs of being an error
detecting device that generates more errors than it detects.
David
Sorry Michael. I was reading the requirements not the goals.
Even there I see I'm wrong.
See requirement 3.
Not quite quote to handle the full spectrum of XML
applications. /quote , see 2.1 but it does reference xsd.
regards DaveP.
NOTICE: The information contained in this email and any attachments is
confidential and may be legally privileged. If you are not the
intended recipient you are hereby notified that you must not use,
disclose, distribute, copy, print or rely on this email's content. If
you are not the intended recipient, please notify the sender
immediately and then delete the email and any attachments from your
system.
RNIB has made strenuous efforts to ensure that emails and any
attachments generated by its staff are free from viruses. However, it
cannot accept any responsibility for any viruses which are
transmitted. We therefore recommend you scan all attachments.
Please note that the statements and views expressed in this email
and any attachments are those of the author and do not necessarily
represent those of RNIB.
RNIB Registered Charity Number: 226227
Website: http://www.rnib.org.uk
