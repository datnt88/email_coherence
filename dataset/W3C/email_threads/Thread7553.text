In the advanced collection design, a reference is a resource that is
independent of its target, e.g. operations on either don't affect the
other. They have distinct sets of properties, and (baring referential
integrity) either can be deleted without affecting the other, and so on.
This allows us to not deal with, e.g., the security problems of relaying
requests from reference to a (possibly remote) target.
Yet there have also been suggestions that this is a *policy* that should
not and need not be built into the protocol. I can easily imagine that, at
least in some limited cases, some users would prefer to sometimes be able
to get a kind of reference that is not independent, so that e.g. a PROPFIND
on the reference returns all and only the properties of the target, and so on.
Let me call such a reference a 'direct' reference. Direct references (and
their targets) do *not* have properties 3.1.2 and 3.1.3. Operations on one
*do* affect the other. A collection listing *does* follow references. A
GET on the reference just gets the target, a PROPFIND goes to the target,
etc. This also means giving up on 3.1.8.
This kind of reference would sometimes be useful, even if it could only be
implemented typically when both the reference and the target were on the
same server, and even though it would require care (e.g. to avoid cycles.
But this is true for symbolic links in file systems, too.)
If it's the case that this kind of reference would ever be desirable (and I
think it is), then I think we should alter the requirements document to
introduce this distinction (between direct and indirect references), and to
state which properties apply to which kind of reference. I don't think we
should try to define this in the protocol document. Direct references
raise too many hard issues to define now. (Remember how much trouble we
got into just trying to define the semantics of referential integrity?)
But if we extend the requirements document, at least we won't be
*preventing* someone from defining the semantics of direct references later
on.
It's fine if the protocol provides only indirect references. It isn't
going to do referential integrity, either. We have to leave *something*
for future generations to do, after all.
I mentioned this to Judy and she said I ought to ask the list, which is
what I am doing now.
To be concrete:
This change would require adding the adjective "indirect" to requirements
3.1.2, 3.1.3, 3.1.4, 3.1.5(?) 3.1.8, and modifying the language in 3.1.12
FWIW, in the protocol, to implement direct references, you'd need to revive
DELREF, because DELETE on a direct reference deletes the target as well as
the reference. But that's for the protocol, not the requirements.
This makes sense intuitively, but I'm having trouble understanding why--what can
you do with a direct reference that you can't do with an indirect one?
"Good idea. It'll make them feel more involved." (Doonesbury reference.)
|John (Francis) Stracke |My opinions are my own.|S/MIME supported |
|Software Retrophrenologist|=========================================|
|Netscape Comm. Corp. | I will not buy this .signature, it is |
|francis@netscape.com | scratched. |
New area code for work number: 650
One question to ask is whether we gain any significant functionality by
requiring support for direct as well as indirect references.
Another is what sorts of references are supported by the file systems and
DMSs that are likely to stand behind WebDAV servers. How easy or difficult
will it be for these systems to map their referencing to what WebDAV
provides? If we can count an most having support for indirect references,
there is less reason to provide direct references in WebDAV. If
significant numbers of these systems support only direct references, then
maybe there is good reason for WebDAV to support direct references.
why--what can
Name:Judith A. Slein
E-Mail:slein@wrc.xerox.com
MailStop:105-50C
Web Site: http://www.nde.wrc.xerox.com/users/Slein/slein.htm
I can describe what Apache already does using configuration files,
which won't go away even after WebDAV is implemented. I'd like to
have all three forms of names (direct, indirect, and actual) available
for manipulation via WebDAV.
The goal of a direct reference (what Apache terms an internal redirect)
is to provide the same source at multiple names in the namespace.
The most frequent use of this is for content negotiation, where a request
on a basename automatically creates a mapping to all other names in
that directory with the same basename. Likewise, we can do the same
thing with derived content. A less often used purpose, though
more applicable to WebDAV, is to maintain separate resource trees so
that access can be more easily controlled by URL. For example, by
placing all of the writable resources (the source) under one URL tree
and all the read-only handles for those resources under a different
URL tree, it is easier to maintain the ACLs. Of course, this isn't
an ideal way to implement WebDAV for these resources, but it is one
that works on systems where per-URL ACLs are inconvenient.
Note that this functionality cannot be implemented by external
redirects (indirect references) because the actual destination
resource may be under different access restrictions than the direct
reference handle.
Regarding terminology, "direct reference" brings to mind a normal URL,
whereas "indirect reference" is using one URL to access another resource
indirectly (what you are terming a direct reference). Since that is
very confusing, I suggest instead that they be referred to as
externally-redirecting names and internally-redirecting names.
....Roy
Thanks for the information about Apache.
The new collections requirements draft has new text related to direct
references. We've stayed with the direct / indirect terminology because
internal / external already has a different meaning attached to it in
WebDAV:
Here are the definitions:
Direct Reference
A reference that has the property that operations on it are
passed through to its target
Indirect Reference
A reference that has the property that operations on it do
not affect its target
Some rationale:
Similarly, both indirect and direct references may be useful.
Each
of these types of references is implemented in existing systems.
Existing HTTP servers are capable of supporting both types of
references. In effect, indirect references give clients access
to
the reference itself, and allow the reference to bear
properties.
Direct references, once created, simplify access to the target
resource by hiding from clients the fact that there is a
reference
mediating between the client and the target resource. Although
it
is desirable for WebDAV to support both indirect and direct
references, the difficulties of supporting direct references
make
it unlikely that they will be supported in the short term.
And 3 new requirements that explain how direct references differ from
indirect references.
3.1.15 Operations on a direct reference, except for creation and
deletion of the reference itself, are passed through to its
target resource.
This requirement is really a restatement of the definition of
a direct reference. There are several reasons for wanting to
support this sort of resource.
Direct references simplify operations for clients, hiding from
them
the fact that a reference is mediating between their requests
and
the target resource.
Many existing systems, including HTTP servers, implement direct
references.
Supporting direct references does introduce issues that make it
unlikely that WebDAV will support them in the short term.
Passing
operations through to the target resource exposes servers to the
risks of circular references and long chains of references that
refer to other references. In addition, passing operations
through
to the target resource can be problematic if the referential
resource and the target resource are on different servers.
Issues
about what credentials to use would need to be addressed.
3.1.16 For any resource, it is possible to discover whether it is a
direct reference.
Since the behavior of direct references is radically different
from
the behavior of indirect references, it is important for clients
to be able to discover whether they are operating on a direct
reference. The client must have a way of finding out whether
the
properties it sets will be stored on the reference or on its
target, etc.
3.1.17 It is not possible for a client to set or view properties of
a direct reference, distinct from those of its target.
Again, this follows from the definition of a direct reference.
Since all operations except creating the reference and deleting
the reference are passed through to the target, the client can
operate only on properties of the target.
Judith A. Slein
Xerox Corporation
jslein@crt.xerox.com
(716)422-5169
800 Phillips Road 105/50C
Webster, NY 14580
