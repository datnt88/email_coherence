One of the main points that has caused much of the recent debate over
signing location and transforms is that some of us believe that
1) the ObjectReference's Location and Transforms will tell core code how to
obtain the bucket of bits digested in DigestValue.
while others of us believe that
2) the ObjectReference's Location and Transforms are a hint that 'may' help
the application find the bits that the core code will need to do the
validation.
I'm having difficulty buying into this latter point of view because I think
that far too much work is being pushed off to the application, which to me
means that most signatures will not validate outside of their application
domains. I don't see the point in having a 'standard' if the result is that
applications don't interoperate.
From an API point of view, proponents of the first idea seem to want to call
CreateSignature() or VerifySignature() and give a pointer to a Signature
element. Proponents of the second idea seem to want the same thing, except
that they must first set up an application-specific callback function that
CreateSignature() and VerifySignature() can use to help dig up the required
bits. Therein lies the rub. Callbacks are a wonderful way to solve
problems if you don't care about globally secure resources, application
interoperability, and so forth. The first idea is in many of our minds
because we associate 'standard' with interoperability.
When the signer creates a signature, we are saying that Location and
Transforms provide 'hints' that indicate how the signer created the bucket
of bits. Presumably, when the signer signed, the Location and Transforms
describe precisely what happened. So, we are basically saying that the
verifier can treat these as hints rather than precise steps. So, the
meaning of these *signed* bits has changed without breaking the signature.
I agree that it will work in any single application context, but it has an
unappealing engineering aesthetic.
Finally, when proponents of the second idea say that Transforms are 'hints',
does this mean that we will be making each application responsible for
resolving the Transforms too? In other words, going back to the idea of the
callback function, must the callback function resolve the Location or must
it resolve the Location and Transforms, giving to core code the exact set of
bits that should match the DigestValue once the DigestMethod is applied?
John Boyer
Software Development Manager
UWI.Com -- The Internet Forms Company
The only assertion made by the signature is that that exact collection of
bytes, paragraph X, was signed. The fact that paragraph X was extracted
from
document Y is in no way cryptographically assured by the XML signature
unless I
include object references both to paragraph X and to document Y (and
perform
additional external validation).
I believe there are two other "orthogonal" assertions:
1. There is a set of documents that when processed via the specified chain
of transforms will yield DigestContent.
2. At some point in time, the document obtained by dereferencing the URI was
a member of that set.
One does not need to "confirm" either of these assetions to have a valid
signature.
Joseph Reagle Jr.
Policy Analyst mailto:reagle@w3.org
XML-Signature Co-Chair http://www.w3.org/People/Reagle/
TO:jboyer@uwi.com,w3c-ietf-xmldsig@w3.org
John,
Actually, both are true. The point is, if I sign paragraph X (a bunch of
bytes), then thats what I've signed whether the paragraph is a standalone
object, retrieved via the net, or extracted from a larger document. The thing
I believe everyone (except perhaps you) agreed to yesterday is that while
target and transforms can be relied upon to tell the core code how to obtain
paragraph X (your point 1), a signature is not automatically invalid if
paragraph X is obtained a different way (your point 2) [i.e. performing the
specified transforms is not semantically required for signature validation].
The only assertion made by the signature is that that exact collection of
bytes, paragraph X, was signed. The fact that paragraph X was extracted from
document Y is in no way cryptographically assured by the XML signature unless I
include object references both to paragraph X and to document Y (and perform
additional external validation).
Dave
Hi Dave,
Your messages always show up enclosed in a text file called BDY.TXT. Maybe
it's a bug in Outlook or in someone's mailserver.
Anyway, I'll copy your message below:
John,
Actually, both are true. The point is, if I sign paragraph X (a bunch of
bytes), then thats what I've signed whether the paragraph is a standalone
object, retrieved via the net, or extracted from a larger document.
I agree that that is what the signer wants to sign regardless of how it is
obtained. Clearly, though, our current formulation signs more than that or
we would not be having this conversation.
The thing I believe everyone (except perhaps you) agreed to yesterday is
that while
target and transforms can be relied upon to tell the core code how to obtain
paragraph X (your point 1), a signature is not automatically invalid if
paragraph X is obtained a different way (your point 2) [i.e. performing the
specified transforms is not semantically required for signature validation].
Again agreed except that if the paragraph X cannot be obtained by the
*signed* target and transforms, then core code has no way of finding
paragraph X without relying on application-specific logic.
The only assertion made by the signature is that that exact collection of
bytes, paragraph X, was signed. The fact that paragraph X was extracted
from
document Y is in no way cryptographically assured by the XML signature
unless I
include object references both to paragraph X and to document Y (and perform
additional external validation).
Firstly, when acrimony began at the IETF meeting, Phil asserted quite
vociferously that the signature on Location was absolutely essential and
that the signature should break if the result of dereferencing Location and
applying DigestMethod does not match the DigestValue. He further asserted
that failure to sign Location was an insecurity.
I agree with him that for many applications this is true, and I agree with
you that if that is what the user wanted, then they can put an
ObjectReference in place that signs the Location too.
So, I'm not talking about what is cryptographically assured. I'm talking
about how core code is going to find X so that it can do the cryptography.
Nothing in this letter refutes the essence of the problem I'm trying to get
us to solve, which is solvable, and which everyone seems to think 'Location
as hint' solves because their seems to be no recognition of the fact that
'Location as hint' = application-specific signature with no
interoperability.
I'm trying to design an XML document processing module that receives a
document, regardless of what company it came from, and validates the
signature in that document before proceeding to do other work with the
document. I have one of two choices:
1) With Location as hint, I have to create a module that understands the
application-specific Location resolution scheme of each business whose
documents I want to process. As time goes on, I will need a small army to
keep my document processor up to date with the inevitable changes that these
people will make.
2) With Location as location (or target as target, it's still a rose!), I
read the location and dereference. The application is not involved in
defining how core code digs up X.
Furthermore, the Location as hint paradigm becomes laughable in the
following scenario:
Consider CompanyA and CompanyB. CompanyA produces a document D used by
CompanyB. The document D is located at http://www.CompanyA.com/documentD.
CompanyB creates many signed documents with ObjectReferences to D. CompanyA
decides to update document D at some time MMDDYYYY, but cannot or for
whatever reason does not use a different URL. This breaks all of CompanyB's
existing signatures.
The 'Location as hint' solution says that CompanyB should make a copy of D
and put it at location http://www.CompanyB.com/documentD, then define the
URL http://www.CompanyA.com/documentD as being a 'hint' to get
decides that they want to use the updated documentD in their new signatures
(as would be the case in legal scenarios). Now what does company B have to
do. Somehow, it has to get its URL resolution code to accept a date
mmddyyyy.
If Date(signed document)  MMDDYYYY, then
elsehttp://www.CompanyA.com/documentD -
I don't know of any socket implementation that allows GetHostName() to be
date specific, so it's a sure bet this would have to be done by custom code
in the application.
Now iterate this over a ten year period.
Now apply the idea (whether custom code or in a configuration file) to the
generic XML document processor, which would have to know about this little
kludge for each company that it has to service.
Can you actually write another letter telling me why *this* interoperability
situation is just a figment of my imagination?
Because there does seem to be a relatively easy fix, and I can't figure out
why this is such a big deal (so it would be nice to actually discuss that
too).
BTW, the generic XML document processor is really just an example. The
'philosophy' of XML (if there truly is such a thing) it to make human
readable data so that applications other than the one that created the data
can read and process the data. Why am I the only one who feels that
Location as hint violates this XML philosophy?
John Boyer
Software Development Manager
UWI.Com -- The Internet Forms Company
Dave
rose!),
I read the location and dereference. The application is
not involved in defining how core code digs up X.
I'd like to design a signature module that doesn't need to know
anything on how to retrieve documents out from a generic location. Not
assuming there only will be http: or one or two more, I would probably have
a retrieval-module that knows how to handle these things. I wouldn't
consider this module not to be application specific but enviroment-specific.
It would know where to look - and it might even look it up in the original
location if required.
copy of D...
Nice example. It nicely proves that using an URL for long-term
referencing a document that can change is not a good idea in the first
place.
If both companies had used from the beginning:
the whole problem is nonexistent. If you use the location as a
location, what would it buy you in your example? The signature still breaks
and you still have no solution to solve the problem....
Still, location as a hint does not hurt here and the only real fix I
see is to properly use URL's.
Peter
In the solution I'm proposing, those who expect Location to
move would omit Location from the SignedInfo message so that it can be
changed without breaking the signature.
Yes, one real fix is to use URLs, which is what we're saying
should be done.
Another real fix would be to completely abandon the idea
that core behavior should have anything to do with externally located
resources.
See the end of
for a description of how much simpler our task would be if we totally pushed
everything to do with resource location off to the application.
I like this because at least the application-specific logic
requirement has something to do with the needs of the application.
John Boyer
Software Development Manager
UWI.Com -- The Internet Forms Company
the only real fix I see is to properly use URL's.
we're saying should be done.
I'd like to rephrase my sentence:
Still, location as a hint does not hurt here and the
only real fix I see is to emph properly /emph use URL's if they are used
as a real location.
idea that core behavior should have anything to do with externally located
resources.
Yes, I think that's something I would support.
Peter
Hi Peter,
Actually, the whole debate is about whether location should be a hint or
whether location should be a emph properly /emph used URL. The latter
is hurt by the former.
Core code must either treat location as a proper URL or core code must call
back into application code to resolve location if it is only a 'hint' as to
how to obtain the bag of bits that were signed.
I favor the idea that we either treat location as a proper URL (which means
that some apps need to omit it from SignedInfo), or that we recognize that
core behavior shouldn't be trying to dig up the bits because it can't and
strip out the notion of trying to go to externally located resources. In
truth, I favor the latter quite a bit, which is a point that I think we
agree on.
I sent a simplified syntax proposal to the list a short while ago. When it
shows up, I would really appreciate it if you would take the time to have a
look at it and start some serious dialog on whether the WG should move in
this direction. To be honest, the proposal relies heavily on what we
already have. It only says to push to the Manifest those things that it is
becoming increasingly clear should be pushed to the application. Thus, a
fair bit of the spec we have would remain the same.
Thanks,
John Boyer
Software Development Manager
UWI.Com -- The Internet Forms Company
