I guess that's what I'm trying to figure out - whether it really
does lack the terms required to become a full FOL language.
If it has implication, universal and existential quantification (via
toClass and hasClass),
How are toClass and hasClass universal and existential qualifiers?
DAML doesn't have the notion of a variable; they're parts of a
restriction, not a logical construct.
In http://www.daml.org/2001/03/reference.html it says "Notice that a
toClass restriction is analogous to the universal (for-all) quantifier of
Predicate logic...."
In other words (I think) - if you have a toClass c property restriction on
property p then for all y where p(x,y), y is class c.
And hasClass - if you have a hasClass c property restriction on property p
then for some y where p(x,y), y is class c
It's a stretch to say that the language has quantification in general - this
seems to be quantification over the object only.
boolean operations and negation,
You can have the cardinality constraints, but where's the negation?
How do you assert that a statement is false in DAML? For a start, to
make logical expressions in DAML, you would need an "AND", and to do
that you'd need to group reified statements, i.e. a context.
Negation through complementOf; And through intersectionOf; Or through
unionOf
(BTW, I don't know the answer to that question - either
whether it truly has those features or if they are sufficient
to claim FOL-ness).
Neither do I, but my gut feeling tells me that it's just an ontology
and inference language, not a full first order logic language. For
that, you need truths, implications, a universal/existensial
qualification, and you need those as first class predicates and
classes, not as things that are just inferrable from the language.
For example, how would you do the following in DAML:-
{ { :x :a [ :b :c; :d :h ] } log:implies { :b :c :d }}
a log:Truth; log:forAll :b , :d .
I don't think it can be done.
Not up on n3 but I assume this is dereifying statements? I don't think it
can be done in daml either - becuase I don't see any way to quantify over
the predicate.
I'm more interested in understanding if daml can provide a
firm semantic base for rule interchange between different
systems. So rules in prolog,datalog,etc can be serialized in
daml and reliably, predictably and without loss of meaning
be deserialized by n3/cwm or some other logic system. Not
sure it would really make sense to do so - just exploring the
possibility...
It would be neat to have some kind of universal logic language for the
Semantic Web, so that some of the terms in DAML could, for example, be
expressed properly rather than in prose, and so that we could build
proper conversion machines, but I don't think it's going to happen
soon. I keep hearing the word "SWeLL" in the air, but I don't know
where that's going. The SW actually moves quite slowly at the moment.
Well now that the hard part is done (the acronym is worked out) perhaps
things can move forward at a greater pace. My personal take is that many
different logic systems will make up the semantic web - with ground facts
exchanged through rdf and rules through (??kif/n3/daml/swell??) you name it.
Geoff
Taking this off-list (actually, to www-archive) because my
understanding is a bit murky from here on in...
Thanks for sticking with it.
But I think that once you go from "p- q" to "q or not p" which in DAML
is more like "union of q and the compliment of p" as you have
demonstrated, you can only rely on the semantics (i.e. rules,
inferences) of DAML to provide the implications, because it lacks the
terms required to become a full FOL language.
I guess that's what I'm trying to figure out - whether it really does lack
the terms required to become a full FOL language. If it has implication,
universal and existential quantification (via toClass and hasClass), boolean
operations and negation, can't it express FOL (albeit in a cumbersome
fashion)? (BTW, I don't know the answer to that question - either whether it
truly has those features or if they are sufficient to claim FOL-ness).
DAML is there to provide
a simple ontology framework, not to state the full range of inferences
up front. It does howver provide you with enough terms to create
simple statements from which many inference rules can be derived.
I understand that the primary intent of daml (at this point anyway) is not
to provide a basis for a full-fledged inference system. Whether the
designers intended it to be and whether it is are different questions.
The question is, if you express the rule in that form (by defining
a class of things that are q or not p and say that all things are
members of that class) will a processor that correctly interprets
the semantics of the daml language necessarily interpret the rule
as an implication?
It should do, but in general RDF inference engines, you'll probably
have to feed the rules in yourself, which is useful because
practically you only want to come to one particular conclusion,
although you could quite easily generate hundreds of others. The
complication arises when you want one particular bit of information,
but have to go through several different inferences to get there,
which you don't care about (i.e. don't want on the output).
My interest really isn't in having a daml-speaking system be able to do
inference (though I think that by claiming to fully support daml such a
system would have to). I'm more interested in understanding if daml can
provide a firm semantic base for rule interchange between different systems.
So rules in prolog,datalog,etc can be serialized in daml and reliably,
predictably and without loss of meaning be deserialized by n3/cwm or some
other logic system. Not sure it would really make sense to do so - just
exploring the possibility...
Once again, TimBL's log namespace, DAML, and RDF Schema make a
powerful mix.
I haven't really played with it. I'm sure it does has the necessary
expressive power (when interpreted by a system that understands log
namespace). I'm just not clear where it's going - is it trying to become a
knowledge representation language or a logic system? is it anticipated that
n3 will become the interchange standard which all other logic systems must
speak? what's the relationship to the current rdf standards process? etc.
--geoff
Taking this off-list (actually, to www-archive) because my
understanding is a bit murky from here on in...
But I think that once you go from "p- q" to "q or not p" which in DAML
is more like "union of q and the compliment of p" as you have
demonstrated, you can only rely on the semantics (i.e. rules,
inferences) of DAML to provide the implications, because it lacks the
terms required to become a full FOL language. DAML is there to provide
a simple ontology framework, not to state the full range of inferences
up front. It does howver provide you with enough terms to create
simple statements from which many inference rules can be derived.
The question is, if you express the rule in that form (by defining
a class of things that are q or not p and say that all things are
members of that class) will a processor that correctly interprets
the semantics of the daml language necessarily interpret the rule
as an implication?
It should do, but in general RDF inference engines, you'll probably
have to feed the rules in yourself, which is useful because
practically you only want to come to one particular conclusion,
although you could quite easily generate hundreds of others. The
complication arises when you want one particular bit of information,
but have to go through several different inferences to get there,
which you don't care about (i.e. don't want on the output).
Once again, TimBL's log namespace, DAML, and RDF Schema make a
powerful mix.
Kindest Regards,
Sean B. Palmer
@prefix : http://webns.net/roughterms/ .
:Sean :hasHomepage http://purl.org/net/sbp/ .
How are toClass and hasClass universal and existential qualifiers?
DAML doesn't have the notion of a variable; they're parts of a
restriction, not a logical construct.
boolean operations and negation,
You can have the cardinality constraints, but where's the negation?
How do you assert that a statement is false in DAML? For a start, to
make logical expressions in DAML, you would need an "AND", and to do
that you'd need to group reified statements, i.e. a context.
Neither do I, but my gut feeling tells me that it's just an ontology
and inference language, not a full first order logic language. For
that, you need truths, implications, a universal/existensial
qualification, and you need those as first class predicates and
classes, not as things that are just inferrable from the language.
For example, how would you do the following in DAML:-
{ { :x :a [ :b :c; :d :h ] } log:implies { :b :c :d }}
a log:Truth; log:forAll :b , :d .
I don't think it can be done.
It would be neat to have some kind of universal logic language for the
Semantic Web, so that some of the terms in DAML could, for example, be
expressed properly rather than in prose, and so that we could build
proper conversion machines, but I don't think it's going to happen
soon. I keep hearing the word "SWeLL" in the air, but I don't know
where that's going. The SW actually moves quite slowly at the moment.
to
become a knowledge representation language or a logic system?
DAML seems to come from many of the KR people, and the log namespace
is something purely from TimBL to play about with (understood natively
only by CWM).
is it anticipated that n3 will become the interchange standard which
all other logic systems must speak?
No. N3 is a "poor man's RDF modelling language" (paraphrasing DanC),
but I can (kinda) be serialized into XML RDF. XML RDF is to be the
standard interchange format that all logic systems speak
(hopefully)...
Notation3 is purely a hack from Tim and Dan, but a good hack. CWM is
quite easily the most advanced query/inference engine that has come
from the SW efforts so far (except perhaps XSB which can be used in a
similar way), and because it has FOL and so forth, you an do quite a
lot with it. But it's also a little bit buggy - Tim seems to have gone
for cramming it with features rather than optimizing it for stability
and speed, which is fine because it's mainly for demonstration at the
moment.
Kindest Regards,
Sean B. Palmer
@prefix : http://webns.net/roughterms/ .
:Sean :hasHomepage http://purl.org/net/sbp/ .
general
- this seems to be quantification over the object only.
That's the problem. It's saying that "by making this restriction, you
are implying that you're doing this quantification", rather than "you
are doing this quantification". If it had a general mechanism for
expressing existential and universal quantification, then I'd say that
it is complete FOL, but there aren't any such terms, and it isn't even
possible to make inferences as such, because (as you note) there is no
way to quantify over predicates.
negation?
context.
through
Cool, but once again, complementOf isn't really direct FOL...
Hmm... could you do an intersection of statements to form a context?
:x daml:intersectionOf [ a rdf:Statement ], [ a rdf:Statement ] .
Yep, I guess you can. Now all we need is that implies predicate, and
the quantifications...
:x daml:intersectionOf :a , :b .
:a a rdf:Statement . :b a rdf:Statement .
:y daml:intersectionOf :c , :d .
:c a rdf:Statement . :d a rdf:Statement .
:z :sub :x; :pred :implies; :obj :y .
:z :Rule; :trueForAll :a, :c; :trueForSome :b , :d .
Strangely enough, Seth (who's on the CC anyway) discussed unreifying a
little while ago on RDF Logic, although I can never remember the URL
of the post. Maybe he can prompt us.
Yes, quantifying over predicates can't be done currently in DAML, but
that doesn't mean it can't be done in RDF. The point is that DAML only
gives you a few terms, and you make what you can out of them. If you
need something that isn't in the language, then you:-
a) Look for a lanugage that does
b) Invent the terms yourself
c) Beg the DAML people to add them to DAML
a) is getting easier all the time, but b) is often the only option,
and then you have to get people to take up your term, which they're
not going to do. The problem with primitives is that they're
primitive - they're difficult to infer, but not impossible. For
example, let's say I come up with sbp:implies, and want to use that
instead of log:implies. I'd have to do:-
{ :x sbp:implies :y } log:implies { :x log:implies :y } .
{ :x log:implies :y } sbp:implies { :x sbp:implies :y } .
To get it to work on both my system and CWM. But that means you double
the amount of statements, which is quite pointless. So the point is
that what we need is a very stable base of terms that everyone can
use: a universal set of terms. The problem with the current suite of
terms is that they are so fragmented: you have RDF Schema which is
ancient, and has quite a few issues, you have DAML which isn't even
maintained by the W3C, and is incompatable with RDF Schema
occasionally, and then you have LOG which is a TimBL hack and has even
had a namespace change from "...log.n3#" to "...log#". This is not a
good status for the Semantic Web, and really the only thing that gets
in the way is the politics.
We need a few modular steps to RDF:-
The basic syntax terms (Description, about, etc.)
Human labelling (title, label, see also, defined by, comment)
The basic schema model (resource, classes, predicates)
Higher schema/ontologies (types, subClass, subProperty, range, domain)
Model (lists, reification, contexts, cardinalities)
Logic (and, or, not, quantification, truths)
Inferences (equivalencies, implication, inverses)
Junk (starts with, uri, namespace, QNames, datatypes, string
functions)
Proof (this was obtained by x y and z)
There are many overlaps between these layers, so they'll have to be
coordinated very carefully.Interestingly, I think that as inferences
are built on top of logic, not the other way around, logic should be
developed as a more basic layer than the inferences.
Let's hope so.
Kindest Regards,
Sean B. Palmer
@prefix : http://webns.net/roughterms/ .
:Sean :hasHomepage http://purl.org/net/sbp/ .
