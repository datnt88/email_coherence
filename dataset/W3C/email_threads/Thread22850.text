In looking through the DOM specs, I could not discern a way to do the
following:
Given two nodes of a common parent, identify which node precedes the other
in the parent's ChildNodes nodelist.
Is there such a creature in the current specs?
Regards,
-Tom
You'd basically look at the nodelist yourself. Takes a few lines
of code -- would you seriously expect DOM to save you the work of
writing such a simple subroutine? If so, why?
- Dave
On Monday, February 28, 2000 5:50 PM, David Brownell
[mailto:david-b@pacbell.net]
Dave,
DOM allows me to access a childNode directly by using the item(index) method
off of the nodelist that is returned from childNodes, rather than walking
the nodelist.
So, I was expecting that if I had the reference to the childNode, it would
have an index property that I would be able to use for routines like this,
rather than having to examine the nodelist itself.
Am I really expecting too much? :-)
-Tom
other
I've heard one strong case where an ordering query would be useful -- not
on NodeLists, but on lists of nodes generated in other ways. That case is
XSLT. It's not uncommon there to want to take the union of several
seperately executed searches and present it as a single list of nodes, in
document order. In that situation, convolving the lists to interleave them
correctly can be a significantly expensive operation.
We've had periodic requests from XSLT developers to add a
Node.isBefore(Node) operation, which they could invoke in the hope that a
specific DOM might have an underlying representation which permits
optimizing this operation. Given that some models _can_ answer this
question much more quickly via their internal representations than via
their DOM API, I think it's worth considering.
Statement of bias: I wrote one such model; that fast-ordering feature is
one of several reasons LotusXSL/Xalan prefers to read the input document
from DTM rather than from a "normal" DOM.
Joe Kesselman / IBM Research
Right, the "list" can be implemented as an array (easy to implement
the "item" method) or as a linnked list (more awkward) or some other
data structure.
Perhaps. If you got used to using it, the linked list implementation
would accumulate some bizarre costs since it'd need to recompute that
property pretty often ... but that'd be more reasonable than asking for
a specific "is this child before that one" primitive, as you'd seemed
to be suggesting!
- Dave
would
this,
You're expecting a particular implementation.
In some implementations, a node does indeed have an index property within
its parent. But others only know who their parent and immediate siblings
are; to get their index, they would have to walk the sibling chain,
"counting on their fingers". It might be more efficient to instead walk
until you either find the other sibling or fail to find it, and just return
that relative positioning rather than absolute.
Note that the general case of relative positioning of two nodes is harder;
you have to determine the lowest common ancestor, then determine which one
comes earlier. And you have to deal with the case where there _isn't_ a
common ancestor... and decide whether to report attributes that way, or as
falling between their owning Element and its children... while remember
that either way, the attributes are officially unordered relative to each
other.
Remember, NodeLists are not necessarily implemented as arrays of nodes.
They're live filtered views of the document which just happen to be
integer-indexed to make them easier to use for folks who think in terms of
arrays. But they're arguably more closely related to the DOM Level 2
NodeIterator and TreeWalker than to a simple array.
Joe Kesselman / IBM Research
Furthermore, if the element is part of an entity, then no single index
will work, as the element node may be in the tree in multiple places.
Schlingt dreifach einen Kreis vom dies! || John Cowan jcowan@reutershealth.com
Schliesst euer Aug vor heiliger Schau, || http://www.reutershealth.com
Denn er genoss vom Honig-Tau, || http://www.ccil.org/~cowan
Und trank die Milch vom Paradies. -- Coleridge (tr. Politzer)
Actually I tend to disagree on that one.
There is some nasty text in the DOM spec saying that the "same" nodes
are EntityRef children as are children of the respective Entity. Is
that what you're thinking about?
But that notion of "same" seems to me like it must be (equals? a b)
rather than (eq? a b), to sneak in two LISP primitives ... since, unlike
the case with LISP, DOM nodes have (non-null) ancestors that prevent
them from being in more than one place at a time. A DOM is a tree,
not a general graph.
(Note to DOM WG: Perhaps the prose on that part of the DOM spec needs
to say what it means by "same"?)
- Dave
This gets into questions of whether multiple copies of an entity share the
same nodes or not... and how the user can tell. I'm not sure that the DOM
makes any promises either way. Some of the open questions about how parsed
entities and namespaces interact make that sharing less likely than it once
was.
Reminder, since we're on the topic: node identity does not require object
identity. In some DOM bindings, asking whether it's the same object is not
the right test. One of the outstanding issues is the possibility of adding
a Node.isSameNode(Node) test, which would work in all bindings.
Joe Kesselman / IBM Research
"identity" being as fuzzy a notion as "equality" -- I said this earlier
in terms of (eq? a b) and (equals? a b).
Would such a test ever be meaningful except for two readonly nodes
inside of an entity (reference)? If not, is there really a compelling
use case for such a primitive?
- Dave
Umph. Yes, it does, doesn't it.. Core, section 1.1.8: "In a document with
no namespaces, the child list of an EntityReference node is always the same
as that of the corresponding Entity." And again in the description of
createEntityReference.
We should probably rephrase that as "equivalent to", or something of that
sort. Possibly with explanation.
Good catch!
Very good point. A DOM implementation may or may not be able to share data
behind the scenes, but the children of one EntityReference are _not_ "the
same nodes" as children of another reference to the same entity; a node can
only have one parent.
There are also some issues about how Namespace prefixes are to be handled
in entities. 1.1.8 discusses those concerns.
Joe Kesselman / IBM Research
object
As long as we remember that there are two distinct kinds of "identity"
being discussed, it's not so bad:
Node identity is clearly defined in terms of the DOM, and is a necessary
concept for a significant number of common tree processing operations. As
one example, take the case of unioning several searches into a single list
of nodes; if you can't ask "is this a node I've seen before", you can't
discard duplicates. Or, consider a hand-coded subtree walker; if you can't
ask "is this the root node I started from", you can't stop yourself from
walking out of that subtree.
Most of us have been blythely assuming that object identity -- the
programming language's node1==node2 or equivalent -- can be used to test
for node identity. But in DOMs which operate as a proxy for other data
representations, it is possible that several DOM Node objects may in fact
be handles for the same node. In that case, == will return false (unless
you're in a language that permits overriding =='s behavior), but
Node.isSameNode(Node) would be defined as returning true.
Equality is yet another question, of course. Presumably equality would be
defined as "represents the same content". We've dithered a bit about
exactly how to define that -- specifically, about whether there's one
definition that really works for the majority of cases -- and between that
and the lack of a compelling need (since this test _can_ be implemented in
terms of the public DOM API), it's been deferred. The main argument for
moving it into the DOM would be that some DOMs might want to apply hashing
or other techniques to improve performance.
Joe Kesselman / IBM Research
I'm not sure where this discussion left off.
My take on this, which others may disagree with:
1) The request for isBefore/isAfter has been made before, by XSLT
implementors. Adding it might be a Good Thing, since in DOMs which do
optimize it the benefits could be very large.
2) getIndexOf strikes me as The Wrong Thing. Not powerful enough to be
really useful, and has the same problems as any other integer-indexed
access to the DOM -- that being that when the document is edited, stored
indices become incorrect and you're stuck with recalculation overhead.
Though I admit to being strongly biased against NodeLists to begin with.
Neither is currently on the Open Issues list for DOM Level 3. I suppose I
should add them.
Joe Kesselman / IBM Research
No. I, too, would find one useful. And different
implementations might optimize it differently if it were a
standard method in DOM.
Once nodes with a common parent are found, trace previous
/ next in a loop (I do both simultaneously) and see which direction
one can be found from the other. If the nodes are not known
to be siblings, the procedure is only a bit more complicated.
Unfortunately, this requires you to be able to detect whether
two node objects within a hierarchy represent the same node.
In some implementations, this can be done by using an ==
comparison on the object references, but there is no guarantee
that the same object will always be returned for a specific node,
so this order comparison cannot be performed portably, unless I
missed something. The inability to compare node identity is an
omission that needs to be resolved.
Alternatively, it might be possible to use Level 2 optional ranges
to answer the question, by setting start and end, and checking
whether the range has collapsed using the isCollapsed attribute.
To me, this seems to be an appropriate use of ranges, if your
DOM implementation is level 2 and supports ranges.
Is anyone aware of a better approach?
Ray Whitmer
ray@xmission.com
Does anyone have a specific use case for getIndexOf, for inclusion in the
open-issue description? Or is it just being requested on the basis of
symmetry with NodeList.item()?
Joe Kesselman / IBM Research
In XML the order of nodes is defined to be significant. Even if you
construct cases where it is not "conceptually", such as an RDB export into
XML syntax, the order is still significant by definition; just as the order
or records in a relation is by definition *not* significant, even if there
is some serial-number or other field floating around that implies an order
to apps/people that know.
Given that XML is ordered, it does seem pretty strange to not be able to
determine what order any given two things are in.
Put another way, the lack of such functionality contradicts the data model.
I would say that is *why* operations are being asked for that turn out to
be very expensive to simulate.
Just like when you simulate XML with an RDB: traversing nodes just to do an
identity export of a document in the right order, requires extra fields or
relations plus a whole lot of sorting -- one big sort if your RDB models
XML via generic nodes, a gazillion little sub-selects and sorts if it
instead uses a separate relation for each element type.
It isn't surprising in either case that you can simulate the other data
model -- but it costs. The data model and data architecture mismatch, and
that generally leads to high costs down the line.
Much better to add the facility and make the interface match the data model
better. Calculate O() for the common operations needed to keep all the
intermediate results in XPath (and therefore also XPointer) in order, it
will add up real fast.
Steven_DeRose@Brown.edu; http://www.stg.brown.edu/~sjd
Chief Scientist, Scholarly Technology Group, and
Adjunct Associate Professor, Brown University
North American Editor, the Text Encoding Initiative
The uncertainty is inherent in large scale systems; "identity" is
a rather complex topic once you start to explore it.
The short version of a _really_ long story is that object identity
in a proxied/distributed system is a very hard notion. Within any
small problem domain you can often make it testable. I've observed
that people working exclusively inside one database tend to assume it's
always testable (e.g. by tuple ID) while people integrating over wider
data domains tend to assume the opposite.
The convenient line is generally: within one address space, it may
be practical to impose a policy that identity is testable, usually
with a primitive like "==". As that single address space gets larger,
that can become impractical ... and between address spaces it's often
impractical to get trustworthy _and_ efficient answers. (Unless
you turn it into a problem isomorphic with a single address space:
master server and lots of clients or slave servers, for example.)
You don't need a strong notion of object identity in order to
answer the ordering question. Ordering is a specific problem
domain notion that is only incidentally related to the general
problem of identity.
- Dave
And I spoke too quickly. In the particular case given, where
the nodes are known to be children of the same parent, you can
just use getNextSibling to count the number of next siblings of
each node, and the node with more next siblings comes first.
Ray Whitmer
ray@imall.com
Being ordered, and being able to easily extract ordering information, are
two different things.
All the information required does already exist in the DOM API, though not
in a convenient form:
Make sure the two nodes aren't the same node
(if they are, neither preceeds the other)
Find lowest common ancestor of the two nodes
Walk its immediate children left to right
Stop when you find the first child whose subtree contains one of the
two nodes. That node comes before the other.
Implementation is left as an exercise for the reader.
We don't currently define a single-step query which _only_ returns the
who-comes-first information. (Nor does the Infoset, as far as I know.)
As has been noted there may be reason to add this, both for convenience and
because some DOMs may be able to offer a faster implementation based on
internal knowledge. But it doesn't necessarily have to be added in Level 2,
since the do-it-yourself calculation does work.
Certainly worth further consideration. It's been placed on the open issues
list.
Joe Kesselman / IBM Research
I'm not sure where this discussion left off. The original question was
something like: is there a method that will allow the user to check the
document order of two nodes. This seems like a reasonable request to me,
and one that many of us have had to implement ourselves while using (and
implementing) the DOM. I'm sure this was discussed in the past, but
dismissed for implementation reasons.
So at the risk of kicking a dead horse, I'd suggest that two sets of methods
would be useful. The first being index-based:
// return index of child or -1 if not an immediate child
int Node.getIndexOf(Node child);
// return this node's index in its parent's child list, or -1 if not a
child.
int Node.getIndex()
The second set of operations is relational:
// return true if arg is positioned before this node.
// If deep is false, only siblings are checked. Otherwise,
// the entire document is checked.
boolean Node.isBefore(Node arg, boolean deep);
// return true if arg is positioned after...
boolean Node.isAfter(Node arg, boolean deep)
For implementations based on an array, the first set will be fast. For
implementations based on a list, the first could be slow. So to make things
fair for all implementors, the second set of methods will probably be
complicated regardless of implementation.
Granted, it may require some work on clarifying what happens when 'arg' is a
child of an entity, but I would think that implementors would be much more
qualified to implement these functions than users. It might even help to
clarify that portion of the spec.
David Brownell wrote,
How about: because some implementations might be able to
provide an O(1) implementation, whereas an external routine
would be likely to be O(number of siblings) or thereabouts.
There're several other queries like this which could usefully
be added and which might allow for similar optimizations:
precedes in document order; is an ancestor of; least common
ancestor; depth from root etc.
Cheers,
Miles
Miles Sabin Cromwell Media
Internet Systems Architect 5/6 Glenthorne Mews
msabin@cromwellmedia.com http://www.cromwellmedia.com/
Just a coding tip:
If an optimized operation isn't supported directly in the DOM, consider
writing a library routine to encapsulte it. This could use custom calls
against DOM implementations that provide shortcuts, but fall back on
standard DOM operations for those which don't have such features.
Definitely not as nice as a standard solution, since the wrapper routines
would have to be aware of specific implementations. That makes it a
maintainance pain; you have to enumerate those implementations and maintain
their special-cases individually. And there is a bit of overhead.
But this sort of approach isn't uncommon right now, as folks try to take
advantage of custom features without losing portability (or benefit from
Level 2 features without losing the ability to manipulate Level 1 DOMs)...
and it has the advantage that if a standardized solution does become
available, the wrapper can be trivially switched over to use it without
impacting the rest of your code.
Joe Kesselman / IBM Research
Joe Kesselman wrote,
We've done that where appropriate but it's a Disgusting Hack(tm).
In fact, a lot of the overhead can be eliminated by testing
just once against the DOMImplementation and getting back an
object which supports a variety of optimized operations over
any instance of that impl ...
Cheers,
Miles
Miles Sabin Cromwell Media
Internet Systems Architect 5/6 Glenthorne Mews
msabin@cromwellmedia.com http://www.cromwellmedia.com/
Good point. A patent search will show you a few O(1) methods for SGML, and
there are other ways known since, some published in the last few years of
the ACM Hypertext and Digital Libraries conferences.
The performance difference could easily be even worse. Some implementations
such as many based on B-trees, are worse than O(number of siblings) because
the time to examine each sibling is worse than O(k) and the costs multiply.
Implementations *ought* to do no worse than you describe, but even
O(|siblings|) vs. O(1) is a *big* deal sometimes; I've seen lots of real
user documents with sibling-lists in the 10,000 range. XML data that's
exported from RDBs (like a lot of e-commerce interchange, for example) will
often have huge fanout. a 10,000 to 1 hit on performance seems like a
pretty good reason to consider adding an interface for something that so
clearly fits the data model anyway....
Yup; there's a must-read paper in Digital Libraries 98 (+/- 1? sorry, don't
have the reference handy, authors were from Korea, though) on ways to
optimize the heck out of all these commonplace operations. Also some good
work in VLDB '99 (though the most relevant ones from there don't actually
mention XML in the titles).
Steve
Steven_DeRose@Brown.edu; http://www.stg.brown.edu/~sjd
Chief Scientist, Scholarly Technology Group, and
Adjunct Associate Professor, Brown University
North American Editor, the Text Encoding Initiative
I think it's a natural complement to NodeList.item(), but I've seen a number
of instances where index-based access is necessary, usually in cases where
the DOM model is adapted to fit existing frameworks.
Here's one that comes to mind immediately: When displaying a node hierarchy
in a graphical interface, it is often necessary to provide access to nodes
based on their index relative to their parent--for example, when removing a
node using an ActiveX tree control, I need to pass the parent node and the
index of the node to delete. Of course this is easy to implement yourself,
but it would be nice to have it done by the DOM implementation. And if the
implementation can optimize index-based access, that's another plus.
The original comment was more along the lines of "can't do
this, why? aaagh!" as I recall ... not the "it's too slow"
that you seem to be suggesting it was.
It's common that some special purpose task can be sped up by
putting it into infrastructure. But that in itself is rarely
a compelling motivation for making it a "standard, everyone
must implement this" part of an infrastructure. If everyone
has to pay for it, everyone _ought_ to benefit more or less
equally from it.
- Dave
Got any suggestions about how to weigh the requirements for
those (big/huge documents) apps against the other ones?
Seems to me that if there's a real need for such methods
it'd be appropriate to collect them into a new interface,
which could optionally be implemented by DOM vendors who
are courting applications working with that type of data.
I'm not yet convinced that those operations are common
enough to warrant more than another optional functionality
module in DOM. Even though you called them "commonplace";
perhaps in your problem domain they are.
- Dave
Or -- if the implementation supported the optional "we've got
these graph-structure primitives" feature, it could use them
without needing custom calls.
L2 _is_ going to be very clear about how folk other than W3C
can define new feature identifiers to pass to Node.hasFeature()
isn't it?
- Dave
There's language in L2's description of hasFeature that addresses this.
We might want to tweak that wording slightly. It currently says "The legal
values are defined throughout this specification and listed in the
Compliance section." I suspect that we meant to say "The values used by the
DOM Specification". We should also probably be more explicit about the fact
that names without periods (ie, without prefixes) are reserved for use by
the DOM spec.
Joe Kesselman / IBM Research
