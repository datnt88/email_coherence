OK, basically it seems that we ought to do the following (DanC?)
For each test case (in the form of a piece of RDF)...
1. Create serialised RDF as an attachment ("test1.rdf")
2. Create expected output (more below) as an attachment ("test1.out")
these come in pairs.
3. Where we've got optional behaviour (x MAY do y) provide enumerated
outputs (test1a.out, etc.)
Expected output should be a list of triples that describe the expected
output (in the following format) OR just "error" to indicate that the
test case is an example of something that should be non-conforming (or
deprecated?).
A triple is represented as:
triple(S, P, O)
where S, P, O are any of:
r("URI")
a("ID")
l("literal")
(with the usual rules about placement of literals). r("URI") is a normal
resource. l("literal") is a literal; a("ID") is an anonymous resource,
which I think (with an eye on the future) that we ought to make
explicitly different from r("#genid").
Something conforms wrt the test case iff it interprets the RDF as
producing* a set of triples identical with the sample output, up to
reordering and the global renaming of anonymous resources.
Re: anon resources - two elements a(X) and a(Y) should be considered to
represent "the same anon resource" iff X=Y (lexically) - and the scope
of the identity of an anon resource is the single test output
attachment.
Clear as mud of course - any real objections?
Once I've had the nod, I'll submit the empty element proposal in that
format (or even beforehand as an example if people prefer).
jan
* for the usual values of "producing" - implying, representing, etc.
jan grant, ILRT, University of Bristol. http://www.ilrt.bris.ac.uk/
Goedel would be proud - I'm both inconsistent _and_ incomplete.
generally: make it available via HTTP and give
it the relevant license and availability/persistence.
Sending stuff to this list grants the relevant license
(as a consequence of the agreement folks executed
when they joined the group; see the charter and
W3C process for details).
I'd like to say that it assures the relevant
persistence, but actually, our list archives have
been known to reshuffle the numbers occasionally. Sigh.
So... sending stuff as attachments to this list
should be sufficient, but I don't think it's strictly
necessary; there are perhaps other ways to meet
the above constraints.
Yikes! optional behaviour? I should hope not; I should
hope each RDF document means exactly one thing. But I guess
we'll figure that out as we go...
We have avoided "deprecated" so far (whew!); let's keep it that
way as long as we can...
I have some comments on the format itself; I think I'll
send those separately...
Dan Connolly, W3C http://www.w3.org/People/Connolly/
I have a certain investment in
S P O.
The SWAP code (cwm, notation3) groks that format.
There's precedent for URI in RFC2396; e.g.
In many cases, different URI strings may actually identify the
identical resource. For example, the host names used in URL are
actually case insensitive, and the URL http://www.XEROX.com is
equivalent to http://www.xerox.com .
-- http://www.ietf.org/rfc/rfc2396.txt
The swap/cwm/n3 stuff doesn't have a syntax for this;
we've considered ?ID; I'd be willing to add code
for that.
How about just "literal"? There are a host of
quoting and unicode issues; swap/cwmp/n3 follows
python currently; I wonder how different it is
from the string literal formats in Java; I'd
be willing to go with that.
3.10.5 String Literals
(does ANSI-C have a unicode-capable string
literal syntax? how about perl?)
Of course, any decision on how to represent
literals in expected results is also a decision
to a whole pile of actual RDF issues: xml:lang, etc.
Yes, it must be different. TimBL provided me with some convincing
examples... I should find those and/or write them up...
Right.
It's too bad there's no way to reduce that to some sort/diff
thingy, but there just isn't. It's inherently a graph-matching
thing.
We've been coding it up, but I'm not sure it's debugged.
(see the includes built-in stuff
Would an implementation in prolog fit on the front side
of one page?
that's if X=Y, not iff.
If X  Y, they could still represent the same resource.
Yes, they're still distinct terms, which is the relevant
point for this excersise, but to persue the diversion,
consider:
mailto:connolly@w3.org http://example/vocab#ownedBy ?x1.
mailto:connolly@w3.org http://example/vocab#ownedBy ?x2.
If ownedBy is functional/unique/many-to-one, then ?x1 and
?x2 represent/denote the same resource/object/thing.
No real objections.... I'm just exploring alternatives
that are grounded in running code...
And actually, now that I think about this a("ID") vs ?id
stuff... we could actually use KIF syntax:
(exists (?x1)
(mailto\:connolly\@w3\.org http\:\/\/example/vocab\#ownedBy ?x1)
I wrote a KIF parser a while ago...
that code is pretty ugly; but it does
have the relevant reference:
[KIF]
Knowledge Interchange Format draft proposed American National
Standard (dpANS)
NCITS.T2/98-004
Last Modified: Thursday, 25-Jun-98 22:31:37 GMT
There are other dialects of KIF; my notes on ANSI KIF
and KIF v3 are in
KIF as an RDF Schema (in progress Aug 2000)
There are a few nitty gritty issues... some versions
of KIF are case-insensitive, and they don't grok
Unicode. I gather from Pay Hayes that those are
being fixed, and we could anticipate those fixes.
And while I'm on that train of thought, I could
go with your triple(P, S, O) format, provided
the details are consistent with real prolog
implementations. Open source, easy-to-install-and-use
implementations, like swi-prolog.
Oh! I would, of course, be remiss if I did not propose and
XML-based format. Perhaps we could implement
the compare-expected-results thingy in XSLT...
I was just playing around with Brian McBride's
executable grammar;
It produces:
statement subjURI="http://example/someThing"
objURI="http://example/someClass"/
I don't like the term 'model' any more. I think
what we've got here is abstract syntax. But
you get the idea.
(Brian: spec.xsl was missing a whole bunch
of xsl:param/ s. Did it work without those
somehow for you? what XSLT processor did you use?)
Dan Connolly, W3C http://www.w3.org/People/Connolly/
Ehh? What are the issues with sorting the triples and providing some
algorithm for anonymous resource naming?
[ :name "Aaron Swartz" ;
:mbox mailto:me@aaronsw.com ;
:homepage http://www.aaronsw.com ] is dc:author of  .
You're welcome to give it a try, but I don't see
any algorithm for naming the anonymous resources
that's any simpler than graph matching.
Dan Connolly, W3C http://www.w3.org/People/Connolly/
I don't know what graph matching is, but what's wrong with:
1) Sort each anonymous node individually in form:
#pred #obj ;
2) Remove line breaks and surround each anonnode with "[ " and " ]."
3) Combine with regular triples and sort
You end up with something like:
#subj #pred3 "aaa" .
[ #pred1 "ob" ; #pred2 #obj ; ].
Am I missing something?
[ :name "Aaron Swartz" ;
:mbox mailto:me@aaronsw.com ;
:homepage http://www.aaronsw.com ] is dc:author of  .
e.g. http://www.agfa.com/w3c/euler/danc-result.n3
is the result of a graph matching (for anonymous
resources) of
onto
The algorithm is pretty simple and can be found
as part of the eval and unify methods of
Jos De Roo, AGFA http://www.agfa.com/w3c/jdroo/
I don't think you can do that in the general case;
sometimes anonymous nodes are objects; they're
not always subjects; see below...
I think you're not taking into account cases like...
[ #hairColor #brown ].
i.e.
rdf:RDF xmlns="file:/home/connolly/,ex.n3#"
xmlns:log="http://www.w3.org/2000/10/swap/log#"
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
Dan Connolly, W3C http://www.w3.org/People/Connolly/
Hmm, good point. OK, how about:
[ #hairColor #brown ; is #hasCousin of #DanC ] .
[ "Aaron Swartz" ; mailto:me@aaronsw.com ; http://www.aaronsw.com ]
What I'm after is a format for producing output from parsers (for
instance) that _doesn't_ require complicated handling; I don't want to
have to debug my test-output generator or reader too!
Triples are fine. A graph-matching algorithm might have a high cost
theoretically, but if we're talking about test cases producing less than
50ish nodes, this shouldn't be a problem.
The reason I used l("blah") rather than "blah", incidentally, is to
permit the attachment of additional information l("blah","language").
I don't really care what the syntax looks like* as long as it's trivial
to produce.
jan
* only religious opinion is "SPO, not PSO" :-)
jan grant, ILRT, University of Bristol. http://www.ilrt.bris.ac.uk/
Axioms speak louder than words.
OK, it's worth spelling this out explicitly (I think DanC and I think
the same thing, but mailing lists aren't the place for unspoken
assumptions).
RDF test cases are (at least, syntax-related ones) are dealing with the
turning of RDF syntax into a graph.
Thus above, I should have referred to "anonymous nodes" rather than
"anonymous resources". Two elements a(X) and a(Y) should be considered
to represent "the same anonymous node (in the resultant graph)" iff X=Y
lexically.
The question of an interpretive function turning nodes into
resources/entities is left as part of the semantic layer; the test cases
we're talking about don't yet require this. That I(a(X)) may
equal I(a(Y)) doesn't really matter here.
Thus, matching test outputs with the expected output is graph
matching (unification while preserving the identity/distinction between
pairs of nodes in each of the input graphs).
Do we all agree?
As to syntax, let's take a view and stick to it. I don't really care
_what_ it looks like, so the formal proposal (given before) holds (use
of r(), a() and l(), with the following amendment:
l("blah")
is a literal. We use java conventions for unicode characters.
l("blah","foo")
is a literal; foo is its xml:lang if one was specified.
If everyone is happy (ie, has no objections on technical merits) then
I'd rather we just go ahead and use this. I don't care if it'd be neater
to use {{% %}} brackets around things - we can debate this endlessly. If
someone out there has a preferred format that they've got a zillion test
cases in, speak now or forever hold your peace*.
jan
* and use perl.
jan grant, ILRT, University of Bristol. http://www.ilrt.bris.ac.uk/
Leverage that synergy! Ooh yeah, looking good! Now stretch - and relax.
Me neither
Its a while since I played with it. I was using Xalan I think.
If I get my head above water, I'll have another look at it.
Brian
Er... I think the non-technical issues actually dominate, in this
case. This is primarily a practical engineering decision.
I agree that technically, i.e. in theory, we could use
lots of things. But I don't agree to your proposal because
it's not backed by running code.
I have a preferred format that I have a zillion test cases in:
RDF/notation3.
I'm happy to discuss alternatives that are backed by running
code.
I pefer python. I'm also happy with the XSLT-based proposals
I've seen. I'm willing
to look at a proposal written in perl; I'll hold my nose ;-)
On behalf of W3C (esp. the I18N WG), I'm somewhat obliged
to prefer an XML-based format, unless there are good reasons
to use something else.
Meanwhile, I do think there are good reasons: (a) because
XML is so hard to read that it unduely increases the
cost of debugging the tests and (b) because using XML might
hide some of the RDF issues that are close to XML.
Dan Connolly, W3C http://www.w3.org/People/Connolly/
Fine. How do I name anonymous "thing"s in n3? It wasn't on the WG
reading list :-)
If I can do that and there's a simple (ie, sed) transformation
between triple(s, p, o) and some well-defined subset of n3 then I'm
happy.
jan
jan grant, ILRT, University of Bristol. http://www.ilrt.bris.ac.uk/
HP-unix: Open Sauce product, available in 57 distributions.
We don't want to spend forever on this.
Jan has made a proposal for a simple triple based syntax. DanC has
said he'd prefer something N3 compatible.
I'm assuming that for clarity we'd be restricting test cases to the
simplest
S P O.
form of N3 - I'd hate for anything to be unclear because we are not
sure what N3 means exactly.
If thats the case, there is very little difference between the two,
and there may well be an advantage to going with a format that N3
processers can slurp in directly.
If:
o DanC were to propose a way of augmenting "S P O." to represent
anonymous nodes.
o We have an issue #rdfms-xmllang questioning representing the xml:lang
attribute as part of the literal. If the outcome of that lang
attributes are part of the literal value then we'll augment this
syntax to include a lang attribute in a literal.
would that meet our needs?
Brian
I've put an 'alpha' version of an RDF namespace parser up at
It looks for the namespace of the files elements and attributes , and
tables them. If needed it will convert uncolonized attributes, and
unqualified namespace declarations into quaified declarations, and
colonized atts. (It does not deal with empty unqualified namespace
declarations (i.e. xmlns="") yet.). I have not yet tested it on any
'torture' files, (Can any one give be the URL of such a file?), but it
should work on any smaller files.
It's built on top of the MSXML parser.
I would be glad of any feed back, or whether a stand alone version
(Java,VB or C) would be useful.
frank boumphrey
Perhaps we should not take this all on at once, but I'm hoping that the
format we choose is usable with standard tools (diff/sort) and provides a
canonical version useful for other things (digital signing, transport,
etc.).
Personally, I'm not much in the mood for coding and debugging a graph
matching tool. However, I can write a script to output the format I suggest
in only a couple of lines and code already exists to read it (the various N3
parsers).
Aaron Swartz me@aaronsw.com | RSS Info
AIM: JediOfPi | ICQ: 33158237| news and information on the RSS format
I believe that it's:
#name :- [ anonymous node ] .
Aaron Swartz me@aaronsw.com | RSS Info
AIM: JediOfPi | ICQ: 33158237| news and information on the RSS format
For something more RDF-centric, Dan Connolly has built an XSLT file to fix
broken RDF files:
You can use it with the W3C's online XSLT service. An example is:
/fixAttrs.xsl&amp;xmlfile=http://www.w3.org/2001/04rs22/confusedPrefixes.rdf
But replace the confusedPrefixes file with any file available over HTTP to
fix it.
Dan, would you mind putting up an HTML form on the syntax hacking page for
people to use? Also, why do the forms use POST instead of GET?
Aaron Swartz me@aaronsw.com | The Info Network
AIM: JediOfPi | ICQ: 33158237| the way you want the web to be
I proposed a solution to this in:
with amendment:
I think this would be a very good choice.
[ "Aaron Swartz" ; mailto:me@aaronsw.com ; http://www.aaronsw.com ]
Actually, that smiley-point is well-made: this testing format
shouldn't depend on all the RDF/n3 specs, code, and
tutorials, which are in flux...
Well, that sort of achieves the relevant effect, but
it's complex to an extent that's not motivated for
this usage. I was just chatting with TimBL, and
I convinced him to add support for
_:name
While he's hacking on that, I'll re-state this proposal,
independent of the N3 code and docs.
We've got terms of the form
_:namefor "anonymous" terms
absURIref for URIs
"lskdjf"for string literals.
and statements of the form
S P O.
where S, P, and O are terms (S and P can't be literals
in the expected results from any RDF 1.0
document.)
I wrote a little perl hack to parse the
format I'm proposing and, modulo
string quoting cruft, turn it into triple(a(x), r(http:...), l("xyz"))
format.
given the test input from
the expected results are in:
which, when fed thru n3-simple.pl, produces:
triple(r(http://www.w3.org/2000/10/swap/test/animal.rdf#Animal),
r(http://www.w3.org/1999/02/22-rdf-syntax-ns#type),
r(http://www.w3.org/2000/01/rdf-schema#Class))
triple(r(http://www.w3.org/2000/10/swap/test/animal.rdf#Animal),
r(http://www.daml.org/2000/12/daml+oil#restrictedBy), a(a))
triple(a(a), r(http://www.w3.org/1999/02/22-rdf-syntax-ns#type),
r(http://www.daml.org/2000/12/daml+oil#Restriction))
triple(a(a), r(http://www.daml.org/2000/12/daml+oil#onProperty),
r(http://www.w3.org/2000/10/swap/test/animal.rdf#parent))
triple(a(a), r(http://www.daml.org/2000/12/daml+oil#cardinality),
l("2"))
triple(a(a), r(http://www.w3.org/2000/01/rdf-schema#label), l("Animal"))
which shows what we all knew: we can use either the n3-simple
format or the prolog-ish triple() format.
The interesting bit is to see which format is backed by a
"do these graphs match?" code first. Preferably two independent
implementations. cwm already does it
for N3, modulo the _:name syntax (and modulo cwm bugs ;-)
Jos, I gather your code can almost do the comparison too.
Jan, have you hacked an implementation of graph matching
for the triple() format yet? It seems like it should
be about 50 lines of prolog. Maybe I'll take a whack at it...
Dan Connolly, W3C http://www.w3.org/People/Connolly/
er... I did.
$Revision: 1.8 $ of $Date: 2001/05/24 15:34:30 $
Oops... that form only works for getting rid
of collection sugar. But there's a link
to a form that works for any combination
of transformation and input, so I'll
fix this next time I'm mucking in there,
rather than swapping in all the context
just now.
Huh? They don't, to my knowledge.
Dan Connolly, W3C http://www.w3.org/People/Connolly/
aaron For something more RDF-centric, Dan Connolly has built an XSLT
file to fix
broken RDF files: /aaron
Yes. I saw that, but quick scan of the XSLT file suggests that this
just fixes attributes in the RDF namespace. (i may be wrong).
We also need to be able to fix attributes in other namespaces.
Frank
and
and
any
but it
to fix
04rs22
/fixAttrs.xsl&amp;xmlfile=http://www.w3.org/2001/04rs22/confusedPrefixes.r
df
HTTP to
page for
view source shows (at line 70):
For my own enlightenment, is there any reason why 'GET' is preferred
in RDF?. I always use 'POST' in my hacking.
Frank
and
and
any
but it
to fix
04rs22
/fixAttrs.xsl&amp;xmlfile=http://www.w3.org/2001/04rs22/confusedPrefixes.r
df
HTTP to
page for
Why is this? Other attributes have no clear meaning and are probably best
ignored.
Aaron Swartz me@aaronsw.com | RSS Info
AIM: JediOfPi | ICQ: 33158237| news and information on the RSS format
Yes, Dan kindly changed it after my post. The reason GET is preferred is
because GET and POST have a semantic meaning, and before trying to add more
semantics to the Web we should do our best to maintain the ones that are
already there. GET is meant to be used for any action that has no side
effects -- thus, any client should be able to request, prefetch, etc. it
without worry. POST should only be used for actions which have some sort of
effect -- unsubscribing someone from a mailing list, etc. For more on this
and other bits of theory to the Web, see Tim Berners-Lee's Axioms of Web
Architecture:
[ "Aaron Swartz" ; mailto:me@aaronsw.com ; http://www.aaronsw.com ]
Yes
How would we handle relative URI's, e.g.:
Brian
I'd suggest just using relative URIs e.g.:
Alternately, we could define a base URI:
[ "Aaron Swartz" ; mailto:me@aaronsw.com ; http://www.aaronsw.com ]
I'm proposing that they get absolutized in the expected results;
in this case:
The input to the test is an XML document, and one of the
properties of an XML document is its base URI. (I suppose
some tests might have syntax errors at the XML level;
but in that case, there are no expected results anyway.)
This might be somewhat tedious: if/when we move the
tests, we have to updated the expected result; copying
them to local disk has to be done in such a way that
the test harness remembers where it came from; etc.
But I think the alternatives are all worse.
Dan Connolly, W3C http://www.w3.org/People/Connolly/
let me jump in here with XML base!
- for the most part it's an ideal spec. Short, snappy, and while it says
a bit about where xml bases come from, it leaves what they do to other
documents.
It would be ideal to expect xml:base to operate under these
circumstances.
jan grant, ILRT, University of Bristol. http://www.ilrt.bris.ac.uk/
Whose kung-fu is the best?
