Dear DOM WG!
Some methods may raise several types of exceptions. It can be
situations where more then one exceptional conditions are met
at the same time. Is it described anywhere how to determine
exceptions' precedence?
For example if I try to call insertBefore method on a readonly
node with newChild being the node created from a different document,
which exception should be raised: NO_MODIFICATION_ALLOWED_ERR or
WRONG_DOCUMENT_ERR?
Thanks.
Yours sincerely,
Vadim.
When more than one exception is possible, then it doesn't matter which
one your implementation chooses to throw, as long as it raises one of
them.
"NO_MODIFICATION_ALLOWED_ERR or WRONG_DOCUMENT_ERR" is the answer. Since
you're in a programming error case (i.e. the application tried to an
illegal action), it doesn't which exception your implementation will
throw.
Philippe
This, I'm sure, is going to irk developers using DOM3. If the precedence is being left undefined so that browser-authors can determine the best error to throw on a case-by-case basis, leaving it out of the scope of the document until, perhaps, DOM4, then I suppose I understand; you can only accomplish so much in one standard.
But at some point developers will want to be able to predict for any set of errors what one error they will receive. Otherwise, a try/catch in a language like Java or Javascript is going to produce varying results for the same error browser to browser. This is sure to be a sore spot for developers once DOM3 proliferates.
-Chris "SoopahMan" Moschini
This has been in DOM since DOM Level 1 and we don't plan to render
current implementations non-conformant.
The program is in fault since it's trying to do an invalid operation. If
more than one valid case applies, the program needs to be fixed imho.
Philippe
It seems to me that current implementations are automatically
non-comformant with higher DOM levels unless they change, since they
won't have any of the new methods or interfaces. It seems to me that
specifying the behavior of existing methods more tightly, but in a way
that is compatible with earlier specs, is no worse. It might even make
sense as a feature you could test for.
Leaving things up to the implementation is in practice no favor to
implementors. For browser-hosted implementations at least, it is often
necessary to copy the behavior of the browser with the biggest market
share at the time a given feature became popular. So if the spec says a
behavior is implementation-defined, but existing apps (read: real-world
web pages) depend on one
specific behavior, then the looseness of the spec only makes life more
difficult for implementors.
I'm not saying this necessarily applies to exceptions. In fact, it
almost certainly doesn't, because ECMAScript code on web pages almost
never checks for exceptions at all. But it's important to keep this
principle in mind when choosing what to leave as implementation-defined
behavior.
I realize, of course, that not all DOM implementations are
browser-hosted. But this subset is very important to the web and worth
considering.
Regards,
Maciej
Oh, agreed - but we don't live in a perfect world. An order of precedence - perhaps ordered by severity - would be helpful to help browsers fail consistently. I've used several imperfect browsers in my day... .
-Chris "SoopahMan" Moschini
