IETF has a set of "golden rules". The two most well-known
rules are:
(1) Be conservative in what you send, liberal in what
you accept.
(2) Do not munge (= modify information objects you
are just transferring)
I am beginning to understand that there is a need for
a new golden rule:
(n) Do not specify standards which require any kind
of intelligence of the software using it.
One example which shows the importance of this new golden rule is the
problem with multipart/alternative and different body parts
containing the same text in different languages. Such use of
multipart/alternative is correct according to the MIME standard (RFC
1522, RFC 2046) only says that this are different alternative
renderings of the same information, but does not say what the
difference is. The receiving mailers must then analyze what is
different between the body parts, in order to find out which piece is
best according to the needs of a particular user. And to make this
decision requires more intelligence than is reasonable to expect of a
mail software. Much less intelligence is needed if the "difference"
attribute to multipart/alternative is used (that attribute is
specified in RFC 1766
As I have poisnted out in previous messages to this mailing list,
such use of multipart/alternative causes disastrous problems with
many popular existing mailers. The original MIME standard did not
have the "difference" attribute
Jacob Palme jpalme@dsv.su.se (Stockholm University and KTH)
for more info see URL: http://www.dsv.su.se/jpalme/
Exactly. We defined something in a standard that hasn't been implemented by
user agents to your satisfaction
This argument might wash if it was the only thing written about the semantics
of multipart/alternative. But it isn't. In fact we're not talking about what
RFC 2046 says here at all, we're talking about RFC 1766, where the
functionality of multipart/alternative was significantly extended past what's
covered in RFC 2046. (I think the addition of a new parameter that entirely
changes how you're supposed to interpret multipart/alternative qualifies as a
significant extension.)
In fact the effect of section 4 of RFC 1766 on the semantics of
multipart/alternative is to extend it in exactly the way you describe: You can
now have a situation where there's no "best" part per se and the differences
parameter tells you how to choose the right one for a given user.
Now, maybe you would like to argue that the text in RFC 1766 isn't sufficiently
clear to understand what needs to be done to handle generalized alternatives
correctly. And I might even agree with that assessment. But I don't think you
can claim that you received no indication whatsoever that the simplistic
"last one you can display" approach described in RFC 2046 had been
extended.
Incidentially, it would have been nice to include the RFC 1766 text in RFC
2046, however, RFC 2046 is a revision of a draft standard (RFC 1521) and at the
time RFC 1766 was only proposed. So I couldn't add it without forcing a recycle
at proposed. Heck, it could not even be referenced, since such a reference
would obviously be normative.
Perhaps before going to full standard, such text could be explicitly
put into the text.
Given that the text in RFC 1766 about this approach has been dropped in RFC
3066 due to lack of interest on the part of implementors, I see no chance
of adding it to MIME itself during a move from draft to full standard.
Ned
I'm perfectly willing to see the history the way you describe:
- RFC 1521 defined multipart/alternative in such a way that it
assumed there is generally one "best choice" for it's "faithfulness
to the original content" and did not adequately address the case
where the alternatives are completely equal in value except in their
value to the *human recipient*. This encouraged implementors to write
code of the "display the last alternative that you can display and
throw away the rest" variety.
- RFC 1766 tried to remedy that situation by significantly extending
1521 for the specific case of language. The remedy did not catch on
with implementors. (I take it this was the usual Catch 22, since no
one would implement sending until their were receivers, and receivers
wouldn't change their code because there were no senders.)
The old and crusty of us didn't do it because of the Catch 22
involved; I wouldn't argue that was from lack of notice. However, my
guess is that newer implementations didn't do it because there was no
indication to do so in 2046.
I disagree that the reference would have necessarily been normative.
I assume that 1766 had at least *one* implementation when it came
out. When we have new implementation experience, certainly it
wouldn't cause a recycle at proposed to include a "Note:" of warning
indicating that the "best-is-last" approach doesn't work with some
uses and that implementors would do well to account for this by
providing user interaction.
This, on the other hand, might be true; I don't know if it's legit to
make the change going to full standard. Hey, wait a minute....aren't
you the one who decides this stuff? :-)
pr
Pete Resnick mailto:presnick@qualcomm.com
