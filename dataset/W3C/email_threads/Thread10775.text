On 23 October 1996, the ERB will vote to decide the following
question. A straw poll indicates the ERB is leaning to keeping
NAME(S) and NMTOKEN(S) but losing NUMBER(S) and NUTOKEN(S).
C.12 Should XML change the set of types available for attributes?
E.g. by suppressing NAME(S), NUMBER(S), NMTOKEN(S), NUTOKEN(S) and
adding constraints in the form of regular expressions, ISO dates,
language-code, external-id, type IDREF, ... (7.9.4, 11.3.3)
We should either expand the space as originally suggested; I like regexp
myself, and it's a drop-in in any language I can imagine people using for
an XML parser (C, C++, Java).
Otherwise, we should just go for CDATA, IDREF, and enumerated attributes
and bag the rest (ID should always be legal, and always be an attribute
called "id", I think). We're not allowing the unquotedness that NAME gets
you, so we might as well make it as easy as possible for each application
to reinvent the wheel of attribute subtyping without any interference from
us. I find the built-in attribute types almost useless, myself.
-- David
RE delenda est.
Some namespace pollution is your friend!
David Durand dgd@cs.bu.edu \ david@dynamicDiagrams.com
Boston University Computer Science \ Sr. Analyst
--------------------------------------------\ http://dynamicDiagrams.com/
MAPA: mapping for the WWW \__________________________
/* suppressing strong urge to blast SGML's "typing" of attributes */
parser (as opposed to a validator) won't have a DTD, aren't we left with just
!ATTLIST foo bar CDATA #IMPLIED ?
For a XML validator (which presumably will need a DTD), the issue becomes one
of a meaningful/useful set of "data types".
If regexps and such are within scope, then considerations such as keeping
names and losing numbers is missing the forest for the trees. Just use
regexps and be done with it.
OTOH, if the choice is restricted to which out of the original set to
retain, then losing all of them except CDATA (perhaps renamed to
RCDATA??;-)) is the
logical choice: an inadequate and overlapping set of alternatives is just
needless complexity. Pass detailed validation to the application -- since
it's the app's bailiwick to grok the attribute semantically.
Arjun
"Features whose purpose is to cause errors should be removed" -- Erik Naggum
On Thu, 17 Oct 96 13:23:55 CDT, Michael Sperberg-McQueen
I agree with David and Arjun. We only need CDATA and ID (which should always be
named ID). With a DTD, IDREF(S), ENTITY(S), and NOTATION can be useful as well.
SGML97 will have "regexp" and then some. The SGML Extended Facilities already
has it. WG8 has not yet designed a revised ATTLIST syntax to incorporate it
properly, though, so it is premature to include it in XML 1.0. (We'll have a
mailing list for SGML97 so all of you will be able to participate in the
design.)
Charles F. Goldfarb * Information Management Consulting * +1(408)867-5553
13075 Paramount Drive * Saratoga CA 95070 * USA
International Standards Editor * ISO 8879 SGML * ISO/IEC 10744 HyTime
Prentice-Hall Series Editor * CFG Series on Open Information Management
I agree with you about regexp. Few people today would design a language
with anything other than POSIX-style internationalised regular expressions
(e.g. they have [:lower:], which refers to all lower case letters where
[a-z] doesn't, as it omits AE-ligature, edh, e-acute, etc., used even
in English outside certain countries...).
You're also correct that there are regexp drop-ins for C, C++, Java and
most other programming languges. Heck, even for FORTRAN probably :-)
Non-standard regexps -- the defacto standard is significantly more
influential than ISO, and has been for over 15 years, to the extent that
even applications such as Microsoft Word use "standard" regular expression
semantics int he Advanced Search -- non-standard regexps are a curse
and and cannot be justified.
But this applies to content models as well as recognition of attributes.
I would rather see every attribute called ID or beginning with ID. be an ID,
and allow multiple ones -- the SGML restriction makes no sense to me at all,
and in any case can't be enforced without a DTD. But you can always use
CDATA for all except one (or all) of the ID attributes you want, and
check them with application-level code, which is what people do today
with SGML, whilst they are wondering why they have to do that :-)
SO I could live with just ID.
If people can't accept the use of fixed attribute names, a prefix would
probably work: xml.id for example.
The same sort of convention is needed for IDREF, and xml.idref is more
appealing to me, as it's easy to explain tht attribute names starting
with xml. are reserved.
Lee
With NMTOKEN(S), you not only retain case insensitivity, but have an
up-front way to delimit multiple values. So I think we should at least
consider keeping it, too.
It's not too hard to come up with reasons to have multiple ID attributes
on one element. I'd like to see SGML97 remove this restriction, and
until then, retain the restriction. Making "id" the canonical name
for XML ID attributes, while intuitive in the framework of SGML86 and
very attractive all around, unfortunately wouldn't provide an easy path
for allowing multiple IDs.
Eve
I never understood why I needed more than one unique identifier for an
element: that's why the SGMl syntax never bothered me. If Eve and Lee both
think it's useful, I'll defer to their judgement (though I'd love an
example).
If we are going to do that, I like Lee's prefix proposal: We could have
attributes named id.attrname and idref.attrname. Making ID attributes
self-identifying in this way, and turning them into an application
convention, removes another problem from ID as specified: the restricted
syntax. We can declare XML IDs as CDATA "with an interpretation" and make
users much happier.
Martin's comment about rude words is a problem, but not one that I can
see how to solve, as we will need _some_ fixed string. ensuring
non-rudeness in any natural language would proabably also insure
meanininglessness all around, too.
-- David
RE delenda est.
David Durand dgd@cs.bu.edu \ david@dynamicDiagrams.com
Boston University Computer Science \ Sr. Analyst
--------------------------------------------\ http://dynamicDiagrams.com/
MAPA: mapping for the WWW \__________________________
I agree wholeheartedly with Eve and Lee--multiple IDs are useful.
I can't remember what I needed them for the last time, I guess it's past
my bedtime. I rememember that I was trying to duplicate the linkages that
a DMS used between its records because it was very easy to generate the
SGML from the report generator. In the end, I didn't use any IDs anyway
since I couldn't assure that they would be valid NAMEs anyway. Didn't
matter, the browser allowed me to make the links anyway.
But, I bet you like symbolic links, don't you? Same principles. With current
SGML implementations, an ID is best if the name is meaningful, but names
are only appropriate to a given context. If you can have two meaningful
names, you can address the needs of two discrete contexts.
bob
Robert Streichstreich@slb.com
Schlumbergervoice: 1 512 331 3318
IFF Decalred Value ID is retained, please yes to multiple IDs for
a single element.
--dal
6010 Executive Blvd. Suite 608 E-mail: dlapeyre@mulberrytech.com
Rockville, MD USA 20852
Multiple IDs for an element would be nice to have in SGML97, but they are hardly
essential for XML 1.0 and they would break SGML conformance.
Charles F. Goldfarb * Information Management Consulting * +1(408)867-5553
13075 Paramount Drive * Saratoga CA 95070 * USA
International Standards Editor * ISO 8879 SGML * ISO/IEC 10744 HyTime
Prentice-Hall Series Editor * CFG Series on Open Information Management
I agree. You can always use CDATA instead and kludge it in the application.
I would argue, in fact, that XML might as well not have an ID attribute
type at all. Just CDATA. Then have an application convention that a
string in an attribute of the form ref.xxx refers to a corresponding
(case sensitive) string in an attribute of the form ref.xxx, where the xxx
must be the same in both cases.
When the arbitrary restriction is lifted in SGML 97, you can declare
the IDs to be IDs instead of CDATA if you like.
This proposal works without a DTD, and with a DTD gives documents that
parse correctly in SGML.
Note:
I was going to write a short note on case sensitivity, but it grew too
long to fit in the margin, and will follow.
Lee
I prefer this to any of the options we have discussed. We should eliminate
ID/IDREF altogether, add Lee's application convention, and generate
warnings for attbitues called "ref.whatever" whose value does not occur on
as the value of a "whatever" attribute elsewhere in the document.
We can add ID/IDREF declarations once SGML97 comes out. XML need never have
them, but the SGML import process will be able to create them
automatically.
Exactly! very nice!
-- David
RE delenda est.
I am not a number. I am an undefined character.
David Durand dgd@cs.bu.edu \ david@dynamicDiagrams.com
Boston University Computer Science \ Sr. Analyst
--------------------------------------------\ http://dynamicDiagrams.com/
MAPA: mapping for the WWW \__________________________
Since a browser, search engine, etc. *shouldn't* validate and thus *can*
do without the DTD, and since an editor *should* validate and thus *should*
have the DTD, I don't see any benefit in having such a generalized
application convention. I don't mind using a few key names which are
already effectively linked to some semantic definition, but I'm uncomfortable
with extending this to a generalized solution.
I also don't really like the idea of partitioning the namespace. What I
had in mind for XML was another attribute where you could specify
additional IDs. This would be an application convention and you could
retain SGML compatibility by using one of the tokenized data types like
NAMES or NMTOKEN. The application convention would be that the values
on this attribute would be added to the ID namespace.
I don't feel too strongly about this feature, however, since any good
browser should be able to join arbitrary namespaces in its stylesheet
language. You don't have any assistance on the authoring side, but I've
overcome this in the past.
bob
