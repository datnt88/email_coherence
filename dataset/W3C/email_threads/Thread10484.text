While fixing a silly mistake in the MT document, I noticed the
following. We require that RDF graphs contain no redundancies in the
sense that the same triple cannot occur more than once in the graph.
However, they can contain redundancies in the sense that a triple
with a bnode in it can be duplicated with a different bnode, even
though the resulting triples would look the same in a graph diagram.
The resulting graph has no extra information in it, but this quirk
allows an RDF graph to have infinitely many consequences. For
example, a single triple
a p b .
has infinitely many consequences;
_:x p b .
a p _:y .
_:z1 p _:z2 .
_:z3 p _:z4 .
-:z5 p _:z6 .
where all these bnodes are distinct; see attached jpeg.
My question is, does the WG feel that it might be worth ruling this
out as a syntactic possibility? If this kind of bnode-duplication
were ruled out, then the set of graphs simply entailed by any RDF
graph would be finite. That would generalize the
no-duplicate-triples condition implicit in our definition of a graph
as a set, to treat triples which 'look' the same when you erase the
bnode labels as though they literally were the same.
Pat
IHMC(850)434 8903 or (650)494 3973 home
40 South Alcaniz St.(850)202 4416 office
FL 32501(850)291 0667 cell
phayes@ihmc.us http://www.ihmc.us/users/phayes
From an implementation perspective, I'd be concerned about ruling out
redundant bnode triples as syntactically disallowed. I think this would
make the implementation of merging two syntactically-valid graphs very much
more difficult (but not impossible).
Is there not an approach you can follow more similar to your use of "tidy"
RDF graphs, in which you demonstrate that for any RDF graph there is a
minimum reduced form of that graph that is semantically equivalent, and
then base your developments and proofs on that form?
Hmmm... maybe it's not that easy. Consider:
ex:s ex:p1 _:a
ex:s ex:p2 _:a
ex:s ex:p2 _:b
ex:s ex:p3 _:b
how does one tell that the
ex:s ex:p2 _:a
ex:s ex:p2 _:b
are not redundant? I think it is, at least, necessary to reason over the
graph as a whole rather than isolated triples.
E.g. defining auxiliary functions:
usePart a G
notPart a G
whose values are the subgraphs of G each of whose triples contain / do not
contain the node 'a' in some role, and
[a/b]G
whose value is G with every occurrence of 'a' replaced by 'b', one can
define some conditions on reducibility of a graph:
if [_:a/_:b]usePart _:a G `subset` usePart _:b G
then (notPart _:a G) is semantically equivalent to G. (Proof
sketch: suppose there is an interpretation that makes G true, then
(usePart _:b G) is true for some denotation of _:b (by conjunction and defn
of interpretation), then the same value used as a value for _:a and _:b
makes (usePart _:a G) true. Hence the truth of (usePart _:a G) under any
interpretation does not change the truth of G under the same interpretation.)
And so on.
I think that as soon as one does not reason in terms of the graph as a
whole, such conclusions cannot be drawn, because it's always possible that
there's some other triple in the graph that makes a selected subset
non-redundant for some interpretation.
#g
Graham Klyne
PGP: 0FAA 69FF C083 000B A2E9 A131 01B9 1C7A DBCA CB5E
Yes. and after sleeping on it, I think its best not to tinker with
the syntax at this stage in any case. And I am pretty sure that I can
handle the problem without doing anything so drastic.
So, Never Mind.
Pat
IHMC(850)434 8903 or (650)494 3973 home
40 South Alcaniz St.(850)202 4416 office
FL 32501(850)291 0667 cell
phayes@ihmc.us http://www.ihmc.us/users/phayes
NP complete - you can embed the subgraph isomorphism problem.
Jeremy
NO
The problem of eliminating such blank nodes is plausibly NP complete.
Certainly GI complete, i.e. exponential.
(See related work on irredunancy of conceptual graphs
Michel Chien et Marie-Laure Mugnier, Conceptual Graphs: fundamental notions
in Revue d'Intelligence Atificielle, Vol 5, no 4, 1992, pp 365-406.
most applicable to RDFS though)
Jeremy
Actually, I think its only cubic.
for each bnode B
for each triple T containing B
if there is a triple instantiating T, remove T
loop
loop
But OK  pretend I never mentioned it.
Pat
IHMC(850)434 8903 or (650)494 3973 home
40 South Alcaniz St.(850)202 4416 office
FL 32501(850)291 0667 cell
phayes@ihmc.us http://www.ihmc.us/users/phayes
NP
Take two directed graphs G and H
Construct an RDF Graph R as follows.
Let the nodes of R = V(G) U V(H) U { g, h, x } (all distinct blank nodes)
Let the triples of R all have predicate rdf:value (which we will omit)
Let the triples of R be E(G) U E(H) U { g, g' | g' in V(G) }
U { h, h' | h' in V(H) } U { x, g , x, h }
then if R is irredundant we have that H is not a subgraph of G.
The directed subgraph problem is NP complete, which forms the interesting
90% of a proof of NP complexity of RDF graph irredunancy.
Your approach neglects the long distance interactions involved in blank
node structures.
Jeremy
But not necessarily the reverse. For example let G be
and H be
then the instance a=d and b=e gives a redundancy (instance which is a
proper sub-RDFgraph) but H and G are not subgraphs of each other.
Those seem irrelevant since we can detect instantiation locally.
One does not need to get into the subgraph problem. The only question
you have to ask is, is this triple redundant? The way to find that
out is to see if it can be instantiated into another triple in the
graph, which can take at most one check per other triple. If it can,
then delete it, remember the instance mapping, and start again from
the top. If it can't, try the next triple. You can detect
irredundancy in n|2 checks of one triple instantiating another.
The graph gets smaller each time, so generating an irredundant
subgraph is going to be polynomial at worst (not sure what degree, to
be honest, but I think cubic, maybe n|3 logN or something like that.)
It doesn't matter if you delete triple T1 because it instantiates to
T2, then later also delete T2, since if T2 instantiates to T3 then so
would T1 have done: instance is transitive.
Pat
IHMC(850)434 8903 or (650)494 3973 home
40 South Alcaniz St.(850)202 4416 office
FL 32501(850)291 0667 cell
phayes@ihmc.us http://www.ihmc.us/users/phayes
Jeremy:
Pat:
(that is true ...)
R (on my construction is)
x g
x h
g a
g b
g c
h d
h e
h f
a b
b c
c a
d e
e f
d f
R' (replacing a=d b=e)
x g
x h
g a
g b
g c
h a
h b
h f
a b
b c
c a
a b (duplicate)
b f
a f
doesn't look anything like a subgraph.
Even if you ignore all the triples I added it doesn't
S
a b
b c
c a
d e
e f
d f
S'
a b
b c
c a
b f
a f
S' contains a node (b) which has two outbound edges and one inbound edge,
unlike S.
irredunancy is not a local phenomenon - I need to work on my NP completeness
proof but you've more work to do on your P proof!
(Note to rest of group these pairs are in fact triples with a missing
rdf:value in the middle; and all the nodes are blank - this might have
something to do with RDF)
Jeremy
Hmmm... what am I missing?:
ex:s1 ex:p1 _:b1 (1)
_:b1 ex:p1 _:b2 (2)
_:b2 ex:p1 ex:o3 (3)
So the triple (2) can be instantiated as either (1) or (3), so it's
redundant, hence can be deleted. But in so doing, we lose the information
that there is a graph path:
ex:s1 --ex:p1- ? --ex:p1- ? --ex:p1- ex:o3
#g
BTW, Jeremy, is there an easy and efficient way to use your graph
isomorphism algorithm to determine if G1 is isomorphic to a subgraph of G2?
Graham Klyne
PGP: 0FAA 69FF C083 000B A2E9 A131 01B9 1C7A DBCA CB5E
No, Graph Isomorphism is believed to be truely easier than NP; whereas
subgraph isomorphism is known to be NP
Having said that, the algorithm are referring to is a long way short of the
state of the art in GI (see nauty)
Jeremy
OK, I see my error. Never Mind.
Quite. Because although instantiation is transitive and so is
subgraph, it can still be the case that an instance of a non-subgraph
instance is a subgraph. So there is no cheap way to avoid doing a
check of all subgraphs; which is NP. I was under the delusion that
one could search by backtracking down the instances, but that will
miss some cases. Still might be room for a cleverer algorithm, but
maybe I wont try to solve P+NP this week.
It means that being a lean graph is potentially a very costly
property to check, whereas I thought it was fairly trivial. Which
means that in general, checking non-entailment between two graphs is
potentially expensive.
Pat
IHMC(850)434 8903 or (650)494 3973 home
40 South Alcaniz St.(850)202 4416 office
FL 32501(850)291 0667 cell
phayes@ihmc.us http://www.ihmc.us/users/phayes
Pat:
Agreed - simple entailment is probably NP complete
(I am not absolutely sure: the subgraph isomorphism problem (which is NP) is
closely related, but I do not have an exact embedding).
The result for conceptual graphs (irredunancy is NP complete) is probably
applicable to RDFS entailment, but again it is real work to show this.
Jeremy
