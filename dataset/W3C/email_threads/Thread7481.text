Dear all,
As the WebDAV group is now preparing to consider versioning in detail, and
we will not be attending the meeting in June at Microsoft, David Durand and
I felt that our best contribution would be to record a list of possible
decisions that should be avoided for versioning on the WWW. We have thus
written a document, "The 7 Deadly Sins of Versioning (plus a venial one)",
that we would like to submit to the attention of the WEBDAV group.
The document is both attached here and available at:
Our experience is that there are large number of pitfalls ahead of us.
We've certainly fallen prey to some of them ourselves (as well as
occasionally falling prey to systems that have them). By arguing that these
items should be examined for avoidance, we intend to forestall
possbilities. This is not an accusation, but a mild warning. We hope that
our cautions and fears are considered exxagerated and pointless. The
reaction that would please us most, would be that everyone says "This is
all obvious. Why are they wasting our time with this stuff?"
Furthermore, we do not mean to provide answers to the problems we list.
Although we do feel that our VTML format, properly applied, would help
solve most of these problems, still we would like to avoid partisanship,
and concentrate on ensuring that the issues are fully discussed and then
dismissed.
Regards to all,
Fabio Vitali &amp; David G. Durand
Fabio Vitali Tiger got to hunt, bird got to fly,
Dept of Computer Science Man got to sit and wonder "Why, why, why?"
Univ. of Bologna ITALY Tiger got to sleep, bird got to land,
e-mail: fabio@cs.unibo.it Man got to tell himself "I understand".
Kurt Vonnegut
Hi,
Excuse me for de-lurking and asking a silly question.
Is it necessary to handle versioning differently from language alternates?
To put it another way, can we unify the problem to how we handle alternate
resources for particular resource. Thus leaving the problem of
interpretation of what the alternates mean and operating on them to the
clients outside of WebDAV.
So far WebDAV has avoided forcing any structure or format on the contents of
the resources that it accesses and stores. I think it would be dangerous to
give this up.
Marcus.
Marcus, thanks for de-lurking: I believe this question would have come out
sooner or later, and it's better to have it right at the start letting us
discuss it before everything else.
So: can we label versions as just another kind of alternate resources, and
forget about it? IMHO: Sure we can. This would simplify the work of the
group a big deal.
On the other hand, it would constitute a major occasion lost to discuss and
provide for the interoperability of different implementations of versioning
systems. Furthermore, it would constitute a substantial betrayal of the V
part of the WEBDAV acronym.
Versions differ from language alternates at least for one major issue: they
are machine-processable. And usually machine-generated. This means that
with versions it is possible to provide more sophisticated services than
simply prompting the user: "I have 23 alternatives of this resources. Here
is the list. Which one do you want?" Thus I believe that providing a way
for these services to interact across implementations is extremely
important and well within the scope of the WEBDAV charter.
Indeed. Especially if the structures and formats eventually come out
limited in scope and flexibility by implementation haste, good-enough
attitude and lack of temporal perspective.
My personal dream is that WEBDAV identifies the overall and long-term
requirements for such structures or formats, and then fork a sub-group to
provide a first generation one that can be, if necessary, good enough and
done in haste, but also one that can be easily grown out of when the need
comes, without at the same time requiring the whole V part of the WEBDAV
standard to be re-discussed.
Fabio
Another difference is that versions are related to each other (usually)
in semi-ordered manner (or tree structure). I'm not sure what "language
alternatives" but it sounds like to be able to represent only
relationships
between one resource and its variants.
Regards,
Kenji
Kenji Takahashi, Ph.D.
NTT Multimedia Communications Laboratories
250 Cambridge Avenue, Suite 205, Palo Alto, CA 94306 USA
e-mail: kt@nttlabs.com URL: http://www.nttlabs.com/~kt
Sent to the w3c-dist-auth-request address (which is routed to my personal
inbox) by accident.
- Jim
No, it's probably not necessary, but might still be a good idea. The notion
of
a version could indicate that something changed in the in the meaning of the
resource, its semantics. Variants might be different views of the same
meaning
for different audiences. With XML, the content and views are separate
allowing
each to change independently, either with versions of variants.
Yes it is necessary because each version may have different renditions (in format and/or language)
cheers
Dylan
Hi,
Excuse me for de-lurking and asking a silly question.
Is it necessary to handle versioning differently from language alternates?
To put it another way, can we unify the problem to how we handle alternate
resources for particular resource. Thus leaving the problem of
interpretation of what the alternates mean and operating on them to the
clients outside of WebDAV.
So far WebDAV has avoided forcing any structure or format on the contents of
the resources that it accesses and stores. I think it would be dangerous to
give this up.
Marcus.
David, Fabio,
Thank you for taking the time to draft your position paper, "The 7 Deadly
Sins of Versioning." While I agree with many of your points, there are some
on which I disagree.
1. Enforced linear versioning
I agree with you -- retrofitting non-linear versioning onto a linear
versioning system may not be possible, and will likely be inelegant if
possible, forcing unnecessary tradeoffs.
2. Serial editing
I agree that parallel editing is useful in many contexts, especially
software development. However, parallel development support requires merge
support, and many media types are inadequately served by merge tools. For
example, how many image merge tools are in existence which help merge two
people's changes to the same image? So, while parallel editing support
should be provided, it must also be possible to limit editing to serial.
3. Integrating versioning and structure information
I'm not sure I followed this point. The requirement in WebDAV is to design
a versioning protocol which works for all media types, not just
XML/HTML/SGML based media types. As a result, by meeting this requirement I
believe we also avoid integrating versioning and structure information.
However, WebDAV versioning also has to work for completely unstructured
information as well -- WebDAv versioning must work for an arbitrary instance
of text/plain or application/octet-stream.
4. Using binary formats
This is a point on which I waver. While I definitely favor use of a
text-based format (the initial WebDAV Distributed Authoring protocol
specification is testament to this), for uses like DRP, sending differences
over the wire in compressed XML vs. a tailored format for efficient
differences will be less efficient. As for applications where efficiency is
the main driver, I wonder whether it will be sufficient.
But, I do agree with you that developing the diff representation in XML does
provide a good opportunity for separation of concerns. But, it does raise
other ones, like how best to encode an arbitrary chunk of binary difference
data in XML. Or, what happens if the difference is in a difference charset
from the original (e.g. applying a UTF-16 diff to a UTF-8 original).
5. Hard-wiring policy
Avoiding hard-wired policy is a bit of a motherhood statement. One of the
difficult issues for WebDAV is the fact that many repositories support some
existing policy, and it would be easier to integrate them with WebDAV if
some hook (like a CHECKOUT/CHECKIN method pair) were provided. I think a
flexible approach to provide these hooks, but also provide operators which
allow direct manipulation of the version history graph. This way WebDAV
provides a built-in policy, but has the flexibility to be interoperable with
systems which don't use the built-in policy.
6. Confusing bytes and characters
While I agree with this point (characters and octets are different, since in
multi-octet charsets like UTF-16 and UCS-4, a single character can be
multiple octets), I disagree with your mechanism for how to handle arbitrary
binary diff information. A combination of XML and MIME multipart requires
the use of two parsers to understand a difference stream. This will always
be inferior to a difference which requires only one parser (e.g., a non-XML
binary diff format), and developers will strongly lobby for the one parser
approach. Plus, the two parser approach will be slower, and harder to
optimize.
It seems to me you've provided a pretty compelling argument against the use
of XML as a difference format.
7. Not providing a computable evolution of addresses
I think the first paragraph shows how text-centric this observation is:
An important application of versioning systems it to be able to determine
the
position, content and identity of all subparts of a resource in all its
versions
in which they exist in some form. Ideally it should be possible to
retrieve and
identify any single character of a document in all the versions in which
it
existed.
How would you track changes to an image, or to a digital movie? One problem
is evolving addresses in a media-type independent way. Another problem is
that on the Web, the smallest addressable part is a resource. There are no
existing standards for sub-resource scope addresses which apply across all
media types.
Conclusions: Ignoring VTML
We are not brainwashed advocates for VTML (in any of its versions).
I may make you both T-shirts with this quote... :-)
I continue to assert that VTML is a technology which holds promise as a
difference format for potential use in WebDAV. Before specifying its use,
I'd like to see how it can accomodate a difference between two images (say,
two JPEG files), or in the general case, how it can accomodate binary
differences.
- Jim
*snip*
All,
here some comments from a "pure" versioning perspective....
1. Enforced linear versioning
I agree as well, it is the mechanism that is important, not the appearance.
But, I do recommend reading the "Linear Versioning" paper by Chris Seiwald
in SCM-6. It tells us about an approach in which linear versioning is
embedded in a CM system, and variants are represented as new name spaces.
The paper illustrates how this simplifies the user perspective quite a bit.
It is a thought to consider this mechanism for WebDAV, the model is
tremendously simple, and actually maps very nicely onto WebDAV.
2. Serial editing
I equal parallel editing to variant handling, the same mechanism can be
used. The problem with variant handling is that there are many ways to
resolve or reserve branches, and this is exactly the prblem that WebDAV
is going to have to address. Traditional versioning systems usually adopt
one policy for variant handling (pre-assign variant number, reserve and
implicitly lock, and many others), but WebDAV will not be able to do this.
To accomodate all types of data, WebDAV has to provide a set of policies.
In particular, now suppose someone does come up with a merging tool for
GIF or JPEG. All of a sudden WebDAV would have to change? No, the policies
should be included beforehand and be well-thought out. Thus, I agree with
both Fabio and DAvid as well as Jim, at times one wants serial editing, but
for serious CM type work, we do need parallel editing, and even there, wep
probably need several mechanisms (some references: TRED, SCM-7, J.J. Hunt;
Continuus model; 3-dimensional versioning, SCM-5, J. Estublier).
Btw, I don't think WebDAV should be concerned with merging, WebDAV should
only be concerned with the data model and allowing a "merged with" link,
or "depends on X, Y, and Z" link type. Merging itself should be outside
the scope, it is a method or operation on the data in the data model.
Thus, merge tools or methods should all be external. I would hate to see
a "merge" method in HTTP...., it will never work for all data types.
3. Integrating versioning and structure information
I think this is a non-issue from the WebDAV standpoint of view, anything
could be versioned (i.e., I agree with Jim, and I think also with Fabio
and David).
4. Using binary formats
There is a subtle difference here between two things:
- the difference between the old version and new version
- compressing data
Both provide a speedup that can be quite considerable, and both might be
needed for everything to really work (consider that 1 meg image where I
change one pixel, compressing helps, but boy, I would rather send the
diff!). Usually a combo would be best. However, sending diff's does
run into point 2: generic merge tools. Thus, I suggest WebDAV should
provide two means of updating a repository: sending a plain new version
(compressed or not) and allowing a diff to be shipped as well (of course,
assuming the serve knows the type). Issues remain, but both will need
to be addressed.
A comparative study on diff algorithms appears in SCM-6, J.J. Hunt,
Tichy, and someone from Bell Labs whose name I forgot here for a sec
(hey, it's late at night). At the moment, there is a clear winner.
It is made available by DuraSoft, and is called BDE (binary difference
engine), a separate engine for differencing. I can't speak for the
authors of the tools, but I would be pretty psyched it is was my tool
that was chosen as standard for all web diffing and they might provide
it for free? Just something to think about.
5. Hard-wiring policy
I think the hardwire policy not only refers to checkin/checkout, but more
to variant handling, parallel editing, locking necessities, etc. I agree
that hooks should be there, but I also would like WebDAV to give me quite
a bit of degrees of freedom in building some versioning/auditing system on
top. If just the hook of checkin/checkout is provided, that is pretty darn
little to work on. In versioning there is, unfortunately, quite a bit of
policy choices, even at the low level. Whatever choices WebDAV makes, I
think very good arguments will have to be provided as to why certain
policies are ignored or not. Good paper to read on policies: Versioning
Models by Westfechtel and Conradi (to appear in ACM Survey's).
Oh, one more note. Notice that the versioning as discussed by Fabio and
David does hardwire one policy: it completely ignores the change-set
approach that is now becoming increasingly popular in CM. As opposed to
managing versions, change-set manage the changes as the entities and
create a particular system on demand by taking a baseline and set of
changes that are merged in. Just so you know, this policy is ruled out
from the start by the approach of storing versions. Some workarounds
are possible (see, Weber, SCM-7, change-sets and change-packages).
6. Confusing bytes and characters
Too webbie for me, but from what I can make of it, a generic binary diff
format could still be used right? XML BINARY DIFF BEGIN and XML BINARY
DIFF END with some baseline version number and off the difference engine
goes.....?
7. Not providing a computable evolution of addresses
An important application of versioning systems it to be able to determine
position, content and identity of all subparts of a resource in all its
in which they exist in some form. Ideally it should be possible to
identify any single character of a document in all the versions in which
existed.
I completely disagree with Fabio and David here. The purpose of versioning
is to provide a generic mechanism to store and retrieve revisions and variants
(versions) of arbitrary data. The structure of the data, the contents of the
data, and all other aspects of the data should not matter. Whatever is
versioned is opaque to the versioning mechanism. Thus, the versioning
should be content-independent. Thus, indeed as Jim says, the statement
Fabio and David make is very very text-centric, and should in my opinion
not be adopted for WebDAV. I want the V in WebDAV to provide me with a
mechanism to store and version my byte-streams and what I do with that is
my business, not the versioning system. I think point 7 makes Fabio and
David fall into their own pitfall numero 3, they let the versioning system
know about the structure. Thus, I think point 7 should be strucken from
the pitfalls altogether.
Conclusions: Ignoring VTML
We are not brainwashed advocates for VTML (in any of its versions).
Yes you should ;-)
The way I view VTML is as a particular policy, it is more flexible than
some other policies out there, but also does not address some other things
other policies do. Thus, VTML is just another system with a policy that
should be able to use WebDAV and should be able to be built on top of
WebDAV.
In any case, as I said, I am a versioning guy, not a Web guy, but I hope
this helps to put some perspective on the issues that are there.....
=== Andre ===
PS: Of course, I appreciate the work by Fabio and David, don't get me
wrong as this e-mail has a negative tone to it. But, coming from
a versioning and CM perspective, I obviously have different opinions
and expectations from WebDAV and I wanted to highlight those here.
Perhaps the answer is that they're both Unicode, so apply the diff in Unicode
and then store the result in whichever transformation format makes sense?
|John (Francis) Stracke |My opinions are my own.|S/MIME supported |
|Software Retrophrenologist|=========================================|
|Netscape Comm. Corp. | This is the .sig that says... |
|francis@netscape.com | Ni! |
New area code for work number: 650
There may be a snag here: if the image is compressed (as it probably is), then a
diff on the bitstreams may not be all that small, since changing that pixel may
change much/all of the downstream data.
One possibility would be to permit type-specific diffs; if you make small changes
in an image, you can send a diff that says "patch the image by changing this
region", sort of like the interframe compression in MPEG. Similarly, if you've
got a compiled Mac application under versioning, and you change a single string
resource, you could send a diff that says, "change 'STR ' resource 1717 to
'foo'".
I'm not sure I'm actually advocating this approach; the complexity might not be
worth the bandwidth savings. I would certainly not advocate putting any
type-specific diffs into the required protocol; I would say make each diff format
a negotiable extension.
|John (Francis) Stracke |My opinions are my own.|S/MIME supported |
|Software Retrophrenologist|=========================================|
|Netscape Comm. Corp. | This is the .sig that says... |
|francis@netscape.com | Ni! |
New area code for work number: 650
Simple summary of a basic point:
Sure, we're text-oriented in the comments we sent -- that's our
specialization. However, no Web-based authoring protocol can afford to
ignore textual data. I'm not sure that we make very many special requests
that could _never_ be useful for non-textual data, but if we do that's not
an argument against them. It is merely an argument that DAV shouldn't
require the use of text-oriented facilities for non-textual data.
dear to my heart, though Pure versioning != Software Engineering.
1. Enforced linear Versioning
The only thing that worries me is losing the ability to express branching
histories and compare/merge/analyze across them.
2. Serial editing
I think not. IOt needs to pick some mechanisms, hopefully ones that block
as few policies as possible (ideally none!).
exactly. I'm not sure that universal merge mechanisms are a good idea. I
believe them to be possible, but it's clear that for each mechanism there
will be combinations of data types and typical operations for which that
mechanism will not be optimal (or even sensible).
Personally, I think merge is so important that we can't ignore it -- but I
tend to agree that we can't solve the problem ideally for all data types:
we may need an extensible mechanism, and some standard minimal methods
suitable for common text and binary types.
3. Integrating versioning and structure information
right. Integrating versioning into data formats is not extensible or sensible.
4. Using binary formats
We were talking only within your first point. Assuming that we need a diff
format, we are arguing that we are better off with a text-based format thna
an optimal but opaque binary format (with its problems of
non-debuggability, byte-ordering, etc.).
In an authoring context, we must also consider that diffs are not always
the output of some automatic process... They should be easily creatable by
editors so that the actual changes made can be represented, and not just
some heuristic guess at a set oif changmes equivalent to the user's actions.
5. Hard-wiring policy
My thesis research is a change-oriented approach to collaborative
authoring, and I certainly hope not to forstall development of such
systems. I see the provision of DIFF and merge mechanisms (with flexible
policies) as the easiest way to support such systems without havning to
convince the whole rest of the world to abondon their version-centric
perspective.
6. Confusing bytes and characters
No, that's the problem. XML can't include arbitrary binary data within a
document, since the in-document data must conform to a valid character
encoding, and certain escaping conventions: not all binary sequences are
reasonable in such data. There are also some problems with potential
transcoding that we should endeavor to avoid. In my variation of VTML, I
did not use XML syntax, but rather ASCII, with carefully simplified
escaping rules so that arbitrary binary data could be handled. Last time I
mentioned that on this list I was bruitally flamed for propagating more
formats when I could be using XML.
Jim may be right, but since so many free XML parsers are already available,
I tend to think that satisfying the XML parser component is pretty trivial.
So I stick by opour suggestion that a 2-part format can work, especially
since MIME and XML are likely to be part of Web-based authoring systems
anyway.
7. Not providing a computable evolution of addresses
All I canb say is that that's _your_ purpose. From an _authoring_ point of
view the purpose of the versioning system is to enable use of the textual
history of the document. The intellectual reason to do such stuff on the
web is to enable links to retain their relevance even as resources change.
And to enable authors to collobrate with others and managhe their own work.
WebDAV must _work_ for text. _I_ am certainly text-centric, but I don't
mind WebDAV supporting operations that may be of little use in the
authoring process. On the other hand, this point is the whole reason that I
_care about_ versioning on the WWW, so I am loathe to strike it.
I recommend Nelson's Literary Machines as a worthwhile text on why this
matters. It's not the easiest book to read and understand, and Ted is far
from the least impassioned person on _any_ topic. But he presents the case
quite thoroughly. You could also read his 1965 paper, "A data structure for
the complex, the changing, and the indeterminate" I think it's on the web
nowadays... I'll look for the URL.
Byte-stream management need not be incompatible with point 7. If you choose
not to take advantage of the ability to find corresponding bytes in
different versions, then you are not _harmed_ by that feature being
avaliable to those of use who need it.
I'd be kinda happy with this. My VTML version and implementation does
support freely combinable changes and arbitrary byte sequences, but does
not have any special operations for non-sequential data types. It also is
_not_ XML based, though I don't think it would be hard to make that happen,
using the techniques I've suggested.
Sure. I've been working on versioning and hypertext for far too long. In
general I've found that the Software Engineering work is rather simplistic
with respect to individual changes and critical operation such as move and
copy (that software can live without, but authors can not). It also has
tremendous facilities and complexity in the area of total configuration
consistency and policy enforcement that are inappropriate for typical
authorial processes (with their typically small, technically
unsophisticated, informal working groups).
No offense taken: Civilly presented arguments pro and con are what this
process should consist of. A vigorous discussion with lots of disagreement
need not be hostile just on that account.
-- David
David Durand dgd@cs.bu.edu \ david@dynamicDiagrams.com
Boston University Computer Science \ Sr. Analyst
--------------------------------------------\ http://www.dynamicDiagrams.com/
MAPA: mapping for the WWW \__________________________
I started this before Andre's note, but then answered Andre first. I've
tried to eliminate redundancy from this direct reply.
2. Serial editing
This is a great way of rephrasing what we said: Parallel editing must be
possible. Your emphasis is different, but the key idea is not to _prevent_
parallel editing. It's very easy to do that if you don't plan ahead.
Parallel editing doe _not_ logically imply merging, if one is willing to
keep divergent versions.
The best manual merge tool I know of for images is Photoshop: you can paint
directly from one image into another... That's a manual merge, of course.
I think there are two things to bear in mind:
1. text is a critical data type.
2. if something is needed for one data type, say text, and not needed
for another, say JPEG encoded images, then it's still needed by DAV; it
just won't be applied to JPEG encoded images!
3. Integrating versioning and structure information
Right. The deadly sin is to try to combine data format and versioning in
some way: This has been proposed multiple times for HTML, and so it is
worth pointing out the pitfall. As Fabio said, a lot of this isn't rocket
science, but we felt someone ought to day it right up front. I suspect that
we may end up needing more than one, or perhaps an extendible set of Diff
formats.
5. Hard-wiring policy
This could be OK, depending on whether the needed operations are provided.
I don't think that we can afford to ingore the special requirements of
authors in a standard intended for use with the Web (based on text formats
at a fundamental level) and intended to support authorship. If those
facilities are not useful to people using HTTP as an SCM transfer protocol,
then they need not be used.
6. Confusing bytes and characters
This may be, but in that case, I'd recommend using an ASCII-based format.
We could even still use XML, with a fixed encoding declaration, and with
binary data stored within the document. I can work out the details of this
is people are interested.
7. Not providing a computable evolution of addresses
Sure. I think that text is an important format. I see nothing in this
requirement that _can't_ be supported for arbitrary binary byte streams,
nor am I aware of any digital data that is _not_ representable by such a
byte stream.
I can certainly imagine data formats for which such operations would be
eminently sensible. The real problem is not that such operations don't make
sense, but that typical formats use aggressive compression techniques that
may hide logical intenral boundaries like those between pixels and frames.
I don't see how allowing for this kind of operation prevents an application
from _not_ using it when it doesn't make sense.
Conclusions: Ignoring VTML
We are not brainwashed advocates for VTML (in any of its versions).
My variation works with binary data (the implementation is a bit
over-engineered, because it's a prototype, but it's certainly not hard to
deal with).
I'm not convinced that byte-stream differencing is sensible for JPEG, but
I'm not sure what other approach is possible for a media-type independent
format.
-- David
David Durand dgd@cs.bu.edu \ david@dynamicDiagrams.com
Boston University Computer Science \ Sr. Analyst
--------------------------------------------\ http://www.dynamicDiagrams.com/
MAPA: mapping for the WWW \__________________________
