One way of doing provenance in RDF 1.0 clarified I could [*] think of is
source rdf:li [ a rdf:Statement; rdf:subject :s; rdf:predicate :p; rdf:object :o ] .
where source is a uriref pointing to an RDF document on the Web
and Statement is according to a "yes" on DanBri's entailment test case
and rdf:li a rdfs:ContainerMembershipProperty .
Jos
[*] could be via done based on an axiom a la
{ ?so log:includes { ?s ?p ?o } } log:implies
{ ?so rdf:li [ a rdf:Statement; rdf:subject ?s; rdf:predicate ?p; rdf:object ?o ] } .
At 16:14 10/02/2002 +0100, jos.deroo.jd@belgium.agfa.com
A simple way to interpret the vote at Friday's telecon is that we decide
that an rdf:Statement represents a stating (an occurence of a
statement). Would that then imply that the entailment does not follow;
i.e. that two resources with the same values for their subject, predicate
and object properties may denote different statings.
Brian
yes, but then
the subject of "Mary hit the-ball"
should be a word starting with "M"
and *not* my wife
clarify versus fix?
Jos
[nods]
I would be happy taking this route. Several people (including myself) have
expressed concern that "doing the provenance thing properly" could be a
big job. I think taking the route outlined above, where rdf:Statement had
multiple members with the same p/s/o characteristics, would be
very useful progress towards making RDF's reification vocab work for provenance.
Such a clarification of rdf:Statement would set things up so that others
(eg. via a Note, via later work of this WG or another, whatever) could
provide further properties that better describe the characteristics of an
rdf:Statement. For example, DanC and I might define util:predicateURI,
util:subjectURI, util:ObjectURI, each having rdfs:domain of rdf:Statement,
to address the concerns aired in the use/mention/superman thread. By
agreeing that rdf:Statement's members aren't individuated by p/s/o, we'd
lay the groundwork for future improvements to reification.
Dan
Much more diplomatic than my rant :)
Brian
Me too.
That's a very interesting insight.
#g
Graham Klyne MIMEsweeper Group
Strategic Research http://www.mimesweeper.com
On 2002-02-10 17:14, "ext jos.deroo.jd@belgium.agfa.com"
I'm not quite sure why you would turn it around that way. Why
not just define a source property for the statement node? I.e.
[ a rdf:Statement; rdf:subject ...; x:scope some:scopeURI ]
Patrick
My take is that the subject would be your wife. The difference
between the statement and the stating is the bNode of type rdf:Statement.
Thus, because bNodes are not tidy, each may uniquely denote a
different stating -- and all statings having the same S,P, and O
are talking about the same statement, no matter where, when or by
whom it may (or may not) be asserted.
It is that bNode that denotes the stating, and which can take additional
properties to describe the context/attributes of that stating, but all
statings have a node intersection with any actual assertions of the
referenced S, P, and O.
A stating can exist by itself. An assertion triple can exist by itself.
And if they exist together, they share nodes.
That doesn't mean that any properties other than S, P, and O for a
stating modify any other stating, nor that a stating entails the
assertion.
Patrick
I think this decision effectively makes rdf:subject etc. vocabulary
useless, i.e. not having any special meaning (I believe Pat made this
point earlier). In other words, 4-triple reification becomes effectively
deprecated (which is fine with me).
How about adding a straw poll on the last sentence to the reification subagenda?
--Frank
Frank Manola The MITRE Corporation
202 Burlington Road, MS A345 Bedford, MA 01730-1420
I think this decision effectively makes rdf:subject etc. vocabulary
useless, i.e. not having any special meaning (I believe Pat made this
point earlier). In other words, 4-triple reification becomes effectively
deprecated (which is fine with me).
Sergey
I disagree. It works just fine, in either Statement or Stating
interpretation for my use of it in the P3P schema.
We already decided not to shoot it. Please move forwards, not backwards.
Brian
I agree that the *sentiment* was not to shoot it, but I don't believe
there was an explicit resolution taken about the 4-triple syntax. I
view this as "saying explicitly what was decided", not "moving
backwards." (NB: If we *really* want to move backwards, all we need to
do is keep leaving stuff like this inexplicit, and watch it come up again.)
--Frank
Frank Manola The MITRE Corporation
202 Burlington Road, MS A345 Bedford, MA 01730-1420
If none of the entailments holds, no special semantics is associated
with rdf:subject et al vocabulary. In other words, using rdf:subject
instead of ex:foo would not convey additional information (in P3P schema
or anywhere else)...
I'm subscribing under Frank's reply here.
Sergey
Strictly, in terms of the formal semantics, I think this is true.
But because the formal semantics is mostly (deliberately) non-committal
about interpretations of vocabulary, I think it is still possible for there
to be some value here documenting some interpretation of the reification
vocabulary that may reasonably be commonly held, even if it doesn't provide
any specific entailments at this time. DanBri suggested an interesting
position that additional properties could be associated with the
reification quad rdf:Statement resource. I can imagine that the common
reification vocabulary might be the "Rosetta Stone" for combining the
results of various experiments that will probably be conducted in this
area, as we try to find useful ways to reason about provenance, modalities
and related ideas.
#g
Graham Klyne MIMEsweeper Group
Strategic Research http://www.mimesweeper.com
We don't have to shoot it, exactly. We can treat it the same kind of
way that Brian treated rdf:Alt. We can say that this vocabulary is
*supposed to* mean that the subject is a particular triple in some
RDF graph and this is the *intended use* of it. However, we can also
say that since RDF itself provides no way to record the relationship
between the subject of a reification 4-triple and the actual triple
that it designates, there is no formal semantic constraint on any RDF
interpretations from the use of this vocabulary and no special
entailments (over and above the normal RDF entailments) associated
with it. But that doesn't mean its *useless*, only that it doesn't
have any extra meaning that RDF is officially able to 'detect' (in
contrast, say, to datatype names).
If y'all want to be ambitious, we could make it even more like
datatypes in that we could invent an external 'reification scheme'
defined by a mapping from some nodes to triples in graphs
(triple-tokens), and treat reification in a way rather like
datatyping, so that there are some semantic constraints attached to
the reification vocabulary. All they would amount to is a requirement
that the interpretation conforms to some 'invisible' reification
scheme, which still wouldn't give us any new entailments, but it
would nail down our intentions and be a hook to hang a more elaborate
reification syntax onto.
If there is any interest in this I could write a sketch of it up by
NEXT Friday.
Pat
IHMC(850)434 8903 home
40 South Alcaniz St.(850)202 4416 office
phayes@ai.uwf.edu
We have run out of time guys. We have to focus on "must do's", not "could
do's".
Brian
