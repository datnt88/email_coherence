Hmmmm.... do we need then to use DAML equivalence
constructs for basic RDF?! E.g.
qn:{http://description.org/schema/}Creator
daml:equivalentTo
qn:{http://description.org/schema/}@Creator .
No, because those QNames are in RDF, and RDF processors handle them by
concatenating them and forming a URI. The XML Namespace specification
defines a difference between the QNames, but it doesn't tell you how to
handle them. The RDF specification comes in and tells people what to do
with the QNames. It tells one to concatenate the QNames togther minus
partition information, to form a URI. There's no problem with that, except
there's no way to identify a QName as a first class object without some
extra properties, or a new URI scheme. So there's no particular need to map
every QName in XML RDF to your URI scheme - to do so would be silly - but
it doesn't stop people using it.
In other words, you've accomplished all that you want to accomplish simply
by inventing this URI scheme. If you force people to adopt it *instead* of
the concatenation mechanism in XML RDF, then you'll form an utter mess,
because the Semantic Web deals with URIs, and not just QNames. Using the
concatenation mechanism is an excellent and quick way to form those URIs
out of QNames. Your URI scheme is good (saves the need for even
decentralized QName properties), and I'm sure that I will be recommending
it to anyone that needs to map between QNames, define them using RDF, or
whatever. WAI PF have been looking for something like this for quite a
while. But RDF uses URIs and not QNames, and now that you've come up with
representing an XML QName (i.e. with all the details preserved as in the
XML namespace specification) as a URI, that's fine.
Now, there are only two errors with your URI scheme. The first is that the
characters "{" and "}" are disallowed in URIs per section 2.4.3 of RFC
2396. This can be easily gotten round by using "(" and ")" instead, e.g.:-
qn:(http://www.w3.org/1999/xhtml)title
that's a shame because I often use "{}" for QNames.
The problem is more difficult. Namespaces are actually URI References, and
yet you need to include them in a URI scheme. URI References with a "#"
aren't allowed in URIs. In other words, the following is illegal:-
qn:(http://infomesh.net/2001/08/example#)myElement
Because the "#" character is also disallowed by section 2.4.3 of RFC 2396.
Perhaps you can just %HH encode it?
qn:(http://infomesh.net/2001/08/example%23)myElement
Which *should* be O.K., but it needs further discussion. Note that if your
namespace ends (or contains) a "%23", then you can escape the "%" to use
that; i.e. "%2523".
qn = 'qn:' '(' absoluteURIexc [ '%23' fragment ] ')' ( elem | glob |
per )
elem = NCName
glob = '@' NCName
per = NCName '@' NCname
BTW, I know that you've only just invented this scheme and so on, but once
people on uri@w3.org have discussed it, could you create an Internet Draft
of it, and send it to the IETF for consideration? Cheers.
Kindest Regards,
Sean B. Palmer
@prefix : http://webns.net/roughterms/ .
:Sean :hasHomepage http://purl.org/net/sbp/ .
I though that we had more flexibility in defining URIs based on the scheme.
Section 3 says:
"The URI syntax is dependent upon the scheme. In general, absolute
URI are written as follows:
An absolute URI contains the name of the scheme being used ( scheme )
followed by a colon (":") and then a string (the scheme-specific-
part ) whose interpretation depends on the scheme.
The URI syntax does not require that the scheme-specific-part have
any general structure or set of semantics which is common among all
URI."
Does a mailto URI fit the grammar given in 2396?
Jason.
There is still a limitation on the total set of characters -- how else
would you know how the URI is delimited from surrounding bits? {} is
excluded because it isn't used within URI, and it is a good idea to reserve
at least one set of brackets for variable replacement algorithms.
Yes.
....Roy
