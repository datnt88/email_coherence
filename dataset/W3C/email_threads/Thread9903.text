I don't know if this is going to be helpful, but I thought it worth the
attempt to pull together the datatyping discussion.
I've been through todays mail traffic and pulled the issues as I've
recognised them. In general I've ignored retoric, exposition of beliefs as
to how it *should* be done and tried to focus on issues that I can, in some
sense make concrete. I've also tried to be even handed. The result is no
doubt imperfect; so help me get it right, next time round.
Issue B1:
In S, if one wants to use both idiom A and idiom B, e.g.
mary age "10" .
age rdfs:range xsd:integer.lex .
and
mary ageD _:a .
_:a xsd:integer.map "10" .
two properties have to be used, age and ageD , in this example.
I believe there is a agreement that this is a difference between the two
proposals.
Indeed, it may be said that the main aim of TDL is to avoid requiring
different properties for these different idioms.
Does anyone in the WG consider this feature of S, on its own, to be a
"can't live with" issue with S?
Issue B2: Multiple Lexical Representations of a data value
S, idiom A, permits multiple lexical representations of a data value:
_:i xsd:double "10.1" .
_:i xsd:double.de "10,1" .
I believe there is agreement that S-A allows this.
Does anyone in the WG consider this, on its own, to be a "can't live with"
issue with S?
Issue B3: the "duh" issue
DanC is concerened that with TDL:
mary haircolor "red" .
and a rule:
?x haircolor "red" = ?x rdf:type redhead .
one cannot conclude
mary rdf:type rdfhead .
since one conclude that both "red"'s denote the same thing.
Jeremy has responded:
From:
mary haircolor "red" .
haircolor rdfs:range xsd:string .
and the same rule one can draw the required inference.
DanC: Does that solve the problem? Do you withdraw that objection?
Jeremy/Patrick: Do you accept that without the range constraint, DanC is
correct?
Issue B4 - TDL breaks existing code
This is similar to B2. I've changed the example slightly from Sergey's.
Consider the graph:
_:f rdf:type film .
_:f dc:Title "10" .
mary age "10" .
Given a query:
(?x dc:Title ?y) &amp; (?z age ?y)
existing applications will return:
?x = _:f, ?y = "10", ?z = mary
Under TDL, they would return null.
Sergey: Does this version of the issue illustrate your point?
Jeremy/Patrick: Do you accept this analysis; would the query return null
under TDL?
Issue B5: Storage Requirements
TDL requires significantly more storage to implement.
Jeremy/Patrick: do you accept this statement?
Issue B6: S requires 4 URI's be registered for each data type
S requires that for each datatype 4 URI's be registered
datatype
datatype.lex
datatype.val
datatype.map
Sergey: Do you agree this is the case? If not, how many URI's are
required to implement ALL the idioms of S and coexist in the same model.
I think the killer issue for TDL is self-entailment (Dan's "duh" test). I
have been following with interest to see if Jeremy can come up with a
workable MT for this: his comments about treating literals like
existentials sounded as if it had promise. But, lacking a plausible MT
proposal by next telecon I do wonder if we don't need to just go with S,
because I've not seen any convincing fundamental problem with it...
I agree with the assessment. It's not ideal, but so far seems to be
standing up better than the alternatives.
I'd say that is a strong plus.
I am persuaded by Dan's argument, especially about self entailment. I
think the above is a consequence of that simple requirement.
I don't see this (query case) as a decider, either way. I suspect it only
breaks existing code for poorly conceived queries (find me a value that is
both a title and an age).
No comment.
Nit: I'd say that 3 rather than 4 URIs are required:
datatype.lex
datatype.val
datatype.map
It would be nice if they weren't, but I don't see this as a big problem.
#g
Graham Klyne MIMEsweeper Group
Strategic Research http://www.mimesweeper.com
This message addresses the main criticisms of TDL.
I will follow up with more detail concerning query, Brian's B3 &amp; B4.
The proponents of S furnish us with an implementation of S, and a model
theory for S (which includes, naturally self-entailment).
I now can create an implementation of TDL in the following fashion.
As I read in any RDF graph I apply the following syntactic transformation.
Match:
?x ?y ?z
where ?y != rdf:value and
?z a literal node
replace with
?x ?y NewNode
NewNode rdf:value ?z
where NewNode is a newly minted bNode.
For example:
a foo "ss" .
is transformed to
a foo _:b.
_:b rdf:value "ss".
We then use the S implementation and S model theory (idiom S-P is the only
idiom used).
Hence:
If S is implementable then so is TDL
The maximum overhead required for TDL is the same as that for S idiom A
and/or S idiom P.
All problems to do with entailment, query, implication, etc. are clarified
and addressed with this process (as long as they are clear and addressed
with S).
From an implementators point of view, it is clearly easier to implement the
syntactic transformation and S-P, than to implement S-A, S-B and S-P.
Graham, does this adequately address your concern about self-entailment?
[Small technical detail:
S-P uses a closed world assumption on data types, whereas TDL uses an open
world assumption. The two can be made equivalent by using S-P with at least
two incompatible types in its closed world both having domain being the
complete set of unicode strings. Two such types are:
xsd:string = {  x, x  | for any unicode string x }
appendA = {  x, x."A"  | for any unicode string, . being string
concatenation }
Jeremy
Jeremy, as far as I can tell, you are proposing:
(a) start with datatyping scheme S, complete with its model theory
(significantly, a literal denotes exactly the corresponding string).
(b) avoid subgraphs of the form a foo "ss" . by preprocessing them into
a foo _:b . _:b rdf:value "ss" .
I think this does address the self-entailment problem.
But I think that adding the requirement for graph transformation will be a
different kind of show stopper, in that lots of deployed software will see
a foo "ss" . and generate a graph containing exactly one arc.
I'm puzzled by this:
I don't think an RDF implementation has to do anything special to process
S-A, S-B and S-P that isn't standard RDF handling. Without any extension
to core RDF, I could define a vocabulary+interpretation that models these
idioms, giving them their intended interpretation, so what's special here
for the RDF processor?
#g
Graham Klyne MIMEsweeper Group
Strategic Research http://www.mimesweeper.com
Jeremy, feel free to correct me if you disagree ;-)
I see the recent refinement of TDL as an attempt to provide
tidy literals to those who want them without loosing the
untidyness that is inherent in the context dependent interpretation
of literals. It was an attempt at a fusion of TDL and S-P,
in the interest of finding a common ground and reaching a
mutually acceptable solution.
As Jeremy has said to me so elegantly, "there's untidyness in
there somewhere", and I agree.
You're either going to have untidy literal nodes or untidy
bnodes with literals hanging off them. There's no way around
that.
If it turns out that the "manditory bnode" idiom is going to
be highly backwards incompatable (and I'm not saying it is),
cest la vie, then we are stuck with untidy literal nodes, and
back to the previous TDL model.
The only show stopper that has been claimed for TDL is
that it doesn't have tidy literals -- based on the view
that e.g. "1984" always means the same thing. I hope that
it has become clear that this view is not
valid in an environment of global interchange between
disparate sources of knowledge.
So it should be concluded that there are no show stoppers
for TDL.
You may not love TDL for stylistic or other esthetic
reasons, but I feel that all supposed "fatal" flaws
with TDL have been addressed.
I don't feel the same is true for S, as my comments to
Brian's summary outline.
Let me state for the record that I am not religiously
tied to TDL. If S can be refined so that what I see as
unacceptable shortcomings are eradicated, then great.
It's not a matter of ego or advocacy -- but about having
a solution that will address all of the desiderada in
as general, efficient, and compatable a way possible.
So, that said, I still await someone to address the
issues of compatability of local and global idioms
and idiom specific vocabularies.
Cheers,
Patrick
On 2002-01-29 19:49, "ext Graham Klyne" Graham.Klyne@MIMEsweeper.com
I find this completely non sequitur.
If any show stopper can be removed by introduction of a different show
stopper, that doesn't mean there are no show stoppers.
I am still open to a TDL proposal that actually works. From a stylistic
viewpoint, I can agree that it is neater.
Yes, I tend to agree, too. In a sense, I think that what S does is push
the resolution of that untidiness out into the application (where implicit
as well as explicit typing information can be brought to bear). If the
untidiness cannot be resolved adequately within the interpretation of RDF
then that seems a reasonable, even inevitable, route to resolution of the
problem.
#g
Graham Klyne MIMEsweeper Group
Strategic Research http://www.mimesweeper.com
