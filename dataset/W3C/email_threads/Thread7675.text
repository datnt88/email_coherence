The last sentence of the last paragraph of section 4 reads "Implementations
MUST ensure the integrity of bindings." Similar language is used in the
second paragraph of section 5.1. However the term "integrity" was never well
defined inside of the specification. As such it is impossible to comply with
this requirement in an interoperable way. I would strongly caution against
attempting to specify the definition for integrity, English is much too
inexact a language for such an attempt to be successful.
As such, I move that both sentences be removed and be replaced with
a series of statements that define, in exact language, the requirements that
are to be represented by the term "integrity", each sentence properly
qualified with a MUST.
A binding is a relation between a segment S in a collection C and a resource
R, represented C:(S- R). We are saying that when a server agrees to create
a binding, it MUST guarantee that the binding will continue to exist until
one of the following happens:
DELETE with a Request-URI whose final segment is S and the rest of the URI
identifies collection C
MOVE with a Request-URI whose final segment is S and the rest of the URI
identifies collection C
BIND with a Destination whose final segment is S and the rest of the URI
identifies collection C, and Overwrite is T
DELETE the last binding to collection C
It is not acceptable for a binding to be destroyed as a side effect of any
other operation.
That's it for currently defined methods, I think. But I also think that we
do have to rely on a more conceptual definition, however inexact, to convey
the implications for other methods that might be defined in the future.
So here's a shot at the conceptual definition:
If a server allows binding C:(S- R) to be created, it MUST guarantee that
the resource R will continue to be accessible through the URI mappings
induced by that binding until it receives an explicit request to destroy the
binding. Such a request would have to ask explicitly that some element of
the relation C:(S- R) be removed, or that the relationship itself be
removed. It would have to explicitly request that the last binding to C be
removed, that the last binding to R be removed, or that the binding C:(S- R)
be removed from C.
--Judy
The last sentence of the last paragraph of section 4 reads "Implementations
MUST ensure the integrity of bindings." Similar language is used in the
second paragraph of section 5.1. However the term "integrity" was never well
defined inside of the specification. As such it is impossible to comply with
this requirement in an interoperable way. I would strongly caution against
attempting to specify the definition for integrity, English is much too
inexact a language for such an attempt to be successful.
As such, I move that both sentences be removed and be replaced with
a series of statements that define, in exact language, the requirements that
are to be represented by the term "integrity", each sentence properly
qualified with a MUST.
I don't understand why this is a requirement of bindings. It certainly
isn't a requirement of normal resources. Why should the requirements on
bound names be stronger than the names they bind to?
....Roy
From: Roy T. Fielding [mailto:fielding@kiwi.ICS.UCI.EDU]
Sent: Thursday, January 20, 2000 7:39 PM
Subject: Re: WebDAV Bindings - Issue Yaron.MrIntegrity
There are applications that depend upon the integrity of bindings. In
particular, the versioning protocol being developed by the Delta-V working
group depends upon it. In versioning, there are many orthogonal ways of
grouping information: by activity, by version tree, by configuration, etc.
Clients depend upon the integrity of this information.
As others have suggested recently, we may want to define weak bindings
eventually, but we've started in this specification with strong bindings.
--Judy
From: w3c-dist-auth-request@w3.org
[mailto:w3c-dist-auth-request@w3.org]On Behalf Of Roy T. Fielding
Another way of stating the rationale for the integrity requirement is this:
we wanted to create a requirement that would prevent bindings that "dangle".
It must not be possible for a client to interact with a binding that doesn't
have a destination resource.
- Jim
Sent: Thursday, January 20, 2000 4:39 PM
Subject: Re: WebDAV Bindings - Issue Yaron.MrIntegrity
this:
"dangle".
doesn't
There are two points you seem to be missing. First, the origin
server doesn't know the resource. The server knows what the URI is and
how to map that URI to a program and/or storage object(s), but the
resource is not the storage object. There are resources that map to no
storage object. In fact, there are resources that exist even before
their origin server has been realized in hardware and connected to the
Internet. There are also storage objects that make up only a small
component of many other resources. Bindings are not about storage
objects.
They are about names within a namespace. If you can create a binding
to another resource, then you can create a binding to no storage object,
which means any requirement that bindings be mappable to storage objects
is completely bogus.
The second point is that I, as an experienced Web developer, have
no interest in the strong integrity requirement. It is, in fact,
contrary to the already implemented forms of bindings that can be
found in every general-purpose Web server post-1993. It isn't
necessary for the abstract notion of adding an internal redirect
to a resource within the namespace of a collection, which is what
BIND is supposed to solve. It is harder to implement than late
binding (in fact, the way it is worded in the spec is simply
impossible to implement, but that can be fixed by talking about
what the server knows and not about resources). It isn't necessary
for interoperability. It doesn't change the fact of life that some
bindings will be left dangling even with the requirement in the
protocol, since a normal resource can dangle, which means the protocol
still needs to express those semantics to the client (even if that
means the response is just 404, though I'm sure we can do better).
It is not a desirable feature in the majority of Web implementations,
since Web authors are familiar with the concept of setting up links
to a resource *before* the resource exists and don't want all their
links to disappear and need to be re-bound just because one URI
(which is the only way to identify a resource) goes away. There is
no conceptual difference between a binding within a collection and
an img src="binding" within HTML.
It is okay if the server *wants* to implement strong integrity.
It is okay for some resources to have strong integrity by their
very nature. All of the HTTP methods that make changes to the origin
are defined such that side-effects on other resources are expected.
It is therefore unnecessary to require it of all resources, even
with the presence of versioning and document management systems on
the backend.
Optional features are meant to be options, not protocol requirements.
Roy T. Fielding fielding@ebuilt.com
Irvine, CA 92614-5840 USA http://www.eBuilt.com
They depend on the integrity of versioned resources. That is a
requirement on the resource, not on the protocol. There is nothing
stopping delta-v from requiring that the bindings created for the
purpose of versioning be strongly bound and verifiable.
....Roy
I hail from the school of hard requirements and the proposed language is
open to too many possible interpretations to be considered "hard". I think
it would be better to specify the explicit conditions given below and then
provide a non-normative explanation of the desired long term behavior.
Yaron
I propose that we delete all uses of the term "integrity" from
the spec, and instead say:
RFC 2518 allows resource deletion requests, such as DELETE and MOVE,
to do a "best effort" deletion on collections, where only some of
the members of the collection are deleted following the request.
In order to guarantee the more predictable BIND/UNBIND semantics when a
binding
unaware client is used to do authoring on a binding aware server,
a binding aware server is required to map deletion requests into the
appropriate UNBIND request.
More formally: If a DELETE request, MOVE request, or a request with an
Overwrite:T header is applied to a resource identified by the URL
/path/x, and /path identifies a collection that supports the BIND/UNBIND
methods, then the request MUST have the same effect as an UNBIND of x from
/path.
In particular, if the request succeeds, the binding named x MUST be removed
from the collection indentified by /path, and whether or not the request
succeeds, no other bindings from any other collection may be removed.
As a corollary to this rule, if a DELETE request, MOVE request,
or a request with an Overwrite:T header is applied to a collection
identified by the URL /path1, then a resource identified by the URL
/path1/path2/path3 MUST NOT be deleted if /path1/path2 supports the
BIND/UNBIND operation.
Cheers,
Geoff
Behalf Of Yaron Goland
The last sentence of the last paragraph of section 4 reads "Implementations
MUST ensure the integrity of bindings." Similar language is used in the
second paragraph of section 5.1. However the term "integrity" was never well
defined inside of the specification. As such it is impossible to comply with
this requirement in an interoperable way. I would strongly caution against
attempting to specify the definition for integrity, English is much too
inexact a language for such an attempt to be successful.
As such, I move that both sentences be removed and be replaced with
a series of statements that define, in exact language, the requirements that
are to be represented by the term "integrity", each sentence properly
qualified with a MUST.
This looks like most of what we want for guaranteeing integrity of bindings.
What we want to avoid is a situation where a binding might be broken or
removed as a side effect of an operation on some other binding. We don't
want a URI to stop working as a result of a DELETE or MOVE operation
submitted to a different Request-URI.
The sort of case we initially considered when talking about integrity is not
entirely covered by your proposed language: Suppose you have two separate
servers (or two parts of the namespace of one server that are separately
managed) and you create a binding from a location on one server to a target
resource on the other. Then unless you had some out-of-band way of
collaborating on the creation of this new binding, the server managing the
target resource would not know that this binding had been created. Then
when the last binding it knows about is deleted, it will be free to destroy
the resource, and the binding on the other server may be broken. The server
can be obeying the rules you state in your message (as far as it knows) and
still do something that will cause the binding to be broken.
So we need to address some constraints to the server that allowed the
binding to be created in the first place -- it should never have allowed the
binding to be created unless it had some way to communicate the existence of
the binding to the server managing the target resource.
--Judy
I propose that we delete all uses of the term "integrity" from
the spec, and instead say:
RFC 2518 allows resource deletion requests, such as DELETE and MOVE,
to do a "best effort" deletion on collections, where only some of
the members of the collection are deleted following the request.
In order to guarantee the more predictable BIND/UNBIND semantics when a
binding
unaware client is used to do authoring on a binding aware server,
a binding aware server is required to map deletion requests into the
appropriate UNBIND request.
More formally: If a DELETE request, MOVE request, or a request with an
Overwrite:T header is applied to a resource identified by the URL
/path/x, and /path identifies a collection that supports the BIND/UNBIND
methods, then the request MUST have the same effect as an UNBIND of x from
/path.
In particular, if the request succeeds, the binding named x MUST be removed
from the collection indentified by /path, and whether or not the request
succeeds, no other bindings from any other collection may be removed.
As a corollary to this rule, if a DELETE request, MOVE request,
or a request with an Overwrite:T header is applied to a collection
identified by the URL /path1, then a resource identified by the URL
/path1/path2/path3 MUST NOT be deleted if /path1/path2 supports the
BIND/UNBIND operation.
Cheers,
Geoff
-----Original Message-----
Behalf Of Yaron Goland
The last sentence of the last paragraph of section 4 reads "Implementations
MUST ensure the integrity of bindings." Similar language is used in the
second paragraph of section 5.1. However the term "integrity" was never well
defined inside of the specification. As such it is impossible to comply with
this requirement in an interoperable way. I would strongly caution against
attempting to specify the definition for integrity, English is much too
inexact a language for such an attempt to be successful.
As such, I move that both sentences be removed and be replaced with
a series of statements that define, in exact language, the requirements that
are to be represented by the term "integrity", each sentence properly
qualified with a MUST.
