Follow up to:
This may probably be something right for the DOM mailing list,
a DOM implementation that consistently returns the same
object for the same underlying node allows you to use that
object to synchronize code that accesses that node.
For example, something like:
for(int i = 0; i  children.getLength(); i++) {
child = children.item(i);
synchronized(child) {
// do something unsafe
Would work as intended if the same node is returned, but would
not block if independent objects were returned for the same node.
Does (or should) DOM 3 address this by adding a getMutex() or
similar method, something like:
for(int i = 0; i  children.getLength(); i++) {
child = children.item(i);
synchronized(child.getMutex()) {
// do something unsafe
Where an existing implementation that had a one-to-one correspondance
between nodes and objects could just return "this" for getMutex().
From: Joseph Kesselman [mailto:keshlam@us.ibm.com]
Sent: Friday, April 20, 2001 1:03 PM
Subject: Re: Node identity comparisons
As far as the DOM API is concerned, Node identity does not
guarantee object
identity. Most existing DOM implementations behave that way,
but not all.
Yes, this was an oversight. Oops.
DOM Level 3 will address this by adding an isSameNode() operation to
directly test node identity.
Joe Kesselman / IBM Research
I'll chime in to note that the DOM currently does not (as far as I
can tell) have anything to say about concurrency. In particular, it
does not require or imply that support for concurrent operation is
required.
I think this is a good thing.
While I think I understand your interest, it's not clear to me that
the DOM needs provide direct support for concurrency-related issues.
If something like this is required, the specification should at least
make it clear that the getMutex() can return null -- not all
environments support concurrency, or an implementation may not want to
provide explicit support for it.
Perhaps you need to present your motivation for using the DOM nodes
as synchronization objects independently from Java -- the idiom of
using an arbitrary object for synchronization is not used in all
languages.
-Fred
Fred L. Drake, Jr. fdrake at acm.org
PythonLabs at Digital Creations
In the intro, "DOM Level 2 does not specify multithreading mechanisms." And
DOM Level 1 listed threadsafety as an issue deferred to later levels.
Every time the DOM has looked at the idea of requiring that implementations
be inherently threadsafe, we seem to come back to the same conclusions.
This can be a lot of overhead in applications which don't need it, and is
insufficient in applications which do need it since the conceptual unit is
often several DOM operations so they'd still have to implement threadsafety
at the higher level... which would make protecting the DOM itself of
negligable value.
However, it's still on our open issues list as something to consider. As is
the possiblity of simply being able to "lock" the whole DOM (claim
ownership of it for an extended period and hold off other users until
ownership is explicitly released), which is probably a more useful
operation but which still seems to involve a lot of overhead for
applications which don't need this protection.
If someone can find a Really Useful Low Cost Portable Solution in this
space, I'd be delighted. Suprised, but delighted. Until then, you'll have
to handle threadsafety at the application or implementation-dependent
level.
Joe Kesselman / IBM Research
