For the benefit of the xmldsig mailing list who are joining this
thread in midstream, first some background:
I replied to a message from Joseph Reagle as follows:
DanC/DanV: the document capturing concern about XPTr's bare name is [1].
Can you look at it quickly and tell me if the concern if unfounded. If
founded, we will fowrad to XML Linking comment list.
[1] http://lists.w3.org/Archives/Public/w3c-ietf-xmldsig/2000AprJun/0213.html
The correspondence referred to there is one which addresses the
question of exactly what pattern is required to pick out a node list
which has one member for every node in a document.
That's an entirely separate question from whether the single node
identified by #foo == #xpointer(id(foo)) is complete, or in some sense
exfoliated (stripped of its attributes and content). I see nothing
either in the referenced correspondence or elsewhere in XPath/XPointer
to suggest the exfoliated view.
ht
Joseph sent my reply to John Boyer, who replies as follows.
From: "John Boyer" jboyer@PureEdge.com
Hi Joseph,
Firstly, the correspondence cited was not restricted to having a node-set
containing one node for each element of the document, as claimed by the
author of the response below. It had to do with the fact that the result of
id() is indeed 'exfoliated' and, because of a syntactic limitation of XPath,
one must create an expression which generates one node for every node in the
document, then filter down to element E and its descendants (including
namespace and attribute nodes).
More importantly, the author is also incorrect in his assertion that there
is no evidence in XPath to support the assertion of an 'exfoliated' node-set
result from the id() function. My opinion is based on [1] as well as email
received from James Clark and Steve DeRose (the editors of the XPath
specification).
[1] http://www.w3.org/TR/xpath#function-id
The Xpath specification is quite clear about the meaning of the id function
[1]. According to [1], the result of the id function is a node-set
containing the element(s) matching the identifier(s) given by the function's
input parameter. A single identifier results in a node-set containing a
single element. The output node-set does not contain the element node plus
its descendants plus all of the namespace and attribute nodes of these
elements.
In conclusion, the problem remains one of how to think about and hence
process a node-set. If a node-set is a set of nodes, then the result of
id("E") is insufficient to indicate the desire for a textual rendering of E
and all of its content, namespace declarations and attributes. Only by
interpreting a node-set as something other than a set of nodes--
specifically, a subtree-root-set-- does id("E") become sufficient.
John Boyer
Software Development Manager
PureEdge Solutions Inc. (formerly UWI.Com)
Creating Binding E-Commerce
jboyer@PureEdge.com
There is no debate that the referent of a barename XPointer == XPath
id() function is a nodeset consisting of a single element node (or
none). It would be incoherent for it to be otherwise -- the nodeset
refered to by an expression consists of those nodes which satisfy the
expression, and e.g. the children of a node with id 'foo' cannot also
have id 'foo', so by definition cannot be part of the referent of id(foo).
What _is_ at issue is what the meaning of this single-element nodeset
is. In the first instance, it means that element node is the referent
of the relevant XPointer. The spec. is at pains to point out that
XPointers don't _return_ anything, they _point_ to things. And in the
XPath data model, just like the Infoset, when you point at something,
you implicitly point at everything you can access from it. The
language and the principle are no different from e.g. fragment
identifiers for text/html -- they point to the element with the
relevant 'name' attribute, but if you GET them you get the subtree
rooted there. It's open to DSig to specify the DSig operational
semantics of XPointers similarly, as far as I can see.
I think for me to help further with this, I need to see the referenced
correspondence from James and Steve -- is it in the dsig archive?
ht
Henry S. Thompson, HCRC Language Technology Group, University of Edinburgh
W3C Fellow 1999--2001, part-time member of W3C Team
2 Buccleuch Place, Edinburgh EH8 9LW, SCOTLAND -- (44) 131 650-4440
URL: http://www.ltg.ed.ac.uk/~ht/
My initial confusion resulted in not understanding what the "analog of the
HTML fragment identifier behavior" [2] meant. John pointed out it didn't
mean what I thought it meant, and you and Daniel have confirmed that.
[1] http://lists.w3.org/Archives/Public/w3c-ietf-xmldsig/2000AprJun/0212.html
[2] http://www.w3.org/TR/xptr#synth-2.1.2
Could you cite the text you are referring to for the sake of completeness?
I don't think there was any correspondence from James or Steve.
Joseph Reagle Jr.
W3C Policy Analyst mailto:reagle@w3.org
IETF/W3C XML-Signature Co-Chair http://www.w3.org/People/Reagle/
Hi Henry,
Yes, what is very much at issue is how to interpret a node in a node-set.
However, the assertion that a node in a node-set is meant to indicate "point
at everything you can access from it" is flawed on two counts:
1) every node in the entire document is accessible from any node in the
document.
2) your intent in making this statement is to have each node be
representative of the subtree for which it is the root. This is a subset of
what is reachable from the node, but more importantly it defies the use of
the term 'set'. The XPath spec is quite clear about the fact that a
node-set contains no duplicates. If the intended meaning of 'node' is 'self
plus all descendants including namespaces and attributes', then it should be
impossible for me to produce a node-set containing an element and a child of
that element since the child is already implicitly included by virtue of
including its parent. Current implementations permit a child to be a
node-set with its parent, substantiating the view of node-set as a 'set of
nodes', not a set of subtree roots.
Moreover, the view that xpointers 'point to things' rather than 'return
things' has little to do with the problem and serves only to cloud the
issue. Nonetheless, the XPath specification says "Each function in the
function library is specified using a function prototype, which gives the
return type...", which substantiates the view that the id() function
*returns* a node-set. So, XPointer's claim that "XPointers don't _return_
anything, they _point_ to things" simply means that they return a node-set
that 'points to' or indicates certain nodes (locations in the case of
Xpointer).
However, the problem is and has always been about what do you do with the
'pointer'? What does it mean to 'dereference' the pointer. Applications of
XPath and XPointer are free to define what they intend to do with the output
result of the XPath or Xpointer expression. In the case of XPath, I have
interpreted the node-set as a set of nodes because that's what the W3C chose
to call it and because that's how XPath expression evaluators act. So,
within XPath serialization and c14n, the act of dereferencing a node-set
produces the text of precisely and only those nodes that are actually in the
node-set.
There is no substantiation within XPath to interpret a node-set as a
subtree-root-set because a node and its child can appear in the node-set.
Finally, the emails from DeRose [1] and Clark [2] are in the dsig archive.
[1]
[2]
They are about the interpretation of an expression like
id("E")/descendant-or-self::node()
which will only produce a node-set containing E and its descendant elements,
PIs, comments, and text, but will exclude the namespace and attribute nodes
of E and its descendant elements. In your prior email [3], you used the
term 'exfoliated', by which one must assume you meant that you found no
evidence that id("E") would produce a result that was devoid of the
descendants, namespaces and attributes of E. My reference those emails from
Clark and DeRose was intended to substantiate the point that indeed the
result of id("E") is 'exfoliated' and further that, by design, the namespace
and attribute nodes are omitted from descendant class axes (which also
implicitly substantiates the viewpoint that one should create a node-set
indicating a node AND its descendants when one INTENDS TO indicate or 'point
to' the node AND its descendants).
[3]
John Boyer
Software Development Manager
PureEdge Solutions Inc. (formerly UWI.Com)
Creating Binding E-Commerce
jboyer@PureEdge.com
Let's back up and try again -- I feel like I've arrived late to a
party where everyone is already deep in a doom-and-gloom-laden
discussion about the awful consequences of something which hasn't
actually happened. I think we're not actually very far from a
resolution, with your messages on another thread pointing the way, if
we reconceptualise a bit.
1) Nodesets. Nodesets are introduced into the XPath data model to
represent the semantics of XPath expressions. The intrinsic semantics
of a node set is a _disjunction_. The interpretation of a nodeset as
the value of an XPath expression is: "Each of the members of this set
satisfies the expression".
This is _really_ important: the value of the XPath expression '//foo'
is the set of all element nodes in a document whose name is 'foo' --
each of them, independently, is an answer to the instruction "Find me
something be starting from the root and looking for a 'foo' element".
Similarly, the value of the XPath expression 'id(baz)' is the set of
all element nodes in a document whose declared-as-type-id attribute
has the value 'foo'. Now XML validity constraints (which must be in
play or we wouldn't know which attributes are of type id) require that
at most one such element exists, so the nodeset is either empty or
singleton.
It would be seriously incompatible with this fundamental aspect of
XPath to include in result nodesets nodes which did _not_ satisfy the
expression.
2) Nodes as results. XPath expressions have values, which are
nodesets. XPointer uses XPath expressions to pick out one or more
points in XML documents. This is made clear as early as the
introduction [1], which uses words such as 'locate', 'address',
'choice', 'reference', 'target', etc. It is entirely up to
applications what semantics they attach to such locations: "The
structures located with XPointer can be used as link targets or for
any other application-specific purpose".
In particular, it is clearly open to applications to specify that the
location picked out by an XPointer, whether short-frag, explicit-id or
other XPointer, is used by DSig as the root of a document subtree.
XML Schema, XInclude and XPath itself take this approach, so there's
plenty of precedent.
3) What does an XPointer point to? The XPath REC introduces a data
model to answer this question [2]. It is clear from this exposition,
in particular from the definition of 'string-value', that the document
subtree rooted in a particular node is well-defined.
Net: XPointer is just fine for your purposes, all that is required is
to state that the DSig interpretation of an XPointer is as picking out
the entire document subtree rooted at the node identified by that
pointer. You do _not_ need to do this by defining a further XPath
function such as your suggested 'subtree' -- indeed to do so what be
counterproductive, as that function flattens the tree and loses
information in doing so.
Hope this helps -- if not I suspect a 'phone call is the next step.
ht
[1] http://www.w3.org/TR/xptr#N598
[2] http://www.w3.org/TR/xpath#data-model
Henry S. Thompson, HCRC Language Technology Group, University of Edinburgh
W3C Fellow 1999--2001, part-time member of W3C Team
2 Buccleuch Place, Edinburgh EH8 9LW, SCOTLAND -- (44) 131 650-4440
URL: http://www.ltg.ed.ac.uk/~ht/
Oops! My previous message begins
and then continues with 100% _my_ prose -- sorry for any confusion.
ht
Henry S. Thompson, HCRC Language Technology Group, University of Edinburgh
W3C Fellow 1999--2001, part-time member of W3C Team
2 Buccleuch Place, Edinburgh EH8 9LW, SCOTLAND -- (44) 131 650-4440
URL: http://www.ltg.ed.ac.uk/~ht/
Hi Henry,
Actually, there isn't much doom and gloom going on, and we seem to be doing
better than being close to a resolution. We already have a number of
resolutions. All of this began very simply when I pointed out a necessary
correction to the dsig spec because there was a difference between what the
xpath expression id("E") returns versus what our spec claimed would be the
serialized result.
Most of what you wrote below explains the basic notions of XPath, which I
have been actively working with for almost a year now. There is no
confusion on my part regarding these basic issues, and I have indeed written
much of the same material in recent emails.
However, I would disagree on one minor point: the definition of string-value
does not provide a definition of subtree that includes namespace and
attribute nodes. Please look again at the definition of string value,
especially the string-value description for element nodes [1], which states
that the string value of an element is the concatenation of the string
values of its *text node descendants*. In other words, no visitation of
namespace and attribute nodes is performed by the string-value DFS
algorithm. This entire thread would have been very small if namespace and
attribute nodes were included in descendancy because we could've just
serialized the node-set result of
id("E")/descendant-or-self::node()
Despite this minor point, I am glad that you (and Daniel Veillard [2]) agree
that applications are free to use node-sets in any way that is convenient,
since I believe it makes the most sense for the purpose of serializing or
canonicalizing XML to treat a node-set as a set of nodes, where inclusion in
the set means inclusion in the textual output, and exclusion from the set
means exclusion from the textual output. The major source of our prior
disagreement seems to have been the assertion that a node-set should always
indicate subtree roots, which was not justified by subsequent comments that
Xpointers are pointers taht indicate what is accessible (since everything is
accessible from any point in the tree).
Furthermore, as I pointed out to the dsig group yesterday, and with which
you indicate agreement below, we are free to define the XPointer URI="#E" as
indicating E plus all nodes that have E as an ancestor. In other words,
subtree(id("E")).
This segues nicely to my final question. As I pointed out in prior emails,
the actual XPath expression that corresponds to the above definition of
URI="#E" is somewhat clumsy, but it is possible to say what we mean to say
in an XPath expression. This is why I claim that we do not, in fact, have a
doom-and-gloom problem. However, you made the statement that defining a
subtree() function would "be counterproductive, as that function flattens
the tree and loses information in doing so." Notwithstanding Dan Veillard's
comments to the contrary [2], I do not think this is the case. When we
create a node-set containing the entire subtree, the document order of the
nodes retains the information necessary for us to create a canonical form or
a serialization that can be passed to a digest algorithm (where document
order for namespace and attribute nodes is defined by sorting [3, 4]).
Could you please explain if this does not adequately address your concern
about a flattened tree?
In conclusion, then, I really do not think we disagree on much if anything
now that we have both familiarized ourselves with the other's position.
[1] http://www.w3.org/TR/xpath#element-nodes
[2]
[3] http://www.w3.org/TR/xml-c14n
[4] http://www.w3.org/TR/xmldsig-core/#sec-XPath
John Boyer
Software Development Manager
PureEdge Solutions Inc. (formerly UWI.Com)
Creating Binding E-Commerce
jboyer@PureEdge.com
w3t-tech@w3.org; w3c-ietf-xmldsig@w3.org
Let's back up and try again -- I feel like I've arrived late to a
party where everyone is already deep in a doom-and-gloom-laden
discussion about the awful consequences of something which hasn't
actually happened. I think we're not actually very far from a
resolution, with your messages on another thread pointing the way, if
we reconceptualise a bit.
1) Nodesets. Nodesets are introduced into the XPath data model to
represent the semantics of XPath expressions. The intrinsic semantics
of a node set is a _disjunction_. The interpretation of a nodeset as
the value of an XPath expression is: "Each of the members of this set
satisfies the expression".
This is _really_ important: the value of the XPath expression '//foo'
is the set of all element nodes in a document whose name is 'foo' --
each of them, independently, is an answer to the instruction "Find me
something be starting from the root and looking for a 'foo' element".
Similarly, the value of the XPath expression 'id(baz)' is the set of
all element nodes in a document whose declared-as-type-id attribute
has the value 'foo'. Now XML validity constraints (which must be in
play or we wouldn't know which attributes are of type id) require that
at most one such element exists, so the nodeset is either empty or
singleton.
It would be seriously incompatible with this fundamental aspect of
XPath to include in result nodesets nodes which did _not_ satisfy the
expression.
2) Nodes as results. XPath expressions have values, which are
nodesets. XPointer uses XPath expressions to pick out one or more
points in XML documents. This is made clear as early as the
introduction [1], which uses words such as 'locate', 'address',
'choice', 'reference', 'target', etc. It is entirely up to
applications what semantics they attach to such locations: "The
structures located with XPointer can be used as link targets or for
any other application-specific purpose".
In particular, it is clearly open to applications to specify that the
location picked out by an XPointer, whether short-frag, explicit-id or
other XPointer, is used by DSig as the root of a document subtree.
XML Schema, XInclude and XPath itself take this approach, so there's
plenty of precedent.
3) What does an XPointer point to? The XPath REC introduces a data
model to answer this question [2]. It is clear from this exposition,
in particular from the definition of 'string-value', that the document
subtree rooted in a particular node is well-defined.
Net: XPointer is just fine for your purposes, all that is required is
to state that the DSig interpretation of an XPointer is as picking out
the entire document subtree rooted at the node identified by that
pointer. You do _not_ need to do this by defining a further XPath
function such as your suggested 'subtree' -- indeed to do so what be
counterproductive, as that function flattens the tree and loses
information in doing so.
Hope this helps -- if not I suspect a 'phone call is the next step.
ht
[1] http://www.w3.org/TR/xptr#N598
[2] http://www.w3.org/TR/xpath#data-model
Henry S. Thompson, HCRC Language Technology Group, University of Edinburgh
W3C Fellow 1999--2001, part-time member of W3C Team
2 Buccleuch Place, Edinburgh EH8 9LW, SCOTLAND -- (44) 131 650-4440
URL: http://www.ltg.ed.ac.uk/~ht/
[... lots of stuff that I agree with deleted ...]
Not so. The XPointer spec says what #E means for XML, and it
says that it means the same thing that #xpointer(id("E")) means.
You can't change the relationship between #E and
#xpointer(id("E")) without changing the XPointer spec.
Dan Connolly, W3C http://www.w3.org/People/Connolly/
Oops, yes I used incorrect terminology. This replacement should be
satisfactory:
Furthermore, as I pointed out to the dsig group yesterday, and with which
you indicate agreement below, we are free to process an Xpath node-set or
XPointer location-set in any manner necessary. Therefore, the XPointer
URI="#E" can
be processed by XPath serialization (or by the new c14n) by processing
E plus all nodes that have E as an ancestor. In other words,
subtree(id("E")).
For the sake of ensuring that there is a resolution whether or not a
subtree() function exists, let me reiterate that, without the subtree()
function, we can still define the processing of the XPointer URI="#E" in
terms of Xpath serialization (or by the new c14n) by using the following
expression:
(//. | //@ | //namespace::*)[count(ancestor-or-self::* | id("E")) =
count(ancestor-or-self::*)]
(The Xpath transform processes nodes on the node-set and omits nodes not in
the node-set).
John Boyer
Software Development Manager
PureEdge Solutions Inc. (formerly UWI.Com)
Creating Binding E-Commerce
jboyer@PureEdge.com
w3t-tech@w3.org; w3c-ietf-xmldsig@w3.org
[... lots of stuff that I agree with deleted ...]
as
Not so. The XPointer spec says what #E means for XML, and it
says that it means the same thing that #xpointer(id("E")) means.
You can't change the relationship between #E and
#xpointer(id("E")) without changing the XPointer spec.
Dan Connolly, W3C http://www.w3.org/People/Connolly/
I agree entirely, up to the last few lines. I think it is
unnecessary and indeed somewhat misleading to define your
serialisation in terms of your definition of subtree. The flattened
set of all descendants has the wrong shape. It makes serialisation
non-recursive, i.e. you can't say: to serialise an element node (an
XPointer result), do this, that, then serialise its attributes, then
do blah, then serialise its daughters in order, then do zyzzy. I
suggest that that's precisely what you want, your own, recursively
specified, definition of 'serialisation'. That's why I brought up
'string-value': I think the definition of 'serialisation' should be
very similar to that of 'string-value'. Doing the definition in terms
of node sets actually makes it harder, in my opinion.
ht
Henry S. Thompson, HCRC Language Technology Group, University of Edinburgh
W3C Fellow 1999--2001, part-time member of W3C Team
2 Buccleuch Place, Edinburgh EH8 9LW, SCOTLAND -- (44) 131 650-4440
URL: http://www.ltg.ed.ac.uk/~ht/
But the whole point is: we don't necessarily want to serialize
all the descendants. We're trying to to use XPath to pick *which*
descendants to serialize.
Dan Connolly, W3C http://www.w3.org/People/Connolly/
Hi Henry,
[mailto:w3c-ietf-xmldsig-request@w3.org]On Behalf Of Henry S. Thompson
w3t-tech@w3.org; w3c-ietf-xmldsig@w3.org
I agree entirely, up to the last few lines. I think it is
unnecessary and indeed somewhat misleading to define your
serialisation in terms of your definition of subtree. The flattened
set of all descendants has the wrong shape. It makes serialisation
non-recursive, i.e. you can't say: to serialise an element node (an
XPointer result), do this, that, then serialise its attributes, then
do blah, then serialise its daughters in order, then do zyzzy. I
suggest that that's precisely what you want, your own, recursively
specified, definition of 'serialisation'. That's why I brought up
'string-value': I think the definition of 'serialisation' should be
very similar to that of 'string-value'. Doing the definition in terms
of node sets actually makes it harder, in my opinion.
The use of node-set doesn't make anything harder. At any point in the
lifetime of a node-set, there must be sufficient internal data structures
necessary to move in along any axis of the parse tree in order to do the
next location step. The information isn't lost.
The genesis of the view of node-set as a set of nodes began around last
August at a face to face meeting of the dsig group when I presented on the
use of Xpath to perform document subsetting, which solves lots of problems
related to digital signatures. I'm not going to reiterate the months of
email explanations pertaining to the idea, nor the public specifications of
how it works [1,2], but I will reiterate the point as made in a recent email
by Dan Connolly [3], we're using the notion of set to specify *which*
descendants to serialize, and which to exclude.
Finally, it should be obvious from the archives that I agree with your
definition of the serialization as a recursive process (trees adhere well to
recursive definitions, after all). Yesterday (and into this morning) I went
to extra lengths to ensure that this recursive nature was clearer than ever
in the new c14n draft, and that the recursive descent was being used in
combination with set membership to decide, for each node, the text that is
generated [4]. It should be clear from the description that an element's
descendants are visited even if the element is omitted from the node-set.
[1] http://www.w3.org/TR/xmldsig-core/
[2] http://www.w3.org/TR/xml-c14n
[3]
[4]
John Boyer
Software Development Manager
PureEdge Solutions Inc. (formerly UWI.Com)
Creating Binding E-Commerce
jboyer@PureEdge.com
ht
Henry S. Thompson, HCRC Language Technology Group, University of Edinburgh
W3C Fellow 1999--2001, part-time member of W3C Team
2 Buccleuch Place, Edinburgh EH8 9LW, SCOTLAND -- (44) 131 650-4440
URL: http://www.ltg.ed.ac.uk/~ht/
Sounds like we're finished. No complaint/change request wrt XPointer
required, right?
ht
Henry S. Thompson, HCRC Language Technology Group, University of Edinburgh
W3C Fellow 1999--2001, part-time member of W3C Team
2 Buccleuch Place, Edinburgh EH8 9LW, SCOTLAND -- (44) 131 650-4440
URL: http://www.ltg.ed.ac.uk/~ht/
