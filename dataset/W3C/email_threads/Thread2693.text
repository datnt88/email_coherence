There've been nine implementation reports so far.
This message summarizes some of the troublesome issues:
The following features are not marked as implemented by two or more
implementations:
H 10.1.2 101 Switching Protocols
H 10.2.4 203 Non-Authoritative Information
H 10.2.6 205 Reset Content
H 14.15 Content-MD5
H 14.42 Upgrade
A 3.2.1, A 3.2.2, A3.2.3, A4.2 (all)
In addition, the following features are claimed to be implemented
by two or more, but have not been tested by two or more independent
implementations:
H 10.2.2 201 Created
*H 10.2.3 202 Accepted
H 10.3.6 305 Use Proxy
*H 10.4.3 402 Payment Required
H 10.4.9 408 Request Timeout
H 10.4.10 409 Conflict
H 10.4.11 410 Gone
H 10.4.12 411 Length Required
H 10.4.14 413 Request Entity Too Large
H 10.4.15 414 Request-URI Too Long
*H 13.3.3 Weak entity tags
*H 14.37 Retry-After
H 14.39 TE
The features except those marked with "*" were
tested by one implementation against another,
but the testing wasn't mutual.
It would be good to focus on broadening the testing
for each of these features, though.
Larry
Section 3.1 (HTTP Version) of the latest draft currently includes
this statement:
Applications sending Request or Response messages, as defined by this
specification, MUST include an HTTP-Version of "HTTP/1.1". Use of this
version number indicates that the sending application is at least
conditionally compliant with this specification.
I think this is at least confusing, and possibly wrong. For example,
the first sentence directly contradicts some statements in RFC2145,
which is cited a few paragraphs earlier. The parenthetical statement
is also odd, since a completely normal HTTP/1.0 implementation could
send messages that are defined by "this specification".
The most important statement that we need to make here is the second
sentence in the paragraph, and I think this is where the MUST needs
to be.
I propose rewriting this pararagraph to be:
An application that sends a Request or Response message that
includes HTTP-Version of "HTTP/1.1" MUST be at least conditionally
compliant with this specification. Applications that are at least
conditionally compliant with this specification SHOULD use an
HTTP-Version of "HTTP/1.1" in their messages, and MUST do so for any
message that is not compatible with HTTP/1.0. For more details on
when to send specific HTTP-Version values, see RFC 2145 [36].
I.e.,
you MUST NOT say you're HTTP/1.1 unless you comply.
if you do comply, you SHOULD say so.
if your message isn't intelligible to an HTTP/1.0 recipient,
say you're HTTP/1.1.
-Jeff
Section 3.7.2 includes these two paragraphs:
In general, HTTP treats a multipart message-body no differently than any
other media type: strictly as payload. The one exception is the
"multipart/byteranges" type (appendix 19.2) when it appears in a 206
(Partial Content) response, which will be interpreted by some HTTP
caching mechanisms as described in sections 13.5.4 and 14.16. In all
other cases, an HTTP user agent SHOULD follow the same or similar
behavior as a MIME user agent would upon receipt of a multipart type. If
an application receives an unrecognized multipart subtype, the
application MUST treat it as being equivalent to "multipart/mixed". The
MIME header fields within each body-part of a multipart message-body do
not have any significance to HTTP beyond that defined by their MIME
semantics.
In general, an HTTP user agent SHOULD follow the same or similar
behavior as a MIME user agent would upon receipt of a multipart type. If
an application receives an unrecognized multipart subtype, the
application MUST treat it as being equivalent to "multipart/mixed".
The phrase "an HTTP user agent SHOULD follow the same or similar
behavior as a MIME user agent would upon receipt of a multipart type"
appears twice here, once in each sentence. The first occurrence
is qualified by (in effect) "except for 'multipart/byteranges'";
the second occurrence has no specific exceptions, but just says
"in general".
It seems confusing to have two such similar statements, with
slightly different qualifications. It also seems odd to use
the normative term "SHOULD" in connection with an "in general".
So I propose changing the second paragraph cited above by removing
the first sentence, so that it reads simply:
If an application receives an unrecognized multipart subtype, the
application MUST treat it as being equivalent to "multipart/mixed".
-Jeff
I too find Jeffs wording to be an improvement, and don't believe that in
any way changes the intent (that is, I think that it is editorial).
