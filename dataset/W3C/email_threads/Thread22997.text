Where should I trundle off to in order to ask of the DOM implementations
community questions pertaining to how the "live" aspects of NodeLists are
dealt with? I realize that the DOM FAQ[1] has a section titled "NodeList
issues", and I have read that. It gives a top-level explanation of how
NodeLists should be viewed. Now what I want to know is how the
implementations are actually doing it. Someone pleasde point me to a
resource.
Thank you!
Christopher Watson
Sr. Software Engineer
Lightspan, Inc.
[1] http://www.w3.org/DOM/faq.html
It has been suggested that a common technique is to enable all NodeList
operations with the capacity to construct an updated list at any moment and
then have a "dirty flag" on the tree (or perhaps on each node) that would
indicate reconstruction is necessary.
I and at least one other person I know of punted on this. I would be very happy
to hear more about this as well because I don't fully understand the above
description myself.
The problem is that it assumes the action used to generate the original list can
be parameterised. For example, if the getElementsByTagName is used to create
the list, you could save this information and the name of the tag used to perform
the query. If the list is a simple list of children however, these parameters are not
required. Perhaps this is not what was intended at all however but instead that
the NodeList simply be patched as needed. When the dirty flag indicates that the
tree (or branch of) has been modified, each member will be examined and
compared to the main tree.
All of this applies to NamedNodeMap as well which is even more troubling
because the Map is not immutable.
Mike
In some implementations, that's going to be considered proprietary
information.
In others, you can not only ask how it's being done -- you can SEE how it's
being done. For example, the Apache Xerces project includes a DOM
implementation (actually, I think it now has at least two such
implementations)... and Xerces is open-source. There are others which will
let you examine their solution in detail.
I haven't rechecked the current implementation, but when I first wrote that
code for Xerces the NodeList was treated essentially as an
incrementally-built cache. The main DOM tree was provided with a way to
indicate that something within a node's subtree had changed -- you can
think of it as a "dirty bit", though in fact it was a counter -- and each
access to NodeList checked whether this had been altered since the last
NodeList request and if so flushed the cache and forced the NodeList to
recompute itself. If the document hadn't changed, this was fast; if it had,
it was slow but Did The Right Thing. Downside is that every document
mutation operation has to be instrumented to update the dirty flag.
If your DOM supports Level 2 Events, this would be another possible
approach. There's a problem with that solution, in that Level 2's mutation
events could be cancelled before they reached the NodeList's event handler,
DOM Level 3 is looking at adding a "listener group" mechanism so
cancellations only affect listeners within the same group; you could use an
informal prototype of that solution to bridge this gap.
I'm sure there are other solutions. Pick one that works for you. One thing
to watch out for: Remember to consider memory-management issues; some of
the alternative solutions we looked for Xerces at had a risk of leaking
objects.
Joe Kesselman / IBM Research
