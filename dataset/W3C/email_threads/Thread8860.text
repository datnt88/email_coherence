Some spelling errors I spotted:
signaute in 6.4.2
canonicalizationalgorithms in 6.5
sytnax in 7.2
It would probably be a good idea to go over the draft with a good spell
checker. Be nice if you could find one that ignores every word that
starts with "x". ;-)
A few other points: in the example in 4.4.4 there are three /X509Data
tags but only two X509Data s.
In 6.4.2 there is a description of how bignums are stored, but this
information is needed earlier, in 6.4.1 in order to store the P,Q,G,
etc. values for DSA keys.
Also, this text suggests making "an even number of bytes". Two problems,
first it is not really an "even" number in the sense of being divisible by
2, but rather an "integral" or "whole" number. Second, the word "byte"
could be better replaced by "octet". If you search the doc you find
a few other places where this substitution should be made (everywhere
except in reference to the byte order mark (BOM)).
Hal Finney
PGP Security
Noted and fixed!
I've done it a few times, but it is a harrowing process given all the
terminology and XML, and I expect/hope we're getting pretty low on typos
given all the eyeballs running over the spec.
Ok.
Yikes. I presume (one of the authors of this section might want to correct
me) that there are supposed to be 3 complete well formed X509 child elements
of KeyInfo (and that there is no nesting), so:
X509IssuerName CN=TAMURA Kent, OU=TRL, O=IBM,
L=Yamato-shi, ST=Kanagawa, C=JP /X509IssuerName
!-- Intermediate cert subject CN=arbolCA,OU=FVTO=IBM,C=US
issuer,CN=tootiseCA,OU=FVT,O=Bridgepoint,C=US --
Ok, we've been trying to use octet consistently (8 bits) since "byte" is
sometimes used to represent n-bit words... The instances where I see we
still used bytes (and are now changed include):
4.3.3.1 The URI Attribute
1. Each disallowed character is converted to [UTF-8] as one or more
/+octets+/.
2. Any octets corresponding to a disallowed character are escaped with the
URI escaping mechanism (that is, converted to %HH, where HH is the
hexadecimal notation of the octet value).
6.4.2 PKCS1
... The integer value is first converted to a "big endian" bitstring. The
bitstring is then padded with leading zero bits so that the total number of
bits == 0 mod 8 (so that there are /+whole+/ number of /+octets+/) If the
bitstring contains entire leading /+octets+/ that are zero, these are
removed (so the high-order /+octet+/ is always non-zero).
Joseph Reagle Jr.
W3C Policy Analyst mailto:reagle@w3.org
IETF/W3C XML-Signature Co-Chair http://www.w3.org/People/Reagle/
I ran the Unix spell program over the text version,
draft-ietf-xmldsig-core-10.txt. 99% of the output was bogus, but I
picked up the following misspelled words:
assurdby
contraints
idenitifier
Janaury
modulii
octect
signaute
sytnax
Hal Finney
PGP Security
Your responses to my two comments here seem to be interchanged. I just
wanted to make sure you noticed the part about the bignum description
in 6.4.2 needing to move up, perhaps to 6.4.
Hal Finney
Yes, sorry. I will take the single paragraph [1] and move it into the DSA
section and in the RSA section provide a backwards reference (e.g., "do the
same thing as stated in DSA").
[1] Arbitrary-length integers (e.g. "bignums" such as RSA moduli) are
represented in XML as octet strings. The integer value is first converted to
a "big endian" bitstring. The bitstring is then padded with leading zero
bits so that the total number of bits == 0 mod 8 (so that there are whole
number of octets). If the bitstring contains entire leading octets that are
zero, these are removed (so the high-order octet is always non-zero). This
octet string is then base64 [MIME] encoded. (The conversion from integer to
octet string is equivalent to IEEE 1363's I2OSP [1363] with minimal length).
Joseph Reagle Jr.
W3C Policy Analyst mailto:reagle@w3.org
IETF/W3C XML-Signature Co-Chair http://www.w3.org/People/Reagle/
