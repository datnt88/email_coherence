There seems to be a bunch of confusion about the role of KeyInfo clauses and
suppositions about particular environments in which XML-DSIG is expected to
operate. I'm combining responses to Peter and Carl here in the hope of
pulling things back together. Apologies in advance for the length.
Brian,
Sorry for the confusion. I misspoke in my email. I meant KeyValue,
not KeyInfo. KeyInfo is very valuable. KeyValue is a specific form of
KeyInfo. Mandating that the KeyValue type of KeyInfo is required to
implement is not good. That's because KeyValue is the "actual key(s) used to
validate the signature. If the key is sent in protected form, the MgmtData
element should be used."
So what I'm saying is that sending an unprotected key by using the
KeyValue mechanism does little good in a trust-management environment, such
as an X.509 or PKIX environment. I'm concerned that (A) by populating
KeyValue, I might encourage users to simply verify the signature based on
the contents of KeyValue without even attempting to validate my certificate
or certificate path, and (B) by making my implementation accept KeyValue, I
open myself up to accepting signatures that I shouldn't trust.
Since neither A or B is acceptable in a PKI environment, I would
rather just not bother with KeyValue at all. Thus we'd like to see it not be
a MUST implement.
--Peter
I think the problem here may stem from the wording Peter highlights and a
confusion of two separate operations: (1) cryptographic signature
validation, and (2) trust management determinations about a particular key
pair. These are two fundamentally separate concepts within XML-DSIG; we
explicitly separate the process of "verifying" that a digital signature is
well-formed (computationally correct) from determining whether to place any
trust in the key pair that performed the digital signature operation or the
semantic content of the properly-signed message. Our primary concern is
with step (1), so we care that conformant implementations always have a way
to communicate enough information to perform the cryptographic signature
check. That's why KeyValue support is required; it guarantees that two
XML-DSIG implementations have at least one method of communicating enough
information to cryptographically validate the signature.
Now, the wording quoted above from Section 4.4, that KeyValue contains the
"actual key(s) used to validate the signature," seems to imply that the
information in KeyValue *must* be used by the verifying application. This
was never the intent of anything contained within KeyInfo, so the language
in the draft clearly needs to be revised. There is no requirement that the
verifying implementation use the specific information contained within
KeyInfo in the actual signature validation, although (as in CMS) we expect
that for efficiency reasons implementations will likely try the included key
information first before hitting a database to look for other potential keys
to use to validate the signature.
Once the signature has checked out, trust management models come into play
(step (2)). Here XML-DSIG makes no statement about how individual
applications may choose to perform step (2), or even what information that
may use to make such determinations. We provide a place, KeyInfo, in which
applications may choose to communicate information that may be useful for
step (2), but again there's no requirement that that mechanism be used.
I agree with you that "sending an unprotected key by using the KeyValue
mechanism does little good in a trust-management environment;" but that's
not an issue here because we're not trying to convey trust to the trust
management engine via the KeyValue clause. As for your two other concerns:
I'm concerned that (A) by populating KeyValue, I might encourage
users to simply verify the signature based on the contents of KeyValue
without even attempting to validate my certificate or certificate path, and
This statement doesn't make sense because it combines steps (1) and (2),
which are explicitly separate. For performance reasons it's quite likely
that verifiers will try the provided key information first to satisfy step
(1). That doesn't help with step (2), though, and clearly implementers of
XML-DSIG must understand the difference between these two steps and what
information they get out of each of them. As an aside, I assume that your
use of "certificate or certificate path" is simply a stand-in for whatever
evidence your trust management engine chooses to accept.
(B) by making my implementation accept KeyValue, I open myself up to
accepting signatures that I shouldn't trust.
Again, this statement confuses signature validation from trust management
processing. Perhaps we need more explicit language in the draft calling out
the fundamental difference between the two.
Thanks to Brian's comments I understand now the idea is for KeyInfo
to serve as a "hint" and little/nothing more. However, I still fail to see
where KeyValue provides anything in the way of "base interoperability" where
a PKI application receives a key via KeyValue from a non-PKI application and
thus fail to see why KeyValue is required. It seems only to provide enough
interoperability for a non-PKI application to deliver a key that cannot be
validated to a PKI application.
I don't understand the distinction Carl's trying to draw here between "PKI"
and "non-PKI" applications. I believe there may be some confusion because
in PKIX applications keys are always delivered as part of the PKIX evidence
(i.e. PKIX certificates) used as input to PKIX trust management processors
(i.e. PKIX chain builders &amp; path validation logic). There is no assumption
in XML-DSIG that any particular trust management engine will use particular
forms of evidence that embed keys. PKIs, in the abstract sense, deal
primarily with making the trust management decisions that form step (2)
above. Since we cannot assume the existence of any particular form of PKI
in XML-DSIG, let alone one that always conveys keys inside trust management
evidence, XML-DSIG must provide the base interop for doing cryptographic
signature checks.
I hope this helps clear things up,
--bal
Armed with an understanding of the intent, which is, as you point out, not
apparent in the text, I think what you are saying is this: KeyValue provides
mathematical interoperability. This appears to be the gist of your comment:
"XML-DSIG must provide the base interop for doing cryptographic
signature checks."
If this is so how is your following statement true:
"there is no requirement that the verifying implementation use the
specific information contained within KeyInfo in the actual
signature validation."
What interoperability is achieved if I can populate KeyValue with anything
other than the "actual key(s) used to validate the signature?" Or do you
simply mean that I may use other means to retrieve the same keying material
for actual use?
Note that my distinction between PKI and non-PKI has nothing to do with
PKIX. I was simply stating that when given a raw key from a non-PKI
environment that a PKI app will fail to validate a signature generated using
that key because a satisfactory certification path cannot be built.
KeyValue does not change this fact. And apparently KeyValue is not intended
to do this. In any event, the parameters are superfluous and should rate a
minOccurs=0.
While the mathematical interoperability facilitated by KeyValue is important
I think the text describing it creates the illusion of a interoperability at
a higher level where there really isn't interoperability. By not addressing
specific trust management schemes, we cannot deny their existence nor the
fact that interoperability issues exist between them. Perhaps text changes
shall clarify the issue. I await the next draft.
-Carl
I've inlined my comments below, prefixed with [bal]...
Armed with an understanding of the intent, which is, as you point out, not
apparent in the text, I think what you are saying is this: KeyValue provides
mathematical interoperability. This appears to be the gist of your comment:
"XML-DSIG must provide the base interop for doing cryptographic
signature checks."
[bal] Correct. "Mathematical interop" is the process of cryptographically
validating the signature, and KeyValue helps with this.
If this is so how is your following statement true:
"there is no requirement that the verifying implementation use the
specific information contained within KeyInfo in the actual
signature validation."
What interoperability is achieved if I can populate KeyValue with anything
other than the "actual key(s) used to validate the signature?" Or do you
simply mean that I may use other means to retrieve the same keying material
for actual use?
[bal] Your second statement is accurate; conforming applications may use
other means to retrieve the same keying material. In fact, part of the
reason KeyInfo is OPTIONAL is that the precise key to use may be implied by
other means. One can easily envision protocols built on top of XML-DSIG
that would take advantage of this option.
Note that my distinction between PKI and non-PKI has nothing to do with
PKIX. I was simply stating that when given a raw key from a non-PKI
environment that a PKI app will fail to validate a signature generated using
that key because a satisfactory certification path cannot be built.
[bal] Can you help me understand why these two sentences are not
contradictory? Your second sentence implies that signature validation is
dependent on making a particular trust management decision about the key,
and further that the trust management decision requires building a chain of
certificates with some particular property. Certificates, chain building,
and qualifying signature validation in this way are not fundamental to PKIs
in general, although they are properties of PKIX in particular.
KeyValue does not change this fact. And apparently KeyValue is not intended
to do this. In any event, the parameters are superfluous and should rate a
minOccurs=0.
[bal] This last statement is false. If you don't include the DSA parameters
then you have not fully qualified the key; without knowing the group
parameters how can you mathematically validate the signature using the
remaining info? Remember that the parameters are not included anywhere in
the SignatureValue element.
While the mathematical interoperability facilitated by KeyValue is important
I think the text describing it creates the illusion of a interoperability at
a higher level where there really isn't interoperability. By not addressing
specific trust management schemes, we cannot deny their existence nor the
fact that interoperability issues exist between them. Perhaps text changes
shall clarify the issue. I await the next draft.
-Carl
[bal] Ah, I understand now, you are expecting from XML-DSIG statements on
items that are specifically beyond its charter (see the Constraints
subsection under Scope in http://www.w3.org/Signature/charter-20000105.html,
and Design Principles &amp; Scope items 3.1 and 3.2 in
please identify what text in the draft led you to this expectation? It
needs to be cleaned up.
--bal
My comments are inline and I've snipped away a great deal of text.
by
This is the core of my initial question. KeyInfo is OPTIONAL. Why require
those wishing to use a form of KeyInfo to implement KeyValue? The fact that
it is optional undermines "base interoperability". The fact that KeyValue
may be protected may further undermine base interop.
using
of
PKIs
I think we are arguing the semantics of the terms "validation" and
"verification". Let's not.
intended
a
parameters
This depends on your point of view. If you accept that the parameters
should never be used directly from the message without outside confirmation,
due to parameter substitution, then it is logical to think that the
parameters could simply be obtained from the outside source and need not be
present in the message. Having them there invites misuse. Some verbage may
clarify this issue, but minOccurs=0 would permit implementations to avoid
including them where unnecessary just to claim "compliance".
Perhaps an explicit statement of the intent of KeyValue. Perhaps some
elaboration/example of MgmtData and its relationship with KeyValue. Perhaps
watch the use of the term validate which is used to describe both KeyValue
and X509Data since it has different meaning in each location. Perhaps use
verify instead when discussing KeyValue.
Lost is this has been the question whether or not the DTD/Schema is
sufficient to support stated usage of KeyInfo.
-Carl
Carl:
I understand that you don't want to implement KeyValue. The fact that
KeyInfo is OPTIONAL and KeyValue is the one subclause of KeyInfo that is
mandatory-to-implement. This is consistent with other IETF RFCs. The idea
here is that if you DO include KeyInfo, then there must be a
mandatory-to-implement form. Do you have a suggested alternative for
KeyValue that is semantically neutral?
I agree that we need some explanatory text on DSA parameters, but the
parameters cannot be omitted from KeyValue for cryptographic reasons
discussed previously. There is no scenario using KeyValue in which the
parameters can be left out.
In terms of your issue with schema, I don't understand that. Maybe you would
also like to include an example of what you think needs to change.
--Barbara
My comments are inline and I've snipped away a great deal of text.
by
This is the core of my initial question. KeyInfo is OPTIONAL. Why require
those wishing to use a form of KeyInfo to implement KeyValue? The fact that
it is optional undermines "base interoperability". The fact that KeyValue
may be protected may further undermine base interop.
using
of
PKIs
I think we are arguing the semantics of the terms "validation" and
"verification". Let's not.
intended
a
parameters
This depends on your point of view. If you accept that the parameters
should never be used directly from the message without outside confirmation,
due to parameter substitution, then it is logical to think that the
parameters could simply be obtained from the outside source and need not be
present in the message. Having them there invites misuse. Some verbage may
clarify this issue, but minOccurs=0 would permit implementations to avoid
including them where unnecessary just to claim "compliance".
Perhaps an explicit statement of the intent of KeyValue. Perhaps some
elaboration/example of MgmtData and its relationship with KeyValue. Perhaps
watch the use of the term validate which is used to describe both KeyValue
and X509Data since it has different meaning in each location. Perhaps use
verify instead when discussing KeyValue.
Lost is this has been the question whether or not the DTD/Schema is
sufficient to support stated usage of KeyInfo.
-Carl
