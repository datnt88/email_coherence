OK, here are the reasons why I cannot live with S, in no particular
order:
1. Local and global idioms are not compatable in the same knowledge base
without having to resort to a duality of ontolgies, one for local idiom
and one for global idiom. Cohabitatino of local and global idioms
is IMO not just a desiderada, but a requirement.
2. Allows definition of alternate notations in lexical forms (e.g. octal)
which are not supported by the actual datatype. I consider this to
violate the precision of the datatype definition and a bug. It also
means that there are two means to subclass a lexical datatype, either
by reference to a new, subordinate datatype or by localized definition
of (unsupported) lexical notations. TDL has only one single means of
doing so, which respects the boundaries of definition of the datatype
creator. With S, applications (and users) must know not only datatypes
but ontologies of notational variant properties (octal, decimal, inKg,
inOz, etc.) rather than, as with TDL, just datatypes.
3. Requires four (4) URIs for each datatype rather than just one. How
can we ask every authority that has already defined datatypes and given
them URI identity to now go back and mint three more URIs so that RDF
can use them?! TDL has already shown that one URI is sufficient.
4. Requires users to understand the MT to understand which URI
variant to use in which idiom (*.lex, *.map, *.val, or *) rather
than addressing such distinctions in the MT alone, as TDL does.
TDL allows you to talk about those different components, but it
does not require you to do so simply to denote the type of a
literal so that some application knows which value it corresponds
to.
5. Requires additional clarification regarding semantics and use
of rdfs:subPropertyOf relation between properties which convey
datatyping.
6. Use of rdfs:subPropertyOf relation between datatyping property
and non-datatyping property is valid in the absence of domain
constraints but not valid if domain constraints defined.
E.g.
#Bob ex:age "30" .
foo:integer rdfs:range xsd:integer.lex .
ex:age rdfs:subPropertyOf foo:integer .
implies that "30" is a member of the lexical space of
xsd:integer, and this is correct and (even arguably)
intuitive and efficient, avoiding the need for
an anonymous node idiom.
But with the additional constraint
foo:integer rdfs:domain xsd:integer.val .
which is valid for idioms using anonymous nodes, e.g.
#Sue ex:age _:1 .
_:1 foo:integer "30" .
where _:1 is then inferred to denote a member of
the value space of xsd:integer, it also means that,
when these two graphs are merged, #Bob, from the
example above is *also* inferred to be a member of
the value space of xsd:integer, and thus a perfectly
valid use becomes an invalid use.
7. Provides no additional expressive power over TDL
yet requires significantly more machinery and deeper
understanding of the model by users, and is not as
compatable with current idioms as is TDL. Per Occam's
razor, TDL is the simpler and better choice.
8. The S model, particularly literal labeled nodes
participating in graph tidying, precludes any later
adoption of a P+ treatment, which is a more ideal
local idiom than D given the consistency of representation
of local and global typing in the graph; I.e. with P+
the literal object node is not shifted to an anonymous
node as with D, it just stays where it is and the local
type is specified for the literal node directly
via rdf:type -- elegant, efficient, and worth keeping
as a desirable future option. S would prevent this
option forever.
In short, S is too complex, too different from present
usage, able to result in conflicting knowledge on
merge that is valid separately, and too burdensome
from the practical point of URI management to be
acceptable.
If S were the only option, I'd still not choose to
use it. I'd look for some other KR solution that dealt
with datatyping in a more economical and user friendly
manner. But since there is another option, TDL, which
has none of the above faults yet meets all of the
specified desiderada, the choice for TDL is obvious.
Gasp, horror! maybe compromise is possible :)
S-A and S-P can live with a single URI. In [1], different URIs were
introduced for clarity, so that a precise distinction can be made
whether lexical spaces, value spaces, or mappings are used for typing in
a given idiom.
(First sign of movement on either protagonist's part).
Jeremy
Sergey:
As a developer, I don't have an option. With TDL-RDF, all of my own
applications in mediation, model management, backend storage etc. would
technically become non-RDF applications, or applications "formally known
as complying with the deprecated RDF 1.0" ;) I don't see any practical
benefit in migrating all existing code to TDL, and I might not be a
single implementor out there.
I would like to better understand this.
The intent in the TDL model theory was that an interpretation with no
supported types was the same as the current model theory. I suspect this
boils down to the tidy versus untidy literal nodes issue.
Tidiness had already vanished from the latest editors draft of the model
theory, which is the one I was working from.
Is that right?
Jeremy
Proposal S [1] suggests three idioms to choose from. In S-A and S-P,
global and local typing can merrily coexist, so I don't see why the
above counts as an cannot-live-with argument. S does not mandate that
all three idioms are required to be accepted for use simultaneously by
the same application.
Of course, each limitation can be twisted so that is looks like a
feature. I believe, it is much easier to arrive at a stable definition
of say integers (which has remained the same for centuries) than to find
an appropriate lexical representation (roman/arabic, decimal/octal
etc.). I see great value in being able to migrate to new encodings
gracefully, without breaking the existing applications. In TDL, you'd
have to use different formats for old and new systems. This is the same
as saving your text document with MS Word 2000 and not being able to
read it with MS Word 95. That's a horror scenario.
S-A and S-P can live with a single URI. In [1], different URIs were
introduced for clarity, so that a precise distinction can be made
whether lexical spaces, value spaces, or mappings are used for typing in
a given idiom.
Same as reply for (3).
This is untrue. Semantics of rdfs:subPropertyOf remains exactly as
defined in the model theory draft.
What a discovery! If you happen to believe that cats are dogs you can
hardly expect consistency. The use that you suggested above is simply
incorrect...
That sounds more like a plug rather than an argument. I think it has
been made sufficiently clear over the past several month, which of the
proposals requires "significantly more machinery and deeper
understanding of the model by users" ;)
Talking about esthetics, what about this: in TDL, if you write
_1 rdf:value "bla"
then _1 and "bla" denote exactly the same thing. Do you consider this
elegant?
Another plug... What about this: "In short, TDL is too complex, breaks
most existing applications, APIs, querying, storage, ..."? ;)
As a developer, I don't have an option. With TDL-RDF, all of my own
applications in mediation, model management, backend storage etc. would
technically become non-RDF applications, or applications "formally known
as complying with the deprecated RDF 1.0" ;) I don't see any practical
benefit in migrating all existing code to TDL, and I might not be a
single implementor out there.
To reiterate, I have nothing against the rdf:type/rdf:value idiom used
by TDL. In fact, I find it not bad at all, and it works perfectly fine
within the framework of the current model theory as illustrated by idiom
P in [1]. However, I strongly object against adopting untidy literals.
-- Sergey
[1] http://www-db.stanford.edu/~melnik/rdf/datatyping/
Right, I tried to illustrate this point in
I'm assuming you are referring to
There, in Appendix A, Subsec 1, tidyness is defined in condition 3 for
both urirefs and literals. The comment "graph is tidy on uriref nodes"
should in fact say "... tidy on uriref and literal nodes", since label()
is used both for uri nodes and literal nodes - unless Pat had something
else in mind? Pat, did you?
Sergey
Jeremy:
Sergey:
l_Theory.htm
I was referring to that version (dec 14 draft)
Near the beginning it says
"Notice that disjoint graphs do not have any blank nodes in common, by
definition, and that each separate occurrence of a literal is considered a
separate node (in contrast to urirefs); we will therefore distinguish
between literals and literal nodes."
I think there are some editorial issues that have left confusion.
Sergey, wanting tidiness, read tidiness.
Jeremy, wanting untidiness, read untidiness.
I think the document probably allows both readings.
Jeremy
PS You should see my cube, it might explain some things about untidiness.
Sergey,
If TDL supports tidy literals (which it does, though the MT will need
adjustment) does this address your concerns about compatability with
your present applications?
A TDL with tidy literals allows (I belive) for Dan's "redhead"
example where the datatyping for a given property is implicit in
the RDF and kept consistent as a characteristic of the application
environment (i.e. everybody agrees that 'hairColor' is a value
from some enumeration "red", "blue", "green", etc. and the
reliability of the axiom inferring redheadedness relies on
conformance to that implicit datatyping).
Eh?
Patrick
But this precludes arbitrary and unrestricted syndication of
knowledge from disparate sources which may use different idioms.
From the perspective of a single, tightly controlled application
environment, it appears a reasonable restriction. From the perspective
of a global semantic web of knowlege, it is not acceptable.
I don't quite follow your argument. Can you give an example of "old" and
"new" formats?
If the lexical space for xsd:integer is defined to be based on decimal
notation, then I hardly see how it is reasonable to expect applications
to support octal notation. An application supports standards, as and
insofar as those standards are defined, and the definition of xsd:integer
says nothing about octal or any other non-decimal notation. The S
approach would allow knowledge to be expressed in a non-standard manner.
If you need/want a way to express integer values in octal, then
define a new datatype, and if you want values of that new datatype to
also be treated as members of the value space of xsd:integer, then
define a relationship between your new datatype and xsd:integer which
reflects such a relationship.
But if an application supports xsd:integer, it should not be getting
values in octal notation and be expected to achieve a correct
interpretation of them.
Fair enough, though the definition of S does not suggest that.
But if S can be revised so that only one URI per datatype is required,
then certainly this specific objection is no longer valid.
Same as reply to reply for (3) ;-)
I've detailed my concerns on this point numerous times. It has
nothing to do with the semantics of rdfs:subPropertyOf being
different, but rather having to clarify for users the
implications for relating properties which may involve datatyping
semantics.
It is not incorrect, though perhaps you have misunderstood it.
Right, S does, so then we agree ;-)
They do not denote the same thing. Precisely where do
you get that? It may be that you do not actually understand
TDL?
In the above example, _1 denotes (if anything) a member
of the value space of a datatype, and "bla" (in the
context of a given datatype) denotes a lexical form,
a member of the lexical space of that datatype.
Are you saying that a member of the lexical space
and a member of the value space are the same thing?
Though, per my recent discussion of TDL with tidy literals,
I would say that it is reasonable to presume that isofar
as the graph is concerned, _1 is simply an object node
and "bla" is simply a literal, and depending on other
characteristics of the graph, may participation in an
interpretation which will treat "bla" as a lexical form
for some datatype.
TDL (the model, not necessarily the MT) is very simple and elegant,
and does not break any existing applications.
Furthermore, the argument that TDL with non-tidy literals breaks
existing applications seems to presume that those applications are
testing for literal node equality rather than string equality
of literal node labels -- a claim which I find *very* hard to
believe.
Can you clarify: do these applications make their equality tests
by actual node identity or by checking if two property values
have the same string equality? If the latter, then I would assert
that TDL, even with non-tidy literals, does not break any such
application.
I really don't believe that this would be the case. I think that
there has been a misunderstanding about what TDL is actually
requiring, or what perhaps such applications are expecting in
the RDF graph.
Still, even if your applications are doing tests for tidy literal
node equality rather than string equality, TDL works fine with
tidy literals (though the MT needs adjustment, perhaps, to
support that).
So, I still don't see any clear evidence that TDL breaks
your existing implementations.
No problem. TDL works fine with tidy literals. Whether or not
literals are tidy or untidy is irrelevant insofar as the TDL
model is concerned (though, again, the present MT may need to
be tweaked).
Have a close look at my recent posting
and please reconsider if TDL really breaks your applications.
Patrick
And the TDL model, being based on labels and not nodes, supports
either case.
So, perhaps all that is needed in order to address Sergey's and
Dan's (and others) concerns about tidiness, is to revise the
TDL MT to reflect the label-based axiomatic qualities of
interpretation defined by TDL.
Eh?
Patrick
Sorry this reply is late.
The latest version of the MT has this paragraph, which I hope will be
unambiguous:
To describe RDF graphs it is first necessary to define the things
that can act as nodes and arcs of the graph. There are three kinds of node in
any RDF graph: urirefs, literal nodes, and blank nodes. A
i uriref /i is defined
to be a URI reference in the sense of a href="#bib_uri" [RFC
2396] /a . span class="newer" We
do not distinguish between urirefs and uriref nodes because urirefs
are considered
to be nodes in themselves /span . A literal node is a particular
of a literal; and blank (or unlabeled) nodes are considered to be drawn from
some set of 'anonymous' entities which have no 'label' and are unique to the
graph. Finally, every arc in an RDF graph is labelled with a uriref. The same
uriref may label several arcs and also be a node in the graph. An RDF graph
can then be defined as a set of triples of the form S, P, O, where P
is a uriref, S is either a uriref or a blank node, and O is either a uriref,
a blank node, or a literal. Note that a given uriref may occur in more than
one graph, but blank nodes and literal nodes are unique to each graph. This
reflects the fact that urirefs are considered to have a 'global'
meaning span class="newer"
but blank nodes and literals do not: blank nodes because they are
local to the
graph, and literals because each occurrence of a literal is considered to be
unique. (This may be a href="#litdisclaim" altered in future /a ; at present
it is the most conservative assumption for the model theory to
make, since some
datatyping schemes may assign different interpretations to several
occurrences
of the same literal.) /span
Pat
IHMC(850)434 8903 home
40 South Alcaniz St.(850)202 4416 office
phayes@ai.uwf.edu
