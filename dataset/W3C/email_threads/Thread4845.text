== Use Case Name
Federated query
== Intent: Task &amp; Roles
Actor/User Agent needs to seamlessly query/access/integrate related
chunks/pieces of data coming from a set of decentralized heterogeneous
sources, and get presented an unified view over a the whole
result-set/data-set.
== Key Benefits / Value
Most of existing DBMS query systems are mostly centralized or subsumes
some kind of central authority/control (and constraints) over their
whole database architecture. What is needed over the Web is a system
that allows fully federated queries over a bunch of distributed and
heterogeneous sources/services/tables. Each source must be fully
decoupled from the others; and must be able to retain its own workflow,
schema and control/authority over its data. Each source only needs to
be interfaced to the data federation through some kind of "proxy
service" which allows to map its native data format or query-language
to a common query/data format; and map results back and forth as
requested. In other words, with a single query statement, the user can
access and join tables located across multiple data sources without
needing to know the source location.
== Description
The Web itself a good example of a federated system, providing dynamic
direct and easy access to several different and heterogeneous
information sources; search engines, image galleries, online travel
agencies, online newspapers, online shops (e.g. Amazon [1]) are
examples. Everybody can easily contribute to the Web by simply writing
a piece of HTML and then publish it to a specific URI location. Links
between similar pages can be easily set up without requiring any kind
of centralized control and requiring few "integrity constraints" but
naming "things" in a specific way; images can be as well be inlined
inside pages by simply pin-pointing to their location URI. Then a
specific Web browser application will take care of aggregating and
assembling the hypertext in a unified view over a bunch of physically
decentralized pages and related images.
Similarly most of the dynamic data available into DBMS systems is
available on the Web. Unfortunately while doing so most of the
semantics of the original database fields/tables is lost and most of
the DBMS usage benefits are somehow lost too [2]. Generally only a
limited set of search operations is made available to the end user a
part plain free-text search. Web services are trying to overcome this
problem with a more general XML based solution, by providing the user
ad-hoc designed API to go beyond simple HTML human-interpretion. On the
other side, such a technology did not proof to be general and flexible
enough to solve most of the database federation problems yet. And this
approach is suited but limited to a closed/vertical application
domains.
Differently, RDF provides a more general and powerful framework built
on the Web for the Web - it is expected that people will start to
annotate their pages/services with RDF descriptions allowing a third
part application to transparently query/aggregate Web resources.
Despite such a large set of solutions available to the user today, what
is needed is a real federated query system which spawn several virtual
database tables/resources/services.
The query system must provide a user-friendly syntax and a standard
API/protocol to express query statements over one or more distributed
data sources - data sources might be Web pages, XML documents, DBMS,
ad-hoc Web Services or any RDF metadata source. Each source might
interface to the query federation system in many different ways [3-12].
The query processing engine then has to split up the input query in
several different sub-queries, to be run on each system, apply the
constraints, join the results back and return to the user. Each result
will then have to retain its full provenance/source information to
allow the user to pose more queries in a second time eventually. In the
easiest and most general case the query system will be simply provide a
way to SELECT a certain number of fields/tables. Full DML functionality
will be better tackled in the original sources using existing DBMS
tools. If any of the sub-queries can not be run or fails to join in the
main query, an empty result set is returned to the user.
== Other
=== Notes
This use cases subsumes some extensive/systematic query optimization,
caching and other important technical/technological aspects not
considered here. As well as the need to globally uniquely identify/name
concepts/objects/relations and tables to make the model really fully
federated (e.g. definition of a URI/URN scheme and resolution
protocol). In relation to the DAWG work we are only/mostly interested
to the data access/query syntax/protocol more than the
technical/architectural choices which an system designer/implementor
would need to consider/stick-to.
=== Applicability/Scale
Real-time data, Legacy data/services, External services
=== Related systems/cases
RDF Access to Relational Databases -
== References
[1] http://www.amazon.com
[2]
darm.html
[3] http://rdfweb.org/2002/02/java/squish2sql/intro.html
[4] http://www.wiwiss.fu-berlin.de/suhl/bizer/d2rmap/D2Rmap.htm
[5] http://kaon.semanticweb.org/alphaworld/reverse/view
[6] http://www.w3.org/2000/10/swap/dbork/dbview.py
[7] http://www.openlinksw.com/virtuoso/
[8] http://www.picdiary.com/triplequerying/
[9] http://iconocla.st/~sderle/squish.pl
[10]
[11] http://www.w3.org/2002/02/21-WSDL-RDF-mapping/
[12] http://www.w3.org/DesignIssues/RDB-RDF.html
While this is an important, and needed, application, this seems out of
scope
to me.
Some particular service could provide a DAWG conformant interface to a
virtual
knowledge store which constitutes a federation of heterogenous
knowledge from
a broad range of disparate repositories -- but a DAWG agent should not
be concerned
with, or even be aware of, such federation.
Such a service would be very useful, and I expect it to be done often,
but it
has IMO no affect on how queries are expressed and submitted to
services for
resolution.
The same goes for any form of distributed query.
(or have I missed something more fundamental, Alberto, in your test
case?)
Patrick
Patrick Stickler
Nokia, Finland
patrick.stickler@nokia.com
(with alberto technical mode on :)
good point - but this would only be yet another specialized system,
where your "DAWG conformant service" would kind of centralize the query
functionality again, and it would need to provide a sort of "brokering
service" to a specific broad range of repositories. And this is not
exactly how the Web works to me - but basically yet another centralized
SQL/DBMS query system, where the client is requested to ask to a
specific service specific questions, while not the other way around.
What about if in your case that "DAWG service" is down or not
accessible? Is the query failing or the client has to piggy back to
some alternative/spare service/solution?
Shouldn't the client instead be able to ask specific questions to
specific distributed repositories directly?
i.e. what I have in mind is a kind of HTML for data
then you would need a DAWG aware client to interpret such a mark-up and
doing the querying/aggregation job for you - ideally, like HTML pages
(HTTP and the Web) allow today to seamlessly inline pictures in one
unified view, there might be new Web browsers/clients/applications
which might do the same for data.
For example, imagine an HTML TABLE aggregating pieces of information
taken from a bunch of URIs - perhaps using some XPath/XPointer to the
the end of them to pin-point to specific nodes/values :)
Er. the same would apply to only a kind distributed query systems,
which you can control/interface to the federation and wrap around a
"centralized" DAWG service. What I meant is more general...
my only concern in the AR-2 use-case was to start to consider the
possibility that DAWG queries might effectively spawn over the Web -
and then we might need some little syntactic sugar to express such a
federation bits into the query.
(just to try to make you understanding what I meant)
E.g. in an hypothetical extended RDQL syntax (almost playing here in
the example) i.e. "get me all items titles and they geo-position" -
where RSS items and their locations are sitting in two separated
sources
SELECT
?item ?title ?lat ?long
FROM
WHERE
( ?db1 dc:source file://my-rss-feeds.rdf ) // local RDF/XML source
( ?item rdf:type rss:item ?db1 )
( ?item dc:title ?title ?db1 )
( ?db2 dc:source jdbc:postgresql://www.foo.com:5555/lat-long ) //
remote SQL database
( ?item geo:lat ?lat ?db2)
( ?item geo:long ?long ?db2)
I hope it is clearer now...
cheers
Alberto
It is clearer. Your example above also relates to ongoing work on named
graphs that I find very interesting. However, I think that such issues
are out of scope for DAWG for two reasons:
1. It really is an implementational detail how one service might
provide a unified point of access to a federation of other services,
and I don't think it is a sufficiently acute need in the general
community to consume WG time to innovate a solution.
2. I believe that whatever solution DAWG recommends, it should be
in sync with the new RDF specs -- and so adding support for
named graphs seems too significant an extension for this first round.
Of course, that's just my personal opinion, and the rest of the WG
may disagree (certainly won't be a first ;-)
Cheers,
Patrick
Patrick Stickler
Nokia, Finland
patrick.stickler@nokia.com
I'm not sure I've completely absorbed this use case, and it does
seem like a stretch... but there
does seem to be something novel to it: it motivates interoperability.
In many of the use cases, it's not evident why we need lots
of services to work the same way: as long as a particular
client and server agree, they're happy. This case
relies, pretty clearly, on lots of interoperable services.
I'd like to see it presented in "once upon a time..." story format,
with more connection to less technical concepts (shopping,
health care, ...).
Dan Connolly, W3C http://www.w3.org/People/Connolly/
see you at the WWW2004 in NY 17-22 May?
I agree that "Federated query" requirements are beyond what a query
language is expected to provide, however just because a particular
application won't be specifically addressed by a recommendation does not
mean the use case can be ignored.
Most naively, you could assume that such a federated knowledge base is
really just translated to a very large collection of RDF. So call that
collection task a part of the non-query application, and a spec which
lets you query the resultant RDF is the part of the use case the DAWG
rec. address.
However, I think it's important that we keep in mind that this is not
necessarily how applications will be architected. Actually gathering all
that RDF into one place may be impractical or impossible. It might be
more reasonable to break a query into smaller pieces and send each of
them to different data source, coordinating only the way the results are
collated together.
To me, this use case brings up the point that there's a real use case
for "large" queries, instead of requiring user combination of many small
queries. If SQL allowed only querying of single tables, requiring users
to perform their own joins (even if result formats made such joins easy
to program), then it would be impossible to perform the kind of back-end
optimization that makes relational database so useful.
From: Patrick Stickler [mailto:patrick.stickler@nokia.com]
Sent: 18 March 2004 00:03
Subject: Re: Use case: AR-2: "Federated query"
yep that's the idea - while assuming the minimum common denominator
between different parties, where each other it is keeping its autonomy,
without requiring it to change its workflow significantly for the sake
of interoperability.
later I could try to formulate the use-case using some better
real-world marketing terminology - also PS-17 ("Opacity of Content
Management Infrastructure") is somehow related to this one
cheers
Alberto
a bit of fairy tale wrapped around the federated query ideal...
Joe Lamda (SP? is it like the greek letter?) wonders what entertainers
had top 10 movies and films.
Scenario 1 Joe Lamda is a geek:
Joe lamda knows that his data will come from IMDB and CDDB and
writes a query appropriately:
QL requirements: local "unification" if different data sources, query targeting
ask http://imdb.com/rdf (
?film :rating ?r {?r = 10}.
?actron :staredIn ?film )
ask http://cddb.com/rdf (
?tune :rating ?r {?r = 10}.
?tune :performer ?actron )
collect (?actron)
Apologies for presuming familiartiy with the algae syntax. It had the
level of expressivity I needed.
Scenario 1 Joe Lamda's query agent is clever:
Joe lamda writes the "intuitive" query and the agent handles federation:
QL requirements: local "unification" if different data sources
ask http://localhost/myAgent (
?film :rating ?r {?r = 10}.
?actron :staredIn ?film.
?tune :rating ?r {?r = 10}.
?tune :performer ?actron )
collect (?actron)
Then the agent splits this into the two queries listed above, does the
unification, and dutifully reports the results back to Joe Lamda in a
nice tabular fashion.
-eric
office: +81.466.49.1170 W3C, Keio Research Institute at SFC,
Shonan Fujisawa Campus, Keio University,
5322 Endo, Fujisawa, Kanagawa 252-8520
JAPAN
cell: +1.857.222.5741 (does not work in Asia)
(eric@w3.org)
Feel free to forward this message to any list for any purpose other than
email address distribution.
