As an implementor of XPath 2.0,I found that it's
difficult to determind the size of context sequence in
an efficient way.Fox example, we want to get the last
node of a sequence:
'/e1[predicate1]/e2[predicate2]/e3[predicate3]/e4[fn:last()]',if
the resulting sequence is very long(e.g. 1,000,000
nodes) and the data is stored in a file,in the worst
case,we'll have to use 1,000,000 IO operations to get
the value of fn:last() and another 1,000,000 IO
operations to iterate to the last node.Note that it is
difficult to optimize the query if the last predicate
combine fn:last() with other functions(e.g.
'[fn:last() - fn:position()  10 ]').
So although fn:last() has provided a more powerful way
to manipulate xml data,it has also introduced danger
into XPath: Implementors have to choose a worse way to
meet the specification and the implementation is
limited to operate on small xml data.
In fact,fn:last() is frequently used to locate the
last item of a sequence,and other case is rare.So a
better solution is to let fn:last() return a boolean:
true if the current item is the last member of a
sequence,and false if it is not.Now fn:last() function
like an EOF marker of a file stream: You won't know
the size of a file until you reach the EOF,but you can
elect to count it during the iteration.And now
fn:last() can be used to operate on a xml stream from
the network on the fly: We don't need to wait for the
whole xml stream to get the value of fn:last().
Do You Yahoo!?
Yes, last() is tricky to implement. But this language is designed for users,
not for implementors. For you as an implementor the challenge is to find
ways of implementing it efficiently.
last() is present in XPath 1.0, and largely unchanged in 2.0. Note:
(a) there have been many successful (and fast) XPath 1.0 implementations
(b) we can't change something that is so widely used.
So the strategy is clear: optimize the case that is frequently used. In the
path expression above, given an appropriate data structure, you should be
able to find the last e4 element without touching any of the others. (For
example, you could have in internal "reverse child" axis and turn E[last()]
into reverse-child::E[1].)
In publishing applications, of course, last() is needed for numbering: "page
1 of N".
Michael Kay
Although it's true that last() has significant performance implications,
consider even simple XPaths like /a/b[/a/c] or /a[b = /a/c]. Because you
can express cross-products, XPath queries can easily be O(N^2) or worse
unless you use indexing techniques (as Michael Kay replied)
If the data is stored in a file, then you need to parse the entire file
anyway to ensure that it's valid XML and to ensure that you've found all
matching nodes.
However, this particular query (if the elided predicates don't get in the
way) shouldn't require processing the file twice. Just remember the last
matching e4 element within each matching e3, and when the e3 close is
reached, emit the last e4 you remembered. In general, predicates of the
form [last()] (and possibly [last() - k] for constant k) should be
optimized.
Obviously there are plenty of other queries, like
//a[last()  position() * b]
that will perform badly in most implementations no matter what kinds of
performance optimizations you make. That's just the nature of the game.
Cheers,
Michael Brundage
xquery@comcast.net
Author, XQuery: The XML Query Language (Addison-Wesley, 2004)
Co-author, Professional XML Databases (Wrox Press, 2000)
wrongly.Now I learn that massimo has a very high work
load,so please don't reply my message to
'massimo@w3.org' again.
Although it's true that last() has significant
'/e1[predicate1]/e2[predicate2]/e3[predicate3]/e4[fn:last()]',if
My implementation is for xdb purpose,and in many
cases,the resulting sequence will be very large.An xml
file is stored in a native format and is pre-validated
before it is stored.
I have misunderstood the scope of the axis.Now I've
learned that it is just relative to the context item:
'/e1/e2[last()]' is to get the last 'e2' item for
*each* 'e1',not the last 'e2' item for *all* 'e1'.(May
be the WG should add an explicit statement about
this?)It seems it's easier to implement than I have
thought.
As Michael Kay said,the XQuery is designed for
users,not for implementators,so it is the
implementor's challenge to find an effective way to
process the query.Maybe this is a good news to the
users,and maybe not: Now a user may need to know more
details about an implementation to make clear what
predicate can be optimized (like '[last()-1024]') and
what predicate can not (like '[last()-1025]' and
'[last()  position() * b]').
At last,I suggest to add a function 'fn:islast()
boolean' which returns true if the current item is the
last item,or false if not.
Do You Yahoo!?
