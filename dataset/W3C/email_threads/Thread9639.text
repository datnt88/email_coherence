Brian asked me (for the Xth time, sigh) to express my concerns about
reification in writing. My position remains that we need an
interoperable and efficient way of doing reification.
If we go for "stating" (answer "No" to Q1 in [1]), no special semantics
is associated with the vocabulary rdf:Statement, rdf:subject,
rdf:predicate and rdf:object. This means applications *cannot
interoperate* using this vocabulary since its meaning is unspecified.
Effectively, going for "stating" amounts to deprecating 4-triple
reification as used today.
If we go for "statement" (answer "Yes" to Q1 in [1]), we get a (rather
painful, admittedly, but endorsed) way of referring to statements found
on Web pages and in RDF databases, recording provenance etc. This is IMO
much more concrete and useful that just providing no definition at all,
although the usability of 4-triple reification still remains seriosly
hampered by its verbosity.
In summary, if we go for "stating" we have *no* official mechanism for
reification. In this case we'd have to suggest an alternative, we cannot
just wash our hands. It is an illusion that we can leave the vocabulary
undefined and at the same time recommend developers to use it in a
consistent way. If we go for "statement" we do have a solution, albeit a
poor one. If we run out of time in finding an alternative *efficient*
way of doing reification, we could of course fall back on "statement"
expressed using 4 triples. In this case, we would not have achieved much
since inefficiency proved to be a show stopper for using 4-triple
reification in the past 3 years.
Sergey
[1] http://lists.w3.org/Archives/Public/w3c-rdfcore-wg/2002Feb/0359.html
Although many of the points that are going to be made in the ensuing
thread on this will have been made before (maybe even X times!), perhaps
we have a different perspective on some of them this time around.
Anyway, let me take a crack (hoping I'm not going to restate some heresy
we've already recanted...)
I agree with the last sentence.
The problem is that I don't believe this is exactly right. There are a
number of things involved here. And verbosity isn't the main issue.
1. The things found on Web pages and in RDF databases are *instances*
of statements, otherwise known (?) as "statings". When I express
provenance (at least a lot of the time), I want to talk about a
particular instance in a particular place, not the single abstract thing
determined by a given (subject, predicate, object) triple. I must, for
example, be able to say "fred wrote s,p,o at location X, at time T1",
and "mary wrote s,p,o at location Y, at time T2" and have those be
distinct things, and not thereby intermingle X, Y, T1, and T2. For
example, does:
stmt1 rdf:type rdf:Statement .
stmt1 rdf:subject aSubject .
stmt1 rdf:predicate aPredicate .
stmt1 rdf:object anObject .
stmt1 ex:writtenby fred .
stmt1 ex:atTime T1 .
stmt2 rdf:type rdf:Statement .
stmt2 rdf:subject aSubject .
stmt2 rdf:predicate aPredicate .
stmt2 rdf:object anObject .
stmt2 ex:writtenby mary .
stmt2 ex:atTime T2 .
entail:
stmt2 ex:writtenby fred .
stmt2 ex:atTime T1 .
I think the answer has to be "NO" if you want provenance in general to
work, because otherwise you can't even suggest that there are two
different instances involved. [Depending on what you read into the fact
that there are separate stmt1 and stmt2 ].
2. In the example above, stmt1 and stmt2 were newly-minted URIs
defined as part of the process of reifying the two original occurrences
of what fred and mary said. That is, in the M&amp;S reification examples,
it's assumed that you can't directly identify the statement you want to
express provenance information about; instead you have to create a new
URI, and then use the reification vocabulary to describe the subject,
predicate, etc. of that new entity. The thing is, that:
a. The best you can do with the reification vocabulary, as it is, is to
express provenance information about some reification (triple quad)
which you effectively claim describes (has the same subject, predicate,
and object as) some actual statement occurrence that the provenance is
*really* about. However, there is no way in the current reification
mechanism to directly establish the relationship between the quad and
the actual statement occurrence the provenance is really about.
b. If the original statings each had a URI, no reification syntax would
be necessary to do provenance. That is, if the actual triple written by
Fred had a URI, I could simply write:
fredtriple ex:writtenby fred .
fredtriple ex:atTime T1 .
Note that for interoperability of provenance I need mutual understanding
of the *provenance* vocabulary (e.g., ex:atTime ), not just the
reification vocabulary.
3. It's not clear that you couldn't continue to use the current
vocabulary with the general meaning suggested by (a). You'd just have
to accept that you have to take a certain amount on faith (that the
reification "description" is a suitable "stand in" for the actual triple
that you're describing with it).
I don't think it hurts to have a standard vocabulary (like the
rdf:subject) for describing the "substructure" of statement
occurrences. It's just that having that vocabulary doesn't get us all
that far in dealing with provenance. I agree that we can't just wash
our hands; too much has been made of "RDF reification".
--Frank [ducking under the desk]
Frank Manola The MITRE Corporation
202 Burlington Road, MS A345 Bedford, MA 01730-1420
Hi Sergey,
I'm sorry about the repeats.
I see what you mean here, and I agree with it, though I think you express
it a bit too forcefully. There was no model theory in M&amp;S at all, but
folks seem to have managed to do useful things with it. Thus, even without
model theoretic semantics, the reification vocabulary can be used, and
provided you understand the semantics attached to it by a particular
application, then you can do useful things with it.
But I agree with you, that it defines no semantics that apply across the
board to all applications.
We have run out of time. However, there has been talk on this list of some
folks getting together and proposing new vocabulary, possibly publishing as
a note. That could be a way forward.
There has been strong support in the WG for the position we have now
reached. I have not officially closed the issue, though I plan to put it
up for closure this week, if Frank agrees that is appropriate.
Brian
Brian, Sergey--
Let me to refer you to:
(my earlier reply to Sergey's post)
and to:
(discussion with Ron Daniel about his provenance use case, and the value
of having the reification vocabulary)
I think that:
a. There *is* value in having the vocabulary
b. We can assign useful meaning to the terms in that vocabulary
c. The vocabulary by itself doesn't do what you want "reification" to
do for the uses described for it in the M&amp;S. I don't see how a decision
for "statement" rather than "stating" changes all that much about the
definition of the reification vocabulary. Even more, I don't see what
good it does to be able to interoperate via this vocabulary if the use
of that vocabulary doesn't allow you to express what you (presumably)
want the applications to interoperate about. Is there some major use
case other than provenance that we don't know about?
Brian says:
I think it's probably appropriate to ask if people think we've done
enough or, at least, what else they think ought to be done to "declare
victory". My own view (expressed in my message to Sergey) is that we
can't just "wash our hands"; too much has been made of "RDF
reification" in the past. That means we probably need to be more
explicit about what our "revised position" is about reification, e.g.,
for guidance of any editor that needs to write about it. (In other
words, here's an invitation for anyone who wants to "declare victory" to
write the "victory declaration statement".)
--Frank
Frank Manola The MITRE Corporation
202 Burlington Road, MS A345 Bedford, MA 01730-1420
I think we have done enough. It doesn't amount to much as part of a
formal definition of a language, but a big step for mankind by
getting the issues clear. I think Brian is eminently qualified to
write the victory statement, but I could have a shot at it.
Pat
IHMC(850)434 8903 home
40 South Alcaniz St.(850)202 4416 office
phayes@ai.uwf.edu
But you know, the same applies to containers. There really is no
semantics to containers, in the sense that no extra semantic
conditions need to be imposed on the RDFS container vocabulary in
order to make sequence-based containers 'work' . But they do work,
all the same, because they wear their relevant structure openly,
expressed in RDF itself (and implicitly in the lexicographic ordering
of the membership property names, in that case) . So one can have
nontrivial content expressed in RDFS without imposing *extra*
semantics on a vocabulary.
As Ive often said, RDF is a pipsqueak of a language, but its not
completely powerless to say things. No special semantics isn't quite
the same as no semantics at all.
Pat
IHMC(850)434 8903 home
40 South Alcaniz St.(850)202 4416 office
phayes@ai.uwf.edu
