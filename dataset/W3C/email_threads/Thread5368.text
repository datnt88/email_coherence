But it seems that the two camps are now on equal footing. Neither has a
completely satisfactory solution and both are trying to find one. Why did
you say that the non-monotonic camp should "shut up" and "all talk about
nonmon systems be ruled out of order"?
Well, it got the discussion started, right? I admit to having found
myself frustrated by the sense that many controversial positions were
becoming just accepted as given without adequate discussion, hence my
abrupt tone.
It was certainly useful to start the discussion. One should just be
careful to make no statements that can politicize the field.
Being monotonic doesn't mean one has to be
bone-headed. I would be reasonably happy with
Theory+Closure+Rn |= false, and having an
explicit strategy for handling contradictions. We
need to be able to handle contradictions in any
case. One such strategy might be to make an
explicit assumption that Rn overrides k+1, which
is thereby treated as a temporary assumption;
that was the original motivation for
circumscription, in fact. This gives a globally
nonmonotonic behavior but keeps explicit track of
the assumptions in each derivation path, so uses
monotonic logic *within* a proof. That might be a
useful compromise, in fact, for practical use.
Notice that the 'contradiction-handling' is
explicitly not part of the derivation in this
case (contrast most treatments of default
reasoning, for example): the overall reasoning
pattern is what used to be called
'truth-maintenance' in AI.
Doesn't sound too elegant compared to circumscription, but ok.
All that is left is to come up with a reasonable theory.
Will be funny if the result will turn out the same as
circumscription (for all practical purposes) and will be implemented using
the plain old negation as failure (e.g., the well-founded semantics).
That actually seems quite likely: it is probably best in areas like
this to stick to time-tested methods if one can. But the issue which
may be merely terminological to some, but seems crucial to me, is
that it is possible to cast circumscription in terms of an
*identified* nonmonotonic assumption which can be stated explicitly
(the minimization of 'abnormal'), and so this framework allows
information to be conveyed within a globally monotonic system of
communication.
So, you are saying that you are ok with "compartmentalized" non-monotonicity.
This is what I thought the role of non-monotonicity could be.
I am not ready to rule out other possible scenarios where non-mon can be
used on the SW, but I can't think of any.
The basic reasoning of the above
paragraph is from Tim Berners-Lee.
He is certainly entitled to his opinion. It may or may not be correct.
Unless he has the logical theory that you are still aiming to develop, his
"reasoning" is no more than a belief at this point.
No, this is unfair. The point that Tim made (the words are mine, but
the point is his) does not depend on developing a logic. It is a
general architectural point about the Web, and can be viewed as a
*requirement* on a web logic. If one wanted a more detailed
expression of it, the place to look would be the REST architectural
theory.
If one understands what he said in a way that doesn't rule out
compartmentalized non-monotonicity, then I think it is reasonable.
But it is hard to tell what he really meant. I think the most plausible
reading was "no non-monotonicity whatsoever".
In any case, I often find that there is a long way to go from an
architectural picture down to the nuts and bolts, and when the bolts are
supposed to be a logical theory of some sort then that road is usually
thorny and full of surprises.
I agree that publishing a statement that makes non-monotonic closure wi
th
respect to an unknown set of sources doesn't carry much useful info for
the
recipient of the statement.
That is my basic point, on which we seem to
agree. The conclusion I draw is that either the
closure should be with respect to a known, and
defined, set of sources, or else the statement
should not rely on a non-monotonic closure.
Yes, I agree.
Excellent. This seems then to be a useful reference point of
agreement. I would be happy if this discussion could be conducted on
this basis, at least, rather than as being about mon vs. nonmon.
I agree in the sense that I see it as a coherent framework, that I see uses
for this kind of reasoning, and that I don't see uses for something
significantly more general on the SW.
But I am not ready to start going after the heretics yet :-)
I specify a schema -- an ontology, if you please.
I would say: I take objects of these classes, the classes have these
attributes of these types. And the objects must satisfy these integrity
constraints. Maybe something else, but this is enough for a start.
What I won't say is which sets of objects I am going to close off. You
give me those objects and I will reason non-mon with them as long as your
objects conform to my schema.
Ah. That is a completely different view of how the SW operates than I
have previously come across, and indeed suggests a resolution of the
debate. Let me check my understanding. You see a clean distinction
between ontological information and data, and regard talk of classes
as belonging to the ontology level: and then a rule may apply
(possibly non-monotonically) to a class in the sense that it is
applied to *elements* of this class, ie to data, or objects, which
satisfies the class description; and the class itself - or more
properly the ontology describing the class - *is* the necessary
information about the intended domain of application of the
non-monotonic rule. In the terminology I have been using, the entire
ontology is 'meta-information' about the applicability of the rule.
Is that more or less right?
Yes, this is how I was thinking about it.
This is an elegant way of combining the
'OWL' view of classes, where they are simply the extensions of
logical predicates, with the OO (what I think of as the Java) view of
classes, where they are categorizations of computational 'objects'.
This is not really a new way of thinking. It is
an overall (idealized) architecture used in the database world.
You write applications that are supposed to work with any instance of the
database as long as that instance satisfies the schema (i.e., the types
and constraints).
On the SW, the "application" is a bunch of rules and the schema is an ontology.
For instance, I can publish a heuristic for planning complex multi-segm
ent
trips.
OK, but how do you convey the information that
this is the intended way that your heuristic is
supposed to be used? You seem (?) to be assuming
that your publication comes with a kind of
protective meta-information which lets a reader
know what the intended purpose, or scope, of the
rules are. How is this meta-information supposed
to be conveyed from the publisher to the reader?
I specify the input schema, as above.
The exact context is known to you.
The type of the context is known to both of us.
But this may still not be monotonic, because you give me your sets of facts
and I circumscribe them.
My heuristic will assume any number of generic inputs and will make
decisions based on the available inputs. It will take the inputs provide
d
by the consumer and close them off.
I see now that we have been talking at cross purposes. I assumed it
would not, because in my understanding of what a nonmonotonic rule
would be doing, there was no provision in any of the extant SW
standards or protocols for supplying this meta-information. I (think
I) see that with your understanding of the role of the rules, things
like RDFS and OWL already constitute that meta-information. However,
if I have this more or less right, this view seems to require a more
delicate account of the relationship between the rules and the
ontology language. The ways that rules relate to class descriptions
is rather different here from the way that Ian Horrocks and Benjamin
talk about this relationship, where both the rule language and the DL
descriptions are simply sublanguages of a common logical framework.
For example, there is no notion of 'constraint' in that world,
whereas it would seem to be central in your view.
Yes, this is a good observation. In fact, even in OWL alone (forget the
rules) there is no notion completely analogous to constraints in databases.
Many people are confused by the "cardinality constraints" in DLs, but this
is not the same thing. In DLs, cardinality constraints are assertions
about the real world and data never violate those assertions. Instead,
data are "made to fit" the constraints (by adding equality or inventing new
elements).
this mailing list is SWS-IG (Semantic Web
*Services*). The scenarios that I had in mind come from the domain of
agents and service descriptions.
SWS \subset SW
so when you are saying that something should be ruled out on the SW then I
monotonically (!) conclude that this must be ruled out in the domain of SWS,
which I don't accept.
Fair enough, but I think that the resolution of the argument lies not
so much in SWS\subset SW as in the *way* that you see SWS using the
SW formalisms. I have been assuming that SW content is data: you have
been assuming that it is meta-data. If it is meta-data then indeed
many of my 'how can that be done??' worries are answered immediately;
and in that case, also, my objections to nonmon reasoning do not
apply with anything like the same force, or even at all, to
data-level reasoning. I need to think about this some more, obviously.
So, vive la (appropriately restricted) non-monotonic SW! :-)
But I don't even accept your statement about ruling out non-mon in the
context of SW-minus-SWS, because it sounds too sweeping to me -- too
non-monotonic :-)
Point taken. Though I think you really mean, too monotonic :-)
No, non-monotonic. Such a statement includes closed-world negation with
respect to a context that is not really clear :-)
My description of the service will say that I am a complex travel planner
and I will use simple services, such as Expedia, Orbitz, Avis &amp; Hertz,
etc. But you tell me which to use (maybe you know a good service in
Thailand, and I might use it for the part of your travel in that part
of the world).
Well, yes, of course I have no quarrel with that: but now, I have a
different puzzle: why does this require any *publication* of
nonmonotonic rules at all? Why does it require ANY kind of content
publication? This sounds to me like a piece of code that is running
somewhere and providing a service: it might even be proprietary; in
any case, it does not need to be publishable, any more than the code
of a query-answering system needs to be publishable.
It probably doesn't need to be published if it is a travel service.
But I can imagine situations where the service is so critical that you
might want to know how it works.
Also, agent-style examples are the easiest to throw around. There are
also much more down-to-earth examples of service-related things that are
convenient to model using defaults. They are just not the neat little things
that one can easily give as examples. I am not even saying that equivalent
modeling cannot be done in a monotonic way. All I am saying is that (as we
already agreed) non-monotonic reasoning patterns can be useful, sometimes
may be indispensable, and they can be made to work in an open environment.
But I might be able to prove
that whenever it gives a positive answer, the answer is correct with
respect to the sources that you gave me. This is all I care in order for
the service to make money.
Fair enough. And that might well be a useful claim to publish, of
course, partly in order to help make money.
So, publishing conclusions made non-monotonically can be useful even if
the exact context in which those conclusions were made is not known to the
consumer (only the ontology of that context may be known!).
I think we made a lot of progress understanding each other. Our
differences are probably not just terminological, but they are
smaller than we thought at the outset.
Indeed. There may be no differences, given my newer understanding of
how you intend that nonmon rules are to be used. I think we may have
been viewing the world from different metalevels, as it were.
Suddenly the difference of opinion became fuzzy ...
Unfortunately, nobody had the patience to read this far to find out that we
actually agree :-)
But I am fine with your agenda of finding a monotonic framework for the
useful patterns of reasoning that are "conventionally understood as non-mon"
Good luck to you. (Honest!) But until you find such a framework, I won't
accept your sweeping statements about the inapplicability of non-monotonic
reasoning on the Semantic Web.
Terminology again, but I think that I might characterize what you are
doing as nonmonotonic reasoning 'under' the Semantic Web rather than
'on' it.
This pun may have some depth to it. You can say that much of what Semantic
Web Services are is "under" the Semantic Web rather than "on" it. I am not
sure that "under" is the only place where non-monotonic reasoning patterns
play a role, but we seem to agree now that they may play a role somewhere
"around" the SW.
--michael
[snip]
Indeed. There may be no differences, given my newer understanding of
how you intend that nonmon rules are to be used. I think we may have
been viewing the world from different metalevels, as it were.
[snip]
I have, FWIW, but I'm not sure what to make of this agreement. Once
more, it may be at the level of nuts and bolts that the blood will
start to flow :)
Cheers,
Bijan Parsia.
Indeed. There may be no differences, given my newer understanding of
how you intend that nonmon rules are to be used. I think we may have
been viewing the world from different metalevels, as it were.
Actually, I don't think so. Getting a bit closer to the nuts and
bolts makes things clearer (for me, at least).
Its interesting that this disagreement/misunderstanding can be rooted
in the differences between two world-views of what class-based
reasoning is really *for*, one based on DL's evolution from logic,
the other based on schemas considered as data descriptions. This
difference of perspectives keeps coming up and seems to be very
important: for example, does one think of range assertions as
constraints (datatype) or simply as assertions (logic)? How about
datatyping? And so on. We keep running into cases where people have
divergent intuitions which can be traced back to the differences in
attitude arising from these two world-views. Clearly at some level
they are similar: Codd's Relational model and the DL logic-based
semantics all agree on the ultimate nature of relations and classes;
but the ways that the two communities think seem often to be sharply
different. Im not sure how to characterize the difference, exactly,
but it seems to be that the DB world-view sees a sharp distinction
between different kinds of information, and tends to treat general
facts as conditions imposed on concrete facts: meta-data as opposed
to data. Distinctions like this may be operationally important but
have no natural place in a logic-based perspective which historically
has been largely motivated by the desire to unify divergent sources
of information as far as possible into one uniform framework.
If one thinks of a universally quantifier assertion as really being
meta-data, i.e. as being about the ground facts rather than just
another fact about the world, then this lends itself immediately to a
host of what seem to someone coming from the logical tradition to be
basically errors: things like considering Herbrand interpretations to
be a fully adequate semantic theory; like finding various
nonmonotonic techniques natural (even obvious) and thinking of
quantifiers are essentially substitutional, all of which are anathema
to logicians. And if you think that the more general assertion's
chief purpose is to control, select or check the internal coherence
of a body of ground data, then the purely logical account of
quantification is inadequate or at any rate incomplete, since a
combination like
(forall (x) (R x x))
(not (R a a ))
is of course inconsistent, but inconsistent in a special way: the
second item is wrong, or should be rejected, as it fails to conform
to the schema. The schema has more assertional force than the mere
data in a DB world, since the schema is a kind of filter or guardian
of the data. Logic has nothing to say about intuitions like this.
Anyway, just rambling. It might be fun to try to get this divergence
between world-views stated clearly, though, as the SW world seems to
require DB folk and logic folk to be able to get along with one
another.
Pat
IHMC (850)434 8903 or (650)494 3973 home
40 South Alcaniz St. (850)202 4416 office
FL 32501 (850)291 0667 cell
phayes@ihmc.us http://www.ihmc.us/users/phayes
Indeed. There may be no differences, given my newer understanding of
how you intend that nonmon rules are to be used. I think we may have
been viewing the world from different metalevels, as it were.
Oh good.
Yes. Stefan Decker and I hit this clash last march in Japan.
Yep. It seems particularly critical in the service realm, as Stefan
again drove home forcefully in Florida last fall. If you describe an
input's type using an OWL class, at invocation time, what information
must you know, and know to send? If the class is Person and person
restricted onProperty childOf someValuesFrom Person...do you have to
send all the information about the parents as well? What if the
individual happens to be a member of parent and soccerCoach (where
neither is a subclass of the other)? Do you send all you know? What if
you're knowledge is incomplete, i.e., you know its a parent but don't
know any further details about the children? For some services that
might matter, others not. This difference isn't usefully expressed by
the simple declaration of type. (Stefan, feel free to jump in if I'm
mangling your point.)
It seems to me to be a severe problem: You are likely to often have too
much *and* too little information.
Also, as is apropos, the handling of incomplete information, and thus
the kind of (and efficiency) of the sort of reasoning you can do.
I tend to think of this as a consequence of the expressivity of the
formalism. TBoxs and ABoxs can be pretty distinct, at least until you
reach a certain level of expressivity.
Oh come! Substiutional quantification rules! :)
Yes.
Cheers,
Bijan Parsia.
Indeed. There may be no differences, given my newer understanding of
how you intend that nonmon rules are to be used. I think we may have
been viewing the world from different metalevels, as it were.
A related intersection of world views keeps coming up in linguistics,
where it appears as the descriptive vs. the prescriptive view of what
grammar is (or does).
Some quick pointers:
Jeff
I have this wonderful image of you and Stefan as sumo wrestlers.
Hmm. How about having a Rule here, a kind of service-best-practices
Declaration from On High, to the effect that ontologies for use in
Service applications ought to be constructed so that just being in
the class, or maybe classes, is enough. If the input's type is
described by membership in a class C or classes C1... Cn, then the
ontology defining C ought to be enough for you to either infer the
information you want, or to be able to figure out what other queries
you might need to make. Then you have at least a snowball's chance of
figuring them out before-hand, and so advertising in your type
description what it is that you need to know, by listing the relevant
classes or inventing a special class.
I'd say the answer ought to be, no, unless the class description is
something like 'person with parents', members of which would be
triples of people, rather than just people.
Exactly, it could never end. It has to be up to the one requesting
the information to say what is needed, surely (?).
What if you're knowledge is incomplete, i.e., you know its a parent
but don't know any further details about the children? For some
services that might matter, others not.
This difference isn't usefully expressed by the simple declaration of type.
It could be, if there was a global convention to that effect. It
would require people to define the classes they needed (such as
classes of person-parent-parent triples): in other words, the global
conventions would drive the ontologies, rather than the reverse.
Which is as it should be, right? We should make our ontologies work
for us, not the other way round.
Nothing that we can do about that, but the real problem here seems to
be how to indicate what information to communicate, rather than what
information is actually there. If information is genuinely missing
then nothing can be done: and there will always be surplus
information that isn't required for some task at hand.
How about datatyping? And so on. We keep running into cases where
people have divergent intuitions which can be traced back to the
differences in attitude arising from these two world-views.
Clearly at some level they are similar: Codd's Relational model and
the DL logic-based semantics all agree on the ultimate nature of
relations and classes; but the ways that the two communities think
seem often to be sharply different. Im not sure how to
characterize the difference, exactly, but it seems to be that the
DB world-view sees a sharp distinction between different kinds of
information, and tends to treat general facts as conditions imposed
on concrete facts: meta-data as opposed to data.
Right. I guess that's a good way to think about nonmon reasoning: its
a way of (perhaps temporarily) filling in missing information with a
best guess.
I take it that this is intended as a joke. However, as Im sure you
must be aware, logicians tend to view jokes about quantification in
the same way that airline baggage inspectors view jokes about bombs.
Sniff.
OK, who is going to write it?
Pat
IHMC (850)434 8903 or (650)494 3973 home
40 South Alcaniz St. (850)202 4416 office
FL 32501 (850)291 0667 cell
phayes@ihmc.us http://www.ihmc.us/users/phayes
