Lisa has asked that we make LABEL functionality optional
(i.e. move it into advanced).
I personally have no problem with that, since labeling
is pretty much orthogonal to CHECKOUT/CHECKIN.
Does anyone object? (and if so, please give some reasonably
specific rationale).
Cheers,
Geoff
I object.
A label is a mechanism for giving a specific revision a human readable name,
as opposed to the server (machine) generated version identifier. While it
is true that you can support linear versioning without the use of labels, it
is similarly true that you *could* have a filesystem automatically generate
an identifier for each file as it is created. My point? The ability to
assign a human-meaningful name to a specific revision allows people to more
easily remember ones that are significant. Instead of remembering that
version 1.6 was the one sent out to customers, a label of "Release_A" can be
used instead. Thus the label feature addresses a basic cognitive recall
problem inherent in the use of machine generated identifiers for revisions.
Since the machine generated identifiers are part of core versioning, the
remedy for them should also be part of core.
The vast majority of commercial and research versioning systems provide some
mechanism for assigning a human readable name to a revision, typically in
the form of a label. I will take the liberty of assuming that they are not
blindly coding a feature everyone else has, and have provided it because it
offers a function their user base has found to be useful. Doesn't it seems
that such a commonly occurring versioning feature should also be part of our
core versioning?
Finally, I am sure that there exist user communities that are confused by
the very notion of versioning, who will never use the label feature.
Similarly, I am sure there are communities of novice word processing users
that are confused by the very notion of word processing, and never use the
spell checking feature. Does that argue for removal of spell checking from
"core" word processing? I think not.
- Jim
I agree that LABEL functionality is very important, and should be
standardized in the protocol, but I don't see that Jim's arguments
identify the significant interoperability problems that will result
if LABEL is optional functionality.
The "auto-generated filename" argument really doesn't apply here.
The version creation method (CHECKIN) always creates a server-named
object. The addition of a label to that object is an optional
additional act that can be performed by a client.
The "spellcheck" analogy is much closer, but using this analogy,
although you'd want to have a standard protocol for accessing
spellcheck functionality from a word processor client, greying
out the spellcheck menu item for word processing servers that
don't support it seems like a reasonable thing to do. Analagously,
greying out the labeling functionality seems like a reasonable
thing to do when a versioning client encounters a versioning server
without label support (just as our client will grey out activity
and baseline functionality when it encounters a server that does
not support activities or baselines).
Cheers,
Geoff
From: "Jim Whitehead" ejw@cse.ucsc.edu
Date: Thu, 5 Oct 2000 11:03:01 -0700
I object.
A label is a mechanism for giving a specific revision a human readable name,
as opposed to the server (machine) generated version identifier. While it
is true that you can support linear versioning without the use of labels, it
is similarly true that you *could* have a filesystem automatically generate
an identifier for each file as it is created. My point? The ability to
assign a human-meaningful name to a specific revision allows people to more
easily remember ones that are significant. Instead of remembering that
version 1.6 was the one sent out to customers, a label of "Release_A" can be
used instead. Thus the label feature addresses a basic cognitive recall
problem inherent in the use of machine generated identifiers for revisions.
Since the machine generated identifiers are part of core versioning, the
remedy for them should also be part of core.
The vast majority of commercial and research versioning systems provide some
mechanism for assigning a human readable name to a revision, typically in
the form of a label. I will take the liberty of assuming that they are not
blindly coding a feature everyone else has, and have provided it because it
offers a function their user base has found to be useful. Doesn't it seems
that such a commonly occurring versioning feature should also be part of our
core versioning?
Finally, I am sure that there exist user communities that are confused by
the very notion of versioning, who will never use the label feature.
Similarly, I am sure there are communities of novice word processing users
that are confused by the very notion of word processing, and never use the
spell checking feature. Does that argue for removal of spell checking from
"core" word processing? I think not.
- Jim
Creation or removal of interoperability problems is a poor criteria for
determining what belongs in core. Using this as the criteria, I could argue
that CHECKOUT should be optional, since it is impossible to identify any
significant interoperability problems that would result from it being put
into advanced versioning. Such a move would raise *oper*ability problems,
but that is my point. CHECKOUT's inclusion in core versioning depends on its
utility for basic versioning use. Similarly, my previous argument was that
labels provide such a valuable facility, useful across such a wide range of
users and use cases, that it belongs in core. I illustrated this by
identifying how labels address the naming problems that accompany the use of
machine-generated version identifiers. Since these problems would be part
of core, it seems to me their remedy should also be part of core.
So, are you arguing that for an operation to belong in core, a user must
perform it every time they do a CHECKIN? You want server-generated
identifiers, since it would be unreasonable to expect a user to individually
name each revision, and you also want labels, since it is unreasonable to
expect a user to never want to name any revision.
I never argued that LABEL *couldn't* be made optional, just that it
*shouldn't*. Any of the methods we're proposing *could* be optional, and a
client *could* adapt to whatever features the server provides. The net
result of this would not be increased simplicity on the client side, though.
Labels are such a widely provided feature across version control systems
that the burden of proof really lies on those who want to move this
functionality out of core. I really need to be convinced that the absence
of labels won't: (a) violate the expectations of versioning-aware users of
DeltaV applications (I personally would think the absence of labels to be
extremely odd in a modern versioning system), and (b) lead to increased
cognitive difficulties due to the absence of revision naming capabilities.
- Jim
I'm with Geoff here -- let's specify a standard, but allow
servers to decide if it is appropriate to their domain.
Chris
I agree that LABEL functionality is very important, and should be
standardized in the protocol, but I don't see that Jim's arguments
identify the significant interoperability problems that will result
if LABEL is optional functionality.
The "auto-generated filename" argument really doesn't apply here.
The version creation method (CHECKIN) always creates a server-named
object. The addition of a label to that object is an optional
additional act that can be performed by a client.
The "spellcheck" analogy is much closer, but using this analogy,
although you'd want to have a standard protocol for accessing
spellcheck functionality from a word processor client, greying
out the spellcheck menu item for word processing servers that
don't support it seems like a reasonable thing to do. Analagously,
greying out the labeling functionality seems like a reasonable
thing to do when a versioning client encounters a versioning server
without label support (just as our client will grey out activity
and baseline functionality when it encounters a server that does
not support activities or baselines).
Cheers,
Geoff
I object.
A label is a mechanism for giving a specific revision a human readable
name,
as opposed to the server (machine) generated version identifier. While
it
is true that you can support linear versioning without the use of labels,
it
is similarly true that you *could* have a filesystem automatically
generate
an identifier for each file as it is created. My point? The ability to
assign a human-meaningful name to a specific revision allows people to
more
easily remember ones that are significant. Instead of remembering that
version 1.6 was the one sent out to customers, a label of "Release_A" can
be
used instead. Thus the label feature addresses a basic cognitive recall
problem inherent in the use of machine generated identifiers for
revisions.
Since the machine generated identifiers are part of core versioning, the
remedy for them should also be part of core.
The vast majority of commercial and research versioning systems provide
some
mechanism for assigning a human readable name to a revision, typically in
the form of a label. I will take the liberty of assuming that they are
not
blindly coding a feature everyone else has, and have provided it because
it
offers a function their user base has found to be useful. Doesn't it
seems
that such a commonly occurring versioning feature should also be part of
our
core versioning?
Finally, I am sure that there exist user communities that are confused by
the very notion of versioning, who will never use the label feature.
Similarly, I am sure there are communities of novice word processing
users
that are confused by the very notion of word processing, and never use
the
spell checking feature. Does that argue for removal of spell checking
from
"core" word processing? I think not.
- Jim
I agree with Jim - but I would also add that labels provide more than just
a human readable name, they provide the ability to define a unique
configuration of the resources in the repository. One often does not want
to get everything from the repository, just the subset of resources in the
configuration identified by a unique label. Baselines provide this type of
functionality in advanced versioning and labels provide it in core. If
labels are removed from core, how is this accomplished?
-- Henry.
Henry K. Harbury hharbury@assetvalue.com
Managing Director
Investments Analytic, Inc.
Software Engineering
14933 SW 91st Avenue
Tigard, Oregon 97224
Voice: (503) 620-2566
From: "Jim Whitehead" ejw@cse.ucsc.edu
Creation or removal of interoperability problems is a poor criteria for
determining what belongs in core. Using this as the criteria, I could argue
that CHECKOUT should be optional, since it is impossible to identify any
significant interoperability problems that would result from it being put
into advanced versioning.
A core client that tries to do a CHECKIN without a CHECKOUT
will fail against an advanced server that requires a CHECKOUT
to precede a CHECKIN.
In contrast, a core client that does not set any labels works
just fine against advanced servers.
Such a move would raise *oper*ability problems,
but that is my point. CHECKOUT's inclusion in core versioning depends on its
utility for basic versioning use.
I disagree. CHECKOUT's inclusion in core reflects the fact that the
versioning model requires CHECKOUT's to precede CHECKIN's. The versioning
model does not require any version to be labeled.
Similarly, my previous argument was that
labels provide such a valuable facility, useful across such a wide range of
users and use cases, that it belongs in core.
This is even more true for a "history resource", but we did not make
that part of core because it was not essential for effective versioning
behavior.
I illustrated this by
identifying how labels address the naming problems that accompany the use of
machine-generated version identifiers. Since these problems would be part
of core, it seems to me their remedy should also be part of core.
Labels are not needed to address the naming problem. I consider the
list that Lisa provided of versioning servers that don't provide
labels as an existence proof of this. In particular, we already have
a large number of standardized properties that a client can use to
help the user to name and select the version they want. For example,
in core we provide DAV:creator-displayname and DAV:comment, and 2518
provides DAV:displayname. In addition, there are a variety of server
generated strings that supplement this user defined information, such
as DAV:version-name, DAV:checkin-date, DAV:getmodificationdate, etc.
A client can just ask for a DAV:version-tree report with the relevant
fields, and the user can use that information to select the version of
interest.
Labels with their "can only identify one version" property are
certainly useful, but by no means essential.
Any of the methods we're proposing *could* be optional, and a
client *could* adapt to whatever features the server provides. The net
result of this would not be increased simplicity on the client side, though.
I assume that all clients will give their user the ability to browse
(and set) properties like DAV:displayname and DAV:comment on the
versions. Whether this is supplemented by the ability to put labels
on those versions seems like a reasonable thing to make optional,
with no significant increase in complexity of the client (just grey out
the "label" menu item).
Labels are such a widely provided feature across version control systems
that the burden of proof really lies on those who want to move this
functionality out of core.
I believe that Lisa has now done this.
I really need to be convinced that the absence
of labels won't: (a) violate the expectations of versioning-aware users of
DeltaV applications (I personally would think the absence of labels to be
extremely odd in a modern versioning system), and (b) lead to increased
cognitive difficulties due to the absence of revision naming capabilities.
I consider that most of the systems that Lisa identified to be modern
versioning systems ... it's just that they are not software
configuration management systems. So if our protocol were only
targeted at software configuration management, I'd agree with you, but
I believe it is essential that core be a suitable "core"
(i.e. minimum) for both document management and software configuration
management.
Cheers,
Geoff
Since many document management clients don't want or need baselining
or configuration functionality, the document management versioning
servers do not want to have to provide the infrastructure
(i.e. labels) for it.
Cheers,
Geoff
Date: Fri, 06 Oct 2000 14:38:26 -0700
From: "Henry K. Harbury" hharbury@assetvalue.com
I agree with Jim - but I would also add that labels provide more than just
a human readable name, they provide the ability to define a unique
configuration of the resources in the repository. One often does not want
to get everything from the repository, just the subset of resources in the
configuration identified by a unique label. Baselines provide this type of
functionality in advanced versioning and labels provide it in core. If
labels are removed from core, how is this accomplished?
-- Henry.
Labels have a role separate from support from baselining. They're just a
mechanism for distinguishing revisions that is controled by the client.
Without labels, clients that want to get a consistent set of revisions
will have to remember all the server-generated URLs and/or version names.
Although possible, this is state that the server should generally be
providing for clients so they don't have to persist this kind of
information.
Since many document management clients don't want or need baselining
or configuration functionality, the document management versioning
servers do not want to have to provide the infrastructure
(i.e. labels) for it.
Cheers,
Geoff
Date: Fri, 06 Oct 2000 14:38:26 -0700
From: "Henry K. Harbury" hharbury@assetvalue.com
I agree with Jim - but I would also add that labels provide more than
just
a human readable name, they provide the ability to define a unique
configuration of the resources in the repository. One often does not
want
to get everything from the repository, just the subset of resources in
the
configuration identified by a unique label. Baselines provide this
type of
functionality in advanced versioning and labels provide it in core. If
labels are removed from core, how is this accomplished?
-- Henry.
From: "Jim Amsden/Raleigh/IBM" jamsden@us.ibm.com
Labels have a role separate from support from baselining. They're just a
mechanism for distinguishing revisions that is controled by the client.
The clients already have this capability via properties like
DAV:comment, DAV:displayname, and DAV:creator-displayname. Combined
with server defined properties such as DAV:version-name and
DAV:getmodificationdate, a user can distinguish one version from
another without the use of labels.
Without labels, clients that want to get a consistent set of revisions
will have to remember all the server-generated URLs and/or version
names.
This is what baselines are for as well, but if a set of users have no
need for getting a consistent set of versions (beyond what is
currently selected as the targets of the version selectors), requiring
that every versioning implementation provide this functionality places
an unnecessary burden on versioning servers targeted at those users.
The fact that there are a significant communitiy of users that care
about versioning, but not labeling/baselining, has been demonstrated
by Lisa's survey of versioning systems.
From: "Jim Amsden/Raleigh/IBM" marjorie@us.ibm.com
Note that just because a versioning repository manager doesn't
support labels doesn't mean that a WebDAV server on that repository
manager can't support labels.
True, but I'm not sure how this is relevant to the current discussion.
Nobody was saying that labels cannot be implemented (clearly they can
be). Lisa's point was that it is a non-trivial effort for
functionality that an important class of clients will not use.
We should be careful about using existing repository
implementations solely as an argument for including/excluding
functions.
The point being made by enumerating existing versioning
systems without label support was that labeling is demonstrably
not essential versioning functionality for a significant
class of users that do want versioning functionality.
I agree with JimW that labeling versions is a
fundamental concept that should be part of core. That fact that a
number of repository managers don't support this doesn't provide
motivation for moving it to advanced to me because 1) these
repository managers aren't trying to be THE Web distributed
authoring and versioning protocol (supporting distributed,
multi-user, multi-version access),
A repository manager is not a protocol, nor does it try to be
one. It just provides functionality to a class of users.
If a demonstrably useful versioning system cannot be marshalled
through the WebDAV versioning protocol without adding in
functionality not needed by users of that system, this
in my view would represent a flaw in the protocol.
2) they aren't prime movers in the repository marketplace,
I'm not sure how you determined who the "prime movers in the
repository marketplace". I consider the systems identified
by Lisa to represent an important class of systems for which
the WebDAV versioning protocol should be appropriate.
3) a number of the ones Lisa mentioned would like to add label support.
Since nobody was stopping them from doing so, the fact that they
chose not to include label support in the current versions of
their systems tells me that this is not an essential feature
of a system that provides versioning support.
Cheers,
Geoff
One of the very differences between a source-management system and a
[simple] document-management system with versioning is that the simple
doc-mgmt system does not have any concept of a consistent set of revisions.
For example, let's say EJW wanted to keep all WebDAV related drafts in a
WebDAV repository. Is there any concept of "consistent set" between the ACL
draft, the versioning draft, and the various advanced collections drafts?
Only minimally if at all -- and any desire to see what changes were made at
the same time can be satisfied by looking at the dates of the older
versions. Such a repository would be useful, keeping a history of document
changes around, yet it would have no strong need for labeling.
In this scenario, comments could serve any need for user-readable info on
previous versions. For example version 10 of the versioning draft might
have a "last call" comment on it. Note that the "last call" version of the
versioning draft has nothing to do with the "last call" version of the acls
draft. There is very little to be gained from supporting labeling when
there is no concept of a consistent set of revisions, and I argue that this
is the case in many simple doc-mgmt systems which support versioning.
Is there a justification for supporting labelling that does not require
advanced source-related concepts like "consistent set of revisions", or that
cannot be satisfied by using the version's comment or date properties?
Lisa
[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Jim
Amsden/Raleigh/IBM
Labels have a role separate from support from baselining. They're just a
mechanism for distinguishing revisions that is controled by the client.
Without labels, clients that want to get a consistent set of revisions will
have to remember all the server-generated URLs and/or version names.
Although possible, this is state that the server should generally be
providing for clients so they don't have to persist this kind of
information.
Since many document management clients don't want or need baselining
or configuration functionality, the document management versioning
servers do not want to have to provide the infrastructure
(i.e. labels) for it.
Cheers,
Geoff
I agree with Jim - but I would also add that labels provide more than
just
a human readable name, they provide the ability to define a unique
configuration of the resources in the repository. One often does not want
to get everything from the repository, just the subset of resources in the
configuration identified by a unique label. Baselines provide this type
of
functionality in advanced versioning and labels provide it in core. If
labels are removed from core, how is this accomplished?
-- Henry.
Is this really the case? Or is just the case for older linear documents.
I agree with your arguments if in fact you have standalone objects as in
your examples. But are these examples a reasonably representative set,
or just a particular subset?
It seems certainly not the case for a Web document which may consist
of a hierarchy of pages, images, MM files and maybe even some sort of
personalization data so Joe's story unfolds differently than Jane's
because of a different set of choices.
The "document" in this case could be a substantial collection, and some
means of tying together a consistent set across different stages of
creation and maintenance and maybe even viewing would be mandatory. Note
time is NOT necessarily a good criterion for selection since edits can
be undone to restore previous versions as a perfectly valid operation.
It seems to me that versioning of such a document should still be possible
with core/simple versioning systems. If I am a lowly author, I don't want
to have to figure out or administrate a complex versioning tool. What does
seem to be needed though is a way to easily mark and identify a set of
objects for such an author to keep some sort of handle on his work.
If there is a way to do this with properties, or some existing core
commands, then there is no need to have labelling in core. If the steps
that need to be followed to do this (like ensuring there is only a single
identifier per version history) are just recreating a "label" operation
then either label itself is redundant or one should use at least a simple
form of it in core.
Perhaps it would be useful to outline a few more scenarios which could be
used to decide just what "core" functionality means, and which types of
documents would be applicable to or excluded from "core versioning".
Cheers,
RossW
(In reply to Lisa's posting...)
jra Lisa, I appreciate you concern for minimizing the requirements for DMS
systems. They play an important role in Web authoring. Perhaps we have a
different view of labels though. See if the comments below address your
issues. /jra
There is very little to be gained from supporting labeling when
there is no concept of a consistent set of revisions, and I argue that this
is the case in many simple doc-mgmt systems which support versioning.
jra Support for labels isn't intended to be used to create and/or manage a
consistent set of revisions. Labels in WebDAV aren't "sticky". You can't
lock a label on a revision. So you could use a label to name a consistent
set of revisions, but you can't be sure you'd always get the same
revisions. That's what baselines are for, and this is clearly an advanced
concept. Clients might move the label anytime. /jra
Is there a justification for supporting labelling that does not require
advanced source-related concepts like "consistent set of revisions", or
that
cannot be satisfied by using the version's comment or date properties?
jra Sure. Labels are just a way of distinguishing one revision from
another using an identifier that has some meaning to the user making the
distinction. So in your example, I find lots of meaning in document
revisions labeled as "last call" even though there is no relationship
between them(manifest as links or references) that needs to be captured as
a consistent set in a baseline. The label just helps identify which version
of the document is in the last call state. Its just easier than saying "go
look at revision 1AB2795" or some other equally meaningful server generated
id. This seems pretty useful, and its pretty simple.
Are you thinking that label support implies baseline support, or that there
is even a relationship between them? Baselines have nothing to do with
labels. They are not related in the protocol. Labels are just added and
removed from revisions. The only requirement is that the same label can't
be on more than one revision of the same versioned resource at the same
time. This, and the ability to use them in a Target-Selector header or
SET-TARGET method is about the only thing that distinguishes them from
properties. ?jra
From: Ross Wetmore rwetmore@verticalsky.com
Is this really the case? Or is just the case for older linear documents.
There are still a lot of largely independent documents (linear is not
really the issue, since you can have useful hyperlinks between
largely independent documents).
I agree with your arguments if in fact you have standalone objects as in
your examples. But are these examples a reasonably representative set,
or just a particular subset?
I found Lisa's survey reasonably representative. She mentioned all the
DMS systems I was familiar with, and clearly did not select out just
those that supported her view.
It seems certainly not the case for a Web document which may consist
of a hierarchy of pages, images, MM files and maybe even some sort of
personalization data so Joe's story unfolds differently than Jane's
because of a different set of choices.
Sure, that all happens, but for a lot of documents it doesn't happen.
In particular, documents and links to documents are designed to be
largely independent of the content of that particular document, so
that documents *can* be changed independently. (Maintaining a web
of tightly interdependent documents is *very* hard, and labels only
begin to address the complexities that are introduced ... you probably
need activities and merge support before you even begin to get it
under control).
Perhaps it would be useful to outline a few more scenarios which could be
used to decide just what "core" functionality means, and which types of
documents would be applicable to or excluded from "core versioning".
I believe that Lisa's scenario is the key one for core versioning.
You have a set of largely independent documents that evolve over time,
and for a variety of reasons you want to be able to easily go back and
look at the earlier states of those documents.
Cheers,
Geoff
Hmm,
I think we are missing something here. I wouldn't want to assume what a
particular application of labels might be for (i.e, the intent) as opposed
to what it is (i.e., the extent).
More than that, I see a problem of coherence (e.g., interoperability over
time or across systems and also up/down-level).
Perhaps it is more useful to come at it like this: - Is it legitimate for
someone to use whatever property is identified for label as a property on a
core-only system, so that if the system were upgraded or the data was
transported to a system with advanced versioning support, everything would
work consistently? That is, on one level it is an user-defined property,
but with semantics from the advanced versioning specification? Is there
some semantics on this property for which this would be a problem?
[I realize that this is a conversation that might be worth holding about
other non-core properties too, but I don't have the draft at hand, so I will
be Socratic instead.]
[[Some of this might have sorted out if there were specific measures of what
it means to achieve interoperabilty by WebDAV and by WebDAV + DeltaV. Oh
well ... There was a specific measure for ODMA and it got broken anyhow
going from ODMA 1.5 to ODMA 2.0]]
-- Dennis
AIIM DMware Technical Coordinator
Dennis E. Hamilton
InfoNuovo
[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Lisa Dusseault
Is there a justification for supporting labelling that does not require
advanced source-related concepts like "consistent set of revisions", or that
cannot be satisfied by using the version's comment or date properties?
Lisa
-----Original Message-----
[mailto:ietf-dav-versioning-request@w3.org]On Behalf Of Jim
Amsden/Raleigh/IBM
Labels have a role separate from support from baselining. They're just a
mechanism for distinguishing revisions that is controled by the client.
Without labels, clients that want to get a consistent set of revisions will
have to remember all the server-generated URLs and/or version names.
Although possible, this is state that the server should generally be
providing for clients so they don't have to persist this kind of
information.
Since many document management clients don't want or need baselining
or configuration functionality, the document management versioning
servers do not want to have to provide the infrastructure
(i.e. labels) for it.
Cheers,
Geoff
I agree with Jim - but I would also add that labels provide more than
just
a human readable name, they provide the ability to define a unique
configuration of the resources in the repository. One often does not want
to get everything from the repository, just the subset of resources in the
configuration identified by a unique label. Baselines provide this type
of
functionality in advanced versioning and labels provide it in core. If
labels are removed from core, how is this accomplished?
-- Henry.
From: "Dennis E. Hamilton" infonuovo@email.com
Perhaps it is more useful to come at it like this: - Is it legitimate for
someone to use whatever property is identified for label as a property on a
core-only system, so that if the system were upgraded or the data was
transported to a system with advanced versioning support, everything would
work consistently?
The protocol says that any server that supports versioning MUST reject
an attempt to PROPPATCH any property (core or advanced) that is defined
as "protected" by the protocol. This provides an error check to make
sure a naive client doesn't create a property that a versioning aware
client could misinterpret as having the protocol defined live behavior.
Cheers,
Geoff
