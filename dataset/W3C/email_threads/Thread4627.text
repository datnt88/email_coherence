Hi
Where can I find the definition of the eq operator?
TIA,
Tobi
Hi Tobi,
The eq operator is defined in Section 3.5.1 Value Comparisons in the
XPath 2.0 WD at:
The way in which eq works for a particular data type is defined in the
F&amp;O WD at:
Most data types that you can compare for equality have a op:X-equal()
operator defined in the F&amp;O WD, where X is the name of the data type.
For example, if you want to find out how two dateTimes are compared,
look up op:dateTime-equal() at:
The exception is that xs:string values are compared using fn:compare()
as defined at:
A complete list of the possible comparisons and the relevant
operators/functions from the F&amp;O WD are given in Appendix B.2 Operator
Mapping in XPath 2.0 at:
Cheers,
Jeni
Jeni Tennison
Hi Jeni
[... thanks for all the pointers and explanations ...]
Somehow I hit the same walls as before:
Why does op:node-equal test for identity, not for equality?
If there is eq and op:node-equal, why is there no fn:node-equal? (or
fn:shallow-equal)
Those questions have been replied to already, I'm just still not
satisfied. But I guess no spec (not even ten related ones :) can satisfy
everyone ... perhaps EXSLT will design a sandard lib?
Tobi
Hi Tobi,
Note that eq and op:node-equal() are not at all related. eq is used
for comparing atomic values; if you try to compare two nodes using eq
then you will compare their atomised values. op:node-equal() is used
by the "is" and "isnot" operators, not the eq operator.
Could you give an example of a transformation where you think such a
function would be useful? I have great difficulty understanding what
your idea of fn:shallow-equal() is and, more importantly, why you
think it would be useful.
Cheers,
Jeni
Jeni Tennison
Hi Jeni
"A comparison with the is operator is true if the two operands are nodes
that have the same identity;"
So "is" and "isnot" operators should use something named
op:node-identical().
In a testing framework, I'm comparing pairs of forrests by comparing
each pair of trees.
I'm doing this with fn:deep-equal(), which works well.
Now, instead of getting true or false back, I'd like to get the first
different item (eg node) back instead of false.
I need a fn:deep-equal() which returns the first different node:
It would recurse down the tree (just as fn:deep-equal() does), stop as
soon as it finds a different node in the second tree, and return it.
When being fed
it would return
or the pair as sequence:
While recursing, the function would compare each node pair by calling
s.th. like
shallow-equal($current_node_in_tree_1,$current_node_in_tree_2)
Yes I could quite easily write the recursing function and the comparing
shallow-equal() myself (eg: if node-kind($node) = 'text' then compare
the string, otherwise etc etc), and I probably will, but I think it
would be a useful addition to a standard lib (be it designed and
specified by EXSLT or W3C).
Tobi
