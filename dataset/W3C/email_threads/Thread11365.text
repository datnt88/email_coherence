1a) Shouldn't the two occurences of ' ' in production 16 (the
definition of QuotedCData) be replaced with '&amp;', and if not, why not?
1b) Shouldn't production 15 (the definition of Literal) prohibit '&amp;'
and '%' as well as the relevant quote character, for consistency with [16]?
2) 4.3, the discussion of entity treatment, is somewhat
unsatisfactory. '[P]arsed character data' is misleading, since by the
syntax PCData cannot contain references! If it means 'content and
QuotedCData' (which are the places entity references are allowed), it
should say so. Also, parameter entity processing is not discussed at all.
4.3.6 also needs careful attention, since as it stands it doesn't give
enough weight to the consequences of 2.1, and might lead the naive to
suppose that ". . .three companies: L&amp;amp;M; B&amp;amp;W; Imperial Tobacco"
is invalid, presuming M and W are not themselves defined as entities.
Indeed taken literally 4.3.6 might lead one to suppose that ANY use of
&amp;amp; is illegal, since PCData may not contain &amp;, and 4.3.6 says
"processing this replacement data (which may contain both text and
markup) . . ." This needs to be clarified, in my view.
Here's a candidate redraft of the relevant bits:
4.3 XML allows character or general entity references in two places,
namely in Element content ([39]) or Quoted character data ([16]). The
names of external binary entities may also appear as/in the value of
an ENTITY or ENTITIES attribute. On encountering one of these
references, an XML processor shall:
2. For both character and entity references, the processor must not
pass the reference itself to the application.
3. For character references, the processor must pass the indicated
ISO 10646 bit pattern to the application in place of the reference.
6. For an internal (text) entity, the processor should process the
defined content of the reference on the same basis (i.e. as content or
QuotedCData) that licensed the reference in the first place, with due
regard to section 2.1 above, and pass the result to the application in
place of the reference, EXCEPT that the content of references
processed as QuotedCData MAY include single or double quotes ad lib.,
or may consist of a single '&amp;' character. Similarly, the content of
references processed as 'content' MAY consist of either a single ' '
character or a single '&amp;' character.
If the processor includes an external text entity under clauses (7) or
(8) above, the results shall be as for internal (text) entities as
defined in (6).
XML allows parameter entity references in three places, namely in
literals ([15]), the internal declaration subset ([33]) or the key
of a conditional section ([58]). Processing in this case is parallel
to that for internal (text) entities as defined in clause (6) above,
with the obvious extension to allow content consisting of a single '%'
character.
Note the use of the label 'content' for production [39] is extremely
infelicitous.
The bit about parameter entity references is important, as it makes
clear that the following is valid XML (as it is SGML):
!doctype foo [
%yy;
]
a &amp;g; b
[nsgml says:
(FOO
-a f b
)FOO
C
Hope this helps.
ht
Henry S. Thompson ht@cogsci.ed.ac.uk asked on Fri, 21 Mar 97
12:00:47 GMT:
I think ' ' is forbidden in attribute values and thus is
correctly included in the negated character class. As various
people have pointed out, literal ampersands should also be
prohibited, so the rule should be something like
QuotedCData ::= '"' ([^" &amp;] | Reference)* '"'
If we want the regular expressions to be formally unambiguous,
I think you're right. And I think we do want them to be
unambiguous, since regexp routines vary so much in how they
resolve ambiguity (greedy and not greedy, earliest match vs.
longest match, etc.) -- but it does make for some ugly expressions.
Tim has discovered, in some treatment of re, a subtraction operator
that means "all but", so we could write
comment ::= ' !--*' ((.*) - '*-- ') '*-- '
I've never seen this operator, but it certainly helps a lot here.
Of course, the implementors will translate it wrong when they / we
translate this into RE tools lacking the subtraction operator, but
that's better than having errors enshrined in the spec. (And
a natural translation into lex will work nicely:
!--*" { BEGIN(COM); }
COM . ;
COM "*-- " { BEGIN(INIT); }
As long as the subtraction is longer than the default rule,
lex will do the Right Thing.
Yes.
I repeat my plea for suggestions for the best way to discuss
the handling of PE references. I see the following possibilities:
A add prose describing how they are handled
B add PERef and EE to the grammar, with prose describing the
rules governing PE contents within declarations, while
retaining the PEReference rule for describing the constraints
on PE references between declarations
C Add PEReference and EE to the white space tokens for the rules
defining declarations, and continue to use PEReference -- but add
EE -- in the rules defining the internal subset, and describe
the relevant rules in prose (i.e. do it just the way 8879
does)
D provide a wholly distinct grammar for the entity structure of
declarations and the two subsets -- with prose describing what
we are trying to convey
Any way we cut this, we are looking at serious amounts of normative
prose; the rules governing PE references just do not fit neatly into
context-free grammars as I know how to write them. As far as
I can tell, possibilities B and D would allow us to put more of
the rules into the grammar and have less to describe in the prose.
But D is at best very eccentric, and B will puzzle some readers
who will not see why there are two productions for PE references.
I repeat: does anybody have a good idea?
Good point; at least an example would be useful.
Thanks; I'll have to look at this on paper to have a rational
reaction. Tim and I will be working on this this afternoon and
can look at it together then.
At the risk of appearing extremely dim: why?
N.B. the term 'element content' has a special meaning in 8879 and does
not mean 'content of an element' there, so using the term 'element
content' for production 39 will confuse those familiar with SGML; the
Validity Constraint called 'Element Content' is badly named from this
point of view.
It does; many thanks.
-C. M. Sperberg-McQueen
I ran it with NXP. I had to make a few changes :
1.) !element foo o o any --- !element foo any
(The ERB hasn't decided yet on this subject, or has it ?)
2.) I had to change the position of yy and zz
(I wasn't thinking about this problem of refering to
an entity that was not yet declared. Now I need to check
carefully when NXP resolves (is supposed to resolve) entity references)
3.) !entity % yy '&amp;#37;zz' -- !entity % yy '&amp;#37;zz;'
(Note the semicolon after zz !)
After these changes I got the same results.
FYI: I tested with latest release. It has not been published yet.
Best regards,
Norbert H. Mikula
= SGML, DSSSL, Intra- &amp; Internet, AI, Java
= mailto:nmikula@edu.uni-klu.ac.at
= http://www.edu.uni-klu.ac.at/~nmikula
I've been campaigning for years for the phrase "parsable character data",
ie char data which it makes sense to parse (because it may contain markup)
as opposed to CDATA which there is no point in parsing because it can't.
///Peter
