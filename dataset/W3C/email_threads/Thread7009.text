The following internet drafts have been submitted to the IETF
for consideration:
"An Extended Class Taxonomy for Uniform Resource Identifier Schemes"
"The 'hrn:' URI Scheme for Hierarchical Resource Names"
"The 'uri:' URI Scheme for URI Reification"
"The 'tdl:' URI Scheme for Typed Data Literals"
"The 'voc:' URI Scheme for Vocabulary Terms and Codes"
"The 'qname:' URI Scheme for XML Namespace Qualified Names"
"The 'xmlns:' URI Scheme for XML Namespace Declarations"
"The 'auth:' URI Scheme for Hierarchical Authority Identifiers"
Note that the URLs above are to unofficial copies of these
drafts on the Nokia site, as they are not yet available
(nor garunteed to be posted) on the IETF site.
Any and all comments are most welcome.
Regards,
Patrick
Hi Patrick,
I assume you knew you were stiring up a hornets nest, right? ;-)
I'm quite aware that the issues that are addressed in my IDs
are areas of strong debate, yes.
Being one of the people in the URI-IG that discussed the classical vs
contemporay view (and an adherent of the contemporary view) I have to
say
that this way lies madness.
Perhaps you missed the part that said that it is compatible with either
the classical or contemporary view?
Let me stress it again, draft-pstickler-uri-taxonomy-00 is compatible
with either the classical or contemporary view.
If you read it without this understanding, I would encourage you to
read it again.
Most of the people on the URI-IG were
involved
in the original discussions about URIs when we had such animals as
URA, URMs, URCs, URAv2, etc. The thing that has become clear is that
a given URI's characteristics have more to do with how it is used than
what its scheme says.
Use and abuse are two different things. I assert that any use of a URI
scheme contrary to the specified intended use is contrary to the very
purpose of standards, and while research and advancement often need
to bend the rules and try unconventional things, eventually, advancements
and improvements need to be addressed in a standardized manner such
that industry can build upon that knowledge in a consistent and reliable
manner.
For example, Dan uses the http scheme for
pretty much everything. For him the http scheme makes a pretty valid
urn-like thing. Others don't use it that way so it doesn't have those
semantics for them and thus isn't one.
IMO, a URI scheme defines, in addition to the syntax, a common semantics
and basis for interpretation of instances of that scheme so that an
application has at least half a clue what to do with such instances.
Otherwise, let's all just use uuid: URIs and define the semantics in RDF.
The one thing I do have a problem with is the inclusion of 'hrn:'
along side 'urn:'. IMHO, since your 'hrn' proposal includes a
domain-name
it cannot be a URN because it is not persistent. The UUID version might
but the domain-name based one isn't....
You missed the essential point about my extended taxonomy and the
definition of a URN -- that while a URN may embody within its representation
the identity of the minting agent, it does not embody the identity of
the resolution agent. URLs do both -- and in fact, the minting and
resolution agents are the same.
I suggest you re-read draft-pstickler-uri-taxonomy-00, particularly
section 3.
An 'hrn:' may include the web authority of the minting agent, and that
is persistent, as that will never change. Unlike a URL, however, that
is *not* the resolution authority -- which like all URNs -- remains
undefined in the URI itself.
The 'hrn:' scheme provides a consistent, open, non-centralized
URN scheme that does not need a dedicated centralized authority
for granting namespaces, but uses web authority as that namespace
and thus is far better suited for the Web, not having the bottleneck
of namespace registration preventing global and mass minting of
URNs.
Furthermore, the 'hrn:' URN scheme is a hierarchical URI scheme, which
is highly desireable for many applications.
By those two criteria, I consider the 'hrn:' URN scheme to be superior
to the 'urn:' URN scheme -- though both are fully valid URN schemes
in that neither refer to any resolution agency explicitly in their
representation and are hence persistent in that regard.
Beyond that the analysis is good from that point of view. The problem is
getting agreement on it...
Absolutely. Agreement about URI classes (or lack thereof) and URI semantics
will be a long road, I think.
But even though I'm coming late to this party, I think I've brought
along some rather good music, and maybe we can all get into the
same groove ;-)
As mentioned above, I think that this statement is erroneous:
"This URI scheme is also a type of URN, as defined by RFC 2396, but is
not a
namespace of the 'urn:' URI scheme [5], because the 'urn:' scheme does
not provide for hierarchical characteristics which are central to the
semantics of this URI scheme. "
The fact that there is a domain-name in there means that it violates
the persistence requirement in RFC 2396.
But this persistence requirement has the rather narrow view that
a web authority (domain name) only indicates a resolution agency,
and that the URL-centric perspective perhaps precludes the broader
role of a domain name representing only the minting agency, which
even if that domain ceases to exist, remains historically valid
and thus persistent -- within the scope of URN schemes which
only attribute significance with regards to minting and not
to resolution.
This is an interesting one but I think you should pick another scheme
name.
The one you picked will end up causing you to much argument over the
name
and none over the merits of the idea. The one question I have is: is
reification so globally well understood that it means the same thing to
everyone? I've been out of the RDF discussions but I seem to remember
this being an issue at one point....
This URI scheme is specifically intended for use within RDF applications.
And as for the name, it seems quite consistent with the URN/urn:
convention ;-)
After all, not all URNs are urn:'s. Likewise, not all URIs are uri:'s.
But all urn:'s are URNs and all uri:'s are URIs.
What is the merit of this over the 'data:' scheme?
Specific, constrained semantics.
Furthermore, the 'data:' URI scheme requires that all datatypes
be registered/defined as MIME types, which is an unnecessary
overhead IMO for the kinds of datatypes in question.
The 'tdl:' approach is that each datatype is denoted by a URI,
and the pairing of datatype URI and lexical form uniquely
identifies a member of the value space of the datatype. This
is based on one proposal under consideration by the RDF Core
Working Group for datatyping of literals in RDF.
C.f. http://www-nrc.nokia.com/sw/TDL.html
While the 'data:' URI scheme *could* be made to work for this
application, it would be cumbersome.
I can't figure out what this scheme has that doesn't already exist in
current schemes. It seems that this one definitely falls into the "a
URI's
semantics have more to do with how you use it than what the scheme has
in it"....
Again, perhaps its significance is not seen because the
distinction between URI classes as defined in
draft-pstickler-uri-taxonomy-00 section 3 is not fully understood.
The key point is that a 'voc:' URI does not resolve to
"something else". It is a URP.
Yes, you could define a similar URI using 'http:' but it would
never be clear whether it should or should not resolve to anything,
and if so, to what.
This is the basis for the classical view that I openly admit to
subscribing to. The URI scheme lets an application know what it
should or should do with a given URI.
Using 'http:' URLs for everything just leaves the application
guessing.
The syntactic similarities between 'voc:' and 'http:' are due
to both of them being hierarchical URI schemes and utilizing
web authorities -- but their semantics are *very* different.
Hmm.... I don't think a URI scheme can disclaim the URI Reference so the
hash mark statement is false.
Under the currently defined URI Class taxonomy, consisting only of URLs
and URNs, no -- but under my extended URI taxonomy, with URPs, it can.
And actually, since the definition of a URI Reference is based on
the *returned* media type from dereferencing a URI, and if a given URI
scheme is never intended to be dereferenced, then it is IMO valid and
reasonable to state that in such cases a URI Reference is simply
undefined (cannot exist, or is vacuous).
This URI scheme has nothing to do with RDF/XML serialization.
The utility of this URI scheme is to achieve intersection of knowledge
in a 'tidy' RDF graph.
"Constellations" of property/value pairs do not constitute equality
in the eyes of RDF insofar as graph merging is concerned.
A URI representation results in there being one and only one node
in an RDF graph for each qualified name and allows one to make
statements about that qualified name resource which are global to
the knowledge base.
I thought we'd fixed that whole XML namespace thing?
1. XML Namespaces still remain problemmatic in several areas, but
that is a totally disjunct discussion that I won't introduce
here to this forum, especially since it is not relevant to
the 'xmlns:' URI scheme itself.
2. The 'xmlns:' URI Scheme does not replace XML NS declarations
in XML instances. As with 'qname:' it provides a consistent
representation for NS declarations in an RDF knowledge base
(or anywhere else such a representation is useful).
What's the difference between this and an 'http:' scheme?
1. It's a URV
2. It can be temporally qualified.
3. Its semantics are explicitly constrained to the representation
of authoritative agents.
Sorry if it sounds like I was picking it apart.
No need for apologies, I wan't folks to pick them apart. That's
how (a) they get better, and (b) how we achieve agreement.
As I said, I know I'm coming late into these discussions (or have
missed them entirely ;-) but I sincerely feel that the contemporary
view is missing something very important and essential -- perhaps
not so essential for the Web, but definitly essential for the
Semantic Web.
Regards,
Patrick
What is the merit of this over the 'data:' scheme?
It's actually interesting (IMO) to note that a 'data:' URI
is in fact a URV (and hence URP) as it is never dereferenced,
but provides a complete, self-contained representation of
a resource. It is a WYSIWIG URI.
Thus the URV classification of 'data:' is far more accurate
regarding its semantics and application than the current URL
classification.
Cheers,
Patrick
... The thing that has become clear is that
a given URI's characteristics have more to do with how it is used than
what its scheme says.
I hardly consider that something that is "clear" or true.
Take the simple example of the identity of a thing versus
the identity of the representation of a thing, where that
thing itself is not a digital resource, e.g. a car.
The "use 'http:' URLs for everything' approach suggests
that a given URL can be used both to denote the thing
(the car) as well as be dereferenced to retrieve a
representation of that thing (e.g. a photo, or technical
specs, etc.)
Yet, a SW application which is trying to "understand"
a given statement such as
cannot tell whether Fred is the creator of the car itself
or of the digital resource retrievable from the URL.
Likewise, if the URL is intended only to be a URT -- i.e.
to be a non-dereferencible identifier of a non-digital
resource (just the car), an application has no way of
knowing if a 404 error is a true error (i.e. it *should*
resolve to "something") or just a side effect of the use
of a URL as a URT.
This degree of chaos in the interpretation of URIs is
IMO completely unacceptable and will greatly hinder the
advancement and deployment of useful SW applications.
Far better would be
and an application knows, based on the defined semantics of
'http:' URLs that it should get "something" when it dereferences
the URL and knows, based on the defined semantics of 'voc:'
URTs that it should not dereference one but use it simply as a
global identifier.
Cheers,
Patrick
Patrick,
Right.
That's not true. We've had this discussion before, and I've pointed
out that your assertion above is about the *resource*, i.e. the car.
If a particular representation of the car was created by somebody else,
then that should be reflected in a different URI, and the relationship
between http://foo.com/freds_car/ and this other URI should be
authoritatively established with HTTP's Content-Location header.
e.g.
GET http://foo.com/freds_car/ HTTP/1.1
Host: foo.com
Accept: image/gif
response headers;
HTTP/1.1 200 OK
Content-Type: image/jpg
Content-Location: http://foo.com/freds_car/image?format=jpg
Then you could make assertions about that particular representation;
MB
Mark Baker, Chief Science Officer, Planetfred, Inc.
Ottawa, Ontario, CANADA. mbaker@planetfred.com
From: "Patrick Stickler" patrick.stickler@nokia.com
I think you've done a great service to the SW in defining these new URI
schema. They clearly define our names such that finally our RDF
applications will know of what we speak:)
Do you know of any nasty side effects of starting to use them immediately -
i.e. will they break any known RDF parsers ?
Seth Russell
language: Semenglish
URI
seeAlso
"http://www-nrc.nokia.com/sw/draft-pstickler-uri-taxonomy-00.html" ,
"http://lists.w3.org/Archives/Public/www-rdf-interest/2002Jan/0127.html" .
Blush... ;-)
I don't know of any URI schemes that will break any RDF parser, since
URIs are expected to be fully opaque in the RDF graph.
As to RDF applications that attempt to grok URIs for various
purposes, I can't say. If they are "stupid" and presume that
every URI is an 'http:' URI and barf when they fail to resolve,
then of course, any of the URP schemes will choke such apps.
But I think folks should be able to start using them immediately
with few, if any, concerns of that sort.
We are... ;-)
Cheers,
Patrick
I agree that if separate URIs are used to denote the non-digital
resource and digital representations/expressions of that resource
that what you say is true (though the argument that I was contesting
about "multipurposed" URIs seems to be a common one).
However, using a URL to denote a non-digital resource is IMO just
plain bad practice. The point of the 'http:' URI scheme (and forgive
me for telling all you other folks what that is, even those of
you involved in writing the RFCs ;-) is to provide a URI that is
meaningful to HTTP resolution, and HTTP resolution is intended
to provide access to digital resources.
The problem is that folks needing to talk about non-digital resources
have been so 'http:' URL saturated that they started using them
out of habit, or (fairly enough) not having much else to use, and
then IMO folks started trying to re-define what URLs are for in
order to justify this (mis)use.
The distinction between URIs denoting accessible digital resources
and URIs denoting either abstract concepts or non-digital resources
is IMO crucial for the future of the SW. Again, it may not be
crucial for the Web, but it is for the SW.
A content header is not a digital-resource, it is part of the
interchange protocol which describes to the recieving application
what the content is -- how can you describe empty content?
And this approach presumes that all that can be known about
such a resource can be expressed in the content header. And it
requires the explicit definition of "non-dereferencable" status
for *every* such URI rather than globally for all instances of
a particular URI scheme, or ideally for a URI class such as URP.
Far better to be able to know that one has a URP and thereby
know that the URI is non-dereferencable than have to define for
*every* URP in existence an explicit header response. Yikes!
What a massive overhead!
This content header approach feels to me like a hack. Sorry.
Regards,
Patrick
Well I'm not going into that again, but at least we've boiled
down your argument. 8-)
It's an assertion, like any other on the Semantic Web, except in RFC 822
format rather than RDF.
Anyhow, my general attitude towards your drafts are that it's a good
idea to be able to know things about resources and the relationships
between them. You appear to want to put at least some of this
information into the URI scheme (e.g. HRNs, where the existence of one
resource implies the existence of other resources), whereas I would
prefer that *all* of these relationships were made explicit with the
mechanisms provided by the Semantic Web, and that the identifiers
themselves remain entirely opaque.
MB
Mark Baker, Chief Science Officer, Planetfred, Inc.
Ottawa, Ontario, CANADA. mbaker@planetfred.com
Well, we could do that by simply using only UUIDs.
But as I pointed out, having to define all of the common, shared
semantics explicitly for every single identifier is IMO the
way of madness.
The whole point IMO of URI schemes is to be able to capture
the common semantics and intended application of sets of
identifiers in a consistent and efficient manner.
Capturing common semantics in a formal taxonomy of URI schemes
allows for all SW applications/layers to benefit, not just
HTTP or applications built on HTTP protocols, but any SW
application, standard, or methodology that is URI aware.
HTTP is not the foundation/heart/soul of the SW. URIs are.
The maximal point of intersection between SW applications
should be URIs and the common semantics defined for URI
schemes and the URI classes to which those schemes belong,
and the taxonomy of schemes and classes should, IMO, be
formal -- i.e. the classical view.
Regards,
Patrick
That's true, but it doesn't mean that the only way to communicate that
sort of information is with a new URI scheme. The most general model
would be to assume an opaque URI scheme, and then build up from there,
no?
What should one do when they need to make these same kinds of assertions
about an existing URI scheme that doesn't already support them (perhaps
because it's opaque)? For example, what if the owner of example.org
wants to assert that http://example.org/foo/bar implies the existence of
MB
Mark Baker, Chief Science Officer, Planetfred, Inc.
Ottawa, Ontario, CANADA. mbaker@planetfred.com
But it does. Although it is rather implicit IMO in the definition
of hierarchical URIs, the individual path components are distinct
and hence can be referenced individually.
Note that that does *not* mean that subpaths correlate to URIs,
and this is the case also with 'hrn:' and 'voc:', only that one
can deduce that such subpaths might be valid URIs and in the case
of 'hrn:' and 'voc:' *if* they correlate to resources, there is
a defined superordinate/subordinate relation.
Obviously, though, it is difficult to rebake a cake, and if you
put the wrong ingredients into it... cest la vie... ;-)
Cheers,
Patrick
They can be referenced, but so can any local path. That's not the same
as asserting that they actually identify a resource.
Hierarchical naming does not in general imply the existence of resources
elsewhere in that same hierarchy. If you think you've found some text
to the contrary, I'd appreciate a pointer though, as I've been looking
into the opacity qualities of RFC 2396 recently.
The point here being that this assertion should be able to be made about
any URI, not just ones using a particular URI scheme. So the most
general model for this would be entirely opaque URIs, and explicit
assertions made about them.
Sorry, I don't follow.
That sounds like it would be funny, if I understood the context.
8-)
MB
Mark Baker, Chief Science Officer, Planetfred, Inc.
Ottawa, Ontario, CANADA. mbaker@planetfred.com
I agree. And never stated that such was the case.
Meaning exactly your argument above, that just because a hierarchical
URI can be parsed into discrete subpaths doesn't mean that any of
the subpaths denote a resource -- but if they do, there is additional
semantics that can be inferred for an 'hrn:' and 'voc:' subpath that
cannot be inferred for an 'http:' subpath (or any other hierarchical
scheme I am aware of).
Thus, there is functionality defined for 'hrn:'s and 'voc:'s that
is not present in 'http:'s, all else being equal (which it isn't ;-)
Meaning that if needed semantics are not defined for a given
URI scheme from the get go, you can't (at least not easily)
go back and add it. That's why alot of thought went into the
recipes for 'hrn:' and 'voc:' ;-)
(though they may still end up tasting bad to some folks ;-)
Cheers,
Patrick
I believe that this is one of the things that the Semantic Web should
be used for. Otherwise, where do you draw the line about which
semantics go where (the URI scheme, or the SW)?
MB
Mark Baker, Chief Science Officer, Planetfred, Inc.
Ottawa, Ontario, CANADA. mbaker@planetfred.com
I agree that the SW and RDF will play a major role in describing
URI schemes and specific URI-denoted resources, but that is neither
here nor there, IMO, with regards to what semantics are defined
for all instances (URIs) of a given URI scheme, or for all instances
(URI Schemes) of a given URI Class versus the semantics or other
knowledge defined for a specific URI -- or rather the resource
denoted by that URI.
It's an issue of scalability.
To say that URI Schemes are to be as semantically anemic as
possible and just make statements about the particular URIs
is going to introduce an untenable and unnecessary overhead
on the SW.
If there is consistent, uniform intersection of semantics for
all instances of a URI scheme, then define that semantics within
the scope of the URI Scheme definition -- and in fact I assert
that that is precisely why we have URI Schemes.
Cheers,
Patrick
On 2002-01-19 10:45, "ext Patrick Stickler" patrick.stickler@nokia.com
And if there is consistent, uniform intersection of semantics
for a set of URI schemes, then define that semantics within
the scope of a URI class (URN, URL, URP, URT, URV, etc.) -- and
I assert that this is precisely why we need the classical
view of URI classification and that the taxonomy of URI Classes
must be formal, so that the knowledge about the semantics
of URI schemes and URIs can be expressed and available to
applications in a maximally efficient manner.
Cheers,
Patrick
But not all URNs are 'urn:'s.
'hrn:'s are also URNs.
We tried that route and after almost 10 years never got any agreement on it.
Both sides had perfectly valid points so we wasted _years_ of time on
arguments that in the end wouldn't have changed much anyway...
Interesting.... so you propose a monopoly on indirect identifier schemes?
What about folks who need or want a hierarchical URN scheme? What about
folks who do not wish to reserve a 'urn:' namespace because the space
they want to use will be transient -- but none the less in need of global
uniqueness. What about ... surely I don't need to enumerate all of the
obvious cases where 'uri:' doesn't do the job...
Sorry that I wasn't present for those ten long years of discussion.
I don't agree, though, with your asserted conclusions.
... If you created a URL object
using "hrn:"
And I disagree. A 'URN' is just one URI scheme and trying to get everyone
to agree that there's more to it than that just wont' fly. I tried arguing
that for a long time and in the end I realized it just wasn't worth the
effort.
Let's please keep the terminology straight. 'URN' is a URI Class, not a
scheme. If you wish to assert that there is one and only one URN scheme,
namely 'urn:', fine, but they are *not* the same thing.
Whether you subscribe to the classical or contemporary view of whether
URI classes should be formal or not, the classes still have definition,
and when we speak of URI, URL, URN, etc. we speak of classes, not schemes.
And when I assert that 'hrn:' is a URN scheme, that assertion is valid,
even per the contemporary view. Whether or not some application should
*know* that it is a URN and ascribe some common shared semantics of URN'ness
to it, or whether it should take it in isolation of any classification,
is a separate issue.
I.e. the only difference between the classical and contemporary views
is whether URI classifications are formal or not, not whether those
URI classes have definition (possibly only informal).
The best thing you can and will get is to simply say that there are URIs
and that each scheme has its own semantics and anything beyond that is
application specific. IMNSHO, I think you'll have a better chance putting
these semantics into RDF than you ever will getting them as standard parts
of the URI definitions....
I intend to express them in RDF, and applications which choose the classical
view of URI classification (that such classifications are formal) may use
such RDF schemas as the mechanism for formal application of such
common semantics.
E.g. see attachment...
Cheers,
Patrick
But not all URNs are 'urn:'s.
'hrn:'s are also URNs.
We tried that route and after almost 10 years never got any agreement on it.
Both sides had perfectly valid points so we wasted _years_ of time on
arguments that in the end wouldn't have changed much anyway...
No. I'm saying that attempting to assert something like that as
universal isn't very productive...
Fine. Specify a new URI scheme and say those are its semantics. But
don't call it a URN since that name is already taken for a different
scheme.
'uri:'?
There is a method specified in RFC 2717 for how to get a new URI scheme.
The document uses the term 'URL' but that's a historical artifact and
not indicative that it excludes particular schemes.
Don't be. It wasn't fun. But please don't ignore it....
Fine. I don't agree with some of yours. The question is: how are
we going to get along?
... If you created a URL object
using "hrn:"
And I disagree. A 'URN' is just one URI scheme and trying to get everyone
to agree that there's more to it than that just wont' fly. I tried arguing
that for a long time and in the end I realized it just wasn't worth the
effort.
Nope... Sorry. I have to use the terminology that we've been using
for the past several years that a lot of us have finally agreed upon.
If you want to introduce new terms that are specific to your application
then fine. But please don't re-use old ones. Its to confusing and raises
to many hackles....
Nope. These groups have spent _considerable_ amount of time coming to the
contemporary conclusion. Most importantly the IETF has been trying to
deprecate the use of the term 'URL' ever since '93.
For you it might be. But you're asserting _vastly_ different definitions
for your terms than most here would...
Ok, then we weren't clear. I think what the group meant to say is that
talking about URI classes _in general_ is a useless endeavor and _in general_
shouldn't be done....
The best thing you can and will get is to simply say that there are URIs
and that each scheme has its own semantics and anything beyond that is
application specific. IMNSHO, I think you'll have a better chance putting
these semantics into RDF than you ever will getting them as standard parts
of the URI definitions....
Fine. But don't start out by attempting to redefine how URIs work. Do that
redefinition in RDF using RDF's rule. Its kind of like me redefining
now RDF works so I can do what I want to do. It might work for me but
it causes all sorts of interoperability problems...
-MM
Michael Mealling| Vote Libertarian! | urn:pin:1
michael@neonym.net | | http://www.neonym.net
On 2002-01-20 20:13, "ext Patrick Stickler" patrick.stickler@NOKIA.COM
Sorry. Typo. that should have been 'urn:'.
Hopefully it was obvious ;-)
I've actually found few to none that have been confused by
my calling an 'hrn:' a URN and who didn't follow what was
meant by URL/URN/URP/URT/URV.
It seems that most of the folks who have a problem with
the classical view are also those who are highly http: URI
centric (i.e. use 'http:' URIs for everything).
Those who feel that 'http:' URIs are URLs and should be
expected to resolve to "something" and not be used to denote
abstract or non-digital resources seem to have no problem
whatsoever with the distinction between URL, URN, etc.
Finally, it may be that all this has been hashed out in
considerable detail in the past (perhaps there are some
position summaries in the W3C or IETF archives?) but
the fact that class identifiers such as URL, URN, etc.
"won't die" suggests that the contemporary view does
not reflect the needs of the web community at large.
The thought has frequently crossed my mind that, while
the Web may get along with the contemporary view, the
Semantic Web will not (or not as well).
Ultimately, the needs of applications will decide the
classicial vs. contemporary issue (and I don't consider
it closed) and there are now emerging applications that
will benefit from a formal, explicit classification of
URI schemes.
Cheers,
Patrick
But not all URNs are 'urn:'s.
'hrn:'s are also URNs.
We tried that route and after almost 10 years never got any agreement on it.
Both sides had perfectly valid points so we wasted _years_ of time on
arguments that in the end wouldn't have changed much anyway...
But your trying to assert the opposite. That there is no such thing
as a URN other than a 'urn:'.
The characteristics of a URN scheme are clear enough. If a URI
scheme has those characteristics then it is fair to call it
a URN.
Honestly, I find the contemporary view very "backwards" in terms
of "contemporary" object oriented engineering which attempts to
capture and reuse generalities wherever possible.
Having no formal taxonomy of URI schemes imposes extra burden
on applications which must interpret URIs.
I disagree. A "clarification" from the W3C does not constitute
the dissolution of the relevant RFC's IMO, and unless you can
justify that the use of a formal taxonomy has a negative impact
to *applications* I see no valid reason for precluding its use.
Well, I don't intend to win my point by argument (alone). My
present work in the are of metadata driven systems and semantic
web applications (which make use of URPs, URTs, URVs, and of
course, URNs and URLs) should sufficiently demonstrate the need
and validity of a formal URI class taxonomy.
All in good time...
... If you created a URL object
using "hrn:"
And I disagree. A 'URN' is just one URI scheme and trying to get everyone
to agree that there's more to it than that just wont' fly. I tried arguing
that for a long time and in the end I realized it just wasn't worth the
effort.
Sorry, but I don't get that from *any* of the official publications of
either the W3C or IETF (and I've been reading carefully). Perhaps you
or a group of folks in some discussion list say so, but from what I can
tell, URN and 'urn:' are not considered the same thing.
It is true that the recent W3C clarification appears to assert that there
is one and only one URN scheme, 'urn:', and from that, one may consider
the two synonymous -- but only if one agrees with such an assertion
(I certainly don't, and it appears that alot of other folks also don't).
I'm not using any new terms. I'm using the terms as they have been defined.
I *am* of course, using them as defined by the classical view, and even
to a certain extent compatable with my understanding of the contemporary
view.
It seems that there is a third view -- the "absolutist view" ;-) which
does not recognize the terms URN or URL at all.
It may need to try harder ;-)
IMO, and with all due respect to all of the participants of those long
and painful debates that I seem to have missed, the contemporary view
has emerged simply because (a) even though URNs were defined, there was
no standard resolution solution and those that needed them were a very
small minority of web users and (b) 'http:' URLs were highly visible and
taken by the majority of web users to be synonymous with URIs and
when folks needed URIs for non-digital or abstract resources, they used
'http:' URIs and the (bad) practice became so prolific, that folks
threw up their hands and said "since 'http:' URIs are no longer
consistently URLs, let's forget about the distinction -- missing the whole
point that (1) the distinction is valuable and valid, and (2) bad practice,
however prolific, should not be a basis for architectural design.
Yes, I admit, "them's fightin words" and apologies in advance for all
insult and injury that may result from them, but I think there is much
more than a grain of truth there... and there's more...
When XML Namespaces came along, folks understandably but inadvisably
began using 'http:' URIs for namespaces -- with the interpretation
and expectation (not specified in the XML NS spec) that the namespace
URI resolve to "something" giving us hacks like RDDL which (albeit
a useful solution for general cataloging of model related information)
misses the whole point that a namespace does not equate to either a
vocabulary or a single schema but is nothing but punctuation; and
further served to encourage the mis-interpretation of namespace URIs.
Had there been valid URT schemes in place when XML NS came, and had they
been used in the XML NS examples, we would have avoided *alot* of confusion
and the differences between namespace, vocabulary, content model, and
schema would be clearer and more widely understood.
Now, all of that mess was still something the Web could live with, but...
The SW, however, changes things quite a bit. Now there is a significant
need for globally unique identifiers denoting abstract concepts and
the difference between a 'thing' and some representation of that 'thing'
that is web accessible becomes acute. And of course, we've needed URT
schemes all along for our DTDs, XML Schemas, RDF Schemas, etc. And
applications neeed to know if an identifier denotes a web resource or
some other, non-accessible (non-digital or abstract) resource, and
that requires knowledge about the URI schemes.
Furthermore, online publishing and media distribution is beginning to
come of age, and the need for URNs is growing with it. Surely folks
at the IETF have noted a increase in the demand for registered 'urn:'
namespaces? Hence the recent streamlining?
Thus there is growing need for applications to be able to organize
and interpret URIs according to scheme specific semantics, and
there are numerous schemes with major, functional intersections
of semantics which would beg for a taxonomy of schemes, thus the
classical view is becoming a necessity.
(and just so folks know where I'm coming from, in addition to being
active in the RDF and SW communities, and a member of the W3C RDF Core
WG, I am also a member of both the Metadata and Identifiers working
groups of the Open eBook Forum, the leading standard for ePublications,
and also am the chief architect of Nokia's documentation and digital
resource management solutions, managing several million pages of
complex technical, procedural, and user documentation, so my views
are based on long, hard experience, and are not just so much arm waving
and armchair philosophising)
All in all, I think that the contemporary view does not serve the
needs of the emerging semantic web and that if 'http:' (mis)use is set
aside, out of the picture, it becomes very hard to justify the
disposal of the URL, URN, etc. distinctions, and the extended classes
URP, URT, and URV reflect distinctions needed by the SW and KM
communities for some time.
Oh, and by the way... ;-) ;-) ;-)
And where precisely is "here"? Planet Earth? IETF? W3C? The URN list?
The URI list?
What's interesting is that, while I've always understood the W3C
clarification as being a clarification of the *views* -- a tour of
the classical and contemporary views and what each one asserts or
presumes -- the folks who were involved in writing it seem to
think that it rather is a mandate for adoption of the contemporary
view. I.e. that the interpretation and understanding of the document
requires alot of reading between the lines or familiarity with the
discussions of the past.
Furthermore, I consider the choice of terms "contemporary" and
"classical" as politically biased, such that if one does not
subscribe to the "contemporary" view, one is behind the times and
not "with it".
It says nothing specific to application designers about what
the two views mean -- apart from a single mention of the word
"formal", which implies that per the contemporary view, URI
classes have no formal definition that an application could
make use of. If not for implementors, then who is the document
intended for?
And, contrary to what you assert above, it does not IMO say that
it is either unproductive nor unadvisable or incorrect to speak
in terms of URI classes or to assign classifications to URI schems.
As far as "clarifications" go, it's not very clear.
The best thing you can and will get is to simply say that there are URIs
and that each scheme has its own semantics and anything beyond that is
application specific. IMNSHO, I think you'll have a better chance putting
these semantics into RDF than you ever will getting them as standard parts
of the URI definitions....
And why the heck not? If ever there was something in need of standardized
definition, it is URI classification. As I've said before, URIs are the
heart and soul of both the Web and the Semantic Web, so while it is
clearly a challenge, we do need to agree about them.
And my extended taxonomy is based on foundational RFCs which, as far as
I am aware, are still valid and authoritative (to the extent that any
RFC is authoritative).
Again, if the IETF or W3C wishes to "kill" URI classes once and for all,
then rewrite the RFCs or publish new ones that supercede and deprecate
the current ones.
"Clarifications" that have multiple interpretations just won't do.
As for me, whether or not it remains a standard, I will continue to
hold the classicial view and utilize formal definitions of URI classes,
and avoid misusing 'http:' URLs as URNs or URTs.
Regards,
Patrick
Patrick Stickler patrick.stickler@nokia.com said:
Unfortunately, there seems to be an awful lot of that sort of thing
going on throughout the Internet, as hordes of ignorant newbies flood
onto it, commercial interests feel they can make more profit
pandering to them than educating them, and the great demand for
professional developers and hence the flood of people into that field
who weren't necessarily in the traditional "computer geek" mindset
ensures that even the "pros" in the Internet community are, on the
average, less technically knowledgeable than they were a few years
ago. The inevitable result is a huge and continuing pressure to dumb
everything down to a level the current-day users, developers, bosses,
and marketing types can understand, and their eyes tend to glaze over
when presented with the sorts of elaborate logical structures that we
"techno-geeks" love so much.
It's happened with domain names: the public gained an oversimplified
"understanding" that they all end in .com, so even noncommercial and
governmental sites often feel compelled to use that ending, and
everybody seems to think that separate domain names are needed for
every silly marketing gimmick because the masses are presumably too
dumb to remember anything with hierarchical subdomain levels in it.
It's happened with HTML: the web designer community never seemed to
be able to understand the concept of a logically structured markup
language, when what they wanted was a desktop publishing language to
create documents that were as static as if they were on paper, hence
the "tag soup" in most Web pages. If they observe that UL makes
the browser indent, and LI plunks down a bullet, well, then, that's
what those tags mean, and who cares whether you actually nest them
correctly if the browser "works" with them even if you do it wrong?
My co-workers still tend to look at me like I'm from Mars whenever I
try to explain any of this stuff; they regard it as kind of a
personal idiosyncracy that I use CITE elements for citing book and
magazine titles on Web pages instead of I (which "means the same
thing", because it looks the same in popular browsers; so why learn
some other geeky tag?), or because I have retrograde notions not
shared by the marketing department to the effect that they maybe
should consider using logical subdomains for sites that are logically
subordinate to others instead of registering yet another silly-
marketing-gimmick domain name.
My personal websites are full of rants on this sort of thing.
I guess new URI schemes are yet another battleground for this sort of
fight... I wonder if "our side" can finally manage to win one? I
guess it depends on whether the developers of the next generation of
software decide to make some use of this stuff, versus sticking to
the simpleminded concept that URIs begin with "http://", while
patting themselves on the back about how sophisticated they are
because they know that "URI" is the current correct name for them
instead of "URL" and that "www.somesillyname.com" is not a complete,
correct URI without the "http://" part.
== Dan ==
Dan's Web Tips: http://www.dantobias.com/webtips/
Dan's Domain Site: http://domains.dantobias.com/
