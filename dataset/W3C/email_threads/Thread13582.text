Hmm... I've changed it to produce that for now, but I'm
not sure I understand what this new and improved URI is
supposed to represent. Does this mean that I have to make
my own namespace so that this can be translated into
something meaningful later?
The main thing we're after is consistent information that can be
queried useful in future. The more consistent your information, the
more useful it is. Imagine the following report:-
http://www.w3.org/blargh rdf:type earl:WebContent;
earl:date "2001-10-15" .
http://www.w3.org/blargh earl:fails :MyTest.
and then a couple of days later, another report:-
http://www.w3.org/blargh rdf:type earl:WebContent;
earl:date "2001-10-17" .
http://www.w3.org/blargh earl:passes :MyTest.
Now, how do you expect to query it to check whether the page has been
fixed, given that the URIs representing the resources are the same?
It's broken. The rule is: one URI, one resource. [People get votes,
URIs get resources!]
So you're putting the "thing" in your own namespace for a few reasons:
to separate it from other "things"; so that you can add data in the
future; so that your data will be consistent; so that people can query
it in the future; so that if you abandon or break it, you lessen the
impact.
You should make "Learning EARL by Example" public,
it's quite helpful.
Thanks - I'm glad that it's useful. BTW, the document is already
public:-
0.95byExample
as are all emails and attachments sent to this list:-
and indeed every other W3C mailing list.
* http://hkn.eecs.berkeley.edu/~nadiah/tester/css.txt#1.1
has a dubious fragment, although it doesn't concern me too
much.
Another place where I wasn't sure of the purpose of the
resource. I'm not sure what's supposed to be there.
Neither am I. It's an issue :-)
The W3C Quality Assurance group is chartered to investigate a test
point definition language. As long as such a framework is scaled up to
the Web, it should be possible to integrate it neatly with EARL.
As for the fragments, what you have there is a document that is in
your own temporary language. EARL 0.95 does not provide information
for identifying the type of a test case document. It does define a set
of classes whose semantics are left for future interpretation by the
group. One of these classes is the "TestCase" class, which has a
predicate testId relating it to a test case file. This allows one to
bundle a group of test case documents, test point specification,
levels, and exclusions together - for example: all of the WCAG 1.0
priority 1 checkpoints except for 2.1.
Actually the script uses POST by default, but it accepts
either.
Ah, that's alright then. Perhaps you could change the forms to GET, if
you think it's suitable to do so?
Kindest Regards,
Sean B. Palmer
@prefix : http://purl.org/net/swn# .
:Sean :homepage http://purl.org/net/sbp/ .
Sean, I completely disagree on this question. I think that what should happen
if there are two reports made which conflict in their details is precisely
what you have outlined below. The resource (the thing being tested) hasn't
changed what it is, and nor has the EARL schema (probably). Some details may
have changed, but most URIs do not have any guarantee that they remain
byte-identical forever.
It is a question for the client processor what to do about conflicting
statements - a generating tool just produces those statements.
If a web page is not accessible on tuesday, and is accessible on thursday,
then it is up to a client to interpret the results and decide that if the
same person makes confliting claims, the best resolution is to accept which
set of claims has the latest date attached. (This is not new. It is like the
CSS cascade, and like principles of applying law that have been around for
hundreds of years). Alternatively, a client can make the decisions on the
author, if there is more than one and they differ. Or ask the user to tell it
how to decide in this case. Or point out that there are differing opinions.
None of these things will happen if you invent a new namespace for the thing
being tested each time you run a test - it is important that it has the same
URI if it is the same thing.
(otherwise we end up in the urn rathole - urns are a great idea, but the only
way to find them is to define a urn- URI mapping, at which point it makes
more sense to have some rdf using uris and be done with it...)
cheers
Chaals
Hmm... I've changed it to produce that for now, but I'm
not sure I understand what this new and improved URI is
supposed to represent. Does this mean that I have to make
my own namespace so that this can be translated into
something meaningful later?
The main thing we're after is consistent information that can be
queried useful in future. The more consistent your information, the
more useful it is. Imagine the following report:-
http://www.w3.org/blargh rdf:type earl:WebContent;
earl:date "2001-10-15" .
http://www.w3.org/blargh earl:fails :MyTest.
and then a couple of days later, another report:-
http://www.w3.org/blargh rdf:type earl:WebContent;
earl:date "2001-10-17" .
http://www.w3.org/blargh earl:passes :MyTest.
Now, how do you expect to query it to check whether the page has been
fixed, given that the URIs representing the resources are the same?
It's broken. The rule is: one URI, one resource. [People get votes,
URIs get resources!]
So you're putting the "thing" in your own namespace for a few reasons:
to separate it from other "things"; so that you can add data in the
future; so that your data will be consistent; so that people can query
it in the future; so that if you abandon or break it, you lessen the
impact.
But it isn't the same thing. If a page fails on Monday that passed on
Sunday, then it's a different page - a different representation of the
same resource. We still have a link to the resource in the form of the
"testSubject" (0.95) or "reprOf" (P1.0) arcs.
Moreover, if we merge the two example reports from my email, we get:-
http://www.w3.org/blargh rdf:type earl:WebContent;
earl:date "2001-10-15", "2001-10-17";
earl:fails :MyTest; earl:passes :MyTest .
which isn't all that queryable. If you instead recognize the fact that
you're evaluating a representation of the resource, and datestamp the
thing/give it an ID, then you can still query by the original
resource, because you have that arc:-
_:x rdf:type earl:WebContent;
earl:reprOf http://www.w3.org/blargh ;
earl:date "2001-10-15"; earl:fails :MyTest .
_:y rdf:type earl:WebContent;
earl:reprOf http://www.w3.org/blargh ;
earl:date "2001-10-17"; earl:fails :MyTest .
You can ask "has http://www.w3.org/blargh been fixed?" using the
following query/rule:-
{ [ earl:reprOf ?p; earl:date ?q; earl:fails ?r ] .
[ earl:reprOf ?p; earl:date ?s; earl:passes ?r ] .
?q string:lessThan ?s } log:implies
{ ?p a :EvaluatedThing; :fixedBetween (?q ?s) } .
for the above, that should give:-
http://www.w3.org/blargh a :EvaluatedThing;
:fixedBetween ("2001-10-15" "2001-10-17") .
OTOH, if you *don't* use a unique ID for each particular dated
representation, there is no way that you can perform that query -
unless there is a different way of modelling the whole evaluation.
Kindest Regards,
Sean B. Palmer
@prefix : http://purl.org/net/swn# .
:Sean :homepage http://purl.org/net/sbp/ .
OK, I had a different understanding of the graph being created - I assumed
that the association of a context (date, author, etc) with a given result
(pass/fail/...) would hold when the graphs were merged.
/me goes to think about it for a while (and re-read the schema we have)..
chaals
But it isn't the same thing. If a page fails on Monday that passed on
Sunday, then it's a different page - a different representation of the
same resource. We still have a link to the resource in the form of the
"testSubject" (0.95) or "reprOf" (P1.0) arcs.
Moreover, if we merge the two example reports from my email, we get:-
http://www.w3.org/blargh rdf:type earl:WebContent;
earl:date "2001-10-15", "2001-10-17";
earl:fails :MyTest; earl:passes :MyTest .
which isn't all that queryable. If you instead recognize the fact that
you're evaluating a representation of the resource, and datestamp the
thing/give it an ID, then you can still query by the original
resource, because you have that arc:-
_:x rdf:type earl:WebContent;
earl:reprOf http://www.w3.org/blargh ;
earl:date "2001-10-15"; earl:fails :MyTest .
_:y rdf:type earl:WebContent;
earl:reprOf http://www.w3.org/blargh ;
earl:date "2001-10-17"; earl:fails :MyTest .
You can ask "has http://www.w3.org/blargh been fixed?" using the
following query/rule:-
{ [ earl:reprOf ?p; earl:date ?q; earl:fails ?r ] .
[ earl:reprOf ?p; earl:date ?s; earl:passes ?r ] .
?q string:lessThan ?s } log:implies
{ ?p a :EvaluatedThing; :fixedBetween (?q ?s) } .
for the above, that should give:-
http://www.w3.org/blargh a :EvaluatedThing;
:fixedBetween ("2001-10-15" "2001-10-17") .
OTOH, if you *don't* use a unique ID for each particular dated
representation, there is no way that you can perform that query -
unless there is a different way of modelling the whole evaluation.
Kindest Regards,
Sean B. Palmer
@prefix : http://purl.org/net/swn# .
:Sean :homepage http://purl.org/net/sbp/ .
Location: 21 Mitchell street FOOTSCRAY Vic 3011, Australia
(or W3C INRIA, Route des Lucioles, BP 93, 06902 Sophia Antipolis Cedex, France)
Well, some bits hold and some bits don't - and it also depends upon
the type of query. For example, you can reduce a bit of EARL so that
it loses all of the context info using a filter/rule. In my previous
email, I reduced the statements from the following evaluations:-
[ earl:asserts [
rdf:subject [ rdf:type earl:WebContent;
earl:reprOf http://www.w3.org/blargh ;
earl:date "2001-10-15" ];
rdf:predicate earl:fails;
rdf:object :MyTest ] ] .
[ earl:asserts [
rdf:subject [ rdf:type earl:WebContent;
earl:reprOf http://www.w3.org/blargh ;
earl:date "2001-10-17" ];
rdf:predicate earl:passes; # typo in original
rdf:object :MyTest ] ] .
RDF Core seem to be in the process of deciding that one reified
statement is not necessarily the same as another, even with the same
subject, predicate, and object. That's consistent with the way in
which I reduced the statements - it's intutive, and it works well with
EARL.
Of course, we don't actually reify all of the statements in the model.
We only reify the actual earl:Assertion itself, because it's all that
we need to reify; the others are objective truths, whereas an
earl:Assertion is subjective, and varies from tool to tool. This
method has been up in the air for some time now, but no one seems to
have challenged it, modulo DanBri's hypertext-in-RDF idea.
I'd certainly like some discussion of the model - which I've been
pondering for some time now - by the group, although everybody seemed
happy with it from day one. In fact [credit where credit's due], the
model came after an entire weekend of work, and hours of discussions
with Aaron Swartz - in which he proposed [1] the model that we had in
EARL 0.9. The model in EARL 0.95 is basically the same, except that
the predicate and object in the assertion are swapped around since it
seems to make a little more sense that way.
I can recall discussing the "only reify the Assertion" idea before
somewhere, but it's pretty difficult to find specific discussions on
the list. It's a bit sad that 90% of the design rationale for EARL is
in the lists... ugh. Then again, at least it's all archived.
[1] http://lists.w3.org/Archives/Public/w3c-wai-er-ig/2001Apr/0033
Kindest Regards,
Sean B. Palmer
@prefix : http://purl.org/net/swn# .
:Sean :homepage http://purl.org/net/sbp/ .
