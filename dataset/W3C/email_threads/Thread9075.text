I currently have an XML file that we create that includes several files (such as Word, Excel, PDF...) that are stored inline with BASE64 encoding. Each of these files can be electronically signed by multiple parties using a standard digital signature (which hashes the content of a file with some metadata like timestamps, IP addresses, etc.) generated for each party.
Clearly, I don't want to have to repeat the encoded file as an element in each Object.SignatureProperties for since the file can have multiple electronic signatures attached (each are independent of the other signatures).
Should I do this by creating an Object element that contains just the encoded file (one Object element per file), and then create multiple Signature elements (one per each electronic signature) such that is has a Reference pointing to the Object.SignatureProperties? From the schema, it doesn't seem that this is possible since the Object element is inside the Signature element. I see something about "detached signatures," but it's just complex enough that I'm not sure how I should be attacking this.
Thanks,
David
David, could you give a pseudo example? I don't even understand why you are
placing these encoded material in a SignatureProperties.
I thought that you were supposed to do this by creating a Manifest
and then have each signer sign that, creating a Signature element for each
one. Alternatively, you could construct a common SignedInfo and then have
each signer incorporate that in their Signature element.
SignatureProperties would make sense only if you were trying to have a
later signer include one or more of the earlier signatures in his signed
document, and we don't have a SignatureProperty name for that action in the
spec. If they're independent signatures, you wouldn't want to use that
feature at all.
Tom Gindin
"David Wall" dwall@Yozons.com @w3.org on 07/25/2002 07:49:49 PM
Please respond to "David Wall" dwall@Yozons.com
Sent by: w3c-ietf-xmldsig-request@w3.org
Subject: Multiple signatures on multiple files
I currently have an XML file that we create that includes several files
(such as Word, Excel, PDF...) that are stored inline with BASE64 encoding.
Each of these files can be electronically signed by multiple parties using
a standard digital signature (which hashes the content of a file with some
metadata like timestamps, IP addresses, etc.) generated for each party.
Clearly, I don't want to have to repeat the encoded file as an element in
each Object.SignatureProperties for since the file can have multiple
electronic signatures attached (each are independent of the other
signatures).
Should I do this by creating an Object element that contains just the
encoded file (one Object element per file), and then create multiple
Signature elements (one per each electronic signature) such that is has a
Reference pointing to the Object.SignatureProperties? From the schema, it
doesn't seem that this is possible since the Object element is inside the
Signature element. I see something about "detached signatures," but it's
just complex enough that I'm not sure how I should be attacking this.
Thanks,
David
are
Here's an example (with the attachment, logo, signature and public keys
truncated for space) of what I have today. I think I have an understanding
now of how to do this better, using Signature elements that reference the
common data elements, but I'm not sure. Of course, I'd prefer to keep my
data format and then wrap the signature elements we have with XML Signature
elements.
message xmlns="http://www.authorchats.com" version="1"
fromEmail
userId="8592082075648" ![CDATA[d.wall@authorchats.com]] /fromEmail
attachment version="1" ownerUserId="8592082075648" messageId="10737424333"
originalName ![CDATA[Sales Rep Agreement Leo
Falcon.doc]] /originalName
createdTimestamp seconds="1018055722" 04/05/02 5:15 PM
PST /createdTimestamp
signature version="3" ownerId="8592082075648" linkedToId="10737419338"
signerUserId="8592082075961"
realSignedTimestamp seconds="1018279613" 04/08/02 8:26 AM
PDT /realSignedTimestamp
emailFullDisplayName confirmed="true" paidConfirmed="false" ![CDATA[
preText ![CDATA[By typing my name clicking the Add my signature button,
I agree to be bound to the terms described in the attached sales
representative agreement.]] /preText
digitalSignature Hp1Wa6W3BAS+OT5...snip...fTgdWD5yhWlaRBA== /digitalSignatu
re
signerPublicKey
signature version="3" ownerId="8592082075648" linkedToId="10737419338"
signerUserId="8592082075648"
realSignedTimestamp seconds="1018055915" 04/05/02 5:18 PM
PST /realSignedTimestamp
emailFullDisplayName confirmed="true" paidConfirmed="true" ![CDATA[David
A. E. Wall d.wall@authochats.com ]] /emailFullDisplayName
digitalSignature Ah1R1lJ/P/GayP1kb+Ffldb6KzVGJJj...snip...oJZTMaRlw== /digi
talSignature
signerPublicKey
logoData
size="17124" /9j/4AAQSkZJRgABAQ...snip...l+L8X4vzOs6X4vxfi/M6zr//Z /logoData
Note that the body, rawData, digitalSignature, signerPublicKey and logoData
elements are base64 encoded binary. Most of the elements that contain
"user-supplied" input are wrapped in CDATA to avoid problems with whitespace
and special characters (avoiding doing transforms as we output this database
data into XML).
The first signature element, for example, since it's inside the attachment
element, is the first electronic signature for that attachment. It's
composed of the elements: attachment.messageId, attachment.id, fileSize,
createdTimestamp, signedWithName, realSignedTimestamp, originalName,
contentType, rawData, preText, and postText and ipAddr.
The second signature element signs the same attachment, but only the
signedWithName, realSignedTimestamp and ipAddress would generally have
different values (not to mention they'd use different public keys!) from
those used by the first signer's signature.
While there are none here, there could be multiple attachment elements, and
the message element itself could have one or more signatures that would
effectively sign the body element instead of an attachment.rawData element.
Does that make it any more clear?
Thanks,
David
I still can't say I undestand since you still seem to have your own
signature scheme (and use say the first signature is, " composed of the
elements: attachment.messageId, attachment.id, fileSize, createdTimestamp,
signedWithName, realSignedTimestamp, originalName, contentType, rawData,
preText, and postText and ipAddr." How do you know that?
Regardless, I might have a sense of your larger application, and this
pseudo-example demonstrates how might one do such a thing with XML
Signatures.
The following is a message with a header, body, and two attachments. Two
signature is included, the first is specified and contains two references:
one to the first attement, and another to the associated Signature
Properties. If you want to sign the *actual* attachment (instead of the
attement element iwth id = "a1") you would need a transform that isolates
the element content (e.g., XPath). You could further decode the base64 data
in that element content, as decribed in:
realSignedTimestamp seconds="1018279613" 04/08/02 8:26 AM
PDT /realSignedTimestamp
emailFullDisplayName confirmed="true" paidConfirmed="false" ![CDATA[
preText ![CDATA[By typing my name clicking the Add my signature
button, I agree to be bound to the terms described in the attached sales
representative agreement.]] /preText
Thanks. I think I understand how to do this, though it does mean we'll have
to rev our signatures (something we've already accounted for with our
'version' attribute).
We "know" that because it's part of our published standard for how the
signature is calculated (and pre-dates XML Signature). Of course, we'd like
to use XML Signatures since it essentially has the data we have, but also
the processing steps defined within so that an external app can recalculate
on its own without having to know specifically the order in which data
elements were applied to the signature algorithm. Today, we publish the
info so that it can be verified independently without requiring our
software, though few ever make use of another system. At least with a
standard format, we'll be compatible going forward.
data
Has anybody decided whether signing the "real data" versus signing the
"hash" has any legal implications? My impression from a crypto perspective
is that it should be the same since the guarantees are the same, though it's
interesting because the person is now digitally signing meta data and a hash
of a document, rather than the document itself. The question now is whether
anybody will care since I think the binding of the party to the document
would be of the same quality (after all, the digital signature on the "real
data" is just a hash anyway). People probably don't care one way or the
other since it's all pretty much indecipherable to them, but when lawyers
are involved, you just never know!
David
Hm, I'm not sure whether I understand it right. What do you understand under the trem "sign"? If "sign" is the DSA or RSA operation of the signing process, you *never* sign the message directly. What happens is that the message is digested and this digest is signed. In XML Signature, the hash of the message is collected in an intermediary object, the ds:SignedInfo and this is again hashed and DSA'ed. The signing process always involves a cryptographic hash function.
Signing "real data", i.e. signing the message directly is not such a good idea as it opens the algorithm to some attacks, especially if you use plain RSA (which would be a very bad idea).
Christian
idea as it opens the algorithm to some attacks, especially if you use plain
RSA (which would be a very bad idea).
True, but a lot of typical signing includes a hash (RSA/DSA with SHA1), but
the SHA1 works against the actual data being signed (in both digital
signature and legal sense). In XML Signature, there's a two step process of
doing an SHA1 on the actual data, and then digital signing (hash the hash
and encrypt with the private key), so the digital signature is "signing" a
hash, not the original data. Anyway, I believe it's sound technically, just
wondered if there's anything "odd" from a legal standpoint since the
signature is once removed from the data being signed.
David
Hi David,
I've given this a fair bit of thought in the past, and the group discussions of this issue included a number of members from the legal community.
The consensus is that there are no problems with our approach.
I do understand your concern completely, that you are signing a bag of bits that is 'once removed' from the 'actual data'. However, there are several points to consider even if we remove the two-step that XML Signature performs:
1) A digital signature itself is generated over a hash of the data. The hash is a 'lossy' technique that boils every message down to a constant sized 'fingerprint'. The legal community already accepts as technologically sound the application of signature techniques over some metadata (a fingerprint or hash) rather than over the actual data itself.
2) Typically, the data being hashed and signed is already removed several steps from the 'actual data' that represents what the user saw, heard or otherwised sensed that comprised the actual agreement. For example, consider a web transaction that includes an image showing an object the signer wants to purchase or the company logo of the brand of object the signer believes he is purchasing. The signer views a 24-bit color bitmap of the image, which is the 'actual data'. But the 'signed data' is a set of XML tags between which appears the base 64 encoding of a JPeg compressed version of the aforementioned bitmap.
Notice, in particular, that the JPeg compression is a 'lossy' technique. Despite these levels of indirection, we find no problem with the approach because there is a well-defined and straightforward set of transformations that allow validation of the actual data against the signed data.
3) Even the very idea of signing the ASCII codes for the characters in an English language sentence implies indirection. Essentially, "what you see is what you sign", but what we sign is an index into a font map that is not even stored in the document. But, as with JPeg images and base 64 encoding, we accept these bags of bits as being the proper representative of what we really want to sign, which is a bunch of dots on the screen.
And now for the purely philosophical: Even the bunches of dots are only useful because, at the resolution typically used on our computing platforms, the dots meld together to form the symbols that having meaning to us.
So, the precedent for well-defined indirection has been set long before XML Signature came to the scene.
John Boyer, Ph.D.
Senior Product Architect
PureEdge Solutions Inc.
idea as it opens the algorithm to some attacks, especially if you use plain
RSA (which would be a very bad idea).
True, but a lot of typical signing includes a hash (RSA/DSA with SHA1), but
the SHA1 works against the actual data being signed (in both digital
signature and legal sense). In XML Signature, there's a two step process of
doing an SHA1 on the actual data, and then digital signing (hash the hash
and encrypt with the private key), so the digital signature is "signing" a
hash, not the original data. Anyway, I believe it's sound technically, just
wondered if there's anything "odd" from a legal standpoint since the
signature is once removed from the data being signed.
David
