I think/hack that both anonymous *terms* can be *unified*
which is NOT the same as equality
Then your hack only seems to works when we can unify anonymous
terms, or they have some sort of UniqueProperty attached. How do
we solve the general case?
There was some related discussion in the telecon
this afternoon, and I was kind of unable to explain
my point...(I'm really hopeless in that respect)
The thing about anonymous nodes is that they
are ***variables***
if they would be constants, we would be able
to identify them with ***URI constants***
Now they are actually existentially quantified
variables, something like: there exists an _:a
or (using existing vocab): this log:forSome _:a
So I think we should say that *explicitly*
is the testresults (and in the model theory)
(the general case?)
Jos De Roo, AGFA http://www.agfa.com/w3c/jdroo/
Hi Brian,
Great, I really find this interesting too!
I think there are 3 kinds of variables
[1] free variables
[2] existentially quantified variables
[3] universally quantified variables
and I think the misunderstanding is that
anonymous resources are (sometimes)
'treated' as [1] whereas I think they
should always be treated as [2].
If somebody writes the following .nt
_:a uriref1 uriref2 .
and says that this is a statement, then
(s)he is basically talking a free variable
(somewhere floating around in triple space)
I think this is wrong because there is no
quantification: the floating thing should
be existentially quantified and I think
the best way to do that is to *point*
to it. That can be simply done with
a statement *using* that term e.g.
uriref3 uriref4 _:a.
or it can be done with
scope-uri the-log-forSome-uri _:a.
I have recently experimented with
implicit scoping, but I think this is
not a scalable approach.
If we have terms existentially quantified,
then I think that a lot can be done with
such terms, but that's another topic...
Jos De Roo, AGFA http://www.agfa.com/w3c/jdroo/
Brian McBride bwm@hplb.hpl.hp.com on 06/15/2001 07:46:30 PM
Subject: Re: log:forSome (Was: Model-specific identity for anon resources, and
its representation: A new issue?
Hi Jos,
With regard to the recent discussion with Jan, I think there might be
some miscommunication. What I think than Jan is saying is that, given
the model:
http://descr1 http:/prop _:anon .
http://descr2 http:/prop _:anon .
it is not possible to express this exactly in the RDF/XML syntax.
The reason is that the only way this can be done is to assign an ID
or a URI to the anonymous resource. That 'resource' then ceases to
be anonymous. In effect, it is no longer a variable. Try
translating the above n-triple example to RDF/XML and you will see
what I mean.
Reading your message again, maybe I get an inkling of what you are
saying. We are talking here about what is an anonymous resource.
We have been saying that it is an existentially qualified variable.
I have been understanding that to mean that it denotes some specific
resource with certain properties, i.e.
_:anon rdf:type rdf:Class .
says there is some specific resource, _:anon, which has type class.
Is that what you would call a 'constant'? Ah. This is beginning
to make sense to me. If it were a constant, then you wouldn't
mind at all that a URI had been assigned to it. That would not
change its nature.
I think you may be saying that what I thought of as a variable
is not really a variable. It does not bind to multiple values.
Instead it represents a single value (constant) though I don't
know what the value is. Hmmm. Now consider:
5+x=1
Is x a variable? No. Its an unknown, until I solve the equation.
Have we been calling anon resources variables, when we should have
called them unknowns?
If what I previously thought of as a variable, is not really a
variable, how would you explain what a variable is, without
having to refer to concepts defined in a logic layer above
rdfcore?
This is really very interesting.
Have a good weekend.
Brian
I think/hack that both anonymous *terms* can be *unified*
which is NOT the same as equality
Then your hack only seems to works when we can unify anonymous
terms, or they have some sort of UniqueProperty attached. How do
we solve the general case?
Hi Jos,
So just to help me a little along the path to understanding,
could you explain a bit more about what you mean by a free
variable. Some examples that I can relate to would be good.
For example is the x in 5x+1=6 a free variable? Thats what
I was calling an unknown. Wheras the x in x+y=0 is a
variable. At least that's the distinction I thought you
were making.
Can you give examples of the difference?
Not being sure about what you mean by a 'free variable' I don't
understand that. I would have said _:a is an unknown. The difference
between a free variable and an unknown is that a free variable
may be bound to many things, an unknown can bind to just one.
Doesn't existential quantification turn a free variable into
an unkown? That's why skolemization works - we can give an
existentially qualified variable a name (assuming for the
moment we are not in the scope of a universal quanitifer,
because we don't have any of those in rdf).
Now if that were true, then you and I have the same model
for what what is going on here. _:a is both an existentially
qualified variable and an 'unknown' because they are the
same thing (in this context - because we have no universal
quantification)
So if that is the case, then what's the problem here?
Maybe the problem is that you are of the view that it does no
hard to assign a name to an anonymous resource. That's just
skolemization. You might then argue, with Sergey, that there
is no need to represent anonymous resources in the model. And
Jan's problem that RDF/XML cannot represent an arbritary model
is not a problem.
By the way I've changed the title from log:forSome. This may
be another misunderstanding on my part, but I'm talking about
anon resources as they would be defined in the lowest layers
of the rdf model. At that layer log:forSome is not defined
so we can't use it here.
If you are taling about a logic language layered on top of the
core, that could explain a lot.
Now you have lost me.
What is a term? RDF doesn't define such a concept.
Brian
that's indeed a very good point about skolemization
in the case that 'we are not in the scope of a universal
quanitifer' we have indeed a full blown *constant*
but I think that in general you can not make that
assumption (your piece of RDF *could* fall in the
scope of many univerally quantified variables (I mean
when used by outside-core things)
WHAT??!!!???? How??? (How can anything outside a document project a
quantifier scope across that document??)
That is an amazing idea, and suggests an entirely new picture of how
the semantic web might work, but if we really think this is possible
then we should get it clear ASAP, as it completely changes the ground
rules. For example there is no such thing as an assertion, since
anything might be only a subexpression of something outside the
document.
A SAP would help here (such a hot weather...)
OK, let's take e.g. the following piece of RDF
(which is at http://www.agfa.com/w3c/n3/ext.n3)
:s0 :is [ :p1 :o1; :p2 :o2].
:s0 :p3 :o3.
and onother one (which is at http://www.agfa.com/w3c/n3/ext-rules.n3)
{{:u :is [ :p1 :x; :p2 :y]. :u :p3 :z} log:implies
{:u :is [ :p1 :x; :p2 :y; :p3 :z]}} a log:Truth; log:forAll :u, :x, :y, :z.
then the query (which is at http://www.agfa.com/w3c/n3/ext-query.n3)
{:s0 :is :z} log:forSome :z.
will result in (which is at http://www.agfa.com/w3c/n3/ext-result.n3)
{:s0 :is [ :p1 :o1; :p2 :o2].
:s0 :p3 :o3} log:implies
{:s0 :is [ :p1 :o1; :p2 :o2; :p3 :o3]}.
:s0 :is [ :p1 :o1; :p2 :o2].
so there is some kind of changed 'extension of objects'
(there must be some link with SKIF here)
OK, we have identified an anonymous node by its content
in the sense of
a (not *the*) thing which has as 'least common'
certain descriptions
and it is kind of 'by value' (not 'by reference')
but is that a problem?
Jos De Roo, AGFA http://www.agfa.com/w3c/jdroo/
that's indeed a very good point about skolemization
in the case that 'we are not in the scope of a universal
quanitifer' we have indeed a full blown *constant*
but I think that in general you can not make that
assumption (your piece of RDF *could* fall in the
scope of many univerally quantified variables (I mean
when used by outside-core things)
WHAT??!!!???? How??? (How can anything outside a document project a
quantifier scope across that document??)
That is an amazing idea, and suggests an entirely new picture of how
the semantic web might work, but if we really think this is possible
then we should get it clear ASAP, as it completely changes the ground
rules. For example there is no such thing as an assertion, since
anything might be only a subexpression of something outside the
document.
Hey, you should be in Florida, 98F and 100% humidity, even the buildings sweat.
Just as an aside: that universal quantifier is scoped by the outer
pair of { }, ie it is entirely inside the document
What indicates that this is a query? (Is there any syntactic distinction?)
Not just a quibble, because in many usages, calling something a
'query' effectively inverts all its quantifiers, so that an
existential in a query is like a universal in an assertion. If you
are following this common convention, then the log:forSome, while
logically correct, is potentially misleading: it is 'functionally'
exactly like a universal, so that the :z variable can be bound to
anything. (In Gentzen terminology, it is on the other side of the
sequent, so all the intro/elimination rules are inverted. In LP
terms, the goal is negated and then you test for unsatisfiability.)
Notice it would be a logical error to skolemise an existential *in a
query*; a query isn't being asserted.
No, you are just doing conventional reasoning here, with universals
in the axioms (assumptions) and existentials in the goals (queries,
conclusions) , both of which mean that all variables can be freely
matched to anything. All your quantifiers are 'universal' in this
sense, and all their scopes are local to their documents; nothing
projects or extends from one document into another, but since the
variables are all universal, they can be bound to terms (names)
occurring in other documents.
(All of this assumes that all the documents are talking about the
same universe, so it is kosher to just smurge together assertions
from different sources and draw conclusions from them as thouh they
were all in one document. This is probably too naive a perspective
for the entire web; but that gets us into a minefield which is beyond
the scope of this WG.)
I think that your use here of universal quantifiers goes way beyond
RDF. All your variables are universal.
Pat
IHMC(850)434 8903 home
40 South Alcaniz St.(850)202 4416 office
phayes@ai.uwf.edu
