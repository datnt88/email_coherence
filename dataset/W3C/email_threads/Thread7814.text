I've noted it in the lock issues list and I suspect Jim already has it in the
2518 issue list, but in the definition section it says that lock-null resources
are not listed as children of their parent... and (by omiision) cannot accept
UNLOCK and PROPFIND methods. Later in the document it says the opposite. I
believe the later information is correct.
Based on that assumption and a "problem" I encountered with LOCK support in the
Linux version of mod_dav, I'd like to propose "lock-null" as a potential value
for the resourcetype property. This will give clients a predictable value there
for lock-null resources.
What is the "problem" in linux mod_dav? Well it claims that the lock-null
resource is a collection. That's not technically incorrect. So I'd like to
insure that we specify exactly what is returned for the sake of clients. And it
seems like a new value would be appropriate.
Could someone *pleeeassse* tell me what problem "lock null" resources
are supposed to solve? I found a message from Yaron dated 3/22/98 where
they appear to be introduced by an analogy with the need for "zero"
when you are counting. I am not convinced (:-).
If you want to "lock" a place where there is no resource, create some
dummy resource there and lock that.
Currently we're stuck with several paragraphs of verbiage telling us
how a lock null resource behaves exactly like a regular resource except
that it returns a "404" when you try to get its body. Is that feature
so important that it warrants the incremental complexity and confusion
that it adds to the spec?
I propose that we strike all references to "lock null" resources in
2518.
Note: Unlike my previous more radical non-proposal (which by the way is
still what I wish we would do :-), this is a serious proposal.
Cheers,
Geoff
We should make sure there is a DAV:resourcetype for every resource defined by
the protocol.
ccjason@us.ibm.com on 10/13/99 12:38:49 PM
Subject: resourcetype locknull
I've noted it in the lock issues list and I suspect Jim already has it in the
2518 issue list, but in the definition section it says that lock-null resources
are not listed as children of their parent... and (by omiision) cannot accept
UNLOCK and PROPFIND methods. Later in the document it says the opposite. I
believe the later information is correct.
Based on that assumption and a "problem" I encountered with LOCK support in the
Linux version of mod_dav, I'd like to propose "lock-null" as a potential value
for the resourcetype property. This will give clients a predictable value there
for lock-null resources.
What is the "problem" in linux mod_dav? Well it claims that the lock-null
resource is a collection. That's not technically incorrect. So I'd like to
insure that we specify exactly what is returned for the sake of clients. And it
seems like a new value would be appropriate.
Lock-null resources were introduced to allow a user to "reserve" a name in the
namespace. That is, to sort of create the resource and lock it in a single
method. Otherwise, there is a race condition between the time the resource is
created and the time it is locked where some other user could get the lock or
otherwise change the new resource. Lock-null resources represent an attempt to
special case situations that arise from the need to have transaction semantics
and stateful servers for distributed authoring. There are other cases (in the
versioning spec too) where methods are overloaded with headers (control couples)
to make them do something that could have been done with a number of other
methods, but not atomically. There's also the argument of reducing round trips,
but this is pretty limited in this case. HTTP can execute a lot of methods in a
second, and authoring environments often have much lighter nonfunctional
requirements that production server systems.
It was a real pain to implement lock-null resources as it is full of special
cases. I too would just as soon see it removed from the spec. It doesn't seem
that the complexity it adds to the protocol is consistent with the potential
problem it solves.
But Geoff, how do you reall feel about lock-null resources?
gclemm@atria.com (Geoffrey M. Clemm) on 10/13/99 01:45:57 PM
Subject: Re: resourcetype locknull
Could someone *pleeeassse* tell me what problem "lock null" resources
are supposed to solve? I found a message from Yaron dated 3/22/98 where
they appear to be introduced by an analogy with the need for "zero"
when you are counting. I am not convinced (:-).
If you want to "lock" a place where there is no resource, create some
dummy resource there and lock that.
Currently we're stuck with several paragraphs of verbiage telling us
how a lock null resource behaves exactly like a regular resource except
that it returns a "404" when you try to get its body. Is that feature
so important that it warrants the incremental complexity and confusion
that it adds to the spec?
I propose that we strike all references to "lock null" resources in
2518.
Note: Unlike my previous more radical non-proposal (which by the way is
still what I wish we would do :-), this is a serious proposal.
Cheers,
Geoff
resources
the
value
there
it
From: jamsden@us.ibm.com
Lock-null resources were introduced to allow a user to "reserve" a
name in the namespace. That is, to sort of create the resource and
lock it in a single method. Otherwise, there is a race condition
between the time the resource is created and the time it is locked
where some other user could get the lock or otherwise change the new
resource.
Isn't this functionally equivalent to someone getting the lock on the
lock null resource between the time when you issued the lock request
and the time it was handled by the server? The fact that they got the
lock on the empty dummy resource you created, as opposed to a lock on a
"lock null" resource doesn't seem to change the situation in any
substantive way.
(Jim: Since you don't like lock null resources anyway, you shouldn't
feel compelled to answer this ... this question is intended for
anyone who *is* in favor of lock null resources :-)
Lock-null resources represent an attempt to special case
situations that arise from the need to have transaction semantics and
stateful servers for distributed authoring. There are other cases (in
the versioning spec too) where methods are overloaded with headers
(control couples) to make them do something that could have been done
with a number of other methods, but not atomically. There's also the
argument of reducing round trips, but this is pretty limited in this
case. HTTP can execute a lot of methods in a second, and authoring
environments often have much lighter nonfunctional requirements that
production server systems.
Yup, to all Jim says here.
It was a real pain to implement lock-null resources as it is full of
special cases. I too would just as soon see it removed from the
spec. It doesn't seem that the complexity it adds to the protocol is
consistent with the potential problem it solves.
But Geoff, how do you reall feel about lock-null resources?
Oh, still pretty ambivalent ... (not :-).
Cheers,
Geoff
Consider what happens if you need to create a resource with a particular
body and some particular properties. If you don't have lock-nulls (or
transactions), then you do PUT, LOCK, PROPPATCH, UNLOCK (or maybe skip the
LOCK/UNLOCK, since it's only protecting one operation). If you and
somebody else are trying to create it at the same time, then you could get
PUT1, PUT2, PROPPATCH2, PROPPATCH1, resulting in resource whose properties
don't match its body. With lock-null, you can do LOCK, PUT, PROPPATCH,
UNLOCK.
|John Stracke | http://www.ecal.com |My opinions are my own.|
|Chief Scientist |=============================================|
|eCal Corp. |Never mind the GUIs--Unix won't be for the |
|francis@ecal.com|masses until we fix backspace &amp; delete. |
From: John Stracke francis@ecal.com
Consider what happens if you need to create a resource with a particular
body and some particular properties. If you don't have lock-nulls (or
transactions), then you do PUT, LOCK, PROPPATCH, UNLOCK
Actually, since you don't know whether or not something is there
already, you'd always first try the LOCK. If the LOCK fails (because
there is no resource there to LOCK), you do a PUT (with an empty body)
followed by a LOCK.
So what you do is:
LOCK (if fail because no resource there, then PUT null-body; LOCK)
PUT; PROPATCH; UNLOCK
So all LOCK-NULL buys you is the avoidance of the extra PUT/LOCK in
case there is no resource there yet.
(or maybe skip the
LOCK/UNLOCK, since it's only protecting one operation).
Even if you just did a single operation, you still want the
LOCK/UNLOCK to prevent another (locking) client from performing
its edits using the state of the resource prior to your
operation (i.e. you don't want to "lose" your operation).
If you and
somebody else are trying to create it at the same time, then you could get
PUT1, PUT2, PROPPATCH2, PROPPATCH1, resulting in resource whose properties
don't match its body. With lock-null, you can do LOCK, PUT, PROPPATCH,
UNLOCK.
Without lock null resources, you still wrap LOCK/UNLOCK around
your sequence of operations. The only difference is that if your
LOCK fails because there is no resource to LOCK, you issue a PUT
with an empty body, followed by a retry of the LOCK.
Note: If someone gets in ahead of you and locks the dummy resource
you just created, that's no different than someone getting their
lock-null LOCK request in ahead of you.
Note 2: Hopefully there are some GET's and PROPFIND's mixed in
with those PUT's and PROPPATCH's, or else you're going to lose
the previous updates, whether or not you use LOCK's.
Cheers,
Geoff
Consider what happens if you need to create a resource with a particular
body and some particular properties. If you don't have lock-nulls (or
transactions), then you do PUT, LOCK, PROPPATCH, UNLOCK (or maybe skip the
LOCK/UNLOCK, since it's only protecting one operation). If you and
somebody else are trying to create it at the same time, then you could get
PUT1, PUT2, PROPPATCH2, PROPPATCH1, resulting in resource whose properties
don't match its body. With lock-null, you can do LOCK, PUT, PROPPATCH,
UNLOCK.
Or similarly LOCK, DELETE (leave null lock flag), PUT, PROPATCH, UNLOCK....
ala MKRESOURCE.
Or LOCK, DELETE (null lock left), COPY (tree perhaps), play, UNLOCK.
Or xserver COPY... LOCK (depth), DELETE, PUT, MKCOL, PROPATCH, MKCOL, etc
UNLOCK.
And reduces possible error conditions in the middle of sequences of methods that
a client might want to invoke. And facilitates backing things out if it has an
error... because it knows what the state is and can feel safer about backing it
out... (depth null lock)
Question... what situations are complicated by lock null resources. I'm sure we
must have covered this, but I forget what they were and I didn't record them.
I'd like to record this in the issues list.
Lock-null resources were introduced to allow a user to "reserve" a
name in the namespace. That is, to sort of create the resource and
lock it in a single method. Otherwise, there is a race condition
between the time the resource is created and the time it is locked
where some other user could get the lock or otherwise change the new
resource.
Isn't this functionally equivalent to someone getting the lock on the
lock null resource between the time when you issued the lock request
and the time it was handled by the server? The fact that they got the
lock on the empty dummy resource you created, as opposed to a lock on a
"lock null" resource doesn't seem to change the situation in any
substantive way.
We could eliminate lock-null resources, and keep the ability to reserve a name
in the namespace if LOCK on a null resource created a resource with an empty
body and locked it. Since LOCK on a null resource isn't going to respond with
404 Not Found anyway, it might as well create the resource.
Or LOCK, DELETE (null lock left)...
/jason
DELETE on a locked resource does not result in a lock-null resource, the
resource is deleted and the lock is lost.
From: ccjason@us.ibm.com
Or similarly LOCK, DELETE (leave null lock flag), PUT, PROPATCH, UNLOCK....
ala MKRESOURCE.
Or LOCK, DELETE (null lock left), COPY (tree perhaps), play, UNLOCK.
Or xserver COPY... LOCK (depth), DELETE, PUT, MKCOL, PROPATCH, MKCOL, etc
UNLOCK.
And reduces possible error conditions in the middle of sequences of methods that
a client might want to invoke. And facilitates backing things out if it has an
error... because it knows what the state is and can feel safer about backing it
out... (depth null lock)
As Jim Amsden mentioned, according to 2518 you will lose your LOCK as soon
as you issue a DELETE, so you will have to request another LOCK, and there
will be a window of opportunity for someone to get in ahead of you with
their LOCK. But their doing so does not introduce any lost update issues,
but just says that you have to wait for them to finish instead of the other
way round. This is just the normal situation in distributed authoring.
Question... what situations are complicated by lock null resources. I'm sure we
must have covered this, but I forget what they were and I didn't record them.
I'd like to record this in the issues list.
With lock null resources, a client has to think about
what special thing they might need to do in case what appears to be
no resource in some cases (404 coming back from a GET), appears to
be a resource in other cases (PROPFIND). In particular, the client
needs to indicate this fact somehow to a user when the user requests
information about a collection. So it is not just the client but
the user that pays a cost for this feature.
If you look at it from the server side, removing lock null resources
is of course an unconditional win (Jim Amsden already made that point
in an earlier message).
Cheers,
Geoff
From: jamsden@us.ibm.com
We could eliminate lock-null resources, and keep the ability to reserve a name
in the namespace if LOCK on a null resource created a resource with an empty
body and locked it. Since LOCK on a null resource isn't going to respond with
404 Not Found anyway, it might as well create the resource.
Having LOCK create a null resource as a side effect?
This can't be "no control coupling" Jim Amsden talking here! (:-).
But seriously, I could easily live with this proposal. Although I am
aesthetically against control coupling of this kind (i.e. creating a
resource and locking a resource should be two separate and orthogonal
requests), I could live with it if that's what it takes to get rid
of lock null resources.
Cheers,
Geoff
But would this work if one intended to reserve a URL to create a collection?
Albert Lunde Albert-Lunde@nwu.edu
We could eliminate lock-null resources, and keep the ability to reserve a
name
in the namespace if LOCK on a null resource created a resource with an empty
body and locked it. Since LOCK on a null resource isn't going to respond with
404 Not Found anyway, it might as well create the resource.
Having LOCK create a null resource as a side effect?
This can't be "no control coupling" Jim Amsden talking here! (:-).
But seriously, I could easily live with this proposal. Although I am
aesthetically against control coupling of this kind (i.e. creating a
resource and locking a resource should be two separate and orthogonal
requests), I could live with it if that's what it takes to get rid
of lock null resources.
This proposal essentially creates a resource and that resource
has special properties... no guid? special resourcetype? MKCOL?. I
guess that could be fine... but it also sounds like it's largely
the same as our current lock null resource. At least in implementation
and behavior... even if different in conceptual model.
brainstorm The thing is, the
goal of this isn't really to create a resource... it's to reserve the
the namespace and perhaps to provide for some atomicity subsequently.
The ideal would be a lock that is rooted in the slot of the parent
collection where the binding resides. This doesn't fit our current
data model since we never really talk about slots. This does resolve
a few problems though. (No, I'm not making a proposal at this point.
Just brainstorming.)
Whoops, I thought I already sent this...
From: ccjason@us.ibm.com
Or similarly LOCK, DELETE (leave null lock flag), PUT, PROPATCH, UNLOCK....
ala MKRESOURCE.
Or LOCK, DELETE (null lock left), COPY (tree perhaps), play, UNLOCK.
Or xserver COPY... LOCK (depth), DELETE, PUT, MKCOL, PROPATCH, MKCOL, etc
UNLOCK.
And reduces possible error conditions in the middle of sequences of methods
that
a client might want to invoke. And facilitates backing things out if it has
an
error... because it knows what the state is and can feel safer about backing
it
out... (depth null lock)
As Jim Amsden mentioned, according to 2518 you will lose your LOCK as soon
as you issue a DELETE, so you will have to request another LOCK, and there
will be a window of opportunity for someone to get in ahead of you with
their LOCK. But their doing so does not introduce any lost update issues,
but just says that you have to wait for them to finish instead of the other
way round. This is just the normal situation in distributed authoring.
Right. That's what 2518 says. That's why I explicitly noted it. But
we haven't completed the spec. The assumption is that we'd support this. If
we do... we could use lock null resources in this way. See my previous
postings on this.
Right, deleting the lock doesn't create a lost update problem. It does cause
a problem where someone else can slip in a lock, thus block you, abort
themselves
because what they expected there is no longer there. But of course you've
already
done the delete, so you've only done a partial execution and you can't really
back out. You've lost atomicity. So to get around this a client app might do
a MOVE
instead of a delete... so at least it has a chance of backing out your change,
but once again someone else's lock can block it even if it's a temporary lock.
As you see... this type of atomicity is not achievable without the this type of
lock.
Question... what situations are complicated by lock null resources. I'm sure
we
must have covered this, but I forget what they were and I didn't record them.
I'd like to record this in the issues list.
With lock null resources, a client has to think about
what special thing they might need to do in case what appears to be
no resource in some cases (404 coming back from a GET), appears to
be a resource in other cases (PROPFIND). In particular, the client
needs to indicate this fact somehow to a user when the user requests
information about a collection. So it is not just the client but
the user that pays a cost for this feature.
Interesting. I'll note that... and give it more thought. JimA just posted
a proposal that would resolve this. Something about giving the null resource
a body. To some extent... it no longer would be a null resource then though.
More thought.
If you look at it from the server side, removing lock null resources
is of course an unconditional win (Jim Amsden already made that point
in an earlier message).
I'll look for that posting and list it here.
From: Albert-Lunde@nwu.edu (Albert Lunde)
But would this work if one intended to reserve a URL to create a collection?
Albert is of course right.
So I can no longer live with Jim's proposal (:-).
So I'm back to:
- return a 404 if there is no resource to LOCK,
- let the client create a "null" instance of what it wants there,
- then the client locks that null instance and it is off and running.
Cheers,
Geoff
Geoff,
That's exactly how I feel about it too. With MKRESOURCE, perhaps even PUT
shouldn't create resources as a side effect, but we have to be compatible with
HTTP conventions.
"Geoffrey M. Clemm" gclemm@tantalum.atria.com on 10/14/99 10:23:30 AM
Subject: Re: resourcetype locknull
From: jamsden@us.ibm.com
We could eliminate lock-null resources, and keep the ability to reserve a
name
in the namespace if LOCK on a null resource created a resource with an empty
body and locked it. Since LOCK on a null resource isn't going to respond with
404 Not Found anyway, it might as well create the resource.
Having LOCK create a null resource as a side effect?
This can't be "no control coupling" Jim Amsden talking here! (:-).
But seriously, I could easily live with this proposal. Although I am
aesthetically against control coupling of this kind (i.e. creating a
resource and locking a resource should be two separate and orthogonal
requests), I could live with it if that's what it takes to get rid
of lock null resources.
Cheers,
Geoff
From: ccjason@us.ibm.com
... according to 2518 you will lose your LOCK as soon
as you issue a DELETE, so you will have to request another LOCK, and there
will be a window of opportunity for someone to get in ahead of you with
their LOCK. But their doing so does not introduce any lost update issues,
but just says that you have to wait for them to finish instead of the other
way round. This is just the normal situation in distributed authoring.
Right. That's what 2518 says. That's why I explicitly noted it. But
we haven't completed the spec. The assumption is that we'd support this. If
we do... we could use lock null resources in this way. See my previous
postings on this.
Fair enough. I was criticizing lock null resources as they are defined
in 2518. Any attempt I have seen to improve the semantics of lock null
resources ends up fixing some problems at the cost of even greater complexity.
So I'm not saying that they don't solve any interesting problems (they do),
but rather that the cost of providing them outweighs the benefits they
provide.
Question... what situations are complicated by lock null resources. I'm sure
we
must have covered this, but I forget what they were and I didn't record them.
I'd like to record this in the issues list.
With lock null resources, a client has to think about
what special thing they might need to do in case what appears to be
no resource in some cases (404 coming back from a GET), appears to
be a resource in other cases (PROPFIND). In particular, the client
needs to indicate this fact somehow to a user when the user requests
information about a collection. So it is not just the client but
the user that pays a cost for this feature.
Interesting. I'll note that... and give it more thought. JimA just posted
a proposal that would resolve this. Something about giving the null resource
a body. To some extent... it no longer would be a null resource then though.
Albert's point (in my opinion) squelched that proposal (:-). Unless
you allow MKRESOURCE to "mutate" a resource to a new resource type,
you will have to delete the resource created by LOCK in order to get
the right resource type, and if we hold to the model that LOCK's are
on resources (not URL's), then when that old resource is deleted, it's
lock cannot be inherited by some new resource at that same URL.
Now I suppose we *could* just say that you can use MKRESOURCE to
"mutate" a resource of one type into a resource of another type,
but that's probably a cure that is worse than the disease ... (:-).
Cheers,
Geoff
No it wouldn't, unless we did something with URLs ending in /. Getting ugly
isn't it.
Albert-Lunde@nwu.edu (Albert Lunde) on 10/14/99 11:23:04 AM
Please respond to Albert-Lunde@nwu.edu (Albert Lunde)
Subject: Re: resourcetype locknull
But would this work if one intended to reserve a URL to create a collection?
Albert Lunde Albert-Lunde@nwu.edu
That's good to hear ... that means the body-snatchers didn't
get you after all (:-). I'm actually not as concerned about
PUT and MKRESOURCE being allowed to both create and update
resources, since they both know what kind of resource should
be there when they are done. I think LOCK is very different
because you *can't* infer from the LOCK call what kind of resource
should be created if none is there at the moment.
Cheers,
Geoff
From: jamsden@us.ibm.com
Geoff,
That's exactly how I feel about it too. With MKRESOURCE,
perhaps even PUT shouldn't create resources as a side effect, but we
have to be compatible with HTTP conventions.
"Geoffrey M. Clemm" gclemm@tantalum.atria.com on 10/14/99 10:23:30 AM
Having LOCK create a null resource as a side effect?
This can't be "no control coupling" Jim Amsden talking here! (:-).
gmc So I'm back to:
gmc - return a 404 if there is no resource to LOCK,
gmc - let the client create a "null" instance of what it wants there,
gmc - then the client locks that null instance and it is off and running.
1. There is a Very Popular Client which does just about this when
creating a new resource.
2. The main problem with "lock null resources" is that the spec is a
little weak on exactly what they are. That causes me as a server
implementor to try to think too hard, when instead I could be having a
delicious latte on the veranda. To my mind, this really reduces the
chances of most servers ending up with compatible semantics for this.
3. OK, how about this implementation? I grant "lock null resource"
requests, but my server has discretion to vaporize the locks whenever
it wants, and it wants to vaporize them one clock tick after it
creates them. Bwahh-ha-ha-ha! Take that, pesky clients! :-)
4. I run a lot of applications every day that work with my local
filesystem, and they seem to cope without the equivalent of "lock null
resource". If there is a namespace collision, which there often is,
I, as a user, deal with that (including the occasional walk to educate
Wally in the next cubicle). It's an everyday occurrence. That's what
open() with the O_EXCL flag is all about, right? Could it be
paralleled in WebDAV with either (a) expanded use of the OVERWRITE:
header, or (b) HTTP/1.1 PUT, etc, with "IF-NONE-MATCH: *"?
bill@carpenter.ORG (WJCarpenter) PGP
bill@bubblegum.net 0x91865119
38 95 1B 69 C9 C6 3D 25 73 46 32 04 69 D6 ED F3
gmc So I'm not saying that they don't solve any interesting problems
gmc (they do), but rather that the cost of providing them outweighs
gmc the benefits they provide.
Back when this was invented, someone must've thought there were
scenarios where it was pretty important to be able to reserve
namespace to be used later. Would someone care to lay out some
scenarios where this is pretty important? (I'm not disputing it.
Just looking for an education.)
bill@carpenter.ORG (WJCarpenter) PGP
bill@bubblegum.net 0x91865119
38 95 1B 69 C9 C6 3D 25 73 46 32 04 69 D6 ED F3
This is a pretty good restatement of the original rationale for lock-null
resources.
Given the preponderance of evidence that indicates this is a difficult
feature to implement, and since the arguments claiming that the feature is
not strictly necessary appear to be sound, I would be happy to remove this
feature as we move from Proposed to Draft standard, assuming that doing so
does not create any interoperability problems.
Yaron's currently on vacation, he may wish to defend this feature when he
returns. I'm certainly not going to, unless I hear a compelling counter
argument.
- Jim
Given the preponderance of evidence that indicates this is a difficult
feature to implement,
Jim, could you point me to that evidence. Earlier today Geoff defered
that question to a note he said JimA wrote. I did a search for it
and didn't find it. The best I've been able to find is simply
folks saying it's hard... but not explaining why. I'd like to
document this.
From: ccjason@us.ibm.com
Given the preponderance of evidence that indicates this is a difficult
feature to implement,
Jim, could you point me to that evidence. Earlier today Geoff defered
that question to a note he said JimA wrote. I did a search for it
and didn't find it. The best I've been able to find is simply
folks saying it's hard... but not explaining why. I'd like to
document this.
Jason: Both Jim and I were referring to the fact the server
writers that have contributed to this thread have said that lock null
resources were unpleasant/hard to implement, and that they'd prefer to
see them removed from the spec. You are correct the reasons for why
it was hard were not detailed.
My arguments have largely been focused on the fact that they don't do
much for a client, and in some ways can make life harder for both clients
and users.
As a server writer, the following are some of the problems with lock null
resources:
They don't act like normal resources. They return 404's to a GET
as if they didn't exist, but show up in PROPFIND's. Are they a binding,
and therefore part of the state of a collection, or something else?
If you have a versioning server, do you have to checkout a collection
in order to add a lock-null resource to it, or not? If you checkin a
versioned collection that has a lock-null resource in it, does that
make that lock-null resource "immutable" (whatever that means)? Do you
have to checkout the versioned collection in order to remove a lock-null
resource from it? When you do a DELETE, does that delete the lock-null
resource at that spot, or does it leave it alone? When you DELETE a
locked resource, should it delete the lock, or leave a lock-null resource
in its place?
Those are a few of the questions that a server writer must answer, and
then hope that the client writers are expecting that behavior. And then
the server writer has to figure out how to model this behavior with their
underlying implementation objects.
Let me know if you'd like more ... (:-).
Cheers,
Geoff
For collections, this doesn't work properly with your/Alan's proposal for static
depth locking. If I'm creating a collection, I do LOCK (404), MKCOL, LOCK--but
this LOCK only locks the resources that are there now (i.e., none). So anybody
else is free to come along and add new resources, and my lock means nothing. For
collections that are meant to model compound documents or some such, where the
entire state of the collection needs to be treated as a unit, this is a Bad Thing.
|John Stracke | http://www.ecal.com |My opinions are my own.|
|Chief Scientist |=============================================|
|eCal Corp. |Illiterate? Write today for free help! |
|francis@ecal.com| |
From: John Stracke francis@ecal.com
For collections, this doesn't work properly with your/Alan's proposal
for static depth locking. If I'm creating a collection, I do LOCK
(404), MKCOL, LOCK--but this LOCK only locks the resources that are
there now (i.e., none).
Your lock on the collection locks the state of that collection, i.e.
the bindings. That means that only someone with the lock can modify
the state of that collection, such as adding new bindings to it.
So anybody else is free to come along and add
new resources, and my lock means nothing.
Not unless they have the lock. See above.
For collections that are
meant to model compound documents or some such, where the entire state
of the collection needs to be treated as a unit, this is a Bad Thing.
As long as you partition the compound object clearly into disjoint
pieces, and provide a mechanism for locking each of those pieces
(including the pieces that glue the other pieces together, i.e. the
collections!), then you can effectively treat it as a unit by locking
"every piece". The problem with the current state of locking in 2518
is that the various locks overlap in various complex ways, making the
interaction between locks hard for clients to predict and hard for
servers to implement. But I think that we can adjust the protocol to
remove this locking overlap in a way that makes it largely consistent
with the existing clients and servers.
Cheers,
Geoff
running.
Huh? In your original post about static depth locking you say:
Here is (what I consider) to be an extremely sensible proposal from
Alan Babich (from a few months ago). He basically says that if you
are going to do depth locking, it should be static, i.e. it should
be a lock on the current members of the collection. If you MOVE
things into and out of collections (because you have the appropriate
lock tokens for the appropriate collections), it has no effect on
the locks on those resources.
Lock the CURRENT members of the collection.
I believe that is what John was commenting on.
This is giving me a headache :-)
-David
My "summary" of the proposal was too terse. When I said:
"if you are going to do depth locking, it should be static,
i.e. it should be a lock on the current members of the collection"
I should have said:
"... it should be a lock on the collection and its current members"
So every successful LOCK locks at least one resource (with no
Depth header, it is exactly one resource). A key point here
(which I managed to successfully obscure :-) is that a collection
is a distinct resource, and a lock on the collection is independent
of a lock on any of its members (separate resources, separate locks).
And to emphasize, a DELETE and a MOVE are modifications to the state
of the collection containing the resource being deleted/moved. For a
MOVE, it is also a modification to the state of the collection
containing the Destination of the move. In either case, it is not a
modification to the state of the resource being deleted/moved.
Cheers,
Geoff
From: "David Motes" david@pentaventures.com
Huh? In your original post about static depth locking you say:
Here is (what I consider) to be an extremely sensible proposal from
Alan Babich (from a few months ago). He basically says that if you
are going to do depth locking, it should be static, i.e. it should
be a lock on the current members of the collection. If you MOVE
things into and out of collections (because you have the appropriate
lock tokens for the appropriate collections), it has no effect on
the locks on those resources.
Lock the CURRENT members of the collection.
I believe that is what John was commenting on.
This is giving me a headache :-)
-David
Uh, something has been taken out of context.
In Alan Babich's proposal (which I favor a LOT), the depth-0 exclusive lock
on the collection arranges that only the lock holder can add or delete
members. Even with a depth-1 exclusive lock (which prevents alteration of
existing immediate members by anyone but the lock holder) there is no
problem about new members. The lock holder creates them with an exclusive
lock and then inserts them in the exclusively-locked collection. This
provides more than one lock to remove ultimately, but no one said this was
effortless. (A multi-lock unlock-any-of-these operation would be handy and
a boon to clients without doing much to server's in Alan's
simply-deterministic unlock model.)
If you look at the combinatorial complexity and housekeeping requirements, I
say this will be an easy winner so long as depth locking is important. The
fact that you can explain this simple model -- and people can still misread
it -- says a lot about what you are saddled with in 2518. It takes
something to implement the Babich model without literally implementing the
invariants of Alan's proposal, and that tells you something about 2518's
current model too. I'd say you win simply on the reduced complexity of
validation and regression confirmation of an implementation. For me, being
able to explain it and understand its deterministic behavior under all
conditions is the key element. (Yes, I am treating LOCK NULL as orthogonal
to this model.)
-- Dennis
Dennis E. Hamilton
[mailto:w3c-dist-auth-request@w3.org]On Behalf Of David Motes
-----Original Message-----
running.
Huh? In your original post about static depth locking you say:
Here is (what I consider) to be an extremely sensible proposal from
Alan Babich (from a few months ago). He basically says that if you
are going to do depth locking, it should be static, i.e. it should
be a lock on the current members of the collection. If you MOVE
things into and out of collections (because you have the appropriate
lock tokens for the appropriate collections), it has no effect on
the locks on those resources.
Lock the CURRENT members of the collection.
I believe that is what John was commenting on.
This is giving me a headache :-)
-David
John,
Locking a collection means users that do not own the lock cannot modify the
collection. That is, they cannot add or remove members and cannot modify the
collections properties.
John Stracke francis@ecal.com on 10/15/99 09:44:50 AM
Subject: Re: resourcetype locknull
For collections, this doesn't work properly with your/Alan's proposal for static
depth locking. If I'm creating a collection, I do LOCK (404), MKCOL, LOCK--but
this LOCK only locks the resources that are there now (i.e., none). So anybody
else is free to come along and add new resources, and my lock means nothing.
For
collections that are meant to model compound documents or some such, where the
entire state of the collection needs to be treated as a unit, this is a Bad
Thing.
|John Stracke | http://www.ecal.com |My opinions are my own.|
|Chief Scientist |=============================================|
|eCal Corp. |Illiterate? Write today for free help! |
|francis@ecal.com| |
