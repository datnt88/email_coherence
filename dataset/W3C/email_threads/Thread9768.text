At yesterdays telecon, by majority vote, we took two decisions about
datatyping which, if taken together, make RDF datatyping effectively
unusable by anyone except librarians. I cannot produce a coherent
model theory for datatyping which satisfies both of these conditions
at the same time, and would suggest that one of them should be
reconsidered. This message tries to briefly explain the problem, and
suggest some alternative ways out of it. I recommend option C below.
The decisions were that (1) we should support the S-B idiom:
Jenny ex:age "10" .
ex:age rdfs:range xsd:integer .
and (2) that the literal in such examples should denote itself, ie
the above asserts that Jenny's age is the string '10'.
(BTW, I know I voted for 1, but at the time I didn't think that
anyone who voted for 1 could possibly vote for 2 as well. )
The problem with this combination is that it seems to have the
inevitable consequence that the class named by a datatype name must
be the set of *lexical forms* of that datatype, rather than the value
space of the datatype. In this example, it requires RDF to treat
xsd:number as a class of numerals - character strings which denote
numbers - rather than a class of numbers. The problem now is that if
that is what the datatype class name is used for, then there is no
way to refer to the class of values of a datatype. This might be
appropriate for an ontology dealing with documents, of course, such
as Dublin Core or SS/BB, but it is fatal for any kind of applied
ontology work or interfacing to most applications, and will be
immediately (and correctly) rejected by DAML+OIL and Webont as
unacceptable and unworkable.
Now, one option here would be to just smile at this - after all, we
are the RDF WG, not Webont - but I would suggest that if we are at
all interested in the possibility of RDF being acceptable as a
foundation for any more ambitious efforts, rather than an dead end,
we should pay attention to the likely needs of most people on the
planet, who will want to use numerals to refer to numbers, rather
than treating the entire XML datatyping scheme as a way of
classifying character strings.
I have been trying to come up with some way out of this dilemma, and
there are several options I can see. Right now I personally prefer B,
but think that C is the best (simplest) compromise, and one that
would be acceptable to the most people (both on and off the WG).
A. The S-B idiom could be replaced by something more complicated
which expresses the intended restriction of the literal to the space
of lexical forms of the datatype. For example, it could be done by
replacing the rdfs:range assertion by the linked pair of range
assertions:
ex:age rdfs:range _:x .
xsd:integer rdfs:range _:x .
If that is acceptable, then that solves the problem, since it frees
up the datatype name itself to have the value space as its extension
when used as a class name. However, I have a nagging feeling that it
will not be acceptable to some people, since anyone who thinks that
S-B is meaningful as it stands is probably under the impression that
datatype class names *do* refer to sets of lexical forms, and will
therefore find this puzzling.
That would require us to reconsider decision (1).
B. We could follow the approach outlined in
***Note, there are still some bugs in the MT equations in that
document.***.
which supports the the S-B idiom, but assigns it a different meaning:
according to this approach, Jenny's age would be ten rather than
'10'. However, the intended restriction to the datatype range works,
eg the literal "humpty" rather than a numeral would still produce a
datatyping error.
This proposal also the merit of not requiring the use of rdfs:drange;
it works by 'overloading' rdf:range. It can also, with a little
tweaking to the MT, be used with tidy literal nodes (and although, as
noted in the document, that would need to be revised if literals were
allowed to be subjects, I would predict that tidy literal nodes would
need to be reconsidered in that case anyway.)
I believe this is the first proposal that combines tidy literals with
the possibility of having datatype-sensitive denotations for
literals, by the way.
That would require us to reconsider decision (2)
C. (New idea, see
for a write-up.)
If we are willing to re-introduce rdfs:dtype (or some other special
vocabulary) then it is possible to combine the two decisions
coherently, with the S-B idiom suitably modified. That is, we can use
rdfs:dtype to impose 'lexical' constraints on the in-line literal
use, as in S-B, and also 'value' constraints on the bnode idiom:
Jimmy ex:age _:x .
_:x rdfs:dlex "10" .
at the same time, without getting the ranges mixed up. The first
asserts that Jenny's age is the lexical form '10'; the second asserts
that Jimmy's age is the number ten. The idea here is that the
rdfs:drange assertion is used PURELY to assign datatype restrictions
to properties, and says NOTHING AT ALL about their ranges. So
rdfs:drange and rdfs:range are completely independent; neither is
assumed to be a subproperty of the other. This frees up the
rdfs:drange from any commitment to the rdfs class interpretation of
the datatype, and allows us to continue to utilize the class name to
refer to the value class (and use the idiom suggested in A above to
refer to the lexical class, if required) independently of the
imposition of datatyping conditions.
Of course we cannot use rdfs:range in this case, so this would
require us to reconsider decision (1); but the required change is
minimal.
In many ways C, is the 'leanest' option so far, in the sense that
it provides the most flexibility with the minimum of syntactic and MT
complexity; it uses tidy literals which always denote themselves, and
leaves the undatatyped MT completely unchanged.
Pat
IHMC(850)434 8903 home
40 South Alcaniz St.(850)202 4416 office
phayes@ai.uwf.edu
I have no problem with the basic concept behind this, but I think that this
specific version of it isn't going to work since it's impossible to write in
RDF/XML.
I think Brian made it very clear that the range in one wasn't necessarily
rdfs:range. It could also be rdfd:range. I think this would be an adequate
solution also.
[ "Aaron Swartz" ; mailto:me@aaronsw.com ; http://www.aaronsw.com/ ]
One way to express the above semantics, which I've proposed
before with no response whatsoever from anyone, is to use a
specific range property that asserts a lexical space specific
constraint on property values.
I.e. rdfs:lrange.
It can be easily expressed in RDF/XML.
It has clear, reasonably mnemonic meaning to users.
It leaves rdfs:range to denote constraint to value space.
It is close enough to rdfs:range that it will seem familiar
while having a mnemonic distinction (l for lexical).
I'm not saying yet which of the three proposals, if any, I wan't
to vote for (have to sleep on it a bit) but I think rdfs:lrange
would sufficiently address the objections to the expression of
this particular approach.
That's true. Though from the perspective of the less-technical
users, a somewhat mnemonic property would I think be appreciated,
and the least amount of new vocabulary as possible.
Using rdfs:range and rdfs:lrange provides that and covers the
bases.
Of course, no matter what we call the ranges or how we express
them, having range constraints for both value and lexical space
in the same graph will raise a conflict. This is a problem with
cohabitation of the inline and bNode idioms that was pointed out
since the earliest considerations of S.
If we are to allow both idioms to co-exist in the same graph, and
I think we must, then we will need a third "flavor" of range
constraint -- one which allows members of either lexical or value
space, leaving it to the graph syntax (literal or bNode) to discern
the distinction. If it is a literal, it is a member of the lexcal
space. If it is a bNode, it denotes a member of the value space.
I think that perhaps Pat's finding of such a "union" range constraint
as unworkable hinges on the fact that it treats the internal structure
of the datatype as opaque, not concerning itself about whether there
actually are two different spaces and what their relationship is,
but just treats all members of all spaces as equal members of the
*RDF* datatype class.
It may very well be that this is too ambiguous for e.g. entailment
proofs (though I'm not sure we have fully explored the options there)
but it does meet the needs to express datatyping in both inline and
bNode idioms and constrain property ranges to either flavor of idiom.
I don't want to reduce the utility of RDF datatyping for WebOnt, but
at the same time, don't want to see it too cumbersome and confusing
for the metadata and content management communities also. And there
is always the option of providing a solution now that has minimal
definition in the MT and the remainder expressed in axiomatic rules
and by other explicit means (even if less formal that the MT) which
captures the idioms and expected meaning of them insofar as humans
are concerned, and then continue to work on a more comprehensive
MT treatment of datatyping in terms of the MT -- i.e. if we decide
at this very moment in time to only capture pairings in the MT, per
the "Dummies" proposal, that doesn't mean that we have given up on
an MT account of datatyping suitable for WebOnt, only that that must
come as a subsequent (possibly immediate) next step, either by us
(if we still have time/energy) or by WebOnt or some other WG.
Need to think on this still a little bit (as I'm sure we all do).
Patrick
Following Patrick's suggestion, I would like to urge that we allow
the use of rdfs:lrange. I know this looks like terminology-bloat, but
it makes possible a very elegant and I think easy-to-use way to
display the user options (see *** below).
In the interests of everyone's sanity, I will not put this up as yet
another web document.
Right, I like this idea and suggest that we adopt it. So the
definition of rdfs:lrange is as follows:
aaa rdfs:lrange ddd .
means that the rdfs:range of aaa is the lexical space of the datatype ddd .
(The MT is:
IEXT(I(rdfs:lrange)) = { x,y : u,v in IEXT(x) implies L2V(y)(v)
is defined }
That makes this synonymous with
aaa rdfs:range _:x .
ddd rdfs:range _:x .
but we can relegate that to an appendix somewhere. We also have to
say what rdfs:lrange means if ddd is not a datatype. It could still
mean the same as the bnode pair, or it could be vacuous. Whatever, a
technical niggle.)
Fair enough, even though our priorities differ.
I really do not think that this proposal is cumbersome or confusing.
Clear your minds for a second of all the debates, take a deep breath,
and imagine, if you can, a blank sheet of paper, and then write this
on it:
aaa rdfs:range xsd:number .
just means the range of aaa is the set of numbers, ie the value space
of the datatype (and has no special datatyping effect on any
literals.)
aaa rdfs:lrange xsd:number .
just means the range of aaa is the set of numerals, ie the lexical
space of the datatype (and has no special datatyping effect on any
literals.)
aaa rdfs:drange xsd:number .
doesn't say ANYTHING about the rdfs:range, but it does impose
datatype-checking on literals (used in either mode, ie with an
rdfs:dlex triple - when the bnode is constrained to the datatype
value of the literal - or the S-B idiom - when the literal is
constrained to be in the lexical space of the datatype; see the
figure in
Intuitively, the first is all about the value space, the second is
all about the lexical space, and the last is all about the
lexical-to-value mapping (and what it does to literals).
So if you want to be DC-sloppy, just use rdfs:drange; you get full
datatype checking but no range constraints. (The range could be the
union in this case, or it could be something else.) If you want to be
precise about your ranges, use one of the first two options. If you
want to be precise and also use datatype-checking, use one of the
first two plus the third (it works with either one equally well, so
that range precision can be added later without having to re-do the
datatyping).
If you want to be precise about ranges, do datatyping and ALSO allow
sloppiness, all at the same time, then you have to be slightly
clever, and use three properties such as ageAsNumber/ageAsString/age,
with the first two being subproperties of the last one and the three
options applied to each one (in that order.) This provides both
'exact' options and also the 'sloppy' option, but the same datatyping
works for them all. This is the only time you have to think about
schemas.
Pat
PS. Just as a general plea to the WG: OK, we have to coddle our
DC-style users. But please, guys, bear in mind that having RDF be a
foundation for Webont is not just a sci-fi fantasy. It is really the
only long-term reason for having RDF around. It is vitally important
that RDF be provided with at least a minimal ability to express what
needs to be said in a semantically precise way. It is going to have
to be able to express, maybe indirectly, *any* content that can be
said in *any* Web language. Already there is enormous 'layering'
hooha going on which arises from RDF's weaknesses as a foundation. If
we make it so dumbed-down that it can ONLY be used for DC-style apps,
then we will have shot Webont in the foot.
PPS. It occurs to me that we could use the name rdfs:dcrange rather
than drange, and say that it means "Datatype Check on range". That
might make the DC users feel even more at home.
IHMC(850)434 8903 home
40 South Alcaniz St.(850)202 4416 office
phayes@ai.uwf.edu
There was no requirement in what we agreed that the range constraint
property was rdfs:range or that value of the property was xsd:integer.
No. What we decided leaves us free to use a different range property or
xsd:integer.lex.
In my view, webont are a very important customer of our work. When I took
this on, I believed that the major challenge we faced is that RDF is trying
to serve two masters, those who want a simple meta data language and those
who want a formal foundation for it. That's hard, but that is what we are
trying to do.
At the very least we must not mess things up for webont to build on rdf.
Brian
