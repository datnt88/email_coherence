Thanks for the new release! Incidentally, the bugs I recently reported in
the 7-Jul-99 Tidy are reproducible in the new 29-Jul-99 version.
Here's a new bug report:
The HTML document below has a table row containing a bad font tag with no
content, no ending /font tag, and no enclosing table cell. 26-Jul-99 Tidy
crashes (on Windows NT, at least) trying to access an illegal address. Andy
Quick's 7-Jul-99 Java version also crashes (with a NullPointerException),
suggesting that the problem in the C version is with the value of prev in
parser.c, TrimInitialSpace(), line 194:
if (prev- type == TextNode)
-------- Example HTML document --------
Thanks,
Randy
Just an FYI, it is not crashing on the Mac OS version.
Here is the error output I am getting from the test case above (using the
26th July 99 sources ) :
Tidy (vers 26th July 1999) Parsing "bad font in tr .html"
line 8 column 9 - Warning: font isn't allowed in tr elements
line 9 column 7 - Warning: discarding unexpected /tr
line 10 column 5 - Warning: discarding unexpected /table
line 11 column 3 - Warning: missing /font before /body
line 11 column 3 - Warning: trimming empty font
line 11 column 3 - Warning: trimming empty tr
line 11 column 3 - Warning: missing /table before /body
line 11 column 3 - Warning: trimming empty table
"bad font in tr .html" appears to be HTML 4.0 Transitional
8 warnings/errors were found!
Here is the cleaned output :
Regards, Terry
This is caused by a bug in TrimInitialSpace() in parser.c
which failed when the element is the first in the content.
The revised routine is as follows:
void TrimInitialSpace(Lexer *lexer, Node *element, Node *text)
Node *prev, *node;
if (text- type == TextNode &amp;&amp; lexer- lexbuf[text- start] == ' ')
if (element- tag- model &amp; CM_INLINE &amp;&amp;
element- parent- content != element)
prev = element- prev;
if (prev &amp;&amp; prev- type == TextNode)
if (lexer- lexbuf[prev- end - 1] != ' ')
lexer- lexbuf[(prev- end)++] = ' ';
++(element- start);
else /* create new node */
node = NewNode();
node- start = (element- start)++;
node- end = element- start;
lexer- lexbuf[node- start] = ' ';
node- prev = prev;
if (prev)
prev- next = node;
node- next = element;
element- prev = node;
node- parent = element- parent;
/* discard the space in current node */
++(text- start);
Regards,
-- Dave Raggett dsr@w3.org http://www.w3.org/People/Raggett
World Wide Web Consortium (on assignment from HP Labs)
Dave,
I hope you and your family had a wonderful time!
Thanks for the fixes.
Randy
