interface NodeList
Node item(in unsigned long index);
readonly attribute unsigned long length;
NodeLists are said to be live such that additions/deletions of children
will be reflected in the NodeList I retrieved prior to the
addition/deletion... Without copying the children to a private object
instance, or locking children nodes; how do I know that the length is valid
when I attempt to iterate over the list?
I don't see problems for a single client environment, but for
connectionless multi-client internet applications; seems a bit sticky.
Comments? Thanks.
Don Hamson
Question 1: What does the following code fragment do?
1 NodeList nl = aDocument.getElementsByTagName("p");
2 int numberOfParagraphs = nl.getLength();
3 for (int i = 0; i  numberOfParagraphs; i++) {
4Node n = nl.item(i);
5n.getParentNode().removeChild(n);
6 }
Answer:
It deletes all of the odd-numbered paragraphs in aDocument, and finally
throws a null pointer exception (NOT a DOMException, since item throws no
exceptions) on line 5 when i  numberOfParagraphs/2. Of course, in a
language like C++ on an OS like Windows, it simply crashes.
Notes:
Caching the length of a NodeList in this way is the only reasonable thing
to do in most cases, because computing it is so expensive. The _correct_
way of deleting all the paragraphs in a document is, of course, to
replace line 3 with:
3' for (int i = numberOfParagraphs - 1; i  = 0; i--) {
but I suspect that this might not be obvious to the ``naive'' script-
writer.
Question 2:
Is this really what you mean by catering to the needs of naive
programmers?
Stephen R. Savitzky Chief Software Scientist, Ricoh Silicon Valley, Inc.,
steve@rsv.ricoh.com California Research Center
home: steve@starport.com URL: http://www.starport.com/people/steve/
Ray Whitmer wrote,
Any implementation which:
1. Caches seen items in the NodeList in something indexable
like an array.
2. Has a simple hierarchical comparison function that given
two nodes can check their traversal order.
can do a simple binary search on the cached items of the
nodelist and remove any nodes that fall in the range being
removed.
On the other hand, any implementation which:
1. Caches a single node with an index.
2. Has a simple hierarchical comparison function that given
two nodes can check their traversal order.
can quickly identify removed nodes which require the index of
the cached node to be modified.
Even cases where the current or single node is removed, it is
not difficult to store a nearby neighbor as the place where
searching is to resume for the removed index. Thus the
remove(list.item(0)) loop can be quite efficient.
Perhaps, perhaps not.
The trouble with your suggestion is that it seems to require
that every active NodeList on a given subtree (maybe all active
NodeLists over the whole tree?) has to be visited each time that
subtree is modified. This means that we have an extra multiplier:
the number of active NodeLists. Now, how many of those are there?
How long is a piece of string? In Java, at least, this is a
serious issue, because the vagaries of GC make it impossible
to tell particularly early whether or not a NodeList is in use.
Implementations which keep an edit count at each Node have
an advantage here, in that they *don't* have to visit each
NodeList (the same would apply for iterators). The performance
issue now boils down to: is the number of active NodeLists
likely to be sufficiently large to outweigh the kind of
gains you describe.
Bizzarely it looks as though the very efficiency that the
strategy you describe provides will be self-defeating: the
faster NodeLists are the more tempting it is to use 'em;
but the more you use 'em, the slower they get.
None of us have any way of knowing a general answer to that
question, because it depends on how the DOM is used.
Cheers,
Miles
Every Nodelist started from any ancester of the subtree which is
modified must be visited. That is not a big list of nodes to visit. If
there are thousands of active NodeLists, Iterators, etc. it could be a
bottleneck.
Yes, it could degrade if badly overused. But what I was pointing out
that the iterators have to be fixed up in a similar fashion. There is
no big win using iterators in the given use cases.
This specification does not look bad, and there seems to be a distinct a
lack of alternatives that would perform better.
If you like static lists better, write simple method that iterates the
entire nodelist, building a static list and despose it before someone
has a chance to mutate it, and you will have about the same (miserable
for most of my uses) performance you would have gotten if static lists
had been part of the spec.
Ray Whitmer
ray@imall.com
