The traditional meaning of 'bag' is:
If
Bag(?x) and Bag(?y)
and
forall ?z, count(?x, ?z) = count(?y, ?z)
then
?x = ?y.
We can't apply this directly to memebers
of class rdf:Bag, because we would end up with
the corrollary:
rdf:_1(?x) = rdf:_1(?y)
rdf:_2(?x) = rdf:_2(?y)
rdf:_3(?x) = rdf:_3(?y)
and so on; this doesn't work out; for example,
consider
?x = Fred, Fred, Bob
?y = Bob, Fred, Fred
we'd end up with Fred = Bob, which isn't
what we want.
But consider an asRealBag property that relates
rdf:Bag's to RealBag's; we start with an
axiom that says there's exactly one for every
rdf:Bag:
for all ?b, if type(?b, rdf:Bag)
then there exists ?b' where
asRealBag(?b, ?b') and type(?b', RealBag) and
forall ?x, if asRealBag(?b, ?x) then ?x = ?b'.
in DAML+OIL terms, asRealBag has cardinality
1 on class rdf:Bag.
Then we define the membership of the real bag
straightforwardly:
if bagMember(?b, ?b') then
forall ?x,
bagMember(?b', ?x) iff
exists ?cmp with
type(?cmp, rdfs:ContainterMembershipProperty)
and ?cmp(?b, ?x)
Hmm... this is of limited utility, due
to the "and that's all!" problem with
rdf container syntax (i.e.
rdfms-seq-representation). There's no
way to tell that something is *not*
in a bag. But maybe we'll fix that someday.
Anyway... then we'd say that for RealBags,
If
RealBag(?x) and RealBag(?y)
and
forall ?z, count(?x, ?z) = count(?y, ?z)
then
?x = ?y.
Now the RealBags can be in the universe
of discourse (my preference), or they can
just be artifacts
in the model theory (replace
the asRealBag property with
a BagEXT ala IEXT and CEXT).
Anyway... that's my idea. I meant to write
it down in RDF/n3, but I haven't gotten
around to it. Maybe Jos will beat me to it. ;-)
Is there code out there that behaves this
way, does anybody know? would it be useful
to specify it sorta like this? Or should
we leave rdf:Bag as just a hint,
ala rdf:Alt?
Dan Connolly, W3C http://www.w3.org/People/Connolly/
Oh Dan, you have no idea how such sentences
are triggering something in me (even so hard
that I just forgot to put the lights of my car
on while I was picking up my daughter at
the trainstation, and it was very dark...)
Suppose we can use your proposed lists as
( first-item-of-list / rest-of-list )
and also ?v for u.q. variables
then we could write in N3
( ) :sameBagAs ( ) .
and
{ ( ?a ?c ) :remove ?x . ?b :sameBagAs ?x }
log:implies
{ ( ?a / ?b ) :sameBagAs ?c } .
which is using predicate "remove" which is like
( item list ) :remove list-with-removed-item
such that
( ?a ( ?a / ?c ) ) :remove ?c .
and
{ ( ?a ?b ) :remove ?c }
log:implies
{ ( ?a ( ?x / ?b ) ) :remove ( ?x / ?c ) } .
that may seem dark, but it actually works
when we add those implications to
i.e.
( :a :a :b ) :sameBagAs ( :b :a :a ) .
Jos De Roo, AGFA htt://www.agfa.com/w3c/jdroo/
Or we could hack it in RDF now by saying that the RealBag ends where
the special end marker is in the ordinary bag, and the rest is just,
er, baggage.
Mine too.
I think thats what we (ie the WG) should do. It leaves this (and
other doors) open, but we don't have time to check that this is the
One Best Way.
Pat
IHMC(850)434 8903 home
40 South Alcaniz St.(850)202 4416 office
phayes@ai.uwf.edu
