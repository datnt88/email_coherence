84. Section 14.2, pg. 93, 4th para., has "the server SHOULD send an
error response with the 406 (not acceptable) status code, though the
sending of an unacceptable response is also allowed." The effect of the
final clause of this statement is to downgrade SHOULD to MAY. Either
remove the final clause or change to MAY. [My preference is to remove
the final clause.] Note that the semantics stated here are expressly
different from Accept and Accept-Encoding which do require 406
responses for unconditionally compliant implementations. This
inconsistency will make it difficult or impossible to implement
agent-driven content negotiation based on Accept-Charset variants.
What is the correct fix here? Opinions solicited.
- Jim
84. Section 14.2, pg. 93, 4th para., has "the server SHOULD send an
error response with the 406 (not acceptable) status code, though the
sending of an unacceptable response is also allowed." The effect of the
final clause of this statement is to downgrade SHOULD to MAY. Either
remove the final clause or change to MAY. [My preference is to remove
the final clause.] Note that the semantics stated here are expressly
different from Accept and Accept-Encoding which do require 406
responses for unconditionally compliant implementations. This
inconsistency will make it difficult or impossible to implement
agent-driven content negotiation based on Accept-Charset variants.
IMO, no fix is required. In my mind, SHOULD and MAY are very close.
Furthermore, the wording looks to me like that for Accept and
Accept-Encoding w.r.t. 406 as far as unconditional compliance is
concerned. And for conditional compliance, servers have the option of
sending an "unacceptable response" in place of an error response. (We
just went over this territory with my question about Accept-Encoding
( http://www.ics.uci.edu/pub/ietf/http/hypermail/1998q4/0057.html ).
Dave Kristol
Glen Adams notes:
84. Section 14.2, pg. 93, 3rd para., is quite confusing: suggest
rewriting without using the term "mentioned". Also, this para. seems to
be stating that if any "iso-8859-1;q=1" is always implied unless
otherwise explicitly present. This means that:
Accept-Charset: iso-8859-5, unicode-1-1;q=0.9
really means
Accept-Charset: iso-8859-1;q=1, iso-8859-5;q=1, unicode-1-1;q=0.9
(in which case 8859-1 would be given equal billing with 8859-5). And
that consequently the only way to exclude 8859-1 is to specify
Accept-Charset: iso-8859-1;q=0, iso-8859-5, unicode-1-1;q=0.9
Is this the intended usage? If so, I find this not only convoluted but
seriously sub-optimal. This emphasis on 8859-1 as default really is too
much. Why go so far overboard?
Not being a charset wizard, I don't have a good feeling for whether
any change is necessary.
Comments?
- Jim
Sorry for the slow response - due to a mailing list malfunction,
I wasn't getting HTTP-WG messages for a few days.
In most cases, the 'cachable' constraint is not on whether
you store the value in a cache, but whether you USE the
cached value. Now, it may be foolish to cache something that
you cannot use, but perhaps not; e.g., even if the results
aren't exactly cachable, could you use delta-coding on the
next request with an appropriate entity tag?
Yes indeed. This might be one of the biggest payoffs for
delta-encoding, since it allows the "virtual transmission"
of a sequence of changing responses without actually sending
all of the bits over and over again.
I don't know whether it's best to say SHOULD NOT and let
implementors figure out the constraints, or to go ahead
and use MUST NOT, but to carefully redefine 'cachable' or
'cached' to mean that the cached value cannot be used,
and thus probably shouldn't be stored.
I agree that the term "cachable" may be a poor one to use in a
statement of formal requirements. But we *do* have the right
formal definition in section 1.3:
cachable
A response is cachable if a cache is allowed to store a copy of
the response message for use in answering subsequent requests. The
rules for determining the cachability of HTTP responses are
defined in section 13. Even if a resource is cachable, there may
be additional constraints on whether a cache can use the cached
copy for a particular request.
although I'm not sure I would trust every implementor to read and
internalize these definitions. Fortunately, the folkloric definition
of "cachable" (meaning: to store at all in a cache) is a stronger
requirement. So an implementor who uses the folkloric definition,
rather than the formal one, risks losing efficiency but not
transparency.
However, Jim proposed:
Responses to methods other than GET or HEAD MUST NOT be cached,
unless the response includes appropriate Cache-Control or Expires
header fields
and the verb here ("be cached") is not formally defined in the
sense that Larry describes, as far as I know. I'd suggest:
Responses to methods other than GET or HEAD MUST NOT be treated
as "cachable" (by the definition in section 1.3),
unless the response includes appropriate Cache-Control or Expires
header fields.
"Responses to methods other than GET or HEAD MUST NOT be cached,
unless the response includes appropriate Cache-Control or Expires
header fields"
I believe that the spec makes the above statement somewhere already,
though I just tried to find it and failed. Jeff?
Hmm. Section 13.4 (Response Cachability) says something
vaguely similar, although it might say something wrong: it
doesn't mention any methods, but says (in effect) that all
status-200 responses are cachable unless otherwise marked.
Since POST definitely allows a status-200 response and is
by default not cachable (section 9.5), this is a contradiction.
I did a quick search for a statement matching the one that Jim
suggests, and didn't find it (which doesn't mean that it isn't
there).
My suggested fix:
(1) In 13.4 change:
Unless specifically constrained by a cache-control (section 14.9)
directive, a caching system MAY always store a successful response
(see section 13.8) as a cache entry, MAY return it without validation
if it is fresh, and MAY return it after successful validation.
to:
Unless specifically constrained by a cache-control (section 14.9)
directive, a caching system MAY always store a successful response
(see section 13.8) to a GET or HEAD request
as a cache entry, MAY return it without validation
if it is fresh, and MAY return it after successful validation.
A caching system MUST NOT treat responses to other methods
as cachable (by the definition in section 1.3) unless the
response includes Cache-Control or Expires header fields
implying that the response is cachable.
(2) In section 9, make a forward reference to section 13.4?
-Jeff
This doesn't work with the wording in section 13.11 which I am basing the
cache interactions for the M- methods used by the HTTP Extensions
Framework on:
All methods that might be expected to cause modifications to the origin
server's resources MUST be written through to the origin server. This
currently includes all methods except for GET and HEAD. A cache MUST NOT
reply to such a request from a client before having transmitted the request
to the inbound server, and having received a corresponding response from the
inbound server. This does not prevent a proxy cache from sending a 100
(Continue) response before the inbound server has sent its final reply.
The alternative (known as "write-back" or "copy-back" caching) is not
allowed in HTTP/1.1, due to the difficulty of providing consistent updates
and the problems arising from server, cache, or network failure prior to
write-back.
The latest draft of the HTTP Extension Framework is available at
I don't mind that the request to the origin server is made conditional
but it must not be served without having been forwarded to the origin
server.
Henrik
Henrik Frystyk Nielsen,
World Wide Web Consortium
This doesn't work with the wording in section 13.11 which I am
basing the cache interactions for the M- methods used by the HTTP
Extensions Framework on:
I don't mind that the request to the origin server is made
conditional but it must not be served without having been forwarded
to the origin server.
If the origin server is using an extension that does require
write-through, then it shouldn't be sending responses with
something like:
Cache-control: max-age=12345
which implies cachability. In the case you're describing, the
origin server has to send something like
Cache-control: max-age=12345, must-revalidate
or
Cache-control: max-age=0, must-revalidate
to get the right semantics.
Unless your extension mechanism wants to support extensions
where the origin-server is ignorant of the caching implications
(which seems foolish), then I think we already have the necessary
mechanisms in place, and we shouldn't be adding new restrictions.
-Jeff
This is different from the cache semantics that I am after.
There is a large group of extensions which your proposed change will
impact: the group of extensions describing under which terms a cached
entry can be handed out based on payment, copyright, licensing, content
filtering, added service, etc.
If the cache knows about one of these mandatory extensions (using the M-
prefix) then it should be able to serve the request without revalidating
the response. Imagine if 80% of requests are M- prefixed with some widely
used copyright extension then the forced revalidations are potentially
seriously impacting cache performance without reason.
True, caches that don't understand the extension will have to validate but
on the other hand, if the extension is fully cachable by everyone then it
hardly calls for messing with the method name but instead for an optional
extension. There is no need to produce more than one GET method.
I do not believe we at this point can change whether we consider caching or
the method to be the highest in the hierarchy.
Henrik
Henrik Frystyk Nielsen,
World Wide Web Consortium
There is a large group of extensions which your proposed change
will impact: the group of extensions describing under which terms
a cached entry can be handed out based on payment, copyright,
licensing, content filtering, added service, etc.
If the cache knows about one of these mandatory extensions (using
the M- prefix) then it should be able to serve the request without
revalidating the response. Imagine if 80% of requests are M-
prefixed with some widely used copyright extension then the forced
revalidations are potentially seriously impacting cache performance
without reason.
True, caches that don't understand the extension will have to
validate but on the other hand, if the extension is fully cachable
by everyone then it hardly calls for messing with the method name
but instead for an optional extension. There is no need to produce
more than one GET method.
Henrik, please read section 14.9.6 (Cache Control Extensions).
It already handles the problem you are describing. For example,
an extension can define the meaning of a new cache-control
directive (let's call it "henrik-mode"), and send:
Cache-control: max-age=0, must-revalidate, henrik-mode=999
Any cache that doesn't understand your extension must ignore
"henrik-mode" and so will do the necessary revalidation. If
the cache does understand your extension, 14.9.6 allows it
to use the "henrik-mode" directive to modify the behavior
of the other two ("modify" may mean "ignore").
I do not believe we at this point can change whether we consider
caching or the method to be the highest in the hierarchy.
I don't think at this point we should be proposing changes to
the HTTP/1.1 protocol without first reading the existing
specification :-)
-Jeff
Jim Gettys:
84. Section 14.2, pg. 93, 3rd para., is quite confusing: suggest
rewriting without using the term "mentioned". Also, this para. seems to
be stating that if any "iso-8859-1;q=1" is always implied unless
otherwise explicitly present. This means that:
Accept-Charset: iso-8859-5, unicode-1-1;q=0.9
really means
Accept-Charset: iso-8859-1;q=1, iso-8859-5;q=1, unicode-1-1;q=0.9
(in which case 8859-1 would be given equal billing with 8859-5). And
that consequently the only way to exclude 8859-1 is to specify
Accept-Charset: iso-8859-1;q=0, iso-8859-5, unicode-1-1;q=0.9
Is this the intended usage? If so, I find this not only convoluted but
seriously sub-optimal. This emphasis on 8859-1 as default really is too
much. Why go so far overboard?
I am not charset wizzard, but I play one on the net. The current
language is correct, no change should be made. It is this convoluted
for historical/compatibility reasons.
Koen.
Jeffrey Mogul:
For the record: I support this proposed change. This is exactly what
we need.
I don't really understand Henrik's objections, but I have the feeling
that they are based on the mistaken assumption that the above addition
specifies a top-level requirement which cannot be overridden. The
addition actually only specifies what the default is if there is no
Cache-Control header in the response.
Koen.
What is the cache allowed do in the following scenario:
client A to proxy:
FOO / HTTP/1.1
host: some.host
proxy to origin
FOO / HTTP/1.1
host: some.host
via: ...
origin to proxy
HTTP/1.1 200 OK
Cache-control: max-age=3600
client B to proxy
BAR / HTTP/1.1
host: some.host
Can it return the cached response? Do we need a vary on the method name?
The definition in 1.3 doesn't indicate this.
Regardless, do you agree that the wording conflicts with 13.11:
All methods that might be expected to cause modifications to the origin
server's resources MUST be written through to the origin server. This
currently includes all methods except for GET and HEAD. A cache MUST NOT
reply to such a request from a client before having transmitted the request
to the inbound server, and having received a corresponding response from
the inbound server. This does not prevent a proxy cache from sending a 100
(Continue) response before the inbound server has sent its final reply.
and also with 5.1.1
Servers SHOULD return the status code 405 (Method Not Allowed) if the
method is known by the server but not allowed for the requested resource,
and 501 (Not Implemented) if the method is unrecognized or not implemented
by the server.
where it in 1.3 it is stated how a server at any time can become a tunnel
Server
... Likewise, any server may act as an origin server, proxy, gateway, or
tunnel, switching behavior based on the nature of each request....
in which case it can't be a cache:
Cache
...Any client or server may include a cache,
Anyway, the reason why I don't think this is a good idea is that *if* a
response is fully cachable regardless of whether the method is understood
or not, then it smell, feels, and looks like a GET request. There is
absolutely no reason to have several GET-alike methods. GET is special
because it is special because it is special.
Note, that this has nothing to do with your cache control extensibility
which I like (and know about) - it just shouldn't be applied to responses
from operations by unknown methods.
A confused? Henrik
Henrik Frystyk Nielsen,
World Wide Web Consortium
What is the cache allowed do in the following scenario:
client A to proxy:
FOO / HTTP/1.1
host: some.host
proxy to origin
FOO / HTTP/1.1
host: some.host
via: ...
origin to proxy
HTTP/1.1 200 OK
Cache-control: max-age=3600
client B to proxy
BAR / HTTP/1.1
host: some.host
Can it return the cached response? Do we need a vary on the method
name? The definition in 1.3 doesn't indicate this.
First of all, the *definition* of "cachable" in 1.3 has nothing
to do with the *specification* of what the proxy is supposed to
do. So I'll ignore that part of your question, rather than trying
to guess what you really meant.
Second, I see what you mean about the need to match the method
name, since otherwise I think we're in dangerously undefined
territory. So I guess that sentence I added should become
A caching system MUST NOT treat responses to other methods
as cachable (by the definition in section 1.3) unless the
response includes Cache-Control or Expires header fields
implying that the response is cachable, and the subsequent
request uses the same method as the request that generated
the response.
Note that the preceding sentence basically includes the usual
exception to the method-matching rule (GET and HEAD "match")
with the implicit understanding that a cache can't take a HEAD
response and give it back for a new GET request. Do we need
to make this explicit, too?
Regardless, do you agree that the wording conflicts with 13.11:
All methods that might be expected to cause modifications to the
origin server's resources MUST be written through to the origin
server. This currently includes all methods except for GET and
HEAD. A cache MUST NOT reply to such a request from a client before
having transmitted the request to the inbound server, and having
received a corresponding response from the inbound server. This
does not prevent a proxy cache from sending a 100 (Continue)
response before the inbound server has sent its final reply.
Well, I could try to wriggle out of this one, but I admit that this is
a little flakey. After all, the MUST applies with the precondition
"that might be expected to cause modifications", and perhaps it's
reasonable that if the cached response with the same method has
a non-zero max-age value, then the method shouldn't be expected
to cause modifications. But the second sentence does contradict this.
So I would change this to:
All requests that might be expected to cause modifications to the
origin server's resources MUST be written through to the origin
server. This currently includes all methods other than GET and
HEAD, unless the request (including its method) matches a cached
response that includes Cache-Control or Expires header fields
implying that the response is cachable.
A cache MUST NOT reply to such a request from a client before
having transmitted the request to the inbound server, and having
received a corresponding response from the inbound server. This
does not prevent a proxy cache from sending a 100 (Continue)
response before the inbound server has sent its final reply.
I can guess that Jim is probably getting itchy.
and also with 5.1.1
Servers SHOULD return the status code 405 (Method Not Allowed) if
the method is known by the server but not allowed for the requested
resource, and 501 (Not Implemented) if the method is unrecognized
or not implemented by the server.
where it in 1.3 it is stated how a server at any time can become a
tunnel
Server
... Likewise, any server may act as an origin server, proxy,
gateway, or tunnel, switching behavior based on the nature
of each request....
in which case it can't be a cache:
Cache
...Any client or server may include a cache,
If you interpret SHOULD as MUST. I don't. Since I wasn't involved
in writing 5.1.1, I'm not sure whether it really meant to say
MUST (or if the word "server" here really includes "proxy").
Anyway, the reason why I don't think this is a good idea is that
*if* a response is fully cachable regardless of whether the method
is understood or not, then it smell, feels, and looks like a GET
request. There is absolutely no reason to have several GET-alike
methods. GET is special because it is special because it is
special.
I think the point is that if an origin server wants to make the
response to a FOO cachable, why should we try to forbid it?
As long as we do it in a way that can't be misconstrued. If
your origin server doesn't want a proxy to cache a response
to a FOO method, then why on earth is it sending "max-age=3600"?
Just leave that out, and nobody gets hurt.
But if this is all too much for a last-minute change, then I
propose resolving ADAMS31 by not changing anything (relative
to -rev-05). I started down this path by complaining about
Jim's proposed change in
and trying to put his words in the right part of the document.
I suspect we will survive if we just leave this part of -rev-05 alone.
-Jeff
I'm fine with Jeff's updated wording, though I think worrying about
the cached entry corresponding to the new request method should be
part of the definition of cachable rather than having to repeat the
conditional in several places. In any case, these are just clarifying
what the implementer should be able to figure out on their own.
What does bother me is
which is a bug -- it should say
An origin server SHOULD return the status code 405 (Method Not Allowed)
if the method is known by the origin server but not allowed for the
requested resource, and 501 (Not Implemented) if the method is unrecognized
or not implemented by the origin server.
....Roy
Jeff says:
OK, we'll keep it as is.
84. Section 14.2, pg. 93, 4th para., has "the server SHOULD send an
error response with the 406 (not acceptable) status code, though the
sending of an unacceptable response is also allowed." The effect of the
final clause of this statement is to downgrade SHOULD to MAY.
"You SHOULD do A, but if you don't, you MAY do B."
does not downgrade the first SHOULD.
Larry
