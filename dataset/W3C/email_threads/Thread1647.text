Let's say we have VCR /somedir/foo.txt corresponding to version history
/repo/vh/vh1. Now consider the following sequence of requests:
1. Checkout source collection (create working collection)
Request:
CHECKOUT apply-to-version /somedir
Response:
Location: /repo/wr/wr1
2. Checkout target collection (create working collection)
Request:
CHECKOUT apply-to-version /anotherdir
Response:
Location: /repo/wr/wr2
3. Move resource from source to target collections
Request:
MOVE /repo/wr/wr1/foo.txt /repo/wr/wr2/foo.txt
4. Execute locate-by-history report for version history of this resource
Request:
REPORT DAV:locate-by-history /repo/vh/vh1
Response:
Which HREF will be returned by last locate-by-history report?
/somedir/foo.txt or /anotherdir/foo.txt or /repo/wr/wr2/foo.txt?
If answer is /somedir/foo.txt then behavior seems to be strange for
the client which performed this move - he had moved the file but find
it under the old path. But it is no (or minor) problems with implementing this
behavior.
If answer is /anotherdir/foo.txt, then the question is whether all
other clients will also receive the same answer for the same
DAV:locate-by-history request before /anotherdir collection is
checked-in? If so, it seems to violate one of the most significant
requirements to version control system - that uncommitted changes made
by some user will not be visible to all other clients.
Looks like the only consistent behavior is that the client which has
checked out /somedir and /anotherdir collection will see foo.txt under
path /repo/wr/wr2/foo.txt while all other clients will see it under
path /somedir/foo.txt until first client checkout these collections.
But how it is possible to implement it? To be able to implement such
behavior I need to somehow verify that user which have done CHECKOUT
of /anotherdir (or in other words owner of wr2 working resource)
is the same as user requested locate-by-history report. So to be able
to implement this behavior we need authentication and notion of
resource owner. But both are not part neither of WebDAV neither of
DeltaV specifications (DAV:owner is declared in WebDAV ACL draft, but
this standard in turn knows nothing about versioning). In other words,
semantic of MOVE can not be expressed in terms of the specification!
If answer is /repo/wr/wr2/foo.txt then in addition to questions and
problems described in previous section, there is one more question -
how it is possible in this case for this client to know path of
foo.txt resource? Lets say that client forgot that foo.txt was
members of /somedir collection and later was moved to /anotherdir.
So the only thing client knows is version of the resource. Can client
somehow request server about the parent of this resource?
Best regards,
Konstantin mailto:KKnizhnik@togetherlab.com
From: Konstantin Knizhnik [mailto:KKnizhnik@togetherlab.com]
Let's say we have VCR /somedir/foo.txt corresponding to version history
/repo/vh/vh1. Now consider the following sequence of requests:
1. Checkout source collection (create working collection)
Request:
CHECKOUT apply-to-version /somedir
Response:
Location: /repo/wr/wr1
2. Checkout target collection (create working collection)
Request:
CHECKOUT apply-to-version /anotherdir
Response:
Location: /repo/wr/wr2
3. Move resource from source to target collections
Request:
MOVE /repo/wr/wr1/foo.txt /repo/wr/wr2/foo.txt
4. Execute locate-by-history report for version history of this resource
Request:
REPORT DAV:locate-by-history /repo/vh/vh1
Response:
Which HREF will be returned by last locate-by-history report?
/somedir/foo.txt or /anotherdir/foo.txt or /repo/wr/wr2/foo.txt?
Only /somedir/foo.txt. /anotherdir/foo.txt will not exist until
/repo/wr/wr2 is checked in. /repo/wr/wr2/foo.txt is not
a version-controlled resource, and DAV:locate-by-history only
locates version-controlled resources.
If answer is /somedir/foo.txt then behavior seems to be strange for
the client which performed this move - he had moved the file but
find it under the old path. But it is no (or minor) problems with
implementing this behavior.
It shouldn't be strange for the client that performed the move.
Changes made to a working resource are not visible until that working
resource is checked in.
If answer is /anotherdir/foo.txt, then the question is whether all
other clients will also receive the same answer for the same
DAV:locate-by-history request before /anotherdir collection is
checked-in?
The answer is not /anotherdir/foo.txt, and the response to a successful
locate-by-history request will be independent of what client makes it.
If so, it seems to violate one of the most significant
requirements to version control system - that uncommitted changes made
by some user will not be visible to all other clients.
Yes, that would be bad.
Looks like the only consistent behavior is that the client which has
checked out /somedir and /anotherdir collection will see foo.txt under
path /repo/wr/wr2/foo.txt while all other clients will see it under
path /somedir/foo.txt until first client checkout these collections.
No, the only consistent behavior is to satisfy the semantics defined
by the report (:-). /repo/wr/wr2/foo.txt is not a version-controlled
resource, and therefore will never be returned by a locate-by-history
report.
Before /repo/wr/wr2 is checked in, the answer will be
/somedir/foo.txt. After the two working collections are checked in,
the answer will be /otherdir/foo.txt. Simple and consistent.
Cheers,
Geoff
[freed from spam trap -rrs]
Date: Fri, 5 Apr 2002 16:27:32 -0500 (EST)
Message-ID: FDEHJMOEIDFPFLBKEICGEEEICGAA.tim@ellison.name
From: "Tim Ellison" tim@ellison.name
The DAV:locate-by-history report is applied to a collection to find the
member that is a version-controlled resource for the given version history.
In this scenario, you have two working collections, whose members are
version histories (not version-controlled resources) so the report would be
no use there.
Since the MOVE operation was on the working collections, it had no effect on
the checked-in version-controlled collections for the source and target, so
you could use REPORT on the source with /repo/vh/vh1 to find
/somedir/foo.txt
Regards,
Tim
TE The DAV:locate-by-history report is applied to a collection to find the
TE member that is a version-controlled resource for the given version history.
TE In this scenario, you have two working collections, whose members are
TE version histories (not version-controlled resources) so the report would be
TE no use there.
So, PROPFIND with DEPTH=1 for working collection will return set of
version histories, not VCR, right?
TE Since the MOVE operation was on the working collections, it had no effect on
TE the checked-in version-controlled collections for the source and target, so
TE you could use REPORT on the source with /repo/vh/vh1 to find
TE /somedir/foo.txt
Ok, there are some other things not clear to me in the example above.
So what happens after
MOVE /repo/wr/wr1/foo.txt /repo/wr/wr2/foo.txt
(assuming that foo.txt belongs to the version history /repo/vh/vh1)
Binding to MOVE /repo/vh/vh1 is removed from /repo/wr/wr1
and is added to /repo/wr/wr2, isn't it?
Then, let's say, we checkin /repo/wr/wr1. The VCR foo.txt should be
removed, right?
Then we checkin /repo/wr/wr2. The VCR with name foo.txt referring to
the history /repo/vh/vh1 should be created, right?
But which version this VCR should select in its DAV:checked-in property?
The obvious answer - the same as was selected by foo.txt VCR
before MOVE. But working collection contains only bindings to versions
histories, so there is no way to store information about checked-in
version.
And one more obscure item for me: if we perform MOVE from versioned
collection to not-versioned collection. Is it allowed operation?
What is the result of such operation? For example:
MOVE /repo/wr/wr1/foo.txt /new.txt
Should new.txt be a new resource (with new resource ID and the same
content as cehcked-in version of foo.txt)? Or it should be foo.txt VCR
itself? Then what is the value of DAV:displayname property of this
resource?
Thanks in advance,
Konstantin mailto:KKnizhnik@togetherlab.com
From: Konstantin Knizhnik [mailto:KKnizhnik@togetherlab.com]
So, PROPFIND with DEPTH=1 for working collection will return set of
version histories, not VCR, right?
Right.
TE Since the MOVE operation was on the working collections, it had
TE no effect on the checked-in version-controlled collections for
TE the source and target, so you could use REPORT on the source
TE with /repo/vh/vh1 to find /somedir/foo.txt
Ok, there are some other things not clear to me in the example above.
So what happens after
MOVE /repo/wr/wr1/foo.txt /repo/wr/wr2/foo.txt
(assuming that foo.txt belongs to the version history /repo/vh/vh1)
Binding to MOVE /repo/vh/vh1 is removed from /repo/wr/wr1
and is added to /repo/wr/wr2, isn't it?
Yes.
Then, let's say, we checkin /repo/wr/wr1. The VCR foo.txt should be
removed, right?
Yes (from /somedir).
Then we checkin /repo/wr/wr2. The VCR with name foo.txt referring to
the history /repo/vh/vh1 should be created, right?
Yes (in /otherdir).
But which version this VCR should select in its DAV:checked-in property?
It's up to the server.
The obvious answer - the same as was selected by foo.txt VCR
before MOVE. But working collection contains only bindings to versions
histories, so there is no way to store information about checked-in
version.
That's correct. One way a server could know to do the expected thing
would be if both working collections were in the same activity, and
the user checked in the activity as a whole. In this case, the
server could remember information about VCR checked-in versions,
and use those as the versions when creating a new VCR.
Note that this is only an issue with working collections. With
checked-out version-controlled collections, the MOVE actually moves
the VCR, so the DAV:checked-in value just goes along for the ride.
And one more obscure item for me: if we perform MOVE from versioned
collection to not-versioned collection. Is it allowed operation?
Depends on the server. I would expect that most servers would not
support this, but they certainly could do so.
What is the result of such operation? For example:
MOVE /repo/wr/wr1/foo.txt /new.txt
Should new.txt be a new resource (with new resource ID and the same
content as cehcked-in version of foo.txt)? Or it should be foo.txt VCR
itself? Then what is the value of DAV:displayname property of this
resource?
RFC-3253 requires that a MOVE keep all the RFC-3253 defined
properties, so such a MOVE would have to expose the version history
resource itself at the new location (not a new resource, and not a
VCR). It's DAV:displayname would be whatever was the DAV:displayname
of the VCR before the MOVE. A server is likely to restrict the location
of version history resources to be in working collections and its
original server-defined location, which is why such MOVE's are
unlikely to be supported.
Cheers,
Geoff
Geoff,
If I understand this correct, then a PROPFIND with DEPTH=1 on the working
collection /repo/wr/wr1 would return the URL:
/repo/vh/vh1
However, in another thread ("Relative URLs, Multiple Bindings") you replied
that URLs returned must be relative to the parent. To quote:
"My reading of 2518 is that it MUST return URLs that are relative to
the parent (e.g. A/B/x and A/B/y)."
Do we have a contradiction here or am I missing out something.
Girish
So, PROPFIND with DEPTH=1 for working collection will return set of
version histories, not VCR, right?
Right.
From: B H, Girish [mailto:g.b.h@sap.com]
From: Konstantin Knizhnik [mailto:KKnizhnik@togetherlab.com]
So, PROPFIND with DEPTH=1 for working collection will return
set of version histories, not VCR, right?
From: Clemm, Geoff [mailto:gclemm@rational.com]
Right.
If I understand this correct, then a PROPFIND with DEPTH=1 on the
working collection /repo/wr/wr1 would return the URL: /repo/vh/vh1
No, it would return "/repo/wr/wr1/xxx (where xxx is the binding name
from the DAV:versioned-binding-set for /repo/vh/vh1 in the collection
version that was checked out). Both /repo/wr/wr1/xxx and /repo/vh/vh1
identify the same resource, but the PROPFIND on /repo/wr/wr1 must
return the first URL.
However, in another thread ("Relative URLs, Multiple Bindings") you
replied
that URLs returned must be relative to the parent. To quote:
"My reading of 2518 is that it MUST return URLs that are relative to
the parent (e.g. A/B/x and A/B/y)."
Do we have a contradiction here or am I missing out something.
The latter (:-).
Cheers,
Geoff
