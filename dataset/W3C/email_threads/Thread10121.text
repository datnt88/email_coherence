Brian McBride said:
We know that:
a b "foo"@@en# datatype .
c d "foo"@@fr# datatype .
entails
a b _:l .
c d _:l .
for all datatypes except rdf:XMLLiteral.
It does? Doh.
I think so, but don't take my word for it. Jeremy?
I still think that's broken; but I'll fix the test case.
Basically these cases outline the various issues - I'll correct them as
appropriate.
Nah - see below - you got it right unless we know that datatype is not
rdf:XMLLiteral. We know its not called that, but unless we make a unique
name assumption, we don't know that its not another name for the same thing.
I also think it is broken - hard to implement in a efficient fashion.
(And the N-Triples syntax above is wrong; ^^ not #)
Typed literals should be opaque nodes with identity, like URI-refs.
Looking at parts of them for RDF interpretations is wrong. This
"ignoring the language in datatype interpretation except for
rdf:XMLLiteral" is seeming increasingly stupid.
If it said:
a b XXX .
c d XXX .
where XXX is any legal syntax for typed literal object node
entails
a b _:l .
c d _:l .
Then it would make more sense to me.
Dave
It does? Doh.
I think so, but don't take my word for it. Jeremy?
I still think that's broken; but I'll fix the test case.
Basically these cases outline the various issues - I'll correct them as
appropriate.
Nah - see below - you got it right unless we know that datatype is not
rdf:XMLLiteral. We know its not called that, but unless we make a unique
name assumption, we don't know that its not another name for the same thing.
I tend to agree. Having XML literals as datatypes doesn't seem to
help with anything and its starting to create new problems, because
so many things are special to this case, not the least being that it
alone is in RDF.
BTW, one thing I still don't have clear is what it is exactly that an
XMLLiteral is supposed to denote. What is the value space of the
datatype?? I used a form of words in the recent semantics doc that
was so recondite that I thought one of the reviewers would have
complained, but I'd rather say something simple and honest.
Yes, but that follows from the basic graph syntax MT, ie its a simple
entailment. Nothing particularly to do with datatypes or lang tags.
Pat
IHMC(850)434 8903 home
40 South Alcaniz St.(850)202 4416 office
FL 32501 (850)291 0667 cell
phayes@ai.uwf.edu http://www.coginst.uwf.edu/~phayes
s.pam@ai.uwf.edu for spam
I think Brian has the wrong end of the stick here ...
While it is true that we have forbidden the language tag from having any
significance for datatyping, it is only in the datatype interpretation that
this prohibition takes place.
Thus
Brian's entailment:
is a {datatype}-entailment, but not any other sort.
Since the test cases are only dealing with XSD entailments then we don't
have to worry about the general case.
i.e. the prohibition on the lang tag meaning anything is not part of the
logic really, just some arbitrary constraint that we have thrown in.
If we make too much of it then Dave's comment:
will win the day.
General principle: you only unpick typed literals, when the type is one of
those in the set of datatypes you are currently dealing with.
If you stick to that then:
- I suggest we do not even consider the boolean entailment
- I suggest the conclusions should always use the canonical form of a
datatype (Brian's bnode in conclusion pattern is also OK).
These suggestions are intended as concessions to implementors.
(Sorry I have not yet looked at the actual tests)
Jeremy
[Patrick Stickler, Nokia/Finland, (+358 40) 801 9690, patrick.stickler@nokia.com]
I've never quite understood why the lang tag was significant
in the case of rdf:XMLLiteral. Is it legacy from M&amp;S or what?
Since the "wrapper" element is not normative and not really
present (and somewhat of a hack IMO) how is the actual meaning
of the literal affected by the lang tag ny differently than other
types of literals?
Can't we just treat all literals the same?
I prefer this model of entailment, because it clearly bases
the entailment on the denotation of the typed literal rather
than its representation, which is just a means to an end; that
end being the value, and once you have the value, the lexical
form and datatype is irrelevant.
Agreed.
Patrick
[Patrick Stickler, Nokia/Finland, (+358 40) 801 9690, patrick.stickler@nokia.com]
My view has always been that the value space of an XML (complex) datatype
is the set of XML Infosets which the lexical forms (XML serializations)
correspond to.
Though I believe Jeremy views the value space as being the set of
canonical serializations. Jeremy?
I think a value space of infosets is more useful.
Patrick
[Patrick Stickler, Nokia/Finland, (+358 40) 801 9690, patrick.stickler@nokia.com]
Not all datatypes define a canonical space, and "cononical forms" are
unknown to RDF datatyping, thus we should not recommend or require
anything that is outside the scope of the RDF machinery.
Patrick
Hmm. NOw I need to know what an 'infoset' is.
Reading http://www.w3.org/TR/xml-infoset/. I find no definitions,
only descriptions which assume that the reader already knows the
concept. Patrick, do YOU know what they are talking about?
That has the merit of being clearly defined, in contrast to "infoset".
Pat
IHMC(850)434 8903 home
40 South Alcaniz St.(850)202 4416 office
FL 32501 (850)291 0667 cell
phayes@ai.uwf.edu http://www.coginst.uwf.edu/~phayes
s.pam@ai.uwf.edu for spam
[Patrick Stickler, Nokia/Finland, (+358 40) 801 9690, patrick.stickler@nokia.com]
Fine. Let's stick with canonical serializations.
Patrick
