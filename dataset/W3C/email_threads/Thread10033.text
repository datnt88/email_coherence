Since RDF now has DAML_style lists (right?), I thought it would be
good to get feedback on the proposed MT for them. So here it is: toss
back any comments, please.
Given a set S, we define a set of lists over S to be a set L
containing the empty sequence  and all structures of the form s,
l where s is in S and l is in L.
As with any recursive 'definition', this in fact is an equation with
many possible solutions. The usual way to interpret this kind of
definition is in terms of a minimal solution of the equation. That
means that one would understand the set of lists to be the smallest
collection of things that would satisfy the recursion, which would be
all finitely deep lists which have no loops, i.e. structures of the
form s1 s2 ... sn   ...  . On this view, every list defines a
finite sequence of elements of S. Other lists are possible, however,
which would also satisfy the recursive definition: infinitely deep
lists, for example, or looping lists of the form l = s, l .
Although it is possible to axiomatize a recursive 'definition' as a
logical assertion, there is no way to finitely axiomatize the least
fixed-point solution. We could impose it as a semantic condition; but
this condition, although intuitively sensible and in correspondence
to the usual semantics for computational languages, may have some
regrettable consequences when used, as here, in the context of a
descriptive language. In particular, there would be no way to
establish the completeness of any finitary inference process relative
to such a semantics. We therefore avoid making this stipulation, and
simply require that the set of lists in any interpretation be *some*
set which satisfies the recursive definition. Note that this means
that any set of lists will at least contain all the finite
non-looping lists.
The semantics of the rdf list vocabulary is then straightforward. In
any RDF interpretation I, we assume that
ICEXT(I(rdf:List)) is a set of lists over IR @@Note the use of 'a'
rather than 'the'.@@
I(rdf:nil) =
x, y in IEXT(I(rdf:first)) iff x = y, l for some l in ICEXT(I(rdf:List))
x, y in IEXT(I(rdf:rest)) iff x = s, y for some s in IR
We note in passing that this semantics requires that the universe IR
is closed under the operation of constructing lists.
Any interpretation I of any RDF graph of the form
A1 rdf:type rdf:List .
A1 rdf:first B1 .
A1 rdf:rest A2 .
A2 rdf:first B2 .
A2 rdf:rest A3 .
An rdf:first Bn .
An rdf:rest rdf:nil .
has I(A1) = I(B1), I(B2), ... I(Bn),   ...  . We will describe
this as a sequence and write it as [I(B1), ... , I(Bn)]. Sequences
are the ordered multisets of the elements of finite lists.
IHMC(850)434 8903 home
40 South Alcaniz St.(850)202 4416 office
phayes@ai.uwf.edu
Pat, I think I'm fine with that
how can we express that
when given
_:l1 rdf:first :a .
_:l1 rdf:rest :b .
_:l2 rdf:first :a .
_:l2 rdf:rest :b .
then _:l1 and _:l2 are tidy
(we have that "for some" is actually
"for one" in this case and I've missed
a notation for that important fact)
Jos De Roo, AGFA http://www.agfa.com/w3c/jdroo/
pat hayes
cc:
Sent by: Subject: RDF lists
w3c-rdfcore-wg-req
uest@w3.org
2002-09-20 12:39
AM
Since RDF now has DAML_style lists (right?), I thought it would be
good to get feedback on the proposed MT for them. So here it is: toss
back any comments, please.
Given a set S, we define a set of lists over S to be a set L
containing the empty sequence  and all structures of the form s,
l where s is in S and l is in L.
As with any recursive 'definition', this in fact is an equation with
many possible solutions. The usual way to interpret this kind of
definition is in terms of a minimal solution of the equation. That
means that one would understand the set of lists to be the smallest
collection of things that would satisfy the recursion, which would be
all finitely deep lists which have no loops, i.e. structures of the
form s1 s2 ... sn   ...  . On this view, every list defines a
finite sequence of elements of S. Other lists are possible, however,
which would also satisfy the recursive definition: infinitely deep
lists, for example, or looping lists of the form l = s, l .
Although it is possible to axiomatize a recursive 'definition' as a
logical assertion, there is no way to finitely axiomatize the least
fixed-point solution. We could impose it as a semantic condition; but
this condition, although intuitively sensible and in correspondence
to the usual semantics for computational languages, may have some
regrettable consequences when used, as here, in the context of a
descriptive language. In particular, there would be no way to
establish the completeness of any finitary inference process relative
to such a semantics. We therefore avoid making this stipulation, and
simply require that the set of lists in any interpretation be *some*
set which satisfies the recursive definition. Note that this means
that any set of lists will at least contain all the finite
non-looping lists.
The semantics of the rdf list vocabulary is then straightforward. In
any RDF interpretation I, we assume that
ICEXT(I(rdf:List)) is a set of lists over IR @@Note the use of 'a'
rather than 'the'.@@
I(rdf:nil) =
x, y in IEXT(I(rdf:first)) iff x = y, l for some l in
ICEXT(I(rdf:List))
x, y in IEXT(I(rdf:rest)) iff x = s, y for some s in IR
We note in passing that this semantics requires that the universe IR
is closed under the operation of constructing lists.
Any interpretation I of any RDF graph of the form
A1 rdf:type rdf:List .
A1 rdf:first B1 .
A1 rdf:rest A2 .
A2 rdf:first B2 .
A2 rdf:rest A3 .
An rdf:first Bn .
An rdf:rest rdf:nil .
has I(A1) = I(B1), I(B2), ... I(Bn),   ...  . We will describe
this as a sequence and write it as [I(B1), ... , I(Bn)]. Sequences
are the ordered multisets of the elements of finite lists.
IHMC (850)434 8903
home
40 South Alcaniz St. (850)202 4416
office
phayes@ai.uwf.edu
Looks fine to me.
You say...
... which seems entirely reasonable, but I couldn't be sure formally why
this is required. Is it that ICEXT(x) is always a subset of IR, hence
ICEXT(I(rdf:List))?
#g
Graham Klyne
Right. But also we want to be sure that all the lists we can possibly
mention also exist, because otherwise a graph describing a list might
be false because the interpretation just doesn't happen to have a
suitable list handy.
Pat
IHMC(850)434 8903 home
40 South Alcaniz St.(850)202 4416 office
phayes@ai.uwf.edu
Er...you can't. That is, there could be two lists with the same members.
Pat
IHMC(850)434 8903 home
40 South Alcaniz St.(850)202 4416 office
phayes@ai.uwf.edu
thus far I thought that 2 sequences with the same members
*are* the same sequence (i.e. the denoted thing is the same)
how could they ever be different, I mean semantically?
Jos De Roo, AGFA http://www.agfa.com/w3c/jdroo/
Aha, of course! Thanks.
#g
Graham Klyne
I think that even though they may be different lists (containing different
graph nodes), if IR is closed under list construction and the given
semantics for rdf:first, rdf:rest then each must entail the other -- by
virtue always being true.
Tricker, I think, is how one gets the expected entailments when a list is
related to some other entity -- I guess the OWL folks will have to sort
that one.
#g
Graham Klyne
Ah, yes. The existence of one such list suffices for both graphs, if
you always use bnodes. But you know, you don't HAVE to use bnodes.
Maybe
ex:Pat rdf:first :a .
for all I know.
Damn right. Speaking as one of them, that's one of the reasons I want
to do RDF lists this way.
Pat
IHMC(850)434 8903 home
40 South Alcaniz St.(850)202 4416 office
phayes@ai.uwf.edu
By being different. I don't know quite how else to say it. That is,
the sequences (of 'firsts') will be the same, but the lists could
still be different. And that makes sense, because for example they
might have other properties, such as who made them; or suppose they
are lists of people in a building at some time. Could have same
members but still be distinct.
Pat
IHMC(850)434 8903 home
40 South Alcaniz St.(850)202 4416 office
phayes@ai.uwf.edu
Well, yes. That's a structure I find myself using quite a lot
(effectively, indicating a list by identifying its head node). Isn't that
just a particular case of relating a list to another entity? ...
#g
Graham Klyne
