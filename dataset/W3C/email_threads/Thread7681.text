Roy, thanks for what you said in the first part of this note.
And whatever you think while reading this, keep in mind that the resource
is not the storage thingy on the back-end -- it is the concept being
referenced by the originator of the URI.
Agreed.
I don't understand how
the server is supposed to know what the resource is when the user is
allowed to create new bindings willy-nilly. Therefore, either the
server needs to be told what the resource is when the bindings are
created (which doesn't seem likely, since most of the users wouldn't
understand the difference) or the definition of DELETE should be changed
to reflect the easier-to-grasp notion of removing the binding.
Are those the only choices?...
Can't we leave the definition of resource suitably vague as we and
our predecessors have? If we do I suspect servers will drive a
WebDAV compliant definition that content authors on their site will
use. Not the opposite.
Almost all servers will support the model of
flat/dead file or repository object that basically is just an echo of
a PUT/GET.provide their own underlying meaning of resource. A server
might also offer support for more intelligent objects like servlets or
perl scripts and also treat those as resources. The author's job is
to encapsulate his concept of a resource within the one of the server's
concepts of a resource which is probably a file or some sort of
repostiory object.
As I just said, most of the time, the server will drive a WebDAV compliant
concept of a resource that that the content authors will use.
One likely exceptions is the concept of a resource essentially being
at the URI. This model doesn't need server support and may not leverage
the server model or even necessarily the WebDAV model of resource. An
example is,
"page_of_the_day.html". Certainly the author could use a proxy
resource that essentially gets it's contents from other resources depending
on today's date, but it's more likely that the author will just choose to
rebind that URI each day. Sure, the casual referencer's
concept of the resource will not be the same as the server's, but the right
thing happens. Does it matter that the author chose to have one foot in
each model?
Jason.
PS. I hate HTML mail too.
All that I can think of at the moment. Another way to put it is:
if the server is not informed of the difference between a new binding to
an existing resource and a new binding representing a new resource that
happens to currently point to an existing resource, then the server must
treat all bindings as unique resources. The alternative---that all
bindings to the same resource represent a single resource---is known
to be false. If the server is treating all bindings as unique resources,
then DELETE on a binding is equivalent to DELETE on a resource.
Since we have a good grasp of what it means to DELETE a binding, and
we can assume that the server can be configured to act appropriately
when the last accessible binding is deleted from a resource, I think it
is reasonable to alter the definition of DELETE so that it follows the
spirit of what is defined in RFC 2616 rather than the exact terminology.
Well, either that or simply declare that every binding is a separate
resource, even when it isn't.
Or, declare a new method called UNBIND that removes bindings but not
resources. I guess then the WG would have to figure out what should
happen when the client attempts to UNBIND the last binding attached to
a resource, and likewise BIND would have to indicate whether the new
binding should be considered a new resource or an alias of an existing
resource. I pretty much assumed that the WG had already discussed this
option and moved on.
Hmmm, my experience is that most implementers will randomly stagger
towards the first implementation that appears to work for their limited
test set, and then refuse to fix it out of fear of breaking backwards
compatibility. Only those who understand the overall architecture are
likely to get it right the first time.
Actually, no. If we treat the web as if it were a distributed filesystem,
it will eventually lose those qualities that make it better than a
distributed filesystem. The most important goal of WebDAV is to enable
manipulation of resources without assuming anything about how the
resource is implemented; it is okay to learn how it is implemented
during the process of interaction, but only to the extent that the
server reveals that information to the client. So we build up this
interface model where the client makes operations on the generic interface
and then the server translates those operations into the mechanism
applicable for that resource.
Namespace operations are a little unnatural in that, even though the
request-URI consists of the target name, the actual mechanism targeted
by the request is the collection resource that governs that namespace.
Hence, MOVE changes the collection, not the resource.
[Gack! I just noticed that the request target of a BIND request is,
well, wrong in the spec. More on this later.]
I don't follow that -- I only see one model there, even if the
"page_of_the_day.html" is a physical file on the server. How it is
implemented doesn't make any difference to the interface presented
to the client except during the authoring operations.
A better example is a collection consisting of "Fred", "Frederick",
and "Douglass". Those could be three different resources (for example,
individuals within a team of coders) or three different aliases for
the same resource. The only person who really knows the answer is the
person defining the namespace -- it just isn't something that a server
can figure out by analyzing the implementation, because what differentiates
one resource from another is the semantics given to them when each URI is
used within some external reference. The server can't even rely on the
implementation giving some indication of the difference, since the
implementation is allowed to change over time, whereas the semantics of
a resource does not (legitimately) change over time.
....Roy
I agreed or didn't understand various parts of your note until I got to the
following. I think
it explains what you're trying to get at when you speak of the server
knowing if something
is the same resource or not.
A better example is a collection consisting of "Fred", "Frederick",
and "Douglass". Those could be three different resources (for example,
individuals within a team of coders) or three different aliases for
the same resource. The only person who really knows the answer is the
person defining the namespace -- it just isn't something that a server
can figure out by analyzing the implementation, because what
differentiates
one resource from another is the semantics given to them when each URI is
used within some external reference. The server can't even rely on the
implementation giving some indication of the difference, since the
implementation is allowed to change over time, whereas the semantics of
a resource does not (legitimately) change over time.
You are trying to emphasize the definition of a resource as being in
the eyes of the author.
And that you want the server somehow be able to know and track the author's
concept of "the resource"... and distinguish it from the current
implementation
of the resource. And because bindings remove the tight one-to-one
association
of the conceptual resource from its implementation, you feel the advent of
bindings is a good place to have the server start maintaining that
separation
and support both concepts fully.
It sounds like you'd like to be able to insert another level of indirection
in our model. A "a-resource" is the author's conceptual resource. A
"s-resource"
is a server's concept of a resource and represents an implementation.
URI: leadprogrammer.html john.html fred.html
aresource: lead_programmer_personal_page aresource: john aresource:
fred
sresource: John.html sresource: John.pl sresource: Fred.html
states of sresources: John.html.001 John.html.002 John.pl.001
Fred.html.001
The "binding" from URI to aresource is pretty static. The URI basically
should
continue to point to the same concept until the end of time.... ideally.
OTOH
over time the author might
change the implementation to use a different sresource for a given
conceptual
resource. And over time the implementation of the sresource might evolve
as it is debugged.
So what we've done in WebDAV is compressed the URI and conceptual resource
layers together since ideally they should remain as a one:one mapping for
eternity. That means if we have a situation like...
leadprog.html john.html fred.html
lead_prog john fred
John.html Fred.html
In webdav we'd create a situation like the following.
leadprog.html john.html fred.html
John.html Fred.html
And you are thinking of the resource as an implementation of the resource
rather than the resource.
Actually I was thinking both. I was emphasizing the server's concept
as something that the author could still leverage to maintain his
concept. I didn't feel it was important for the server to maintain
the author's concept of a resource, but I felt that if the author
wanted the server to, it could. That's what I meant when I spoke
about a proxy object.
What I was saying about a proxy object is that
the author could actually create a server resource to represent his
concept of a resource and distinguish it from its implementation. That
object
would not implement anything. It's only job would be to redirect
to the server object that currently implements the authors concept.
The server could manage both the conceptual resource and the implementation
resource as WebDAV resources.
The fly in the ointment is that ideally we'd like the proxy object
to have a ***strong*** link/binding (whatever you want to call it) to its
implemenation object. The only type
of strong links that we provide right now are bindings. And they are only
kept by collections. So this proxy object would basically need to be a
collection. Presumably that collection would only be allowed one child
and it would always internally redirect to it. Of course it can't always
redirect ALL requests. Presumably there are operations that we might want
to do on the proxy itself. (Maybe there aren't.)
Anyway, the basic ground work is there to do this if the author wants to.
It isn't explicitly supported in the protocol though. It could be at a
later date though. As I said, the ground work is there.
BTW... you mentioned that BIND acts on the wrong object. I think most of
us recognize this, but I just wanted to remind you to get back to us with
your commments and insight on that.
Jason.
Yes, and not just trying -- that is the definition of a resource.
The definition derives from the central requirement of the Web:
independent authoring of interconnected hypertext across
multiple trust domains. Forcing the interface definitions to match
the interface requirements makes some things *seem* vague, but that
is only because the interface being manipulated is only an interface
and not an implementation.
That's not quite what I meant. What I was saying is that IF the spec
is going to make a distinction between bindings and resources, THEN
the protocol must provide a mechanism for the author to communicate
that distinction to the server. IF, instead, the interface simply
assumes that all bindings are separate resources (as does RFC 2616),
then there is no need for that communication mechanism.
Don't get me wrong: there are some advantages to having a protocol
mechanism for identifying true aliases of a resource outside of DAV
(e.g., elimination of replicas in caches), but in the past those
advantages haven't been worth the effort.
No, that's where lossage occurs in this discussion. A resource is not
the storage object. A resource is not the mechanism that the server uses
to handle the storage object. A resource is a conceptual mapping --
the server receives the identifier (which identifies the mapping) and
applies it to its current mapping implementation (usually a combination
of collection-specific deep tree traversal and/or hash tables)
to find the currently responsible handler implementation and the
handler implementation then selects the appropriate action+response
based on the request content. None of this implementation is part of
the Web interface.
For example, consider what happens when a site grows in user base and
decides to replace its old IIS server with a brand spanking new Apache
server running on a Sun ULTRA. The disks are replaced. The operating
system is replaced. The HTTP server is replaced. Perhaps even the
method of generating responses for all of the content is replaced.
What doesn't change is the Web interface: if designed correctly, the
namespace on the new server can mirror that of the old, meaning that
from the client's perspective, which only knows about resources and
not about how they are implemented, nothing has changed aside from the
improved robustness of the site. (;-)
So, while it is okay for the bindings spec to say that bindings are
somehow different from resources, it is absolutely critical that it
not equate resources to some part of the server implementation. Call
those other things handlers if you like, but understand the difference
when interpreting what the existing HTTP requirements mean, because
those HTTP requirements are on resources and resource identifiers,
not on handlers.
....Roy
Meet me at ApacheCon 2000 http://www.apachecon.com/ , March 8-10.
