Several people have proposed defining the RE/RS problem out of
existence by defining the RE and RS function charcters as codes that
won't occur in entities, via the SGML application for XML.
James Clark takes the stand that the definitions of RE and RS are what
codes the parser should communicate to the application when they are
encountered, so redefining them won't change whether or not they
occur. He also posits that lines in an input file from DOS or UNIX
should be interpreted as records.
That certainly seems a reasonable interpretation, but I can't find
anything to that effect in 8879. Clause 7.6.1, "Record Boundaries",
defines the rules for RE ignorance or preservation, but doesn't say
anything about when the parser generates an RS or RE signal. Charles
Goldfarb's commentary thereto (pp. 321+322 of the SGML Handbook)
discuss translating lines into records, but that's not normative.
The best normative thing I can find is 4.140, "function character
identification parameter: A parameter of an SGML declaration that
identifies the characters assigned to the RE, RS, and SPACE functions,
and allows additional functions to be defined."
This suggests that, since characters are assigned to functions, that
the characters in the document should assume the roles of these
functions; ergo, if non-ocurring characters are the ones assigned to
those roles, the function characters never occur. Is that not the
intended meaning? If not, what is?
I think that, if the RE/RS problem can be redefined out of existence,
that it can be very easily handled at the application level. Some
have suggested this already; I outlined a proposal in conversation
with Gavin Nicol, and he seemed to think it worthwhile. I'll send
that in another message if others agree that it is possible for an
application of ISO 8879:1986 (not :2001) to define every entity to
have a single record.
-Chris
!ENTITY crism PUBLIC "-//EBT//NONSGML Christopher R. Maden//EN" SYSTEM
[Charles Goldfarb]
The standard (and the Handbook) recognize the possibility that
records might not exist in some storage formats. In those cases, you
can assign RE/RS out of existence. But when records actually exist,
you *cannot* evade handling them by not assigning RE/RS and sweeping
them under the rug (where "rug" = application or entity manager).
But when *do* "records actually exist"? There is a perception evident
here, and one that I had always taken for granted, that the data
between carriage returns (a "line") was to be interpreted as a record.
But I can't find anything in 8879 to that effect! IBM mainframes have
records; they are definitely records, and nothing else. But in an
ASCII text file, from UNIX, DOS, or Macintosh, what constitutes a
record, normatively? I think 8879 does not prescribe a particular
behavior in this regard.
In any case, the fiat of the ERB (per Eliot) seems to have rendered
this discussion moot for the purposes of the Working Group. I'm still
interested in the subject, but we probably shouldn't clutter the list.
Maybe an RE BOF at SGML '96? (-:
-Chris
!ENTITY crism PUBLIC "-//EBT//NONSGML Christopher R. Maden//EN" SYSTEM
The standard (and the Handbook) recognize the possibility that records might not
exist in some storage formats. In those cases, you can assign RE/RS out of
existence. But when records actually exist, you *cannot* evade handling them by
not assigning RE/RS and sweeping them under the rug (where "rug" = application
or entity manager).
If a document is created in an editor that lets you enter tags as text, you must
deal with REs. That is because you could be using white space to "format" the
source text, and some of that whitespace will be indistinguishable from true
information. (See my earlier postings on this point.)
If the editor only lets you enter elements through menu selection, it can avoid
having any "formatting" REs in its source document. It is for such editors that
the standard makes provision for assigning the RE/RS characters out of
existence.
Bottom line: You can assign the RE/RS characters out of existence, but not the
RE/RS problem. It is inherent in all direct entry of markup and undelimited
data, not just SGML.
Charles F. Goldfarb * Information Management Consulting * +1(408)867-5553
13075 Paramount Drive * Saratoga CA 95070 * USA
International Standards Editor * ISO 8879 SGML * ISO/IEC 10744 HyTime
Prentice-Hall Series Editor * CFG Series on Open Information Management
See the definition of record in 8879 (clause 4.252). I don't think it
leaves any doubt that a record is intended to correspond to an input-line.
James
It's even easier. If the entity manager does not recognize the functions,
then the characters need never be generated. Nothing in the standard
_requires_ recognizing the RE/RS functions at all. Defining RS/RE out of
the code space is just to avoid wasting code points (which are valuable in
8-bit code-spaces) on something that will never occur. Within a 10646
framework we could even choose a particular code in the private-use area,
given the improved number of codepoints available.
-- David
David Durand dgd@cs.bu.edu | david@dynamicDiagrams.com
Boston University Computer Science | Dynamic Diagrams
Quote of definitional text (emphasis mine):
4.252 Record: A division of an SGML entity bounded by a record start and a
record end character, _normally_ corresping to an input line on a
text-entry device.
That "normally" is a hole that I think I'm justified in driving a truck through.
I'll also note that, at least for the Mac, there is no notion of line, if
we take Simpletext (supplied with every Mac by Apple) as the System's
"text-entry device." In Simpletext CR is a paragraph delimiter, due to
automatic word wrapping. This wrapping is not only a feature of most
applications, but it is actually built into the system suypplied
text-display and handling functions.
This is just one example, but the uniformity of file handling in Unix
suggests that '\n' is an application convention, and not a system feature
(so we are even within our rights to ignore it).
Also the notion of text-entry device is vacuous or at least ill-defined in
the days of modern windowing systems. Will the Hollerith card never die?
RE delenda est.
-- David
David Durand dgd@cs.bu.edu | david@dynamicDiagrams.com
Boston University Computer Science | Dynamic Diagrams
Yes. It was an early goal of Unix (it's in one of the Bell Tech. Journal
Special Issue papers, I think) to avoid record-based files altogether.
I think a lot of the RS/RE trouble comes from confusion between the
representation and that which is represented. Some people (many people)
want to be able to say
this is
a monospaced example
and the columns line up.
and have spaces, tabs and newlines be significant in the markup in order
to represent that in a ``WYSIWYG'' way. Then people with no background
in design can try and lay out their source code or DTDs and align unrelated
things at the expense of clarity :-), and neither the receiving application
nor the screen or paper layout designer can correct the errors without
extensive hand work, it's awful.
Rants aside :-), this is an insidious form of minimisation. Insidious
because it does not in fact have a fully normalised form!
It is one thing to use SHORTREF or DATATAG to map newline to BR or
&amp;linebreak; or something. It is quite another to use spaces tabs and
newlines to draw ASCII art. If people want to do this, they should use
a NOTATION.
Perhaps we need a kind of Unix vgrind that takes an SGML instance or
DTD fragment and pretty-prints it into an XML representation.
that lets you view C in Panorama, for example) and plain text, how important
would this issue still be?
You can't include C or C++ in SGML without pre-processing anyway,
because of int *ip = &amp;i; being not only legal but common, unless you change
ERO to be @ or something else saner than &amp;. Same with perl.
Unix shell scripts are OK with &amp; because it's not usually followed by
a name, although 1 &amp;2; occurs fairly often in both shell and awk. But you
do get prog input output, which isn't OK in #PCDATA, and even
prog /tmp/xxx which can't go in CDATA.
You can edit the files to put spaces
in or quote the  and &amp;  signs, but that's pre-processing.
So I suggest that in the Twenty Page XML Book there by a note about how
to include program listings, and exactly which characters need to be escaped,
and how to escape them, and have done with it. And if multiple spaces and
newlines need to be escaped, as I expect, say how.
Lee
At first, I was going to say that this was a poor example and suggest
that you considered most of the programming reference books on your
shelves, but then I realized that it isn't so bad. The only difference
is that I think you're assuming that someone typed your example. We have
hundreds (thousands?) of tabular ASCII report options in various
software products. The documentation for that software naturally contains
samples of those reports. I just can't picture myself promoting a
language that requires people to go in and add markup to these examples.
I don't think I could even convince myself to use such a language.
bob
Robert Streichstreich@slb.com
Schlumbergervoice: 1 512 331 3318
Could you picture a trivial variant of SGMLNORM (XMLNORM?) that brackets all the
data and solves the RE/RS/whitespace problem properly?
Charles F. Goldfarb * Information Management Consulting * +1(408)867-5553
13075 Paramount Drive * Saratoga CA 95070 * USA
International Standards Editor * ISO 8879 SGML * ISO/IEC 10744 HyTime
Prentice-Hall Series Editor * CFG Series on Open Information Management
Then SGML, HTML and XML aren't for you.
The first SGML document I ever saw was a report about R&amp;D. There was a
declaration at the start,
that made the document parse.... :-)
But you'll probably need to do a better job than that. So you'll need to
add markup.
Quoting spaces is no harder than quoting &amp; and .
If that's not feasible (and I know that it isn't always feasible), you may
have to stick
to text/plain.
Lee
I'm sorry, but I don't see how you've arrived at this conclusion. SGML
works quite well for us. I can use CDATA elements to contain the examples
and have yet to run into an ETAGO that has caused a problem. If there is
an ETAGO in the content, then there is a corresponding PCDATA element
so that we can markup the ETAGO (and any EROs or STAGOs that we now have
to be concerned about). All of our tools support some form of verbatim
formatting. So, it works just great.
Somehow I think the frequency of spaces is slightly higher than occurrences
of ' ' and '&amp;'.
bob
all the
Sure I could picture it. It's always in the back of my mind as an option
should XML turn out too strange. With OmniMark in my back pocket and the
tremendous potential of Jade round the corner, I feel strangely secure.
(By the way, shouldn't we all chip in and take out an insurance policy
on James?)
I had such a thing in mind way back when I suggested "client/server" XML
as an option. Didn't get much interest, though. I kind'a wish it were a
viable option though since it would ease the tension between easy to type
and easy to parse. You could make the client parser *very* simple. The
server parser could be more complex, but not much more so. Perhaps I
shouldn't have used "client/server" as the name. I really see it to be
more like elisp with a byte compiler only instead of compiled, you have
a very easy to parse, but still human-readable version for machine to
machine communications (or agent to agent if you prefer).
bob
Robert Streichstreich@slb.com
Schlumbergervoice: 1 512 331 3318
