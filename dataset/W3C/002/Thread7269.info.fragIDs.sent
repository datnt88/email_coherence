Yaron Goland asked Roy Fielding last week what the history was on the MOVE and COPY methods which were in the initial HTTP 1.1 draft, and which were subsequently removed. 
Roy cc'ed his response to me, and I feel it is of interest to the group. 
- Jim Roy Fielding: That part of the early HTTP/1.1 spec (draft 00) was never completed, so it probably isn't worth looking at. 
The only thing I did was define the methods COPY and MOVE as being methods, but did not supply the other information that would be needed to make them work. 
In fact, I think we are better-off without any MOVE and instead just have a COPY and DELETE combination (the reason being that the copy destination needs to "run" the copy method, but only the copy source is capable of running the delete method -- since the source and destination can be different servers). 
Basically, what I started to do was to use those method names and have the source of the action be the request-URI. 
However, I now believe that the request-URI needs to be the destination-URI, since it is the destination 
server which will be performing the COPY operation. 
The question is: how do 
you specify the source-URI(s) for the copy? 
I originally thought that using a Location or Content-Location header field on the request would do it, but that makes those fields more difficult to specify. 
Instead, what I suggest is that you use the body of the request as a list of source URIs for the copy, e.g., COPY /new/resource HTTP/1.1 Host: www.ics.uci.edu 
Content-Type: text/uri-list Content-Length: 38 which would have the added benefit of allowing multiple copies COPY /new/dir/ HTTP/1.1 Host: www.ics.uci.edu 
Content-Type: text/uri-list Content-Length: 640 in a single request. 
That one could also be done using relative URIs. 
There is a substantial disadvantage in not supplying MOVE in addition to COPY and DELETE. 
It forces servers to perform a copy operation when a much cheaper directory operation may be possible. 
I see no reason why sending a MOVE operation to the source location of a URI should not cause that server to do a POST of the information to the new location and delete it locally. 
This would indicate that the method should act on the source URI rather than the target. 
ie to move a file from 
MOVE http://etna/foo http/1.2 
Destination-URI: http://etna/bar Which could equally be :- MOVE http://etna/foo http/1.2 
Destination-URI: http://krakatoa/bar This has the substantial advantage that the machine that holds 
the data can wait until receiving the 2xx OK response before performing the local delete, also the command would not be permitted unless the user had delete as well as copy permission. 
If Destination-URI were a list of URIs one could instruct a server to perform a "multimove", ie distribute a document to multiple destinations. 
This could be very usefull if integrating to e-mail. 
One can request that a server perform a document distribution task :- COPY http://etna/foo http/1.2 
Destination-URI: mailto:hallam@ai.mit.edu mailto:ejw@ics.uci.edu 
I think that the command operating on multiple sources is much less usefull. 
I don't think that the entity compartment should be utilized for specifying the source or destination. 
It seems to me that this would be better used to put a comment on the reason for the operation. 
Phill 
One reason for having a separate MOVE operation is that if the document has 
attributes, you want a COPY operation to result in new values for certain attributes (like create date, creator) whereas a MOVE operation should leave the values alone. 
--Judy 
Name:Judith A. Slein E-Mail:slein@wrc.xerox.com 
MailStop:128-29E 
I disagree. 
Such attributes make little sense in the context of the Web, indeed the Web currently has no knowledge whatsoever of such things. 
If I move a file from one area of URL space to another that does not imply a transfer on the backing store. 
Phill 
I don't mean just file attributes, but metadata in general -- author, title, publisher, subject, etc. 
Most metadata stays the same whether a document is MOVEd or COPYd, but there are exceptions. 
URN, if implemented, is another attribute that should never change when a document is MOVEd, whereas a COPY of a document should get its own URN. 
Although work on metadata on the Web is very much "in progress" (URC, Z39.50, STARTS, etc.), I think it is an important part of document management that should be encompassed by the Web. 
It should be possible to set metadata using HTTP, however it turns out to be 
expressed. 
And the metadata should get updated properly when a document gets COPYd or MOVEd. 
--Judy Name:Judith A. Slein E-Mail:slein@wrc.xerox.com 
MailStop:128-29E 
I agree with the objectives but not with the conclusion. 
I see the keeping of metadata consistent to be a problem for the metadata system and not for http. 
The reason for this is that metadata can be external to the object. 
The assertion "http://foobar.com/wellcome is a load of rubbish" is not something that foobar.com are likely to want to store, manage or otherwise be involved with. 
Whether a piece of metadata which relates to a resource which is bound to name A should be in some way bound to the resource created at name 
B through the operation COPY A- B is not a simple issue. 
In my view it is 
something that will have to depend on the particular assertions being made. 
For example say I have a copy of the CNN site for 6th Sept 1996. 
I annotate this site with some political commentary "Operation Adios Bob Dole". 
In this case I am making an assertion relating to the content of the message which is intended to be linked to the name of the resource (ie the annotation has a secondness property wrt the resource if we adopt Pierce's trichotemy). 
Now say that someone comes along from the Dole camp and makes an annotation "What do you expect from those pinko lefties from Massachusetts?". 
In this case the annotation is clearly connected to the site hosting the annotated copy of CNN and is not an annotation on the CNN document. 
I don't think that this type of issue can be settled except by considering the prperties of each assertion with respect to the individual operations. 
We might set out a set of laws which may or may not be satisified by various assertion types. 
IE "MOVE Invariance" : f(A) Move (A-B) ; f(b) (if f(A) is asserted before we move the resource at A to B then f(B) follows). 
The assertion "Authored" clearly has move invariance, but "created" does not since creation is usually interpreted as being the act of binding a resource to a location. 
Phill 
That is possible, but only when the resource can be moved as a filesystem object in a single disk within a single server. 
If we were to limit MOVE to be only within a single server, that would be reasonable. 
The reason why it can't do that is because we currently have no way for the client to "lend" its authentication credentials to the server such that the server could perform that action on behalf of the client. 
Again, this is only an issue in cross-server MOVE methods. 
[And it would be a PUT, not a POST.] 
Yes, it does have an advantage in terms of atomicity. 
However, it might be better to just introduce a form of transaction support, since we already need that anyway. 
That too would be a reasonable solution, assuming that it is desirable to have the comments be typed via the content-type/encoding mechanism (I think so). 
Naturally, you could also include comments in the form of a Comments field. 
If people do choose to use a new header field for the list of source or destination URIs, then it is important to use a robust syntax. 
In other words, the URIs should be bracketed or "quoted" so that they are easily distinguished from adjoining commas or folding. 
......Roy 
I wish this was a problem :-( Unfortunately at present we simply don't have anything remotely like an authorisation scheme for the web. 
Neither BASIC nor DIGEST will really cut it for this application. 
That is hardly suprising since neither was designed with cross realm authorisation in mind. 
BASIC was an ad hoc hack and DIGEST was a cleanup job on BASIC which was compromised by the existing commitments made by BASIC. 
I think that as a matter of principle the distributed authoring people should ignore the current Web authorisation mechanisms. 
They are simply inadequate for collaboration. 
Assume that the security framework will be extended to meet the needs of collaboration. 
If you don't you will find that what you can do will be so limited that it will scarcely be worth worrying about. 
Yes we need it, but a MOVE instruction is equivalent to "read-test-modify" in terms of atomic transactions. 
Its a building block from which much else can be built. 
I think that even if we put support for transaction management into the Web there will be a need for MOVE since Transactions are likely to be something supported only on high end servers built on top of file or object systems which provide native transaction support. 
I see MOVE as something that the UNIX servers can support without difficulty and without huge expense. 
Agreed. Phill 
Thanks, Phill. 
I understand better what you are after now. 
I'd like to leave aside the particular example of annotations, since we might have a long argument about whether they are metadata or related documents. 
But I agree that it's up to the metadata system to set policy for whether metadata gets copied / moved with a document or not, whether it gets updated or not, or whether the user gets to decide. 
It implements a set of rules about MOVE Invariance and COPY Invariance. 
My background is in the kinds of document management systems Steve Carter listed in his note. 
The typical policy there is the one I described, where a MOVE keeps the document associated with all the same metadata it had before (well, except for its location if that is an attribute); a COPY results in a new unique identifier for the new copy, a new value for creator, a new value for create date, and perhaps for other system-controlled attributes, and the opportunity for the user to set new values for user-controlled attributes. 
The problem for a metadata system with this policy is that it has to know when it gets a COPY request whether that COPY is really going to turn out to be a MOVE, in which case it should treat the attributes in a different way. 
So it seems that you have to be able to communicate this to the metadata system somehow if you are going to allow the metadata system to have this policy. 
It's certainly possible for document management systems to behave in other ways, for example, letting a single set of metadata be associated with many copies of a document; or letting multiple sets of metadata (appropriate for different users, perhaps) be associated with the same document; or letting metadata be set for a document that is not online at all. 
--Judy Name:Judith A. Slein E-Mail:slein@wrc.xerox.com 
MailStop:128-29E 
