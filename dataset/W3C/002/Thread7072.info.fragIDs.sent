Roy et. al, RFC2396bis [1] Section 3.5 para 4 states: "As such, interpretation of the fragment identifier during a retrieval action is performed solely by the 
user agent; the fragment identifier is not passed to other systems during 
the process of retrieval." 
Is the focus of this sentence on retrieval deliberate - ie. the spec has nothing to say about whether or not fragment identifiers are passed to other 
systems during operations other than retrieval? 
I'd have expected this prohibition to have been more universal. 
Thanks, Stuart 
I'd say that the prohibition must indeed be focused on retrieval. 
There are other applications for which it is vital that a fragment identifier part of a URI be passed to other systems - XML namespaces and passing RDF data come to mind. 
#g Graham Klyne 
I think what Stuart is noting is that a fragment is also not passed 
for PUT or POST or any other action on the URI via HTTP. 
I am still thinking of a way to rephrase it. 
Perhaps what it should say is that the fragment is not passed to another system upon dereference of the URI? 
....Roy 
Or perhaps something along the lines that the server is not expected to use the fragment ID as input into the generation of a representation? 
-Tim 
I think that the important bit is that the fragment identifier 
is not used in the scheme-specific processing of the URI. 
Whether or not you pass the fragment to "another system" upon dereference may depend on your entire dereference mechanism (e.g., you _could_ pass the fragment along as a hint if you had a pipeline that was deciding which embedded images to pre-fetch in the next step of the pipeline). 
Larry 
This seems out of scope for a generic syntax specification. 
I see no reason why it should prohibe to define a protocol that is capable of redirecting references to doc1#foo to doc2#bar or convert a reference to doc#xpointer(id("abstract")/range-to(id("acks"))) into a protocol specific fragment request for, after all, the identified fragment. 
I think what Stuart is noting is that a fragment is also not passed 
for PUT or POST or any other action on the URI via HTTP. 
The "any other action... via HTTP" seems pretty severe to me. 
I think it's OK to state that for certain methods, the fragment identifier is not considered to be relevant to the request (e.g. GET, PUT, POST, 
etc. But for other methods, e.g. MGET, MPUT, MDELETE as defined by the URIQA model (http://sw.nokia.com/uriqa/URIQA.html) 
such a constraint would preclude alot of interaction between SW agents via HTTP concerning resources denoted by URIrefs with fragids. 
I am still thinking of a way to rephrase it. 
Perhaps what it should say is that the fragment is not passed to another system upon dereference of the URI? 
That would, of course, depend on the definition of "dereference". 
I consider e.g. MGET to involve dereference of a URI to a description of the denoted resource. 
Again, I think it is safest to take a more conservative position on this and simply note the irrelevance of fragids for particular methods. 
That said, even if some fragid is not relevant for some particular method, that does not mean that software should not include the fragid in requests. 
Or perhaps more generally, the URI of a request should be honored by all intermediate agents (proxies, firewalls, etc.) and should not be modified in any way. 
If the ultimate server recieving and acting upon the request disregards a fragid because it is not relevant to the method in question, fine. 
But we should not have to worry about fragids being lost in transit, particularly when using new/experimental/proprietary methods. 
The irrelevance of fragids to GET, PUT, POST, etc. should not preclude research and experimentation by either licensing or encouraging software to discard them in transit. 
Cheers, Patrick Stickler patrick.stickler@nokia.com 
....Roy 
(nods...) I was vaguely wondering about something like that. 
#g Graham Klyne 
Hello Roy, 
Broadly yes, although was trying avoid an HTTP bias. 
The quoted text express the constraint in a protocol independent fashion - to retrieval operation. 
I'm trying to understand why it is so important to state such a constraint wrt to retrieval and whether or not, maybe on the basis of minimal constraint, it was intentionally stated only for retrieval or whether it should be more universally applied. 
Thanks, Stuart 
Well, after thinking about this a bit, I've changed my mind. 
I think fragment identifiers are only defined for use with retrieval, because the semantics of the fragment are (supposed to be, at least) defined by the media type of the retrieved result. 
With other operations, there is no clear media type. 
Using fragment identifiers for other purposes, with PUT, 
POST, or any other operation, shouldn't be defined in the IETF 'Standard'. 
Maybe someone wants to propose some other semantics for fragment identifiers with operations other than retrieval, but I don't think this document is the right place to include those extensions. 
Larry 
That makes sense. 
However, at least with HTTP other operations, PUT and POST, do have potential to return response messages that carry representations with a 
media type - (in which case I guess one could argue that they are also a form of retrieval and hence covered - hmmm). 
Yes... I think staying silent about non-retrival frag id semantics is likely best. 
[Which implies the status-quo wrt the RFC2396bis draft - apologies for the disturbance]. 
Thanks, Stuart 
Not at all. 
doesn't represent status quo, only "status contemplated in Roy's reply." 
The status quo is still in a should-fix state. 
RDF has established use patterns that require passing the #fragment part to "other systems." 
[conceptual analysis] A resource may be considered to represent a view of the state of the universe. 
In that view extraction, the fragment part must not affect the 'select' semantics but may beneficially affect the 'present' semantics where the 'view' operation is factored into 'select' and 'present.' So, the #fragment part MUST NOT affect the information contained in the representation in response to a recovery request. 
The User Agent MAY strip the #fragment part and apply it post-recovery without loss of information. 
But "MUST NOT" pass to "other systems" is unjustified and detrimental. 
It should be fixed. 
If we want to warn people off of abuse-encouraging variants, we need to check out appropriate uses and draw the line appropriately before we go there. 
Has there been abuse? 
Is there a public discussion of it somewhere? 
In standard browsers, the fragment ID does affect the initial scroll and focus properties of the view in the viewport. 
In assistive middleware such as the SWAP system, it would be appropriate for the system to add-in a synthetic synopsis from the top of the page to the (#fragment-indicated) point where reading starts as a third-party annotation. 
Al 
Hi Larry: 
I wonder what this means with respect to the INFO URI scheme which defines a fragment component as a regular part of the syntax, info-URI = info-scheme ":" info-identifier [ "#" fragment ] while at the same time asserting that INFO URIs are non-dereferenceable (and hence there are no representations and no associated media types). 
In discussing the use of fragment components in the INFO I-D we use language which is closely aligned with that used in 2396bis (sect 3.5) to assert that: The (unescaped) values for the "fragment" component identify secondary information assets with respect to the primary information asset which is referenced by the "info-identifier". 
It would seem that the historical use of fragment components has been to provide an addressing mechanism into a resource representation following a retrieval operation, as commonly used in HTTP requests. 
But in a pure information context there may well be non-dereferenceable URIs such as INFO which still have a clear need to articulate secondary resources with respect to primary resources. 
So I do query what the role of media type is in these contexts. 
Tony 
I think if these are really totally undereferencable, then only using slashes is much better. 
If they are to be dereferencable via various indirection mechanisms, then the fragment identifier gets carried over to the result of subsequent retrieval. 
Regards, Martin. 
Yes, at least proposed. 
There were proposals for schemes that tried to say something like "in general, you don't need to send the fragment identifier, but for this scheme, you actually do". 
That's what Larry's statement at would address. 
Regards, Martin. 
What did Larry say? 
He said that you can't identify client and server in the future, so don't key rules to those roles. 
He did offer that one might rephrase the rule as keyed to the scheme-specific processing. 
But that was simply to avoid the above problem. 
He wasn't introducing any evidence of abuse, that is to say instances where violation of this rule had been exploited to do something bad. 
Larry's statement is IMHO grounded in HTTP and HTML. 
I didn't regard it as a position taken after a careful review of the model and functioning of the 'info' scheme. 
'Abuse' requires actual damage, not simply the violation of a clause in a draft spec. 
Hopefully Larry will find time to comment again. 
On the other hand, there may be a perfectly good binding in URI syntax for the 'info' model that uses path segments or ?query-part name-value selectors rather than #fragments for what the current proposal uses #fragments for. 
Al 
I specifically meant: "I think that the important bit is that the fragment identifier is not used in the scheme-specific processing of the URI." 
I think that's not what you address in your comments below. 
Regards, Martin. 
I'm not sure I'd call it "abuse". 
But when moving a document from Draft Standard to Standard, it's reasonable to restrict backward incompatible changes; if this is the "legacy" view, so be it. 
I believe that it has been legitimate for URI implementations to assume that the main URI can be separated from its fragment, handed off to a separate URI access mechanism (which looks at the scheme and does scheme specific processing) and then the fragment is applied after the results have been accessed, without reference to the scheme or any of the other components of the URI. 
This isn't "http" specific, because it works across access schemes http, ftp, file, data, cid, Other kinds of processing, hinting, and uses of fragments during processing might be _allowed_ and even reasonable, but *requiring* that the scheme-specific implementation can access the fragment (by defining the scheme-specific fragment interpretation) should not be allowed. 
Larry 
