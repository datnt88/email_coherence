<s> Hi, Quick summary of options: 1.  </s>
<s> Current Spec .  </s>
<s> This is intuitive (in my opinion) because it is based on a linear sequence of set operations. .  </s>
<s> Typical (IMHO) use cases require 2 XPath evaluations.  </s>
<s> However, increasingly complex filtering requirements incur increasing cost; an arbitrarily complex expression requires an arbitrarily large number of simple XPath expressions.  </s>
<s> However, the standard XPath filter may be more useful for these anyway. .  </s>
<s> Operation can, in most cases, be commingled with c14n for efficiency, but: .  </s>
<s> The union operator is really ugly and unintuitive.  </s>
<s> 2. Christian's Spec .  </s>
<s> *I* do not believe this is as intuitive; it involves labeling  </s>
<s> nodes and then traversing the document, proceeding based on node labels (e.g., omit-but-traverse). .  </s>
<s> Typical use cases require 2 XPath evaluations.  </s>
<s> Increasingly complex filtering requirements can be solved in a fixed number (2/3) of increasingly complex XPath expressions.  </s>
<s> .  </s>
<s> Operation can be commingled with c14n for effiency.  </s>
<s> 3. Or, we can take a variant of the current spec.  </s>
<s> I won't detail it horrendously, but basically: .  </s>
<s> The XPath Filter 2.1 takes, as a parameter, a sequence of operations, each of which is characterized as a set operation (intersect, subtract, union) and an XPath expression.  </s>
<s> .  </s>
<s> Operation over an input node set is as follows: * Construct a node set N consisting of all the nodes in the input document.  </s>
<s> * Iterate through each of the operations.  </s>
<s> # Evaluate the XPath expression; the result is X. # Expand all identified nodes to include their subtrees; the result is Y. # Assign N = N op Y * Use the resulting node set N as a filter to select which nodes from the input node set will remain in the output node set, just as the XPath 1.0 filter.  </s>
<s> This is tantamount to intersection with the input node set.  </s>
<s> * Implementations SHOULD note that an efficient realization of this transform will not compute a node set at each point in this transform, but instead make a list of the operations and the XPath-selected nodes, and then iterate through the input document once, in document order, constructing a filtering node set N based upon the operations and selected nodes.  </s>
<s> * Implementations SHOULD note that iterating through the document and constructing a filtering node set N can  </s>
<s> be efficiently commingled with the canonicalization transform if canonicalization is performed immediately after this transform.  </s>
<s> .  </s>
<s> With this formulation, intersection and subtraction are IDENTICAL to the existing spec, with the only change being that you can put them in one transform or many. .  </s>
<s> Union is, however, much improved (in my opinion).  </s>
<s> You can only use it to include nodes that would be removed by a previous operation in the same transform.  </s>
<s> As a result, the output node set will only include nodes from the input node set. .  </s>
<s> Efficiency is as with the current spec.  </s>
<s> Basically this fixes union.  </s>
<s> I write this a while ago; thought I'd send it rather than delete it.  </s>
<s> It's probably wasteful to propose yet another option.  </s>
<s> Merlin  </s>
<s> Hi Merlin, First, I don't think that it's "wasteful" to propose yet another option.  </s>
<s> It shouldn't be too late for good ideas.  </s>
<s> 1: Current spec: - I agree that the three operations (union/intersect/subtract) in general are intuitive, but (for me), it's absolutely non-intuitive that I can use union to include nodes which have not been in the input node set (even if it's /possible/ from the XML Signature spec).  </s>
<s> - One thing that makes all this a little bit confusing is that e.g. a union(/) as last step destroys all the selection work from previous steps because it includes everything again.  </s>
<s> 2: My spec: - Well, of course, for me, it's intuitive ;-)) - It has a nearly constant runtime 3: Merlins xfilter v2.1 - If I understood it right, you select the same nodes from the input *document* as in v2.0, but then you do not output the result as result node but use it as intersection mask with the input node set.  </s>
<s> Multiple 'steps' can be combined in a single ds:Transform - That's good, because it does what a /filter/ does.  </s>
<s> It cannot re-include nodes which have already been excluded in a previous ds:Transform.  </s>
<s> - As a result: I REALLY like it -- but I do not understand the following:  </s>
<s> Does this mean that based on the operations, you make some tree-labeling ;-)) and then you make one tree-traversal to output the selected nodes?  </s>
<s> Sounds cool, in that case, the efficiency would be much better then the current results of v2.0.  </s>
<s> What kind of algorithm do you use for - make a list of operations and selected nodes, - decide based on this data which nodes are the result.  </s>
<s> Christian --On Donnerstag, 6. Juni 2002 01:09 +0100 merlin merlin@baltimore.ie  </s>
<s> r/geuer-pollmann@nue.et-inf.uni-siegen.de/2002.06.06/10:29:55  </s>
<s> Yes, but this is the exact algorithm that implementations of the _current_ XPath Filter 2.0 transform _should_ use if a sequence of the current XPath Filter 2.0 transforms precedes c14n.  </s>
<s> This formulation of the filter simply makes it easier to express in terms of SHOULD language.  </s>
<s> If you're asking for a normative algorithm for the general case, then I would have to think for a while.  </s>
<s> Restricting myself somewhat: First, let's characterize a sequence of filters: Filter ::= (INTERSECT | SUBTRACT | UNION)+ You will observe that adjacent SUBTRACT and INTERSECT operations can be idempotently reordered, and that adjacent operations of the same type can be computationally merged.  </s>
<s> However, I would expect that type of thing to be done in the XPath expressions so I will ignore this.  </s>
<s> Restricting myself to the following production, which captures all _common_ (in my opinion) use cases: SimpleFilter ::= A:UNION* (B:INTERSECT | C:SUBTRACT)* D:UNION* Iterate over the document.  </s>
<s> (define (include-node) ;; whether or not to include a node (cond ;; returns the first match ((encountered-any D) t) ;; if you've encountered a node in a trailing union ((encountered-any C) nil) ;; not if you've encountered a subtraction node ((null B) t) ;; if there are no intersect operations ((encountered-all B) t) ;; if you've encountered a node in each intersect node set (t nil))) ;; not otherwise Note that encountered-any returns nil if its parameter is an empty list of node sets, but encountered-all is true in this case.  </s>
<s> We can therefore express this concisely: (define (include-node) (or (encountered-any D) (and (not (encountered-any C)) (encountered-all B)))) You can implement encountered-foo and therefore include-node strictly in terms of node labeling, a stack and iteration.  </s>
<s> Obviously you must also consider the input node set.  </s>
<s> Going from this to a fully general solution is fairly straightforward.  </s>
<s> Observe that UNIONs are subject to ALL subsequent INTERSECT and SUBTRACT operations, but no preceding ones, and that the entire filter is equivalent to: UNION/ Filter I can then say that a node is included if I have encountered a node in ANY ( UNION operation AND NOT ANY SUBSEQUENT SUBTRACT operation AND ALL SUBSEQUENT INTERSECT operations ).  </s>
<s> Work done to compute this is proportional to the number of filters but only done at a labeled node.  </s>
<s> Merlin  </s>
