A question. 
RDFS has a class named rdfs:Literal. 
Presumably this is supposed to be the class of all literal values, right? 
So it ought to be the case that for any literal LLL, this would be true: LLL rdf:type rdfs:Literal . 
But that's syntactically illegal. 
In fact it is impossible to say that literal has any properties in RDF, so why do we have a class in RDFS of things that we aren't allowed to say are in a class? 
(This came up when I was trying to characterize valid inference in 
RDFS, by the way. 
Sorry if this has been discussed before, but I've only just noticed it.) Pat Hayes IHMC(850)434 8903 home 40 South Alcaniz St.(850)202 4416 office phayes@ai.uwf.edu 
Not sure if this sheds light, but danbri is fond of quoting this from the schema spec: Although the RDF data model does not allow for explicit properties (such as an rdf:type property) to be ascribed to Literals (atomic values), we nevertheless consider these 
entities to be members of classes (e.g., the string "John Smith" 
is considered to be a member of the class rdfs:Literal.) Note: We expect future work in RDF and XML data-typing to provide clarifications in this area. 
I think this is a bit of a kludge. 
[ "Aaron Swartz" ; mailto:me@aaronsw.com ; http://www.aaronsw.com/ 
] 
Not just a bit, but a kludge, whole and entire. 
Thanks for pointing it out, though. 
Pat 
IHMC(850)434 8903 home 40 South Alcaniz St.(850)202 4416 office phayes@ai.uwf.edu 
OK, so can we declare literals resources yet? 
;-) That would certainly solve the problem. 
Seriously though, once we define the structure of a literal, it will be an easy task to create a URI scheme / URN namespace which can be used to identify them and map them onto URIs. 
[ "Aaron Swartz" ; mailto:me@aaronsw.com ; http://www.aaronsw.com/ 
] 
My take is that it provides a way of characterizing the things that literals denote. 
So even if LLL rdf:type rdfs:Literal . is not valid syntax, I think it's reasonable to be able to say that LV (as in XL: qLiteral - LV) is the same as ICEXT(I(rdfs:Literal)). 
I think this is consistent with the material Aaron refers to in his response to you. 
I think that material also hints at the possibility of recognizing different sub-types of rdfs:Literal. 
#g 
Graham Klyne MIMEsweeper Group Strategic Research http://www.mimesweeper.com 
Well, there is something very odd about having a constraint that is perfectly clear, perfectly natural, and assumed in the semantics, but being unable to say it in the formal language, especially when its perfectly clear HOW to say it in the formal language. 
(Its a bit like not being able to assert subclass loops, in fact :-) 
That would be OK, since there the rdfs:Literal would be the value of rdfs:subClassOf rather than the subject of something. 
Pat 
IHMC(850)434 8903 home 40 South Alcaniz St.(850)202 4416 office phayes@ai.uwf.edu 
It was a kludge of its time: RDF folk were encouraged at the time, rightly I think, "not to go there" w.r.t. any detailed representation of data types, since XML Schema was going to do that work for us, and for all XML-based languages. 
The RDF Core WG is chartered to clean this kludge up in RDF Schema; how adventurous we are in doing so remains to be discussed... Dan 
Well, yes. 
I sort-of assume the shackles will one day be removed from literals-as-subjects, but I'm just trying to make sense of that with which we are given to deal. 
It did occur to me that, after I wrote the comment above, the capability is arguably redundant now we have a formal model theory to work with. 
Our predecessors maybe had to introduce rdfs:Literal to give themselves some vocabulary to talk about what you constructed with ( XL : qLitereal - LV )? 
#g Graham Klyne MIMEsweeper Group Strategic Research http://www.mimesweeper.com 
