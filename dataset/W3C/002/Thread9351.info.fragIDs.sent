I think we need to nail down the handling of simpler cases before getting too involved in arcane syntax options. 
By simpler cases, I mean how are we to interpret simple RDF like this: rdf:Description rdf:about="#me" ex:shoeSize 10 /ex:shoeSize /rdf:Description 
dirt simple: ...#me ...#shoeSize "10". 
No no, wait a minute. 
You are having your cake and eating it. 
That triple doesn't conform to your proposed idiom; it uses the literal 
label in object position on an arc not labelled with a datatype mapping. 
If you allow this kind of triple and also your bNode idioms, 
you need to somehow connect them. 
Can we infer one from the other? 
Both ways? 
If so, the simple idiom (as you have here) is equivalent to the extended bnode form, so why do we need the latter? 
If not, how do we manage to establish any kind of inferential connection between them? 
Pat IHMC(850)434 8903 home 40 South Alcaniz St.(850)202 4416 office phayes@ai.uwf.edu 
I think we need to nail down the handling of simpler cases before 
getting 
too involved in arcane syntax options. 
By simpler cases, I mean how are we to interpret simple RDF like this: rdf:Description rdf:about="#me" ex:shoeSize 10 /ex:shoeSize /rdf:Description 
dirt simple: ...#me ...#shoeSize "10". 
Indeed, that triple doesn't conform to my proposed idiom, but that's because the RDF from which it's transcribed doesn't conform. 
I don't want folks to write that sort of RDF. 
I'm not 
trying to have my cake and eat it too. 
I want folks to write or it uses the literal label 
Sorta. Can we infer one from the other? 
Both ways? 
no. 
We don't. 
Dan Connolly, W3C http://www.w3.org/People/Connolly/ 
I think we need to nail down the handling of simpler cases before getting too involved in arcane syntax options. 
By simpler cases, I mean how are we to interpret simple RDF like this: rdf:Description rdf:about="#me" ex:shoeSize 10 /ex:shoeSize /rdf:Description 
dirt simple: ...#me ...#shoeSize "10". 
Yes, but what if they do write it? 
Its not *illegal*. 
Oh, I think I see, For you, all literals are strings, right? 
No exceptions. 
So if I say my shoesize is a string, then that's what I'm saying; and if that's not what I meant, then silly me. 
But now consider the following circumstance. 
Suppose that for some weird reason, something knows that Pat's shoeSize is represented by a literal string "10", and that's all it knows. 
Maybe a page scraper found it somewhere and wants to record what it found in RDF. 
However, it has no idea how this string is supposed to be interpreted; it hasn't had time yet to look up 'shoeSize' to find out what datatype it expects to be using. 
It will do that later, maybe. 
What can it do? 
It shouldn't write Pat shoeSize "10" . 
on your scheme, since that is only correct if shoeSize uses a string. 
What it ought to is write something like this: Pat shoeSize _:1 . 
_:1 some unknown datatype "10" . 
But there is no way to write that if you don't know the datatype. 
(Hmmm. 
Maybe this is a case use for anonymous predicates. 
If we could write Pat shoeSize _:1 . 
_:1 _:2 "10" . 
_:2 rdf:type rdfs:Datatype . 
that might be just right.) Maybe what it ought to write is something like Pat temp:ShoeSize "10" . 
temp:ShoeSize temp:tobereplacedby shoeSize . 
and then leave the re-transcription to something else which knows about temp: names (??) Pat IHMC(850)434 8903 home 40 South Alcaniz St.(850)202 4416 office phayes@ai.uwf.edu 
