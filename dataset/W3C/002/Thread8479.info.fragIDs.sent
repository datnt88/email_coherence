1. Includes changes based on that days discussions. 
2. Includes section 7 text from Bartel, will send more tonight. 
3. Includes text from Eastlake on MIME types. 
4. Includes additional editing from Reagle for clarity/organization. Joseph Reagle Jr. Policy Analyst mailto:reagle@w3.org 
XML-Signature Co-Chair http://w3.org/People/Reagle/ 
4.3.3 
Transformations 
Are transformations to be applied in the order specified? 
If the Transformations element is omitted, the only operation performed is the default c14n algorithm (null or identity). 
Am I correct in reading this as "the spec will eventually define a default c14n algorithm, which will be either null or identity"? 
I assume this same default will apply to SignedInfo when its c14nAlg is omitted? 
If so, language should be added to sec 4.0 or 4.1. 
-Greg Greg Whitehead Chief Scientist Signio, Inc. 1600 Bridge Parkway, Suite 201 Redwood City, CA 94065 650-622-2250 
gwhitehead@signio.com 
8.2 Signature Validation 2.calculate digest over all transformed signed object(s) based on the algorithm in Object reference(s). 
If the object is contained within the Object element, only the object itself is hashed (i.e. the Object and /Object  tags are excluded). 
3.compare value against digest value in SignedInfo (if mismatch, validation fails). 
Is it consensus now that checking the digest is core signature behaviour? 
If yes, why? 
There seemed to be reasons for allowing dsig applications to check signatures without checking integrity of the Objects - e.g. a scenario where a trusted third party can wittness the validity of signatures without knowing the signed content. 
AUS Dr. Andreas U. Schmidt, Dept. 
SIT | mailto:aschmidt@darmstadt.gmd.de 
GMD German National Research | phone :+49-6151-869-712 
TO:aschmidt@darmstadt.gmd.de,w3c-ietf-xmldsig@w3.org Yes. 
The current consensus is that at the top level, the ObjectReferences in SignedInfo, core processing includes validating the digest. 
One motivation, among others, was that a core signature operation whose behavior does not include verifying that the item referenced is the item signed would be deficient at best. 
In building an application, you can have the ObjectReference point to a Manifest (or other document of your definition, such as a TTP request/response) which contains references to other objects. 
In this case, the core behavior would validate the digest on the Manifest, but not the referenced objects. 
Dave 
From: aschmidt [mailto:aschmidt@darmstadt.gmd.de] 
Sent: Tuesday, October 05, 1999 4:59 AM Subject: Re:draft resulting from 990930 call 
8.2 Signature Validation 2.calculate digest over all transformed signed object(s) based on the algorithm in Object reference(s). 
If the object is contained within the Object element, only the object itself is hashed (i.e. the 
Object 
and /Object  tags are excluded). 
3.compare value against digest value in SignedInfo (if mismatch, validation fails). 
TO:gwhitehead@signio.com,w3c-ietf-xmldsig@w3.org Greg, There are actually two defaults, one for canonicalizing SignedInfo, and one for canonicalizing an Object. 
Each of these will have a default specified (which may or may not be the same - TBD). 
We'll add the language to 4.1 for the SignedInfo default. 
Dave 
From: gwhitehead [mailto:gwhitehead@signio.com] Sent: Monday, October 04, 1999 8:39 PM Subject: RE: draft resulting from 990930 call 
4.3.3 
Transformations 
Is it consensus now that checking the digest is core signature behaviour? 
If yes, why? 
There seemed to be reasons for allowing dsig applications to check signatures without checking integrity of the Objects - e.g. a scenario where a trusted third party can wittness the validity of signatures without knowing the signed content. 
The consensus was to check the digest of the objects indicated by signedobjectref. 
We perceived 'manifest' as just another object whose digest should be validated by core signature behavior. 
The manifest idea could then implement the feature you are interested in. 
Create a 'manifest' element listing the resources and their hashes. 
A signature would hash the manifest and digitally sign the hash. 
Verification would validate the integrity of the manifest element. 
It would then be the app's responsibility to validate or not validate the hashes it contains. 
The idea is that we need both methods. 
Obviously you understand the need for the manifest method. 
However, if we just had a method that validated manifests, then we could not say that core signature behavior was capable of validating the actual data that most people want to sign. 
John Boyer Software Development Manager UWI.Com -- The Internet Forms Company 
