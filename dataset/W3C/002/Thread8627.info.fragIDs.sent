Hi Joseph, Don, and Dave, 
I would like to ask you to consider at length the merits of completely throwing out any notion that core behavior should dig up resources external 
to the document containing the Signature element. 
The proposal below basically takes what we have now and throws out all of the stuff that most people really dislike, so it is not terribly different from what we have now. 
The benefits appear below the proposal, and they should be considered seriously. 
Object + Processing Rules: 1) All of the elements except SignatureValue must be created by the application prior to generating the signature 2) The Canonicalization method will be applied. 
3) The XPath filter will be applied, marking which elements should be kept and which should be omitted 4) The filter markers in the Signature element will be turned on, except for SignatureValue, which will be turned off. 
5) The marked portions of the document will be rendered to text. 
6) The text will be digested by the algorithm given in the SignatureMethod 7) The signature will be created using the SignatureMethod and KeyInfo For verification, follow steps 2 through 6, then 7) Compare the digest from step 6 with the one in SignatureValue, using the SignatureMethod and KeyInfo for decoding purposes. 
ADVANTAGES: 1) Nowhere do we see the need for core behavior to perform network access. 
Our task has been greatly simplified by signing an XML document (in whole or part) rather than trying to sign some arbitrarily large subgraph of the web with core (or mostly core) behavior. 
2) We acknowledge that obtaining the bag of bits from a non-local source is an application-specific task. 
An application that needs to associate a stylesheet, for example, with the XML should either put a copy of the stylesheet in an Object or it should push the whole problem out to a Manifest. 
This ties an application-specific behavior to an application-specific need. 
3) The hash in SignatureValue is applied directly to the data. 
Sure it can be argued 4) We have no need of the base64 transform. 
If an app wants to sign something in non-XML format, it must either be a signature over a base 64 (or similar) encoding, or the app must do it through a Manifest and use application-specific logic. 
5) This design gets rid of the need for that awful XSLT transform. 
I've only ever wanted the XPath transform to perform precision omission from the current document. 
The ability to completely transform into something else is weird. 
Yes, we often take some XML and transform it by XSLT before showing it to the user, but in my opinion, it is not necessary to sign the result of that transform. 
We only need to sign a bag of bits that includes precisely the information necessary to reconstruct what the user saw. 
Following "what you see is what you sign" too closely results in the maxim that the only thing we should sign is a bitmap of the screen (which clearly is not useful). 
6) Simplicity of specification and implementation. 
7) Complete ability to have core behavior be self-contained. 
The only thing we can safely count on being available is the document we are currently working with. 
To create a tight, complete core behavior, we should only be signing stuff in that document and pushing the resource location issues to the application. 
This proposal is by no means perfected, and it is heavily reliant on a subset of what we already have. 
Really all I'm proposing is getting rid of the unnecessary baggage that has been added by the fact that we want to sign external resources with core behavior when clearly we cannot. 
Can you please consider and respond to this proposal. 
Maybe we want to keep on doing what we're doing, or maybe we want to get something out ASAP that truly reflects what core behavior can reasonably do and truly delegates to application behavior those things (like resource location) that MUST be the responsibility of the application. 
To be honest, I like the thing we have now, and it's fine by me if we go forward with it, but we started this process from scratch last July with the idea that we would shave out many extraneous features of the proposal we had at the time, and I think it is only fair to apply the same effort to our own work. 
Did we just get it right on the first hit, or have we again fallen into a trap of trying to cover too much in the core behavior such that core cannot be accomplished without help from the application? 
John Boyer Software Development Manager UWI.Com -- The Internet Forms Company 
It isn't clear to me that we shouldn't be able to sign external bytes referenced by a URL in core behavior. 
It doesn't make sense to me to have to encode and include a BLOB in order to sign it. 
Perhaps locations should be restricted to certain protocols in their simplest forms (http, ftp, file, etc.) We should be able to use standard URLs if they can be reasonably dereferenced. 
Maybe I'm missing something here. 
Thanks, Rich 
This conversation has been useful to me in that a number of things are clearer in my own head, which is a good thing! 
Two responses follow, one in a chair capacity and one in a technical capacity. 
Chair: There doesn't seem to be strong support for change on the list so far. 
I think this is mainly for two reasons (1) people aren't keen to change 
what we have now and (2) in your proposal it relies upon XPath. 
Procedurally, David has said he will work on another rev that the editors will post next week and it will hopefully speak more clearly on these issues. 
At that point we can take a consensus poll in terms of moving forward and document any minority positions. 
Technical: The one thing I like in your proposal is the clarity between the signature core (cryptographically validating bytes) and manifests. 
As I originally envisioned our design, the "core behavior" would do nothing more than worry about signature (cryptographic) validity. 
We would also define a manifest for resources and their content's digests. 
If we did a good enough job in defining the manifest semantics we could require Signature applications to be aware of those semantics! 
(I knew doing a good job on that topic would be hard and I think we've seen that it is!) Whether we called it SignedInfo (and included two other pieces of information) or occurred within or without the Signature was immaterial in my mind. 
What I hope we can do is make a few minimal changes so as to restore this distinction between a bucket of bits and manifest/reference semantics. 
An easy way to do this I think would be to introduce an element within SignedInfo in which you can place arbitrary data; this might include a set of ObjectReferences or not. 
However, I'm not sure I've convinced others this is a useful thing. 
Finally, I feel I've learned the following about ObjectReferences. 
People should feel free to tell me if they agree or disagree with any of these specific points: 1. 
A digest (and subsequent signature) is over bits. 
How you get those bits is immaterial to the digest. 
2. Since the "critical bits" of the DigestContent (the stuff digested) is often not explicitly represented, it is useful to document the way in which they were derived -- that specification might even permit multiple ways (the URI is dynamically dereferenced, more than one XML instance transforms into the final XML instance that is digested, etc.). 
However this information has no necessary meaning to the DigestValue itself -- the question is whether the final value is the same. 
2.1 Consequently, my earlier thinking of starting with a source document, and putting it through various transformations (and achieving closure) starts at the wrong end of the stick. 
As TimBL stated when we started worrying about transforms and context, you are signing the derived content. 
3. WE define what our syntax means. 
We are not "changing its meaning under the covers." 
We have to explicitly define the meaning of every bit of syntax we have. 
This is why I like to think in terms of assertions with a subject, predicate and object. 
I think it is a good idea to say the presence of a Transforms and a Location element means: a. 
There is a set of XML documents that when transformed yield DigestContent (the content that is finally digested.) b. 
At some point in time, the XML document obtained by dereferencing this URI was just such a document. 
BTW: I'm not quite sure why you feel the current spec required XSLT, merely one of many possible transform algorithms and one I think we should optional in section 5.1 given it is still a WD (and XPath is now a REC). 
Joseph Reagle Jr. Policy Analyst mailto:reagle@w3.org 
XML-Signature Co-Chair http://www.w3.org/People/Reagle/ 
Hi Joseph, (Also Dave, this contains yet another description of why I like XPath, which you asked that I explain again at some point). 
I'm glad you had a look at the simplified syntax. 
I really don't mind whether we simplify or whether we move forward with what we have and solve the Location problem in some way. 
As for the XSLT transform, you could make it optional or preferably take it out. 
I didn't suggest the need for it. 
I only needed XPath so I would have a precision language for describing what was omitted from the digested content. 
However, it seemed to me that people other than me wanted to do some very application specific things like compress/decompress, so I threw in the idea of a Java-based transform. 
Once you do that, though, the idea of an XSLT is certainly no scarier. 
I've been putting this off as long as possible for fear that XPath would be thrown out of the spec, but part of the problem is that I don't agree with Tim BL (entirely). 
I agree that we are indeed signing only the bits that get digested. 
However, I don't agree that nothing can be said about the original document before the transforms. 
The whole idea behind document closure is that an XPath transform contains an 'assertion' that only certain very precisely defined changes can be made to the pretransformed document without breaking the signature. 
The permissible changes can undergo a security review within the application context, the result of which would be the agreement of the reviewer(s) that such changes could not materially affect the signer's signature. 
Obviously, if an attacker modifies the bits directly covered by the digest, then the signature breaks. 
But, if the attacker modifies regions of the document not originally signed by the user, but they are modified in ways that violate the conditions established by the XPath, then the modifications will be added to the digestible message during verification, which will also break the signature. 
In other words, if an attacker were to modify the document in a way that is 
not permitted by the (signed) XPath transform in the ObjectReference, then the signature would still break because the wrong message would be constructed for comparison to the DigestValue. 
So, the XPath can indeed protect the entire document from unwanted modifications despite the fact that it drops out certain pieces. 
When we verify, start with a document, and apply the XPath transform. 
If the signature validates, then two assertions can be made: 1) the document contains all the bits it used to contain, PLUS 2) the document as a whole has not been modified in ways contrary to the precise definitions given in the XPath. 
This is the essence of how XFDL signatures work, only there was 
no XPath at the time, so we created our own syntax (it is specific to XFDL parse trees, whereas we now require XPath because we want to do the same idea only on generic XML documents). 
Thus, my interpretation of ObjectReference is quite different from yours. 
The information in ObjectReference that allows me to arrive at the bag of bits covered by the DigestValue is quite important to achieving document closure. 
It is quite necessary that it have well-defined processing rules and that it be signed by the SignatureValue (except that sometimes people might want to omit a very specific transform like the base 64 decoder). 
As for reliance on XPath in the 'simplified' proposal, it would require only a slight tweak in order for me to say that every instance of XPath in the simplified proposal would require an XPath in our current spec. 
The only thing I did was took out the idea of multiple element references. 
XPath easily allows you to list multiple elements, so there is no need for us to invent our own separate syntax (except of course that people don't want to use the W3C recommended XPath syntax). 
John Boyer Software Development Manager UWI.Com -- The Internet Forms Company [mailto:w3c-ietf-xmldsig-request@w3.org]On 
Behalf Of Joseph M. Reagle Jr. 
external 
This conversation has been useful to me in that a number of things are clearer in my own head, which is a good thing! 
Two responses follow, one in a chair capacity and one in a technical capacity. 
Chair: There doesn't seem to be strong support for change on the list so far. 
I think this is mainly for two reasons (1) people aren't keen to change what we have now and (2) in your proposal it relies upon XPath. 
Procedurally, David has said he will work on another rev that the editors will post next week and it will hopefully speak more clearly on these issues. 
At that point we can take a consensus poll in terms of moving forward and document any minority positions. 
Technical: The one thing I like in your proposal is the clarity between the signature core (cryptographically validating bytes) and manifests. 
As I originally envisioned our design, the "core behavior" would do nothing more than worry about signature (cryptographic) validity. 
We would also define a manifest for resources and their content's digests. 
If we did a good enough job in defining the manifest semantics we could require Signature applications to be aware of those semantics! 
(I knew doing a good job on that topic would be hard and I think we've seen that it is!) Whether we called it SignedInfo (and included two other pieces of information) or occurred within or without the Signature was immaterial in my mind. 
What I hope we can do is make a few minimal changes so as to restore this distinction between a bucket of bits and manifest/reference semantics. 
An easy way to do this I think would be to introduce an element within SignedInfo in which you can place arbitrary data; this might include a set of ObjectReferences or not. 
However, I'm not sure I've convinced others this is a useful thing. 
Finally, I feel I've learned the following about ObjectReferences. 
People should feel free to tell me if they agree or disagree with any of these specific points: 1. 
A digest (and subsequent signature) is over bits. 
How you get those bits is immaterial to the digest. 
2. Since the "critical bits" of the DigestContent (the stuff digested) is often not explicitly represented, it is useful to document the way in which they were derived -- that specification might even permit multiple ways (the URI is dynamically dereferenced, more than one XML instance transforms into the final XML instance that is digested, etc.). 
However this information has no necessary meaning to the DigestValue itself -- the question is whether the final value is the same. 
2.1 Consequently, my earlier thinking of starting with a source document, and putting it through various transformations (and achieving closure) starts at the wrong end of the stick. 
As TimBL stated when we started worrying about transforms and context, you are signing the derived content. 
3. WE define what our syntax means. 
We are not "changing its meaning under the covers." 
We have to explicitly define the meaning of every bit of syntax we have. 
This is why I like to think in terms of assertions with a subject, predicate and object. 
I think it is a good idea to say the presence of a Transforms and a Location element means: a. 
There is a set of XML documents that when transformed yield DigestContent (the content that is finally digested.) b. 
At some point in time, the XML document obtained by dereferencing this URI was just such a document. 
BTW: I'm not quite sure why you feel the current spec required XSLT, merely one of many possible transform algorithms and one I think we should optional in section 5.1 given it is still a WD (and XPath is now a REC). 
Joseph Reagle Jr. Policy Analyst mailto:reagle@w3.org 
XML-Signature Co-Chair http://www.w3.org/People/Reagle/ 
Consider 4 cases: Document(A) --Transform(1)-- DigestContent(A) --Digest -- DigestValue(A) where Document(A) when transformed results in a DigestValue(A). 
Document(A') --Transform(1)-- DigestContent(A) --Digest -- DigestValue(A) where Document(A') includes changes to the material excluded by Transform(1). 
(reference validation) Document(B) --Transform(1)-- DigestContent(B) --Digest -- DigestValue(B) where Document(B) includes changes from Document(A) that were part of the included portion, resulting in a different DigestValue. 
(reference invalidation) Document(C) --Transform(2)-- DigestContent(A) --Digest -- DigestValue(A) where Document(C)  Document(A) and Transform(2)  Transform(1) I believe I am stating that the later case is a true reference validation. 
I believe you are asserting it is not. 
Consider a more concrete instances of examples 1 and 4. Document(A) Transform(1) select second name element (then digest and sign) Document(B) Transform(2) select first name element (then digest and sign) I'm saying the DigestValues of both things will be equal, and if the signature was over the first, then it will validate the second. 
You are saying they should not be, and I don't understand why (aside from the wrong side of the stick) since the thing you signed was the digest of " name john /name " in either case! 
If one were to argue that the user will be shown Document(A,B) not DigestContent(A,B) and these elements were ordered (who sent the most email smile ), then I could sort of see your argument. 
However, Tim's point was that you are signing the derived content, and if these things are ordered and you want to preserve that ordering, then your transform should have captured that bit of syntax!! 
You still get closure. 
Joseph Reagle Jr. Policy Analyst mailto:reagle@w3.org 
XML-Signature Co-Chair http://www.w3.org/People/Reagle/ 
Yes, I am stating that the final case is NOT a reference validation as you claim. 
It would break because Transform(1) is a signed part of SignedInfo, so changing to Transform(2) will break the SignatureValue even though the DigestValue validates. 
If you do not sign the ObjectReference transforms, then as I have explained before, you have the following situation: Suppose I have a document ABCDE, and I have a transform that says keep all nodes, except *omit* C, if the transforms are not signed, then an attacker can change the transform to say *keep* ABDE without breaking the signature. 
The difference between the former exclusive logic and the latter inclusive logic is in what can happen to the document containing AB?DE. 
With inclusive logic, it can become 'aaabbbcccdddAByyyzzzsssssDEblahblahblah' without breaking the signature. 
With exclusive logic, it can only be ABDE or ABCDE. 
As an example, suppose ABDE is the state of the document after a first signature is added, and C is the work that must be done by a second signer, then an XPath for the first signer can precisely define C such that it does not substantially impact the meaning of ABDE. 
The XFDL example I gave at FTF#2 is an example of exploiting this idea, and this is the essence of what I've been calling document closure. 
C represents the body of things that the can be done to 'close' or finish the document after it has been signed by signer 1. Deviation from C breaks the signature. 
Thus, the Xpath transform that says 'Omit C' is a signed assertion that the signature of signer 1 is valid if and only if changes other than C have not been made to the document. 
John Boyer Software Development Manager UWI.Com -- The Internet Forms Company 
is 
was 
Consider 4 cases: Document(A) --Transform(1)-- DigestContent(A) --Digest -- DigestValue(A) where Document(A) when transformed results in a DigestValue(A). 
Document(A') --Transform(1)-- DigestContent(A) --Digest -- DigestValue(A) where Document(A') includes changes to the material excluded by Transform(1). 
(reference validation) Document(B) --Transform(1)-- DigestContent(B) --Digest -- DigestValue(B) where Document(B) includes changes from Document(A) that were part of the included portion, resulting in a different DigestValue. 
(reference invalidation) Document(C) --Transform(2)-- DigestContent(A) --Digest -- DigestValue(A) where Document(C)  Document(A) and Transform(2)  Transform(1) I believe I am stating that the later case is a true reference validation. 
I believe you are asserting it is not. 
Consider a more concrete instances of examples 1 and 4. Document(A) Transform(1) select second name element (then digest and sign) Document(B) Transform(2) select first name element (then digest and sign) I'm saying the DigestValues of both things will be equal, and if the signature was over the first, then it will validate the second. 
You are saying they should not be, and I don't understand why (aside from the wrong side of the stick) since the thing you signed was the digest of " name john /name " in either case! 
If one were to argue that the user will be shown Document(A,B) not DigestContent(A,B) and these elements were ordered (who sent the most email smile ), then I could sort of see your argument. 
However, Tim's point was that you are signing the derived content, and if these things are ordered and you want to preserve that ordering, then your transform should have captured that bit of syntax!! 
You still get closure. 
Joseph Reagle Jr. Policy Analyst mailto:reagle@w3.org 
XML-Signature Co-Chair http://www.w3.org/People/Reagle/ 
