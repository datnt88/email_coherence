[ Has this been done to death before? 
I looked in the archives and didn't see this exactly, but if I missed it can someone steer me toward it? 
] Canonical XML makes use of information that may have started life in a DTD (e.g. entity declarations and attribute types) but does not directly include the DTD in the c14n output. 
Section 1.3 of the Canonical XML Recommendation discusses cases where this may lead to (possibly false) negatives, i.e. discarding or changing the DTD can produce different c14n results, which when used in dsig will lead to digest mismatches. 
In particular, the second-last paragraph discusses the effect on attributes whose type is ID. 
I'm wondering about the converse -- cases that can lead to false positives, i.e. changing the DTD doesn't change the pile of bits that comes out of c14n (so, when used in dsig, the digest will still match and the signature will still verify), but the document now means something different. 
The example that I have in mind uses attributes whose type is ID, and it goes something like this... say I'm a disgruntled screenwriter, and for the next episode of the soap that I'm working on I produce a plot outline like this: !DOCTYPE Soap [ !ATTLIST Character name ID #REQUIRED nickname CDATA #IMPLIED ] and get sign-off from the series producer. 
(For concreteness, say he signs the entire document using an enveloped signature, and puts the signature just before the closing " /Soap "). 
Now I modify the ATTLIST declaration, changing the ID attribute from "name" to "nickname", and end up with !DOCTYPE Soap [ !ATTLIST Character name CDATA #REQUIRED nickname ID #IMPLIED ] This still verifies, but now Tim dies instead of Bob, which isn't the outcome that the series producer thought he was signing. 
Thomas Maslen DSTC 
Hi Thomas, Fabulous work. 
Hasn't been done to death and is quite original. 
A beautiful example of the dangers inherent in being forced to accept the limitations of 'existing technology'. 
My immediate reaction to any omission of data is 'document closure', i.e. if an article of data is necessary to the interpretation of a document, then don't omit it. 
It often happens that only the 
application designer is capable of fully assessing this. 
In the case of the DTD, either design the application so that the DTD is largely superfluous or, if it is needed, then find a way to include it in the signature, even if C14N excludes it. 
One could put a Reference 
to the dtd file and an Object containing a copy of the internal DTD subset in the signature before signing. 
After a core signature validation, the application could check to make sure that no change of DTD occured. 
It may seem disappointing that core validation is not enough, but I 
think many of us have long believed that there are a lot of applications 
for which it simply won't do. 
In particular, implementing the maxim "What you see is what you sign" requires (at a minimum) a post-processing step to ensure that the presentation layer stylesheet used to render data actually matches the one included in a signature. 
I personally have found a number of other steps useful/necessary in complex signature scenarios involving signatures over partial documents. 
Despite the existence of application-specific solutions, your example is excellent. 
John Boyer Senior Product Architect, Software Development Internet Commerce System (ICS) Team PureEdge Solutions Inc. Trusted Digital Relationships v: 250-708-8047 f: 250-708-8010 1-888-517-2675 http://www.PureEdge.com 
http://www.pureedge.com/ 
[ Has this been done to death before? 
I looked in the archives and didn't see this exactly, but if I missed it can someone steer me toward it? 
] Canonical XML makes use of information that may have started life in a DTD (e.g. entity declarations and attribute types) but does not directly include the DTD in the c14n output. 
Section 1.3 of the Canonical XML Recommendation discusses cases where this may lead to (possibly false) negatives, i.e. discarding or changing the DTD can produce different c14n results, which when used in dsig will lead to digest mismatches. 
In particular, the second-last paragraph discusses the effect on attributes whose type is ID. 
I'm wondering about the converse -- cases that can lead to false positives, i.e. changing the DTD doesn't change the pile of bits that comes out of c14n (so, when used in dsig, the digest will still match and the signature will still verify), but the document now means something different. 
The example that I have in mind uses attributes whose type is ID, and it goes something like this... say I'm a disgruntled screenwriter, and for the next episode of the soap that I'm working on I produce a plot outline like this: !DOCTYPE Soap [ !ATTLIST Character name ID #REQUIRED nickname CDATA #IMPLIED ] !-- (Uses URI fragments but could also use IDREF attributes) -- and get sign-off from the series producer. 
(For concreteness, say he signs the entire document using an enveloped signature, and puts the signature just before the closing " /Soap "). 
Now I modify the ATTLIST declaration, changing the ID attribute from "name" to "nickname", and end up with !DOCTYPE Soap [ !ATTLIST Character name CDATA #REQUIRED nickname ID #IMPLIED ] !-- (Uses URI fragments but could also use IDREF attributes) -- This still verifies, but now Tim dies instead of Bob, which isn't the outcome that the series producer thought he was signing. 
Thomas Maslen DSTC 
Yes. 
This is the bit that worries me: is there a danger that only a handful of people have the necessary competence to use this specification correctly? 
In particular, my guess is that an application designer, even one with a security background, will be hard put not to stumble into security traps caused by XML nuances. 
The guidance in the Security Considerations section is very good, but it may have to cover a lot more territory still if we're to have a better than even chance of getting people to produce secure applications. 
One could put a Reference to the dtd file and an Object containing a copy of the internal DTD subset in the signature before signing. 
After a core signature validation, the application could check to make sure that no change of DTD occured. 
Fair enough. 
I had thought of the (non-XML) signature over the external DTD but hadn't thought of including a copy of the internal DTD as PCDATA or CDATA; neat. 
However, doing this requires going well outside what DOM 2 provides, and maybe even outside what SAX 2 provides, which seems to go against the efforts in dsig and particularly c14n to use information that is preserved by SAX and DOM. 
[I've just had the pleasure of writing the character-munging code to copy the DTD from the original version to the edited version of a document that is being massaged by SAX or DOM; all I have to say is bah humbug]. 
I'm not sure about the feasibility of this: 
either design the application so that the DTD is largely superfluous [...] 
because ID attributes are awfully useful if the graph is anything more fancy than a tree. 
Can we state a sufficient set of conditions for a language/DTD to be safe? 
(I'm not sure that _I_ can -- the ID-attribute hack was the obvious one that occurred to me, but are there more subtle possibilities involving e.g. whitespace normalization in different attribute types?). 
I've also been wondering about XML Schema. 
In some ways the situation is a lot better than with DTDs, because (a)it's easy to sign schema info because it is expressed as XML elements (hence visible in SAX and DOM), and (b)xsi:schemalocation attributes are a hint that a schema processor is free (even encouraged?) to ignore. 
On the other hand, it seems as though you could have some fun if you knew that the signer's schema processor did honour xsi:schemalocation and the verifier's schema processor did not, or vice versa. 
Thomas Maslen DSTC 
You're right that securing XML in the general case isn't easy. 
It's one reason for things like Section 7.1 of the specification. 
Donald From: Thomas Maslen maslen@dstc.edu.au 
Message-Id: 200107130825.f6D8PC402131@piglet.dstc.edu.au 
In-reply-to: Your message of "Thu, 12 Jul 2001 10:34:39 MST." Date: Fri, 13 Jul 2001 18:25:20 +1000 
One could put a Reference to the dtd file and an Object containing a copy of the internal DTD subset in the signature before signing. 
After a core signature validation, the application could check to make sure that no change of DTD occured. 
either design the application so that the DTD is largely superfluous [...] 
