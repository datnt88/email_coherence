Brian dropped by and asked me what the key differences between S and TDL were. 
Here is a list: ** A single triple: bob age "30" . 
In S "30" is a string, in TDL it is untyped. 
** Range constraints for this triple. 
In S-B the range constraint is something like: age rdfs:range xsd:integer.lex . 
whereas in TDL (using the .map 
prefix that is not part of TDL) we would have: age rdfs:range xsd:integer.map . 
** The role of the map, the lexical space, the value space. 
S makes strong distinctions between these. 
TDL always uses the map as representing the datatype (and then does not use the .map 
extenstion). 
** syntactic stylistic The local idiom D and the local idiom S-A are different syntaxes, roughly meaning the same thing. 
D has better compatibility with DAML. 
** interaction of multiple different lexicalizations with possibly multiply different types. 
S-A is strong S-B is weak TDL is in between. 
(An example is when we have two integer dataypes one with binary lexicalization and one with decimal lexicalization). 
S-B allows "100" with both types as legal (despite two different values to the application) S-A allows "100" as legal and the syntax forces disambiguation of one type or the other, S-A also allows compatible lexicalizations [eg:binary "100" ] [ eg:deciaml "4" ] on the same node. 
TDL detects a type conflict and rejects a document trying to give "100" both types. 
Jeremy 
As I said in my discussion of how perl programmers might do datatyping in RDF, it's not necessarily the case that in S, "30" is a string; we could call them "scalars" if you don't like using "30" to represent an integer. 
What's necessarily the case is that in S, "30" denotes the same thing in all interpretaions, but in TDL it doesn't. 
Dan Connolly, W3C http://www.w3.org/People/Connolly/ 
In TDL (though not perhaps the current TDL MT, which should be revised) a literal is a literal is a literal. 
In the graph, it simply is a string that, IFF paired with a datatype, may be interpreted as a lexical form (a member of the lexical space of that datatype). 
This is just as with S. However, I do disagree with the statement that "30" always denotes the same thing in all interpretations -- as its interpretation is context specific, either per a given predicate or explicitly defined typing (local or global). 
In my latest illustration, showing that the TDL model (though not the TDL MT) is agnostic about, and hence compatable with tidy literals, the literal "30" has two interpretations. 
The literal itself is not always the same thing. 
A lexical form is always the same thing, per the definition of datatypes, lexical spaces, and mappings from lexcal spaces to value spaces -- but it is the interpretation of a literal that gives us the lexical form. 
The literal itself may be interpreted as many lexical forms, depending on the context form which a TDL is derived. 
Patrick 
But how do you know? 
If you don't define the datatype, 
or if your knowledge migrates out of the circle of your control? 
What if I need "30" to mean something else? 
What if it is 
supposed to be a monthDay? 
How about a human age in years? 
What if it is a magnitude of kilograms? 
And how could one assign some other interpretation either in S or TDL if "30" always denotes the same thing? 
I think that your argument has nothing to do with any limitation of TDL. 
I think you will encounter the same problems with S as well if you leave datatyping knowledge implicit in your application and yet expect your data values to be portable to other application spaces with the same interpretation. 
Patrick 
I don't know how to have a conversation like this. 
I'm using the word "interpretation" in the technical sense of our model theory working draft. 
I can't make sense of "its interpretation is context specific". 
You seem to have switched to some informal use of the word "interpretation". 
Dan Connolly, W3C http://www.w3.org/People/Connolly/ 
Because the specification says so. 
I don't know how to make sense of that. 
I doubt you really need "30" to mean something else. 
Zillions of perl and tcl programmers, for example, do just fine with just one kind of literal. 
I expect you just need to talk about something closely related to "30", such as the integer whose decimal (or octal or ...) numeral is "30". 
You can do that with S. 
All handled by S, to my satisfaction. 
I have working 
calendar applications, stuff that does mathmatical 
calculations, etc., all using S (S-B, in particular). 
See http://www.w3.org/2000/01/sw/ . 
One doesn't. 
If one wants to refer to something other than the two character string '3' followed by '0', one uses a different expression than "30". 
After several months of implementation experience with S, I have not run into any problems with S. 
Dan Connolly, W3C http://www.w3.org/People/Connolly/ 
It's called the global semantic web, where RDF encoded knowledge is interchanged around the world between disparate applications. 
But, again, perl and tcl have *BUILT IN DATATYPES*. 
Sorry for shouting, but I keep having to repeat that point. 
RDF has *NO* built in datatypes -- therefore, all typing must have some explicit definition, either locally or globally, if we are to consistently interpret the literals to the values they are intended to denote. 
You seem to presume that your own, personal applications will provide the datatyping knowledge for interpretation, and that in such a context, you have no need of local or global datatyping mechanisms in RDF -- fine, that is true so long as you stay in your own little isolated bubble. 
If you expect to interchange knowledge freely around the world, then you'd better figure out how to express your datatyping knowledge (and expectations) in a portable way. 
The S approach seems contrary to the very purpose of having standardized datatypes -- so that applications know what to expect. 
S allows folks to change the rules on the fly, and that won't facilitate global interoperability. 
Fair enough, but there are other people who also need to be satisfied here, no? 
I'd love to take a look, but perhaps you could narrow the reference a bit, eh? 
And *how* dear sir will an application know what that *other* expression is supposed to mean. 
You seem to have a view that RDF is like a programming language with a well defined, native, built in set of datatypes with disjunct lexical spaces where there is a an implicit datatype membership determinable for every lexical form encountered. 
I'm not sure you are evaluating these datatyping proposals with the same scope of expectation that others (myself included) are. 
Good for you. 
How much of your data is globally exchanged with other applications? 
And do those applications share your implicit expectations regarding datatyping of literals? 
Patrick 
I still don't see how this relates to the design choices at hand in any technical sense. 
Tcl has one datatype: strings. 
Perl has one (relevant) datatype: scalars. 
I suggest that RDF can do likewise. 
(see S, idiom B, for details). 
It doesn't seem to matter how many times each of us repeats his position; it's pretty clearly not going to convince the other. 
I think I have said what I have to say. 
Dan Connolly, W3C http://www.w3.org/People/Connolly/ 
The TCL/PL approach strikes me as having no datatyping in RDF -- but leaving all datatype interpretation to the application level. 
Fine. 
That's certainly an option. 
To leave RDF as it is, with no datatyping -- beyond saying that literals are Unicode strings -- and let applications and other standards address it; but I fear that that will have a significant impact on the utility of RDF for broad global interchange of knowledge. 
Cheers, Patrick 
