Hey folks, Here's an excercise for those of us who think we fully grok the convergence datatyping proposal ;-) I would like to use the following use cases to clarify exactly what is meant by the various *range constraint properties used by the convergence datatyping proposal. 
I hope this will ensure that we all actually do understand the convergence proposal the same way ;-) Some of these may be "impossible" or "badly formed" cases, or trivial variants of others, and if so, I'd like it to be stated why. 
I've used rdf:lform rather than rdf:value, to avoid 
any influence from existing presumptions about what rdf:value means. 
rdf:lform can be taken to have a range of "lexical form" (member of lexical space) and a domain of "data value" (member of value space) for some datatype. 
Each example should be considered in isolation, the bnodes are not shared between examples and the only other information that can be applied is that provided by the MT, closure rules, etc. 
Specific questions: a) what is the range constraint -- value space, lexical space, both? 
b) what does each bNode, if any, denote? 
c) is there enough information to recognize datatypes? 
d) is there enough information to execute a datatyping mapping to a value? 
I won't give my own answers just yet ;-) 1. dc:date rdfs:range xsd:date . 
xxx dc:date "2002-02-14" . 
2. dc:date rdfs:drange xsd:date . 
xxx dc:date "2002-02-14" . 
3. dc:date rdfs:range xsd:date . 
xxx dc:date _:1 . 
_:1 rdf:lform "2002-02-14" . 
4. dc:date rdfs:drange xsd:date . 
xxx dc:date _:1 . 
_:1 rdf:lform "2002-02-14" . 
5. dc:date rdfs:range xsd:date . 
xxx dc:date _:1 . 
_:1 rdf:lform "2002-02-14" . 
_:1 rdf:dtype xsd:date . 
6. dc:date rdfs:drange xsd:date . 
xxx dc:date _:1 . 
_:1 rdf:lform "2002-02-14" . 
_:1 rdf:dtype xsd:date . 
7. dc:date rdfs:range xsd:date . 
xxx dc:date _:1 . 
_:1 xsd:date "2002-02-14" . 
(note no other statements about xsd:date) 
8. dc:date rdfs:drange xsd:date . 
xxx dc:date _:1 . 
_:1 xsd:date "2002-02-14" . 
(note no other statements about xsd:date) 
9. dc:date rdfs:range xsd:date . 
xxx dc:date _:1 . 
_:1 xsd:date "2002-02-14" . 
xsd:date rdf:type rdfs:Datatype . 
xsd:date rdfs:subPropertyOf rdf:lform . 
10. dc:date rdfs:drange xsd:date . 
xxx dc:date _:1 . 
_:1 xsd:date "2002-02-14" . 
xsd:date rdf:type rdfs:Datatype . 
xsd:date rdfs:subPropertyOf rdf:lform . 
11. xsd:date rdf:type rdfs:Datatype . 
xsd:date rdfs:subPropertyOf rdf:lform . 
xsd:date rdfs:range _:1 . 
dc:date rdfs:range _:1 . 
xxx dc:date "2002-02-14" . 
12. xsd:date rdf:type rdfs:Datatype . 
xsd:date rdfs:subPropertyOf rdf:lform . 
xsd:date rdfs:drange _:1 . 
dc:date rdfs:drange _:1 . 
xxx dc:date "2002-02-14" . 
Have a nice weekend! 
;-) 
Patrick 
There could be some debate about our ability to add things to the RDF namespace without changing its URI. 
How about rdfs:lform? 
B 
Fine with me. 
I guess we anyway agreed that we're pushing the datatype stuff into RDFS, so that would mean we should use rdfs:dtype rather than rdf:dtype as well. 
Patrick 
My answers, based on the union interpretation of rdfs:drange for datatype classes proposed (officially) in 
a) the value space of xsd:date b) n/a c) no d) no 
a) the union of the value and lexical spaces of xsd:date b) n/a c) yes, rdfs:drange ddd implies ddd rdf:type rdfs:Datatype d) TDL("2002-02-14",xsd:date) 
a) the value space of xsd:date b) some member of the value space of xsd:date c) no d) no, we do not know what lexical space the literal belongs to, and the rdfs:range constraint say's nothing about lexical representation, only about value spaces 
a) the union of the value and lexical spaces of xsd:date b) some member of the value space of xsd:date c) yes, rdfs:drange ddd implies ddd rdf:type rdfs:Datatype d) TDL("2002-02-14",xsd:date) 
a) the value space of xsd:date b) some member of the value space of xsd:date c) yes, rdf:dtype ddd implies ddd rdf:type rdfs:Datatype d) TDL("2002-02-14",xsd:date) 
a) the union of the value and lexical spaces of xsd:date b) some member of the value space of xsd:date c) yes, from both rdfs:drange and rdf:dtype d) TDL("2002-02-14",xsd:date) 
a) the value space of xsd:date b) some member of the value space of xsd:date c) no d) no 
a) the union of the value and lexical spaces of xsd:date b) some member of the value space of xsd:date c) yes, rdfs:drange ddd implies ddd rdf:type rdfs:Datatype d) TDL("2002-02-14",xsd:date) 
a) the value space of xsd:date b) some member of the value space of xsd:date c) yes, by explicit statement d) TDL("2002-02-14",xsd:date) 
a) the union of the value and lexical spaces of xsd:date b) some member of the value space of xsd:date c) yes, by explicit statement and from rdfs:drange d) TDL("2002-02-14",xsd:date) 
a) the lexical space of xsd:date 
b) the lexical space of xsd:date 
c) yes, by explicit statement d) TDL("2002-02-14",xsd:date), though requires dedicated treatment of the bNode range intersection between xsd:date and dc:date Note that this treatment is not always necessary since the union interpretation of rdfs:drange provides for an interpretation of inline literals -- it's only needed if one wishes to exclude all of the bNode idioms from being valid. 
a) error, because a lexical space is not a datatype and the understood range of rdf:lform is a lexical space b) n/a (or if you ignore the error, the lexical space of xsd:date) c) yes, by explicit statement d) TDL("2002-02-14",xsd:date), with same qualification in #11 
Continue having a nice weekend ;-) Patrick 
In case it isn't clear to some why the bNode denotes the lexical space of xsd:date, it should be pointed out that this follows from the dual nature of datatype properties and the fact that xsd:date is a subproperty of rdf:lform and rdf:lform has an implicit range of the lexical space of a datatype. 
Thus, from the first triple, we know xsd:date is a datatype class. 
From the second triple we know its range is its own lexical space. 
From the third and fourth triple we see that it shares the same range as dc:date, and thus the range of dc:date is the lexical space of xsd:date. 
And from the last triple we know that the literal is a member of the lexical space of xsd:date and thus, we can determine the TDL pairing. 
Patrick 
OK, I guess. 
But then why not use the rdfd: namespace idea? 
That would make things easier for people, seems to me, since they could very quickly see whether or not datatype magic was being utilized, and we could isolate the 'special' aspects of the MT to a distinct namespace, which I like on aesthetic grounds. 
In any case, can we please get this sorted out, as it is a pain in the anatomy to have to re-draw the diagrams just to change the vocabulary. 
Thanks. 
Pat IHMC(850)434 8903 home 40 South Alcaniz St.(850)202 4416 office phayes@ai.uwf.edu 
and also to write the testcases... (although I must say that I prefer the rdfs: namespace) 
Jos 
On 2002-02-19 2:49, "ext jos.deroo.jd@belgium.agfa.com" 
I prefer rdfs: as well, and it will give the datatyping vocabulary, I think, more "prominence" or "authority" to be within the RDFS namespace rather than somewhere else. 
Patrick 
I think I prefer this too. 
#g Graham Klyne MIMEsweeper Group Strategic Research http://www.mimesweeper.com 
