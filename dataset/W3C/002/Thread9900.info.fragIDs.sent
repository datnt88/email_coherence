Well, I appear to agree with Sergey and disagree with Patrick, ... ... at least about the topic of disagreement! 
I think RDF graphs are fundamentally untidy. 
The serious concerns I have with S are as follows: 1. Tidiness. 
Different occurrences of the same string have different types, and IMO are better modelled as distinct entities. 
S does not allow for this. 
This is not asserting that implementations may not use string interning or equivalent techniques for storage compression, merely that the semantics of a literal node depend on context. 
2. Idiom B. Idiom B, where the lexical form of a datatype is used directly in a single triple, is for me, the primary idiom of RDF M&amp;S. 
For me, articulating implicit typing within that idiom is the goal of the datatyping work. 
S's articulation of idiom B is deficient. 
2A: Unfortunately in S, idiom B is explicitly a sop to backward compatability which does not interwork properly with the preferred S idiom, idiom A. The examples we have already seen have been Jenny ageA _:a . 
_:a xsd:integer.map 
"4" . 
Jenny ageB "4" . 
ageA rdfs:range xsd:integer.val . 
ageB rdfs:range xsd:integer.lex . 
The single conceptual property of age gets reflected differently in the two idioms, and the value of the age property is an integer in one, and a string in the other. 
I think idiom B is *the* idiom of choice, and datatyping should explicate how one gets from the string lexicalization to the intended value. 
2B: Monotonicity and the open world assumption on type information. 
S (idiom B and P) is non-monotonic with respect to type information, or at least forces the RDF application to behave as if the underlying theory were non-monotonic. 
[Sorry this is rather obscure, I will ask for a clarification about S-P, which will illustrate my concerns] 
That's it. 
Other areas of difference are I think open to compromise. 
So just as Sergey could live with one uri for each type (as in TDL), I could live with S's three or four. 
While I think the D syntactic idiom is better than S-A from a backward compatibility viewpoint, and I do not like S idiom A, I could live with S-A being the recommended local idiom. 
I also have doubts about the implementability of S, and will seek clarifications from Sergey. 
Jeremy 
I agree ;-) Patrick 
In S-P as I understand it rdf:value is understood in relation to the known datatypes: In other words, rdf:value "extracts" the lexical representation from a given pair: EXT(I(rdf:value)) := {  x,y , y | x,y is an element of a datatype mapping} (Notice that for the above definition to be well-formed, we need to be able to enumerate all datatype mappings. 
This can be done using special vocabulary e.g., xsd:date.map 
rdfs:subClassOf rdfdt:DatatypeMapping). 
So for example, in a minimal RDF implementation in which we only have strings rdf:value is a 1-1 mapping. 
Thus in that sort of implementation we would have: _:a foo _:b . 
_:b rdf:value "string" . 
_:c bar _:d . 
_:d rdf:value "string" . 
implies _:a foo _:b . 
_:c bar _:b . 
(in the premise both _:b and _:d are  "string", "string"  ) If a second RDF implementation has a greater range of datatypes then it may be the case that "string" can map to something else. 
In this case the implication above does not hold. 
e.g. if we support xsd:string and xsd:integer then we have the following: _:a foo _:b . 
_:b rdf:value "1000" . 
_:c bar _:d . 
_:d rdf:value "1000" . 
does not imply _:a foo _:b . 
_:c bar _:b . 
I believe the semantic web will be built on the systematic application of the open world assumption. 
S-P requires a closed world assumption on datatypes, that results in defeasible implication, and hence non-interoperability. 
This is a significant concern. 
Similarly S-B seems to require applications to make similar defeasible typing above the RDF layer. 
Without any type information a string should be treated as a string. 
In the light of a single range constraint the application should treat the string in accordance with that datatype. 
If multiple range constraints apply to the same lexical node then it is unclear what an application should do. 
So S-B also suffers non-monoticity but in the application layer. 
Jeremy 
