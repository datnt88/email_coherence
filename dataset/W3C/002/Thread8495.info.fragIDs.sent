G. Algorithm Granularity 1. Suites as one algorithm i.e., compound Algorithm names, like RSA-SHA1, can occur 2. Orthogonal specification i.e., simple Algorithm names but Algorithms occur as Parameters to other Algorithms NOTE: As long as we permit user defined algorithms, there is no way to stop someone from using G.1 and as long as we allow parameters, there is not way to stop someone from using G.2 although you can make G.2 a bit less convenient, depending on your parameter syntax. 
So the question is really just for the algorithms we specify in the WG documents. 
There are arguments on both sides. 
This is a religious issue. 
I have my own opinions but we will go with the WG consensus. 
Donald E. Eastlake, 3rd 17 Skyline Drive, Hawthorne, NY 10532 USA home: 65 Shindegan Hill Road, RR#1, Carmel, NY 10512 USA 
I vote for G.1., expressing algorithm suites as one algorithm: a) This is how most other standards seem to do it. 
b) Ambiguity is possible in the case of G.2.; I believe this is the reason for a). 
In general, the technical specification for different algorithms may express their output in different fashions. 
For example, in RFC 2437 RSASSA-PKCS1-v1_5 outputs an octet string, while in FIPS 186-1 DSA outputs two integers (r and s). 
If you were specifying an algorithm that could take RSA or DSA as a parameter, you would need to specify exactly how the output of each is used by the encompassing algorithm. 
For the G.2. method you could always say on the encompassing algorithm definition of A that "the algorithm parameter must be X or Y; the output of X will be encoded this way, the output of Y will be encoded that way" but this seems to me to be equivalent to defining A-X and A-Y. 
Might as well express it that way. 
c) G.2. can be accurately and easily expressed in G.1. fashion but not vice-versa because of the ambiguity issue. 
-Mark Bartel JetForm 
G. Algorithm Granularity 1. Suites as one algorithm i.e., compound Algorithm names, like RSA-SHA1, can occur 2. Orthogonal specification i.e., simple Algorithm names but Algorithms occur as Parameters to other Algorithms NOTE: As long as we permit user defined algorithms, there is no 
way to stop someone from using G.1 and as long as we allow parameters, there is not way to stop someone from using G.2 although you can make G.2 a bit less convenient, depending on your parameter syntax. 
So the question is really just for the algorithms we specify in the WG documents. 
There are arguments on both sides. 
This is a religious issue. 
I have my own opinions but we will go with the WG consensus. 
Donald E. Eastlake, 3rd 17 Skyline Drive, Hawthorne, NY 10532 USA home: 65 Shindegan Hill Road, RR#1, Carmel, NY 10512 USA 
This has been true, however it has also lead to an explosion of OIDs for some things (consider RSA-with-(MD2, MD5, SHA1, ...). 
I am afraid that I cannot see this as a problem at the moment. 
I'll think on it. 
However it seems to me that you are going to have this problem in the core spec today if it is really ambiguious. 
What is encoded into the SignatureValue field for DSA? 
R &amp; S or the single octect stream? 
If this is an issue we need to look at it now as we already have it. 
I like G.2 since it also leads to ease of implemenation. 
I can look for and hash without having to do a table lookup on the signature algorithm and then feed the hash back into the signature code later. 
jim 
