The latest draft says: 
An ABNF-driven parser will find that the border between authority and path is ambiguous; they are disambiguated by the "first-match-wins" (a.k.a. "greedy") algorithm. 
In other words, if authority is present then the first segment of the path must be empty. 
The second sentence does not follow from the first. 
Consider this URI: foo://joe@example.com:0x3FF/blah 
According to the grammar, this can be parsed in either of two ways: (1) authority = path = //joe@example.com:0x3FF/blah 
(2) authority = joe@example.com 
path = :0x3FF/blah It cannot be parsed this way: 
(3) authority = joe@example.com:0x3FF 
path = /blah because non-digits are not allowed in the port. 
The first-match-wins rule implies that the correct parsing is (2). 
Note that the first path segment is not empty, but is ":0x3FF". 
The regular expression in appendix B claims to break a well-formed URI down into its components, but it gets this one wrong, yielding the 
components in (3). 
Perhaps the grammar should be tightened up so that this URI is invalid. 
Note that the RFC-2396 grammar does not accept it. 
If the grammar is kept as-is, the regular expression should be fixed to parse this URI correctly, and the statement about the first path segment 
being necessarily empty should be removed. 
That might have implications for relative URI resolution... 
In any case, it might be nice for the draft to provide a regular expression that not only parses well-formed URIs, but also detects ill-formed URIs (by failing to match them). 
AMC 
Adam Costello's example is an interesting one. 
I just sat down this morning to apply abnf2re to automatically generate parsing expressions from the bis4 grammar. 
Actually, the parsing results I get are as follows. 
from URIbis4 import * parseURI('foo://joe@example.com:0x3FF/blah') 
('foo', 'joe@example.com:0', 
'x3FF/blah', None, None) That is, the first-match-wins rule gives authority = joe@example.com:0 
path = x3FF/blah 
Previous grammars produce a different kind of anomaly. 
from URIbis3 import * parseURI('foo://joe@example.com:0x3FF/blah') 
('foo', None, '//joe@example.com:0x3FF/blah', 
None, None) 
Perhaps the following text is appropriate. 
"An ABNF-driven parser will find that the border between authority and path is ambiguous; they are disambiguated by the "first-match-wins" (a.k.a. "greedy") algorithm. 
This produces correct results whenever the authority is absent or the first segment of the path is empty. 
Although the grammar permits a nonempty path in the presence of an authority component, the URI is considered ill-formed in this case." 
This is of interest to me and is one of the reasons that I have developed abnf2re. 
The goal is to provide regular expressions 
that correspond exactly to the ABNF syntax within specification documents. 
Yes, the grammar issue was noted by Ray Merkert on Feb 17th. 
Note that the text already says a more forceful equivalent 
in section 3.3: If a URI contains an authority component, then the initial path segment must be empty (i.e., the path must begin with a slash ("/") character or be entirely empty). 
Is that not sufficient? 
....Roy 
from URIbis4 import * parseURI('foo://joe@example.com:0x3FF/blah') 
Sure enough. 
Oops. 
I'm more convinced than ever that this URI should be invalid, because the boundary between authority and path is so well camouflaged. 
It sounds cool. 
Is it available? 
Google finds only this mailing list. 
I think defining the syntax of an element (or a sub-element) using a combination of a loose grammar and further restrictive prose is an invitation for misunderstanding. 
The reader is likely to think the prose is merely stating a fact implied by the grammar, rather than adding rules not already expressed in the grammar. 
(In this case, I thought the prose was stating an implication of the first-match-wins rule, but I was mistaken.) 
I think it's safer to either define the (sub-)element entirely by prose (omit the grammar) or use a tight grammar along with prose that merely provides intuition about the self-sufficient grammar. 
But I now see the motivation for the other approach. 
A tight grammar is suitable for defining a syntax (that is, distinguishing between valid and invalid strings) but is inconvenient for decomposing strings into their components (because one component, like path, might match any one of various tokens, like abs-path, opaque-part, or rel-path, so you need to detect which token was matched and assign it to the component). 
Conversely, a grammar convenient for decomposing a string into its components (where a given component is always matched by a unique token) will be loose (will accept invalid strings). 
Perhaps specs should provide both grammars, and implementations should do something like: if string matches validation_regex then match string against decomposition_regex else report error RFC-2396 provides a validation grammar, and the current draft of 2396bis provides a decomposition grammar. 
I think both grammars are valuable. 
If either grammar is omitted from the spec, implementors are likely to roll their own and make subtle mistakes. 
If the spec omits the validation grammar, some implementations are likely to do only decomposition, not validation, causing invalid URIs to seem to work reasonably with some implementations and not others, which invites interoperability problems and makes it difficult to extend the syntax in the future (because some implementations already accept the extended syntax and do who-knows-what with it). 
It's inconvenient but possible to use a validation grammar for decomposition, but it's not possible to do validation with a decomposition grammar. 
Because of the importance of validation for interoperability and for extensibility of the syntax, I think if a spec provides only one grammar it should be a validation grammar, but it might be better to provide both. 
Maybe the decomposition grammer need not be provided in ABNF form, only regex form, whereas the validation grammar would be provided in both forms. 
AMC 
I already responded to that question, but I just noticed that a more succinct response is possible. 
Section 4.1 of the current draft says: The ABNF of URI-reference, along with the "first-match-wins" disambiguation rule, is sufficient to define a validating parser for the generic syntax. 
It would be very nice if that were true, but it's not. 
A validating parser based on the ABNF and the first-match-wins rules will find that foo://example.net:0x3FF/ is valid, with path = "x3FF/" (and indeed, Rob Cameron built such a parser, and that's what it reported). 
But the additional rule in the prose of section 3.3 implies that this URI is invalid. 
Should we try to make the quoted statement true? 
AMC 
