I see a problem with versioned collections. 
Suppose /foo/, /foo/bar/, and /foo/bar/baz.html are all versioned. 
Now, under the current protocol draft, you would refer to revision 1.5 of /foo/bar/baz.html by something like: GET /foo/bar/baz.html 
Revision-Id: 1.5 Right? 
But that implies that, in all the different revisions of /foo/ and /foo/bar/, there can be only one revision history for /foo/bar/baz.html. 
Suppose /foo/bar/ has two branches, and /foo/bar/baz.html was created separately in each of them; there should be no relationship between /foo/bar/baz.html in revision 1.5 of /foo/bar/ and /foo/bar/baz.html 
in revision 1.3.1.2 (that is, on a branch which forked off at revision 1.3). 
Either Revision-Id: has to take a path of revision IDs, or we have to get rid of versioned collections. 
(Personally, I'd vote the latter; I don't see what problem they're solving.) |John (Francis) Stracke |My opinions are my own.|S/MIME supported | |Software Retrophrenologist|=========================================| |Netscape Comm. 
Corp. | Vote for Ron, and nobody gets hurt! 
| |francis@netscape.com 
| --actual campaign poster from Chicago | 
You are correct, each versioned component in the hierarchy path will have to resolve its revision. 
This will require both a branch label and version label because we support multiple lines of descent, and it may be impossible or undesirable to require unique lables across branches (they may not all be available at any given point in time). 
w3c-dist-auth-request@w3.org on 10/09/98 02:04:36 PM Please respond to w3c-dist-auth-request@w3.org Subject: A problem with versioned collections I see a problem with versioned collections. 
Suppose /foo/, /foo/bar/, and /foo/bar/baz.html are all versioned. 
Now, under the current protocol draft, you would refer to revision 1.5 of /foo/bar/baz.html by something like: GET /foo/bar/baz.html 
Revision-Id: 1.5 Right? 
But that implies that, in all the different revisions of /foo/ and /foo/bar/, there can be only one revision history for /foo/bar/baz.html. 
Suppose /foo/bar/ has two branches, and /foo/bar/baz.html was created separately in each of them; there should be no relationship between /foo/bar/baz.html in revision 1.5 of /foo/bar/ and /foo/bar/baz.html 
in revision 1.3.1.2 (that is, on a branch which forked off at revision 1.3). 
Either Revision-Id: has to take a path of revision IDs, or we have to get rid of versioned collections. 
(Personally, I'd vote the latter; I don't see what problem they're solving.) |John (Francis) Stracke |My opinions are my own.|S/MIME supported | |Software Retrophrenologist|=========================================| |Netscape Comm. 
Corp. | Vote for Ron, and nobody gets hurt! 
| |francis@netscape.com 
| --actual campaign poster from Chicago | 
Let's do the easy one first: why do you need versioned collections? 
(Saying why you need something is always easier than saying how you will make it work :-). 
If you make a (non-collection) resource revision immutable, one of the things you freeze is any references it contains to other resources. 
Those references will be invalid if you don't save the "state" of the namespace that the containing collections provide. 
This makes versioned collections essential for any application that wants to version a resource whose semantics depend on other resources that it "contains" or "refers to" (such as a book made up of chapter resources, or source code that includes header resources. 
I believe though that the solution is reasonably straightforward, namely, that you use the same branching/labeling conventions for your collection resources that use for your non-collection resources, and then use a consistent rule/convention when selecting both the collection and all its members. 
This is one of the reasons why I believe the VPortal mechanism (which selects a revision from just a single versioned resource) will not prove to be very useful, while the dynamic configuration mechanism (which provides a mechanism for consistently selecting revisions from an entire collection) will be both necessary and sufficient. 
Cheers, Geoff From: John Stracke francis@netscape.com 
I see a problem with versioned collections. 
Suppose /foo/, /foo/bar/, and /foo/bar/baz.html are all versioned. 
Now, under the current protocol draft, you would refer to revision 1.5 of /foo/bar/baz.html by something like: GET /foo/bar/baz.html 
Revision-Id: 1.5 Right? 
But that implies that, in all the different revisions of /foo/ and /foo/bar/, there can be only one revision history for /foo/bar/baz.html. 
Suppose /foo/bar/ has two branches, and /foo/bar/baz.html was created separately in each of them; there should be no relationship between /foo/bar/baz.html in revision 1.5 of /foo/bar/ and /foo/bar/baz.html 
in revision 1.3.1.2 (that is, on a branch which forked off at revision 1.3). 
Either Revision-Id: has to take a path of revision IDs, or we have to get rid of versioned collections. 
(Personally, I'd vote the latter; I don't see what problem they're solving.) 
But isn't that what configuration management is for? 
|John (Francis) Stracke |My opinions are my own.|Both candidates | |Software Retrophrenologist|=======================/are better than a| |Netscape Comm. 
Corp. |megalomaniac mutant lab mouse bent on | |francis@netscape.com 
|world domination...but it's pretty close.| 
Date: Fri, 09 Oct 1998 14:32:57 -0700 From: John Stracke francis@netscape.com 
But isn't that what configuration management is for? 
Traditionally, "configuration management" includes: - artifact indentification - change tracking - version selection and baselining - software manufacture (building derived files) - managing concurrent update Some of these are clearly concerns of WebDAV (e.g. managing concurrent update), and others are clearly not (e.g. software manufacture), and others fall in the middle somewhere. 
Given the prevalence and importance of Web resources that refer to other Web resources, maintaining the validity of those references under versioning does seems like an essential aspect of WebDAV (and the CM vendors have pretty standard approaches that are reasonably straightforward to apply). 
Cheers, Geoff 
