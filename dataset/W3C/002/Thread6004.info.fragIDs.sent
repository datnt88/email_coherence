I'd like to add some comments, and raise some questions, regarding 
Jean-Jacques Dubray's paper (http://www.ebpml.org/ebpml2.2.doc), which 
was discussed a bit in an earlier thread. 
If I can attempt a summary: Dubray's paper advocates separating message flow, data flow, and control flow definitions. 
This provides a 
separation of layers, without precluding the ability to model both 
interior and exterior flows. 
The control flow model is "pluggable", so that in fact the same framework could support different kinds of control flow modelling - the examples use BPSS, but this isn't required. 
A few comments: Generally, this seems to be an interesting and valuable approach. 
It leverages some of the work that has gone into ebXML, which is one of the more sophisticated B2B frameworks. 
The paper envisions that business transactions could involve an 
exchange of multiple messages, that these could be asynchronous, and 
that correlation between messages may therefore be necessary. 
I think 
these are necessary features to support, but the examples don't really 
demonstrate how to support them, as far as I can tell. 
Transactions 
are also identified as being out of scope (p. 15). 
The DataFlow example (p. 15) seems to me overly simple. 
It shows data inputs and outputs connected by XSLT transformations. 
This is useful, 
but it's only one example of what could be a complex transformation, 
possibly involving iteration and other workflow concepts. 
This being the case, is it useful to distinguish a data flow from a control flow? 
(The diagram on p. 15 actually confuses the two, because there's a 
comment indicating that a "Control flow" is starting, but the tag that begins it is called "DataFlow", although its end tag is "ControlFlow"). 
It would be interesting to see in more detail whether, and how, something like BPEL4WS could be fit into this framework - I understand that they're fundamentally different approaches, but to the extent that they're attacking the same problem, it ought to be possible to take a BPEL4WS model and re-express its essentials in this framework. 
There is mention at the end of the paper of three planned followup papers - are any of these available? 
--Jon 
BPEL4WS, BPML, WSCI, etc are based on processes defined for each communicating agent, dating back to the model proposed in CSP and 
later 
refined in pi-calculus and other works in that space. 
BPSS and EBPML 
prefer 
to express processes as a centralized sequence of exchanges and then 
each 
agent has to derive its process by extracting all activities related 
to some 
role. 
I think there's conversion from one to the other, but I don't have 
evidence 
that you can move from the CSP model to the centralized one and back 
without 
losing some information. 
I don't think it is accurate to describe BPSS as "centralized". 
It was derived from the UNCEFACT Business Collaboration 
Protocol metamodel, which is a state-alignment protocol. 
That is, the protocol is intended to align the states of 
"common knowledge" or mutually-agreed-upon state machines, which may be implemented using the Half-Object-Plus-Protocol pattern. 
(Nothing centralized.) 
The protocol does make a distinction between external collaborations (whose states must be aligned) 
and internal activities (whose states are none of 
anybody else's business). 
So if you took a model which included both external and internal activities (in this sense), and moved to BPSS, the BPSS representation would only include the external activities. 
That does not mean the internal activies would be lost. 
It's just a separation of concerns. 
-Bob Haugen 
I think that what Assaf is expressing is that BPSS and the paper I 
published on ebPML.org 
describe message exchange with no specific point 
of view (from a party perspective), therefore appearing to be at the 
"center". 
Because these approaches are point of view neutral, they do 
not suffer from the same "centricity" syndrome that characterize BPEL4WS, BPML or even WSCI. 
In BPEL4WS one describe a collaboration by specifying the message exchanges from his/her point of view. 
Of course the other business partners have to have a mirror definition such that it works. 
As I said earlier, WSCI offers a little more flexibility via the "global model" concept borrowed from WSFL, but in essence WSCI does exactly like BPEL4WS, it forces each party to describe the collaboration from his/her point of view. 
So instead of introducing this notion of "centralized sequence of 
exchange" I think it is fair to say that BPSS offers a "neutral" view of 
the choreography while BPEL/BPML and WSCI offers and "interface-bound" or "party-specific" view of the collaboration. 
In all cases, the goal is more or less to achieve state alignment 
between collaborating parties. 
JJ- 
From: public-ws-chor-request@w3.org 
[mailto:public-ws-chor-request@w3.org] 
On Behalf Of bhaugen Sent: Wednesday, February 26, 2003 8:21 AM Subject: RE: Dubray paper comments + questions 
BPEL4WS, BPML, WSCI, etc are based on processes defined for each communicating agent, dating back to the model proposed in CSP and 
refined in pi-calculus and other works in that space. 
BPSS and EBPML 
to express processes as a centralized sequence of exchanges and then 
agent has to derive its process by extracting all activities related 
role. 
I think there's conversion from one to the other, but I don't have 
that you can move from the CSP model to the centralized one and back 
losing some information. 
point 
I understand, but think there are a number of interesting issues 
arising from this difference. 
of 
I agree with that formulation to some extent. 
But one could also describe the party-specific models 
as focusing on one party's internal procedural workflow 
and expecting the other party to conform. 
Is it? 
Are the internal activities really aimed at state alignment 
between collaborating parties? 
Yet another way to think about it is the difference between procedural and conversational workflow models - where procedural = command-and-control and conversational = collaboration. 
-Bob Haugen 
From: public-ws-chor-request@w3.org [mailto:public-ws-chor-request@w3.org]On 
Behalf Of bhaugen Sent: Wednesday, February 26, 2003 8:00 AM Subject: Re: Dubray paper comments + questions 
It's the chicken and egg problem and neither spec is free of that. 
In BPML you would describe the internal procedural workflow. 
But we are not 
positioning BPML as a choreography language, we are positioning it as a 
language to describe - in loose terms - the internal procedural workflow. 
Then it's up to you to decide whether to begin with a choreography (in BPSS or WSCI) and build a workflow, or whether to decide that the choreography should support your existing workflow. 
You can make that decision then write a BPSS to support your workflow, can't you? 
It's really a matter of best practice, and I've heard at least once the claim that since some system has an implementation the interface could be expressed using BPSS in order to communicate with it, in effect binding the choreography to the workflow. 
Let's not confuse best practices with models. 
No. But where do you read about 'internal activities'? 
arkin 
Assaf: 
[JJ] I think that we had already concluded that this is not really such 
a problem. 
Clearly what ever is the outcome, the specification need to 
allow for starting from either point of view: collaboration or 
executable business process and derive the other one. 
I don't think it 
is an issue anyways: how could we design a technology that does not allow for that? 
You don't seem to speak about the third level (long-running behavior of 
system components). 
Any thoughts on that level? 
JJ- 
Absolutely right. 
I do assume that we're talking about long-running behavior all along which 
explains a lot of the complexity of the spec. 
In a long-running behavior you would have complex flows that are chained to 
each other. 
You can capture a simple flow with something like a sequence, 
but that doesn't extend well. 
You will probably want to break the complex 
flow into smaller flows and chain them together, which is where we introduce 
spawn and call*. 
In a long-running behavior you would also have flows that repeat multiple 
times within some state and that may be subject to how many messages are 
exchanged (or in reverse, capture the message exchange), which explains the 
need for nested processes. 
And of course you need to address the time issue, whether you want to 
express a minimal passage of time (e.g. delay) or put a time constraint on 
the completion of a flow (e.g. onTimeout). 
And probably some other requirements. 
Anything specific? 
arkin * The notion of recursive composition which is captured in this way and also 
with nested processes is very interesting, since it allows you to draw 
conclusions about a fine grained entities, then about a composition including multiple entities, and a composition including multiple 
compositions, and so forth. 
Seeing how formal process models do it, we've 
structured the language in a similar manner to allow the same form of 
recursive composition/analysis. 
I think a lot of this may be necessary, but (to revisit an earlier issue 
raised on the list) I'm not sure that the requirements for choreography 
necessitate a full-blown workflow modelling language. 
In fact, I have 
some concern that the existing proposals may be overly complex for 
modelling useful types of WS interaction (especially in a B2B context), 
while being less than adequate for more general worklow purposes, in 
which not everything is directly in service of a WS message exchange. 
Which is why the proposal to separate specification of message flow from 
control flow was attractive, at least IMO. 
--Jon 
issue 
choreography 
context), 
from 
[JJ] Beyond that I think that it is also necessary to make this 
distinction to reach the point of a "true SOA". 
The systems components 
that I was talking about are the services in the SOA. 
These services can 
be combined at will, the system is tolerant to replacing these system components by equivalent components. 
You can also utilize something like WSIF to optimize the interactions between these system components. 
I bet that a lot of application would benefit from being built that way. 
If all applications were built that way you could also imagine a very efficient "plug &amp; play" architectures. 
JJ- 
chained 
are 
explains 
to 
constraint 
and 
draw 
of 
arkin 
