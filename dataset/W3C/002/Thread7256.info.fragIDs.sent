If there was a discussion period on collections, I missed it. 
I do have some comments to make, however, especially in light of DRP. 
The DRP index differs from ours (aside from implementation details) in several ways: 1. 
It describes the entire hierarchy, whereas ours describes only a single level of the hierarchy. 
2. It contains different information about each member of the hierarchy. 
3. DRP hierarchies have only internal members, whereas WEBDAV allows both internal and external members. 
To reconcile the two specifications, I think (1) it would be very useful for us to provide an index that describes the entire hierarchy rather than just one level. 
I think what is really desirable for (2) is for the client to be able to specify in an INDEX request what information it wants about the members of the collection. 
Collections are used for lots of different purposes, and different properties of the members will be useful in different contexts. 
However, this flexibility would make it impossible for the index to be stored as a file, as DRP suggests -- it would have to be generated in response to the client's request. 
As for (3), I think that allowing external members of collections is essential. 
This is what allows the same resource to be shared by several collections. 
Other comments on collections: MKCOL was still pretty sketchy in the last draft. 
When it gets defined in more detail, it would be good if the entity body could be standardized to define how clients would submit internal members and also external members. 
To repeat a comment from Orem, we need to be clear about whether every URI hierarchy will behave like a collection, or only collections that were created using MKCOL. 
This has lots of implications, especially once recursive operations are defined for collections. 
Will those recursive operations (MOVE, COPY, LOCK, etc.) work for all URI hierarchies, or only for collections created with MKCOL? 
A user can only figure out where he wants to MOVE or COPY a resource if he can see the context he's operating in. 
We've made a stab at providing this with INDEX, but will it work for all URI hierarchies, or only for collections created with MKCOL? 
etc. Compound documents as collections: I would like to be able to use collections to represent compound documents. 
Collections are ideal for this use because they let you operate on the compound document as a whole (or they will once recursive operations for collections are defined) and also to operate independently on any of its members. 
But for collections to represent compound documents, three things need to be standardized: 1. Support for ordering 2. A way to identify component types 3. A way to determine whether a collection represents a compound document 2 and 3 just require additional DAV properties: A ComponentType property (with values such as CONTENT, DTD, STYLESHEET, etc.) that attaches to members of compound document collections, and an IsCompoundDocument property that attaches to collections. 
Support for ordering is the only significant change. 
It would involve the following: INDEX would have to return the list of members in the correct order. 
(No change in syntax is needed, just a change in what the server is required to do.) MKCOL with an entity body would have to treat the order of the items in the entity body as significant. 
It needs to be possible to add both internal and external members at a particular place in the sequence of members. 
It needs to be possible to move a member from one place to another in the sequence. 
It may also be useful to be able to delete members by sequence number as well as by URI. 
We would have to decide whether to add navigation methods like get next, get previous. 
We could just require clients to get the index and do the navigation themselves. 
Versioning and collections: It should be possible to version the collection as a whole, as well as any of its members. 
Where members are versioned, there needs to be a way to define what a client 
should get when it retrieves a member of the collection: A specific version of the member, or the current published version of the member. 
--Judy Name:Judith A. Slein E-Mail:slein@wrc.xerox.com 
MailStop:105-50C 
What kind of language ("MUST" or "SHOULD") most effectively promotes interoperability in this case? 
Why use the protocol if you are going to ignore the object model? 
Del 
Jim Whitehead ejw@ics.uci.edu 09/19/97 11:54AM 
If the the whole hierarchy is not treated as a collection, you leave open the possibility of some user confusion. 
The namespaces of the URLs and 
the 
collections overlap, but are not identical. 
For example, if you have collection /A you could have /A/B where B is an internal reference and 
/A/C 
where C is not part of the collection, simply part of the URL space. 
This 
might be useful, but it will certainly be confusing. 
My assumption has always been that any collection-like object in a DAV server's namespace should be modeled using a WebDAV collection -- an assumption so deeply ingrained none of the authors ever thought it was worth writing down. 
(Bzzt! 
:-) I agree a requirement should go into the specification stating that collection-like objects SHOULD be WebDAV collections. 
My question is whether this should be a MUST or a SHOULD requirement. 
I'm leaning towards SHOULD because there are cases where part of a server's namespace is computed, and hence can be potentially infinite. 
For example, if a server has a part of its namespace which acts as input to a cgi script (e.g., http://www.foo.org/finger-script/cgi-bin/user@host) what should INDEX return for the /cgi-bin/ collection if there is a MUST requirement? 
On the other hand, if it was a MUST requirement, there could be language added which states that a server is not required to expose every member of a collection where the membership depends on the current request. 
Although I'm unsure what the best way would be to express this, or whether this causes more problems than it solves. 
- Jim 
client 
At present, since each version of a resource is a separate resource, retrieving a member of a collection retrieves just the resource itself, which may be a member of a version tree. 
[Dylan Barrell] Surely this should read - when retrieving the member of a collection it retrieves the default version of the resource - otherwise what is the use of the default version in the version tree? 
Cheers Dylan 
