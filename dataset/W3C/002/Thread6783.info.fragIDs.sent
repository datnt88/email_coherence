I've attached a tool that excerpts schemas and examples into a XHTML spec. 
It actually contains two (proposal/implementation)s. 
The first (-r(egexp) is an implementation of a convention used by the XKMS editor (PHB) and uses include elements in the spec and xml comments in the external XML instances to demarcate the regions to excerpt. 
include class="Code" source="Schemas/xkms.xsd" section="MessageAbstractType" /include The second (-x(ml) is my own approach and uses PIs with a XPtr. 
?include 
class="Code" Source="Schemas/xkms.xsd#xpointer(//complexType[@name='RespondWith'])"? 
Source files for the -r(egexp) source spec, schema and examples can be found in the zip from [1]. 
For example: aeon:XKMS pin.py -m r part-1-source.html out.html 
[1] http://lists.w3.org/Archives/Public/www-xkms/2002Dec/0075 
A dummy spec source file for the -x(ml) source spec is also attached, the schema and examples is the same as above. 
For example: aeon:XKMS pin.py -m x test-xml-source.html 
out.html 
Pros/cons for the approaches follow. 
Include external xml chunks into an XHTML file according two two different schemes: regexp: within an XHTML file include elements indicate tokens to be used with a regular expression to excerpt external XML found between comments tags. 
(Source document is invalid; easy to demarcate contiguous regions, fast.) xml: within an XHTML file ?pi? 's specify an XPointer which indicates what XML to excerpt. 
(Source document is valid, requires no change to schema and examples, flexible expressions; slower (i.e. XPath), not all XPath/XPointer expressions are supported presently.) Usage: pin.py -m [r(egexp)|x(ml)] input output''' 
For what it's worth, I've taken a sort of inverse approach in XML Schema -- I've added support for a 'text' attribute on the eg element to the stylesheets, so that e.g. does the right thing, and written a very simple script which "quotes" XML so that it can be included in this way. 
Then my Makefile has something such as spec.html: spec.xml xmpl1.xml,txt 
%,txt: % xml2xmpl $   $@ 
where xml2xmpl looks like this: #!/bin/sh echo -n " txt ![CDATA[" rxp $@ echo "]] /txt " 
ht Henry S. Thompson, HCRC Language Technology Group, University of Edinburgh Half-time member of W3C Team 2 Buccleuch Place, Edinburgh EH8 9LW, SCOTLAND -- (44) 131 650-4440 URL: http://www.ltg.ed.ac.uk/~ht/ [mail really from me _always_ has this .sig -- mail without it is forged spam] 
As an aside, I actually started out with trying to use XInclude which I thought would be optimal but: 
1. I couldn't figure out a way to include XInclude elements in XHTML and have it remain valid XHTML. 
2. The returning XML isn't "encoded" for inclusion in XHTML, I thought of putting it inside ![CDATA[ but figured it wouldn't work since CDATA is *not* supposed to be parsed, and consequently the XInclude should be ignored. 
3. Not sure how good the XPtr support in XInclude implementations (e.g., xmllint) is. 
don't you just use parse="text", xinclude spec says: The fetched resource is treated as plain text and converted to a set of character information items without attempting to parse the resource as XML. 
This feature facilitates the inclusion of working XML examples David This e-mail has been scanned for all viruses by Star Internet. 
The service is powered by MessageLabs. 
For more information on a proactive anti-virus service working around the clock, around the globe, visit: 
I agree, it should be. 
The XInclude elements are namespaced. 
Since DTDs aren't namespace-aware, you either have to live with a document that is well-formed but not DTD-valid, or you have to fiddle the DTD to allow the xi:xinclude element in reasonable places. 
Schema-validity should, of course, be doable. 
You could do some trick such as use a class="xinclude" href="..."/ in your document so that it would validate and then write a trivial XSLT transform sheet that maps the above into xi:xinclude href="..."/ just before you need to do the including. 
This is what XInclude's parse="text" attribute is for. 
Quoting [1]: The fetched resource is treated as plain text and converted to a set of character information items without attempting to parse the resource as XML. 
This feature 
facilitates the inclusion of working XML examples, as well as other text-based formats. 
I'm not sure what xpointer support would have to do with this. 
When you use parse="text", the "resource is treated as plain text" so xpointer is irrelevant. 
(But there are XInclude implementations [2] that do support various levels of XPointer.) paul [1] http://www.w3.org/TR/2002/CR-xinclude-20020917/#text-included-items [2] http://www.w3.org/XML/2002/09/xinclude-implementation 
I expect at some point we'll have XHTML+XInclude. 
I believe that's a feature of XHTML2.0, but also expect there might be an intermediary identifier/namespace/DTD from XHTML1.* . 
The tricky bit is actually between these two requirements. 
I know a common source of errata in my specs is typos between the in-line and external schema and in the in-line examples. 
Consequently, it'd be better to maintain the schema and examples externally, and keep them all valid. 
(Which means not in little fragments.) So, when I want to include part of an example or schema I want to use xptr to select the relevant part and include it. 
If I understand, I can't do that if the parse type is text; and if it's not text then it is returned as XML. 
What I'd need it a: parse="xml" return="text"? 
So in my script I evaluate the XPath, Canonicalize the result,and return the encoded XML (e.g., ' ', ' ','&amp;') in a pre element: nodes = expression.evaluate(context) 
for node in nodes: chunk = Canonicalize(node,unsuppressedPrefixes=[]) chunk = ' pre class="%s" %s /pre ' % (hclass, encode(chunk)) 
