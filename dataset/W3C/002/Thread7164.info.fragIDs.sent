One other simpler modification to the grammar to address the problem of the path being undefined is: net-path = "//" authority net-path-suffix net-path-suffix = ["/" path-segments] path = abs-path / rel-path / net-path-suffix Of course, //ABCD+y in http://ABCD+y would still be parsed as a path. 
From: Rob Cameron [mailto: cameron@cs.sfu.ca] 
Date: Wed, 11 Jun 2003 12:31:42 -0700 Subject: Re: [uri] none defined for a URI, though the defined path may be br   empty (zero length) or opaque (not containing any "/" delimiters)" br   br   The production for net-path says that abs-path is optional, so for a br   URI like http://ABCD?query, we have both abs-path and rel-path br   undefined and not empty and therefore path would be undefined. 
Do we br   still have to assume that path is empty even when both abs-path and br rel-path are undefined ? 
or is the above statement from the draft br incorrect ? 
br  br  Bummer. 
The statement is correct, but I'll need to fix the ABNF so br  that it always ends up with a matching production. 
br  br  Thanks for the report, br  br  ....Roy br br I've been playing with an experimental grammar modification that br addresses this problem and also addresses the following br additional wrinkle: http://ABCD+y is a legal URI according to br the ABNF (as translated to regexps by abnf2re). 
br br parseURI('http://ABCD+y') br ('http', None, '//ABCD+y', None, None) br br That is, because ABCD+y is not a legal authority, the br regular expression matching rules for http://ABCD+y backtrack br to accept //ABCD+y as a path. 
br br To address both the problem reported by Mark and the br problem above, I have found that there may be merit br to simplifying the URI production to directly reflect the br opening statement of section 3: br br "The generic URI syntax consists of a hierarchical sequence of br components referred to as the scheme, authority, path, query, and br fragment." 
br br URI = scheme ":" ["//" authority] path [ "?" query ] [ "#" fragment ] br br This rule reflects the five-component structure and the statement br that a path always exists, even if it is empty. 
It can be made br to work with either of the two following definitions of path: br br path = abs-path / rel-path br path = segment *( "/" segment ) br br Running a parser based on either of these changes with br all the test cases listed in section 5.4 (both normal and br abnormal examples) gives precisely the same results as br with the grammar of bis-02 or bis-03. 
(By the way, it br might be good to have some IPv6 literals in the test br examples.) br br On the problem case of parseURI('http://ABCD+y') br ('http', 'ABCD', '+y', None, None) br br Arguably, this is a better parse if http://ABCD+y is to be br accepted as a URI. 
It is also a better parse if http://ABCD+y br is to be ruled out by the extra-grammatical restriction: "when br an authority exists, the path must either be empty or an br abs-path." 
(Alternatively, "when an authority exists, the br first segment of the path must be empty.") 
br br Overall, I think the theme of grammar simplification reflected in the br change from bis02 to bis03 is a good idea. 
One other br area that could us e some attention is the grammar of IPv6 br literals. 
br br br br Join Excite! - http://www.excite.com 
The most personalized portal on the Web! 
In addition to the semantic bug, I think the assumption that the base URI doesn't contain dot-segments in its path should be dropped. 
If a URI has an absolute path beginning with a "//" and doesn't have an authority, then the absolute path must be written as /.//... 
Another example where the target URI would be invalid is if the relative URI is scheme:/.//ff 
or scheme:/..//ff and the parser is strict or the parser is non-strict and base URI's scheme != relative URI's scheme. 
One more thing. 
If the relative URI has a scheme then, regardless of the base URI, the target URI will equal the relative URI for a strict parser. 
Should the algorithm fail in this case if the base URI is illegal (doesn't have a scheme) even though the target URI has nothing to do with the base URI? 
(i.e., should the assumption "only the scheme component is required to be present in the base URI" be dropped in this case?) Join Excite! - http://www.excite.com 
The most personalized portal on the Web! 
No, the algorithm does not have to account for every possible bogus reference and maintain that bogosity. 
It only has to be consistent in handling the bogus parts. 
URIs that do not have authority components are not going to have any paths that begin with "//", period. 
There is no reason for the algorithm to jump hoops for nonexistent schemes. 
....Roy 
Below I suggest modifications to section 5.3 that ensure correct URI construction for all (scheme, authority, path, query, fragment) 5-tuples. 
Motivation: Suppose that an infostructure is to be moved from h://a/b/c/d to f:/d with all links made relative. 
It is not inconceivable that the document at h://a/b/c/d contains URIs like h://a/b/c//e and http://a/b/c/this:that In the first case, the following relative_URI calculation may be performed. 
(URIbis3.py) 
compute_relative_URI('h://a/b/c/d', 'h://a/b/c//e') 
'.//e' This relative URI is fine when resolved with respect to the original base, applying the algorithm of 5.2. 
resolve_relative_URI('h://a/b/c/d', './/e') 
'h://a/b/c//e' But when interpreted relative to f:/d, we have a problem. 
resolve_relative_URI('f:/d', './/e') 
'f://e' Here e has been erroneously interpreted as an authority. 
build_URI('f', None, '//e', None, None) should ensure that "/." is prepended to path. 
In the second case, the computation of a relative URI might attempt the following construction: build_URI(None, None, 'this:that', None, None) yielding "this:that" rather than "./this:that" as mentioned at the end of section 4.2 For example, uripath.py exhibits this behaviour. 
refTo('h://a/b/c/d', 'h://a/b/c/this:that') 
'this:that' With only slight modifications to 5.3, these ambiguities of URI construction can be avoided. 
if defined(scheme) then append scheme to result; append ":" to result; endif; if defined(authority) then append "//" to result; append authority to result; endif; if defined(path) then if defined(authority) then if path is neither empty nor begins with "/" then error('an absolute or empty path is required') endif elsif path begins "//" then append "/." to result elsif not defined(scheme) and the first path segment contains ":" then append "./" to result endif; append path to result else error('undefined path') endif; if defined(query) then append "?" to result; append query to result; endif; if defined(fragment) then append "#" to result; append fragment to result; endif; return result; 
