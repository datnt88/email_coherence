This is contrary to one of Dave Solo's earlier design principles. 
The main thing I'm pointing out is that if we remove this invariance, then we must also allow Transforms to vary. 
A scenario communicated to us by Rich Himes is as follows: Use XML file with data enveloped to deliver signed data to desktop. 
Once on desktop, switch data to residing on desktop, and change URI to point to that data, then remove the copy of the data from the XML file (making it much smaller), and store the detached signature for possible later use. 
And, to underline what John is implying, the data transform is no longer base64, but native, so the transform and the location both change. 
Unfortunately, the digest value needs to be signed or there is no security, so we must sign ObjectReference. 
So we either sign the whole thing and live with invariance (using Don's manifest ideas and application processing rules to accomplish the desired effect), or we do something like add Transforms to omit the things that the primary signature shouldn't sign (like Location and/or Transforms in the ObjectReference). 
For reference (19991022): !ATTLIST ObjectReference Id ID #IMPLIED Location CDATA #IMPLIED Type CDATA #IMPLIED !-- 
The values of Location and Type conform to the productions specified by [URI] -- and !ATTLIST Object Id ID #IMPLIED Type CDATA #IMPLIED Encoding CDATA #IMPLIED !-- 
Where type and encoding CDATA conforms to the productions specified by [URI] -- 
We "must" sign the digest method and digest value (and type?) but I believe it 
should not be a requirement for location or transforms to be signed. 
Some 
applications may require these to be signed, so it should be an option. 
Seems to 
me that logically, ObjectReference refers to Object which in turn should allow 
the data format and location to vary without breaking the signature. 
It is precisely the same data semantically, and that is what we should be signing (a 
type of canonicalization). 
Forcing applications to freeze the location will be a 
huge problem in the long run, IMO, even if it isn't a URL. 
Likewise, freezing 
the transform will be a problem for the longevity of the signature in some cases. 
(I just realized that allowing location to change helps resolve the ID 
conflict when documents are merged.) 
One way to do this is for the Transforms element of ObjectReference to specify a 
transform on Object (rather than it's content), to allow exclusion of a location/transform within Object (transform is not currently specified in object). 
I'd like this to be more natural though, by adding an attribute to 
ObjectReference, for example. 
Thanks, Rich 
to 
Not sure I understand that completely, so forgive me if I'm wrong. 
But while the location of the data does not change the digest value of the object to be signed, the transform does, so there is no way of changing transform without the need for changing the signature. 
Now, I understand that 
excluding it doesn't mean we don't know about it. 
But then, I see no point in excluding the transform if we need it, and furthermore I strongly suspect security issues at risk if the transform can be changed. 
Those issues don't come up with the location. 
Concerning location, it might be cleaner to move it out to a manifest, if it needs to be signed, as it clearly is something that can vary, or to exclude it by default, but I am not so sure here. 
Let's look at location and where it's needed. 
If I create a signature, I will most often pack it with the document somehow. 
Here location is not an issue. 
If I create a detached signature, like say a PICS label bureau or similar, I will need the location authenticated anyway as I would be opting for it. 
And if that location is no longer correct, that wouldn't matter. 
I don't see a real case where the location would change and I still would need the same signature (containing the location) verify. 
Can I be in posession of a document and unable to find a signature with that specific location in? 
I can imagine cases like downloading a document and a signature 
to my harddisk, where the signature contains the former location. 
In that case my signature verifying aplication should now that in this case the non-verifying location is no longer correct and tell me. 
Like Outlook tells me that a signature is cryptographically ok but I don't trust it because... similar case to me! 
My conclusion: location is fine as is. 
Peter Dr. Peter Lipp IAIK, TU Graz Inffeldgasse 16a, A-8010 Graz, Austria Web: www.iaik.at 
In response to: 46 
believe it 
We are not signing resources nor their URLs, we are signing a resource's content that is "shown" when the URL (location) is dereferenced. 
To that end, the DigestValue acts as the best location indepedent URI (identifier) one could ask for. 
Consequently, this seems like a reasonable thing to do. 
(But ...) 
Seems to 
allow 
signing (a 
will be a 
freezing 
the ID 
However, it seems to me that we might be adding a fair amount of headache to our specification to address a problem that is not ours to solve. 
I'm of mixed feelings on the topic, but we are not tasked with designing ways of 
referencing things in a "location indepedent globally unique, persistent" 
manner. 
specify a 
to 
You mean an exclude attribute? 
I'd prefer we remain consistent on that point. 
Regardless ... Consider an alternative in the "assertion about assertions" school of philosophy. 
(I touched on some of these issues before in [2]). 
Since an ObjectReference is merely a set of assertions, someone can make an assertion that the content yielded from a new {URI,transforms) is the same as that of an old one. 
ObjectReference asserts the following: Y.a ObjectReference with Identifier/Location "http://1" yields content Y.b content when Transformed yields content' Y.c content' when DigestMethod'd yields DigestValue IF the nature of Y changes then anyone else can make a new statement and sign that (and you can trust that based on your evaluation of that person's trust-worthiness.) 
Z.a ObjectReference with Identifier/Location "http://2" yields content'' Z.b content==content'' 
[2] http://www.w3.org/Signature/Drafts/xml-dsig-design-resources-990723.html Joseph Reagle Jr. Policy Analyst mailto:reagle@w3.org 
XML-Signature Co-Chair http://www.w3.org/People/Reagle/ 
to 
The source data is formatted in two different ways. 
Thus, the transforms must be different to come up with the same hash. 
The case I was concerned about involves a PDF (for example) that is first embedded in the document (for transmission) and then placed in a file. 
In the first case, the transform would be a base64 decode, and the second case would have no transform. 
The resulting transform output in both cases would be the raw PDF, but with different locations and "transforms". 
The simplest example is a changing URL. 
It is common to encounter a web page 
that has been renamed, perhaps because another company bought this one out (changing domain.) 
I could even see this happening with URNs (for political or other reasons, perhaps sloppiness) but it isn't as likely. 
Suppose I have a site that has signed RDF statements about documents on my own site and I decide to change the base location. 
Surely problems such as this will be common. 
Rich 
Aren't we causing the problem that is "not ours to solve" by freezing these values that will likely change? 
I suspect that moving stuff out of the digest 
calculation isn't too much of a headache, but I admit that it would change the structure. 
We could also exclude (/include) these values using attributes or another transform. 
Another possibility is to specify these values (location and transforms) at the same level we specify other attributes (e.g. date-time signed) and optionally include them as objects. 
I think this would be appropriate in some contexts where we need the detailed 
audit trail of location changes, and it would be a nice option. 
It may be a bad 
example, but (an example I just e-mailed, sorry for the dup) suppose I manage a 
site with signed RDF statements about the documents on my site and I "dumbly" 
used URLs to refer to them. 
Gigacorp buys my company and changes the domain to 
www.gigacorp.com. 
I'd prefer to just correct the references than to add thousands of RDF statements correcting each reference. 
Also, in my court filing 
example where I am moving a document (base 64 PDF) from a delivery envelope to a 
native PDF, I don't want the clutter (the standard needs to be less intrusive 
IMO.) 
Thanks, Rich 
The resulting transform output in both cases would be the raw PDF but with different locations and "transforms". 
Understood. 
I know that example, but that happens so rarely that I would consider it appropriate to resign. 
Peter Dr. Peter Lipp IAIK, TU Graz Inffeldgasse 16a, A-8010 Graz, Austria Web: www.iaik.at 
We didn't freeze them, they are frozen by definition: if someone uses a URL, that is an assertion that 
A: the content dereferenced at URL and transformed yields the following DigestValue. 
How do you make an assertion sans location semantics, such that: B: some object when found and transformed yields the following DigestValue ? 
I think this is a valid question. 
We have a requirement to identify objects via URIs. 
The URI need not be a URL. 
(In fact, I think the DigestValue is a good URI). 
We could relax that requirement and remove "Location" from the signature and only provide it as a resolution hint; or we permit a level of indirection pre/post signature creation. 
Pre: ObjectReference uses some mechanism such as a directory, URN, manifest etc. that provides resolution. 
Post: you allow a "redirect" or "cache" statement to be associated with the signature that states "the URI found in ObjectReference resolves to X" 
detailed 
a bad 
manage a 
"dumbly" 
domain to 
filing 
envelope to a 
intrusive 
If the fact that those statements were found at www.gigacorp.com 
was not part of the semantics you wanted to be bound by (and I agree with Phillip that some people do want to assert this) I'd recommend using an IDREF as the URI of the resource that is digested, and the IDREF points to an object in the signature which includes "hints" for finding and resolving content. 
Joseph Reagle Jr. Policy Analyst mailto:reagle@w3.org 
XML-Signature Co-Chair http://www.w3.org/People/Reagle/ 
I believe that we seem to get into a "authenticated" versus "nonauthenticated attributes" kind of discussion. 
Some in this WG wanted to avoid having that feature (and I never got to understand why, besides that it came from lessons learned elsewhere). 
Being able to chose where to put things is a way to solve that even if we don't call it that way, but does this make a difference? 
Peter 
