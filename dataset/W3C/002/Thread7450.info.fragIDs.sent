(This is exactly the same issue as the one Yaron raised earlier, about whether creating a direct reference creates a forest of new references, except expressed in terms of binding.) Suppose you have two existing collections, C1, and C2, where C1 contains C2, and the name bound to C1 is A/, and the name bound to C2 is A/B/, and that collection C2 contains R.html. 
Then we have the following mapping from names to resources URL resource A/ C1 A/B/ C2 A/B/R.html R Now suppose one binds the name X to C2 A/ C1 A/B/ C2 A/B/R.html R X/ C2 
Does this also create a binding for X/R.html to R? 
If Yes, does this impose an unreasonable storage burden on the server? 
(Perhaps not. 
The bindings for the "contents" of collection C2 are stored with C2, not with the name X/) if No, then what does a server do with X/R.html? 
I think it has to--X is supposed to be indistinguishable from A, after all. 
(If X/R.html didn't exist, then what would be the point of creating X?) 
I don't think so. 
It may have some performance penalties (having to dereference the bindings for each parent collection), but i's a tradeoff. 
People who don't like the performance don't have to use bindings. 
|John Stracke | My opinions are my own | S/MIME &amp; HTML OK | |francis@ecal.com|============================================| |Chief Scientist | NT's lack of reliability is only surpassed | |eCal Corp. | by its lack of scalability. 
-- John Kirch | 
Interesting problem. 
To review: we start out with the following collections and resources (no links or aliases) C1 |_ C2 |_ R.html Now we bind A to C1. We get: A -- C1 |_ C2 |_ R.html Now one could ask, what are the members of A? Seems like it would have to be C2 as we traverse the alias A to the resource it is bound to in order to figure out what it is. 
Next we bind A/B to C2. A -- C1 A/B -- |_ C2 |_ R.html I'm not sure what this means. 
In what context is A/B bound to C2? Or is it bound to C1/C2? 
What is C2 by itself other than a member of C1? If I ask what are the members of A again, what do I get? 
C2? B? C2 and B? In other words, creating aliases must be done in the context of collection semantics. 
We could treat A/B as an alias, not a path name containing two entries. 
Then A still contains C2, and A/B contains R.html. 
This looks a little funny though because unless you know A/B is an alias bound to something, you don't get the expected semantics i.e., that A contains B. I think BIND must be done in the context of a parent collection, just like PUT of MKCOL. 
So binding A/B to C2 would have to enter the alias B as a member of C1. 
Now C1 contains C2 and B where B is an alias of C2. 
So C1 contains two URLs referencing the same resource. 
Finally, introduce another alias for C2, X A -- C1 A/B, X -- |_ C2 |_ R.html So the members of X are R.html. 
I don't think there is a binding from X/R.html to R.html, only a binding from X to C1/C2. 
When resolving the binding we get C2 which has member R.html making X appear to contain R.html. 
"Jim Davis" jdavis@coursenet.com on 04/13/99 02:05:30 PM Subject: BIND forest question (This is exactly the same issue as the one Yaron raised earlier, about whether creating a direct reference creates a forest of new references, except expressed in terms of binding.) Suppose you have two existing collections, C1, and C2, where C1 contains C2, and the name bound to C1 is A/, and the name bound to C2 is A/B/, and that collection C2 contains R.html. 
Then we have the following mapping from names to resources URL resource A/ C1 A/B/ C2 A/B/R.html R Now suppose one binds the name X to C2 A/ C1 A/B/ C2 A/B/R.html R X/ C2 Does this also create a binding for X/R.html to R? If Yes, does this impose an unreasonable storage burden on the server? 
(Perhaps not. 
The bindings for the "contents" of collection C2 are stored with C2, not with the name X/) if No, then what does a server do with X/R.html? 
From: "Jim Davis" jdavis@coursenet.com 
Suppose you have two existing collections, C1, and C2, where C1 contains C2, and the name bound to C1 is A/, and the name bound to C2 is A/B/, and that collection C2 contains R.html. 
There is a third collection that contains a binding of "A" with C1. Let's call this collection C3. 
This also needs a mapping, so suppose the server maps "/" to C3. 
This means we have the following mappings: / is mapped to C3 /A/ is mapped to C1 /A/B/ is mapped to C2 /A/B/R.html is mapped to R In C3, "A" is bound to C1. In C1, "B" is bound to C2. In C2, "R.html" is bound to R. So we have 4 mappings and 3 bindings. 
The extra mapping (i.e. of "/") is one that the server does through some magic like a configuration file. 
Then we have the following mapping from names to resources URL resource A/ C1 A/B/ C2 A/B/R.html R Yup (plus the "/" mapping I introduced). 
Now suppose one binds the name X to C2 I assume this binding is in C3. A/ C1 A/B/ C2 A/B/R.html R X/ C2 Yup. 
These are some of the new *mappings*. 
Does this also create a binding for X/R.html to R? No, but it does create a *mapping* from /X/R.html to R. Which is why it is very important to distinguish a *binding* from a *mapping*. 
A single new binding (to a collection) creates a new mapping for *each* member of that collection. 
If you bind / to /foo, you get *lots* of new mappings (an infinite number, in fact), but only one new binding. 
Since mappings are games that a server plays, this is fine (unlike a new bindings, each of which requires a change of state to a collection). 
Cheers, Geoff 
