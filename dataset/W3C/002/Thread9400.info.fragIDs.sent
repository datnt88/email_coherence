+ Does the WG agree that the new specs should descibe a specific Unicode string to be delivered by rdf:parseType="Literal"? 
I must confess I'm not very clear what this means. 
I should clarify (or at least try to :) ). 
The old spec M&amp;S seems to be deliberately vague about precisely which triple is generated by say: My reading is that it permits _:anon rdf:value " foo/ " . 
and :anon rdf:value " foo /foo " . 
and _:anon rdf:value " foo / " . 
and _:anon rdf:value " foo / " . 
etc. In general, for each feature identify as not in the infoset in XML Infoset, I think it is plausible to make examples where the old spec is deliberately ambiguous as to what the triple should be. 
Another example, (less silly) My reading is that it permits _:anon rdf:value " foo a='a' b='b'/ " . 
and _:anon rdf:value " foo b='b' a='a'/ " . 
Either we decide to continue this deliberate ambiguity, or we decide to resolve it. 
This is the question I was raising. 
The old spec is also quiet about XML comments, XML processing instructions, XML namespaces, and references. 
Maybe that was wise, maybe it was foolish. 
Jeremy 
The unicode reference for making comparisons seems to be: which is a W3C Last Call Working Draft whose last call period ended on 23 Feb. 
I haven't yet understood what it says. 
A speed read suggested that when creating RDF data you should normalise your unicode strings. 
(i.e. RDF processors just do a simple comparison). 
I'll try and give a better summary sometime next week. 
Jeremy 
Bill: 
***the purpose of 'should not' is to allow applications some flexibility on dealing with language tags. 
That is, when a literal is equal to another but only one has a lag tag, they can be considered equivalent, which might be sufficient for some applications to make a match. 
Pat: 
I find this odd. 
Why not let them be equal in this case? 
Omitting the language tag presumably means that no language information is being supplied. 
But in that case, there is no need to reject a match with an identical literal which does have a language tag, is there? 
I agreed with Bill earlier, and continue to do so. 
The purpose of defining equality is that in the model theory we are talking about a graph, which is a set of edges. 
We need to be able to tell whether one edge is the same or different from another edge. 
We are not trying to define a processing model for language aware RDF processors. 
I think the graph constructed by _:a rdf:value ("Roma", "it"). 
_:a rdf:value ("Rome", "en"). 
_:a rdf:value ("Rome", "fr"). 
_:a rdf:value ("Roma", _ ). 
is different from _:a rdf:value ("Roma", "it"). 
_:a rdf:value ("Rome", "en"). 
_:a rdf:value ("Rome", "fr"). 
If the literal ( "Roma", _ ), i.e. with no language specified, is the same as ("Roma", "it"), i.e. in italian, then the two graphs are identical. 
Now, suppose we have a language aware graphical information system, and a user whose preferred language is "fr-ca" (French Canadian) comes up. 
I have quite deliberately not tried to specify which label goes onto the big city half way up italy. 
Such an app may be clever enough to decide that "fr" is a better match to "fr-ca" than _ but maybe not. 
A different application, may always read a pair ( "string", _ ) using the currently set default language; while that certainly should not be the default case, I wouldn't want to rule it out as a way of processing RDF. 
Jeremy 
***the purpose of 'should not' is to allow applications some flexibility on dealing with language tags. 
That is, when a literal is equal to another but only one has a lag tag, they can be considered equivalent, which might be sufficient for some applications to make a match. 
I find this odd. 
Why not let them be equal in this case? 
Omitting the language tag presumably means that no language information is being supplied. 
But in that case, there is no need to reject a match with an identical literal which does have a language tag, is there? 
OK, fair enough, and very good points. 
I guess that I have been 
thinking of the lang attribute as a kind of property, which isn't 
appropriate when we are talking about syntactic identity. 
So I withdraw my query and suggest that Bill go back to his original three-(or maybe 2.5 -)valued truth-table. 
Pat IHMC(850)434 8903 home 40 South Alcaniz St.(850)202 4416 office phayes@ai.uwf.edu 
[freed from spam trap -rrs] Date: Fri, 14 Sep 2001 17:35:20 -0400 (EDT) From: Graham Klyne Graham.Klyne@MIMEsweeper.com 
+ Does the WG agree that the new specs should descibe a specific Unicode string to be delivered by rdf:parseType="Literal"? 
I must confess I'm not very clear what this means. 
Thanks, it's much clearer to me. 
At the risk of stating the obvious, I'd like to distinguish: - a literal specified as an attribute value - a literal specified as XML element content conforming to #PCDATA - a literal specified as XML element content conforming to ANY, using rdf:parseType="Literal". 
In the first two cases, I think the resulting literal is a Unicode string 
corresponding to exactly the content of the property element or attribute. 
The third case is less clear to me, and I think is the only case where one may consider the resulting literal string is not necessarily an exact copy of the property element content. 
In this case, recognizing that the content is XML (and is clearly intended to be) I think the minimum requirement to be met is that the Unicode string value of the literal is an equivalent XML element content. 
Again, obvious I think. 
If the model theory didn't seem to require a concept of literal equality 
I'd be inclined to leave it at that. 
At this stage, I see two possibilities: (a) for parseType="Literal", treat the literal as an infoset (not a Unicode string) and define equality based on infoset equivalence, or (b) apply canonicalization to achieve an equivalent result on Unicode strings. 
Now, here's a question, a test-case even: are the following three literals the same?: (a) rdf:Description ex:property="value"/ (b) rdf:Description (c) rdf:Description I think the first two are, but I'm uneasy about the third one as that is signalled as being XML, not just a character string. 
Also, what about: (d) rdf:Description ex:property=" value "/ (e) rdf:Description (f) rdf:Description #g 
+ Does the WG agree that the new specs should descibe a specific Unicode string to be delivered by rdf:parseType="Literal"? 
I must confess I'm not very clear what this means. 
Graham Klyne MIMEsweeper Group Strategic Research http://www.mimesweeper.com 
I thought I would summarise where I had understood we had got to during the teleconference - although noting no decisions were made. 
We should consider pair ( Unicode-String, URI ) as generalisation of ( Unicode-String, lang ). 
There was agreement with the treatment of equality proposed. 
Desire to find wording that is consistent wioth current implementations of rdf:parseType = "Literal" while suggesting canonicalisation as a good idea. 
The main points in the e-mail still outstanding are from Graham. 
Graham: 
IMO, we should say this explicitly, and explicitly prohibit whitespace trimming. 
[ ... snip ... in the third case ... ] Graham again: 
My reading of the WG was that there wasn't a lot of support for option (a) and I am currently not seeing exploring it as part of the action 2001-09-07#5. 
If the WG is unhappy with whatever Bill and I come up with, we may wish to review that. 
Jeremy 
Jeremy, please can you explain why we need f*. 
Why not just f? 
Brian 
Out of context that could be misinterpreted :-). 
The argument, which is not bullet-proof, goes like this. 
For general purpose applications our analysis suggests f, this is hence our recommendation. 
However, we do not wish to tie the hands of application developers who have specific linguistic needs. 
Thus the f* can be read as true by an application developer who may have a strong default to some given language. 
e.g. a small company developing tools specifically for the US Hispanic market may have a default language tag value of "es-US" (I think that's the right one). 
Then any RDF input which doesn't say it isn't is then interpreted as "es-US". 
e.g. in the same scenario, the software tool might need to have a small footprint database and when an RDF file is loaded irrelevant triples are immediately discarded. 
These are distinguished by not having language tag "es-US". 
This does seem to give real advantage for f* in this scenario. 
I don't find this argument convincing; but conversely I am not sufficiently persuaded that it is the wrong way to go to want to prohibit it. 
In many ways my argument that we are talking about the syntactic equivalence of terms rather than a language processing model rather goes against this; &amp; the use of xml:lang="es-US" on the rdf:RDF tag addresses the default language issue. 
A further point, is that in M&amp;S xml:lang processing is optional. 
f* is hence justified by backward compatibility. 
The * in f* is the difference between SHOULD and MUST. 
Bill, do you have anything to add here? 
Jeremy 
I suppose I think of this a bit differently. 
The way I see it we are discussing two things here: 1. when two literals are equal from the point of view of the model theory 2. the matching algorithm an application might use when it does a query or other operation on an RDF model The inclusion of f* mixes these up. 
As I see it, the specs we are writing define equality for the model theory. 
We are not defining application behaviour. 
In which case all f* are actually f. 
That is of course, unless we want to and can persuade Pat to move to a logic which distinguishes between 'should be' and 'must be'. 
(only joking, Pat :) 
An application may choose any matching that is appropriate for that application; I'm told that Geordie's can have a good guess at what some Norwegian means, but I don't think we should build that sort of thing into our specs. 
Brian 
Well, oddly enough, I did once do some work on three-valued logics, and was thinking about that when commenting on the f*s. 
But I now think that what that "truth-table" is about is syntactic identity, not equality (ie same referent). 
So the f*'s are OK as far as the MT 
is concerned: they basically give some wiggle-room for what counts as the 'same' literal expression. 
The MT accepts whatever answer is used, and applies itself to the result. 
In an ideal world, one would hope that if two expressions were in the f* category then a processor that decided they were different expression (members of XL) might at least have the good grace to say that they *meant* the same thing (mapped to the same member of LV). 
If that isn't the case then the MT might give different truthvalues for the same expression depending how its literals are parsed; but I guess that seems OK to me, under the circumstances. 
Either way, the MT doesn't break. 
If we were to decide that the lang attribute is a genuine rdf 
property of something (of what, by the way?) rather than part of the 
syntax, then I might have to reconsider. 
Pat 
IHMC(850)434 8903 home 40 South Alcaniz St.(850)202 4416 office phayes@ai.uwf.edu 
I so love that whooshing sound as something passes completely over my head :( 
I'm not sure what is meant by syntactic identity, and I'm not sure why I should care about it. 
The truth table shows (s,_)=(s,t) as f*. 
The character strings "(s,_)" and "(s,t)" are clearly different, so that can't be what is meant by syntactic identity. 
If (s,_) could be equal to (s,t), then presumably it could also be equal to (s,w) where w != t. 
Does that mean we can conclude 
that (s,w)=(s,t) - not according to the truth table. 
Are we be dealing with an '=' operator which is not transitive? 
Maybe (s,_) can equal (s,t) or (s,w) but not both at the same time. 
Does (s,_) denote exists(x): (s,x) ? 
In my naive view of the world, the literal denoted by ("foo", "http:/lang/en") is not equal to ("foo", _), just the same as the pair (1,2) is not equal to (1,3). 
What is the value in making this any more complicated? 
I'm expecting when some a bunch of rdf/xml or n-triples is read that we can be definitive about the number of unique triples in the graph that results. 
It worries met that f* will cause me to lose that property. 
I think I'm just confused. 
Brian 
No, its easy. 
Robin Hayes = the youngest son of Pat Hayes, but "Robin Hayes" =!= "the youngest son of Pat Hayes" since the latter has more letters in it. 
Equality is same denotation (maybe different expressions), syntactic identity is same expression. 
Ah no, wait a minute. 
That is, I now understand, the old-fashioned wimpy WYSITLI (...is the lexical item) view of syntactic identity. 
That is the view that led me to say a while ago that a literal mustn't be the same character string as a URI, since otherwise you wouldn't know if it was a literal or not. 
But I now gather that there are other ways to ensure that something is a literal over and above its mere *appearance*. 
So Im assuming that the new XML-savvy syntax experts have got some criterion for saying whether or not two syntactic thingies are supposed to be considered 'the same' in the logical syntax, and I will take the MT from there. 
Well, maybe, but not both at once. 
Ah, you were ahead of me. 
No no, that would be in the actual logic. 
But we are talking syntax here, so unless you want to quantify over parts of lexical items (did someone say "reify" ??) then you just don't get into questions like this. 
Its more like asking whether or not 'foo' is considered the same as 'Foo'. 
Well, see Jeremy's earlier message. 
I have no opinion on this issue, to be honest, but I just wanted to make clear that the MT doesn't *require* that all those f*s have to be fs. 
Ah, that is a good point. 
It will, indeed, since the number of nodes will change since they have to have a lexically unique labelling. 
Well, if its any consolation, I have a headache. 
Pat IHMC(850)434 8903 home 40 South Alcaniz St.(850)202 4416 office phayes@ai.uwf.edu 
