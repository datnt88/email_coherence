Hi Merlin, I have a problem to verify your signature.xml from 
merlin-iaikTests-two.tar.gz which was for testing exclusive c14n: The first Reference (digest input in c14n-0.xml) 
seems to be wrong. 
The others can be verified. 
It looks like this (indentation added by me): - c14n-0.xml ----------------------- Parent xml:foo="bar" xml:fool="barbar" xml:lang="en" xml:space="default" GrandChild xml:foo="barbarossa" xml:fool="barbar" xml:lang="ge" xml:space="preserve" /GrandChild This reference was simply the XPath transform (and implicit inclusive c14n omitting comments). 
What I see is that both the Parent and the GrandChild have a xml:fool="barbar" attribute while the GrandChild shouldn't. 
Regards, Christian 
Hi Christian, This is a feature of the c14n spec; see the second paragraph of 2.4: The processing of an element node E MUST be modified slightly when an XPath node-set is given as input and the element's parent is omitted from the node-set. 
The method for processing the attribute axis of an 
element E in the node-set is enhanced. 
All element nodes along E's ancestor axis are examined for nearest occurrences of attributes in the xml namespace, such as xml:lang and xml:space (whether or not they are in the node-set). 
From this list of attributes, remove any that are in E's attribute axis (whether or not they are in the node-set). 
Then, lexicographically merge this attribute list with the nodes of E's attribute axis that are in the node-set. 
The result of visiting the attribute axis is computed by processing the attribute nodes in this merged attribute list. 
This probably isn't aesthetically ideal; however, it doesn't cause any problems. 
Merlin r/geuer-pollmann@nue.et-inf.uni-siegen.de/2002.05.23/14:45:23 
The information contained in this message is confidential and is intended for the addressee(s) only. 
If you have received this message in error or there are any problems please notify the originator immediately. 
The unauthorised use, disclosure, copying or alteration of this message is strictly forbidden. 
Baltimore Technologies plc will not be liable for direct, special, indirect or consequential damages arising from alteration of the contents of this message by a third party or as a result of any virus being passed on. 
This footnote confirms that this email message has been swept for Content Security threats, including computer viruses. 
Hi Merlin, OK, I understood the writing. 
But now a question. 
Given the following 
document. 
The document subset is formed of the C and E element (//C | //E). 
Is the result after c14n this one? 
I read the c14n spec so: 
That's really strange. 
Intuitively, I'd guessed: Christian --On Donnerstag, 23. 
Mai 2002 14:24 +0100 merlin merlin@baltimore.ie 
Hi Christian, 
I believe you're right. 
I think it's just a small oversight in the spec that we'll have to live with. 
Exclusive c14n doesn't seem to have this feature. 
Merlin r/geuer-pollmann@nue.et-inf.uni-siegen.de/2002.05.23/16:10:27 
The information contained in this message is confidential and is intended for the addressee(s) only. 
If you have received this message in error or there are any problems please notify the originator immediately. 
The unauthorised use, disclosure, copying or alteration of this message is strictly forbidden. 
Baltimore Technologies plc will not be liable for direct, special, indirect or consequential damages arising from alteration of the contents of this message by a third party or as a result of any virus being passed on. 
This footnote confirms that this email message has been swept for Content Security threats, including computer viruses. 
Hi Merlin, No, that can't be. 
That's strange. 
For instance, the exclusive c14n spec 
[1] tells me that subset c14n by selecting elem2 in this document n0:local xmlns:n0="foo:bar" xmlns:n3="ftp://example.org" 
n1:elem2 xmlns:n1="http://example.net" xml:lang="en" results in this: n1:elem2 xmlns:n0="foo:bar" xmlns:n1="http://example.net" xmlns:n3="ftp://example.org" xml:lang="en" Given the interpretation below, the xml:lang="en" would have to be also in the n3:stuff element. 
And it isn't. 
So I would (again) say that the first reference of merlin-iaikTests-two.tar.gz is wrong. 
Christian 
[1] http://www.w3.org/Signature/Drafts/xml-exc-c14n --On Donnerstag, 23. 
Mai 2002 15:23 +0100 merlin merlin@baltimore.ie 
Right, I think this is the same bug (the spec is clear, just counter-intuitive so implemented incorrectly) I had to correct last month. 
[1] However, I also discovered a bug from Gregor's example 1 [a]. 
Presently, c14n.py does the following: 1. takes any xml_attrs (e.g., xml:lang) from previous recursions not rendered and adds them to local xml_attrs. 
2. if the element we are processing is in the subset, it renders the accumulated xml_attrs as part of that element and and resets xml_attrs=[] 3. it recurses. 
This has the effect of rendering all XML attributes that are "in affect" since the last ancestor was rendered. 
Sounds sensible, but it's not correct according to the the spec [b]. 
To fix this, I think we'd have to test whether the immediate parent was in the nodeset and keep a dictionary (instead of a list) of *all* ancestors' xml:foo attributes (not just since the nearest rendered one), with the *nearest* value. 
(Moving from a list to a dictionary is akin to what I did for the namespace bug.) This bug exists in c14n, not exc-c14n. 
Hi Christian, 
I can't speak authoratitively to the specific test and example in Merlin's set, but on the c14n and exc-c14n front I can run the examples... xmlsec-python test_c14n.py 
-e -x "(//. 
| //@* | //namespace::*)[ancestor-or-self::n1:elem2]" -n "n1 http://example.net" 
-i foo.xml Normal c14n is: /xmlsec-python test_c14n.py 
-x "(//. 
| //@* | //namespace::*)[ancestor-or-self::n1:elem2]" -n "n1 http://example.net" 
-i foo.xml n1:elem2 xmlns:n0="foo:bar" xmlns:n1="http://example.net" xmlns:n3="ftp://example.org" xml:lang="en" xml:lang does not appear in n3 in either case. 
In the exc-c14n: you don't bother with any xml:foo attribute that aren't utilized in that immediate element in the source instance; in c14n you only look for ancestor xml:foo attributes if the immediate element's parent element is omitted from the selection. 
Have you tried interoping with Gregor's examples yet? 
He included a good test of this stuff. 
Hi Merlin, hi Joseph, 
I guess, NOW I got it. 
First of all, I can verify Merlin's signature now. 
Just to check that I understood it right: If I c14nize a document subset, I do only have to make this weird xml:* copying magic if the current element is an "orphan" node (to use this exclc14n lingo term), i.e. if the parent of the element is not in the document subset. 
If the parent of the current element IS in the document subset, I do NOT do the copying of all xml:* attrs, right? 
Joseph, please do not include the geuerp-iaikTests-one.zip from my former mail, it's wrong. 
I don't post a geuerp-iaikTests-two.zip because it does the same things which are in Merlins example. 
Christian --On Donnerstag, 23. 
Mai 2002 14:24 +0100 merlin merlin@baltimore.ie 
Yes, *and* when you do copy all the xml:* from the ancestors because of a missing parent element you go *all* the way up to the root, not just up to the next ancestor element in the subset. 
Counter-intuitive but the spec is clear once you get over your intuitions -- I had the same problem! 
[1] [1] http://mail.python.org/pipermail/xml-sig/2002-April/007665.html 
First, here is my example on c14n and exclC14n. 
Maybe others can validate? 
Thanks. 
(secret key for hmac is six octets of "secret"). 
This weird behaviour of c14n of document subsets leads to a very strange result. 
Till today, my understanding of c14n was that given some input 'X', the c14n algorithm can be applied multiple times without changing the result. 
But now, I see that 1.) Given a document subset 'X' with a form that the above rule comes to play. 
2.) Then we see that c14n(X) != c14n(c14n(x)) I included a sample for this (the last three references) in the interop. 
Regards, Christian 
Hi Christian, There are at least two problems I see with your c14n: Your c14n is: 1) Your XPath does not include any nodes from the namespace axis, so xmlns:ds="http://www.w3.org/2000/09/xmldsig#" should not be emitted. 
You probably want an XPath of this form (I haven't thought much about it): count(ancestor-or-self::included) count(ancestor-or-self::notIncluded[1]/ancestor::included) This will include xml:lang="de" which you may or may not want; tweak as necessary. 
If you want a detailed discussion of the disconnect between the XPath info set concept of the namespace axis and DOM, look back at some of the threads from one or two years ago. 
I know I contributed my confusion to some of them. 
2) xml:lang="de" is not defined in the ancestor axis of the first included element, and is not included in the node set, so should not be emitted. 
While I'm not convinced that there is a requirement that c14n(X) == c14n(c14n(X)) - c14n produces the canonical form of a node set, and the output of c14n is not the same node set as the input, so there is not a claim that the outputs should necessarily be the same - I think in fact that property may hold true. 
Can you send a clearer counterexample in-line, even just in pseudo XML? 
Merlin r/geuer-pollmann@nue.et-inf.uni-siegen.de/2002.05.24/18:29:44 
The information contained in this message is confidential and is intended for the addressee(s) only. 
If you have received this message in error or there are any problems please notify the originator immediately. 
The unauthorised use, disclosure, copying or alteration of this message is strictly forbidden. 
Baltimore Technologies plc will not be liable for direct, special, indirect or consequential damages arising from alteration of the contents of this message by a third party or as a result of any virus being passed on. 
This footnote confirms that this email message has been swept for Content Security threats, including computer viruses. 
The only thing I've seen was something like this: Would it be possible that you create some obfuscated nodesets in a 
signature to have a good test vector? 
I mean canonicalizing a node set which omits xmlns:*, xmlns and xml:* attributes in both element which are part of the node set and elements which are not included in the node set. 
That would be VERY nice. 
In all other test vectors I use for unit testing and interop, I don't have such esoteric node sets. 
It's not that important, just an idea. 
If you take this fragment and you take all nodes but the notIncluded element into the node set: Then Canonical XML produces the following octet stream: If you canonicalize this octet stream again, you get 
That was what I wanted to express with "c14n(node set X) != c14n(c14n(node set X))" But I see that this is not only the case for the xml:* attributes but also leading and trailing whitespace which is outside the "new" document element after c14n. 
Hi Christian, r/geuer-pollmann@nue.et-inf.uni-siegen.de/2002.05.24/21:47:22 
That's probably one of the discussions.. 
Sure, I'll try sending along something. 
That's not correct; repeated xml:* attributes are not suppressed, they are emitted at every element that defines them. 
Whitespace is probably the best example; other examples that (now) come to mind would be canonicalizing multiple disjoint elements, node sets that omit parts of the namespace axis, etc. Merlin 
Hi Merlin, 
Cool, thanks in advance. 
Sorry, even for (inclusive) c14n? 
I mean, the first c14n step takes a node set input and therefore must emit the xml:* attributes each time it the parent is not in the node set. 
But if the resulting octet stream from the 1st c14n is c14nized again, it is parsed into a node set, and this time, all nodes are in the document subset, so as far as I understood the processing, the 2nd xml:* attributes are omitted. 
Kind regards, Christian 
