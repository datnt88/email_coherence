In general, I think WebDAV ties locks to resources. 
I think this is embodied in a few things we take for granted: - DELETE a resource, and its lock goes away. 
- LOCK a URI that doesn't have a resource, and DAV requires you to create one (a LNR). 
However, there's a statement in the spec that flies in the face of that: "A successful MOVE request on a write locked resource MUST NOT move the write lock with the resource. 
" You could justify that exception by saying yes, in general, locks are tied to resources but do not survive moves. 
But does that work?? 
What if you MOVE (or rename!) a collection that has locked or lock-null resources inside it? 
If you follow the logic that locks do not survive moves, then you must: - remove all the locks of all the children, including LNRs - remove the LNRs, now that their locks are gone Does any server follow that behaviour? 
Or are locks in practice preserved on some or all MOVE operations? 
lisa 
The best way to explain the defined MOVE semantics for a LOCK is to say that a LOCK is on a URL, but that it is deleted when the resource mapped to that 
URL is deleted. 
So a MOVE of a collection will delete all locks on URL's for that collection, but that doesn't necessarily remove all locks on the resources in that collection. 
For example, suppose the URL /x/foo.html and /y/bar.html are mapped to the same resource. 
If you LOCK /x/foo.html, and then MOVE /x/foo.html to /z/foo.html, the resource mapped to /z/foo.html is no longer locked. 
If on the other hand, 
you LOCK /z/bar.html and then do the same MOVE, the resource mapped to /z/foo.html 
remains locked. 
Cheers, Geoff In general, I think WebDAV ties locks to resources. 
I think this is 
embodied in a few things we take for granted: - DELETE a resource, and its lock goes away. 
- LOCK a URI that doesn't have a resource, and DAV requires you to create one (a LNR). 
However, there's a statement in the spec that flies in the face of that: "A successful MOVE request on a write locked resource MUST NOT move the write lock with the resource. 
" You could justify that exception by saying yes, in general, locks are tied to resources but do not survive moves. 
But does that work?? 
What if you MOVE (or rename!) a collection that has locked or lock-null resources inside it? 
If you follow the logic that locks do not survive moves, then you must: - remove all the locks of all the children, including LNRs - remove the LNRs, now that their locks are gone Does any server follow that behaviour? 
Or are locks in practice preserved on some or all MOVE operations? 
lisa 
On Behalf Of Clemm, Geoff 
So far I can follow; it's not a bad model. 
I'd append "or moved" to the end; most people will consider this different than "deleted" because we have different methods for MOVE and DELETE. 
I don't follow your example as well (reproduced below) because WebDAV doesn't specifically allow for one resource to be mapped by several URLs. 
Let's keep it simple and assume that a WebDAV system only maps URLs to resources 1:1. 
That means that when a collection containing null resources is moved or is renamed, all the locks in the collection disappear, and the null resources must be cleaned up. 
That seems contrary to what the users would like to see happen; that's the scenario that made me rethink the way this works. 
Lisa Geoff's example: 
From: Lisa Dusseault [mailto:lisa@xythos.com] On Behalf Of Clemm, Geoff 
So far I can follow; it's not a bad model. 
I'd append "or moved" to the end; most people will consider this different than "deleted" because we have different methods for MOVE and DELETE. 
I agree that is worth making explicit to avoid any confusion. 
I don't follow your example as well (reproduced below) because WebDAV doesn't specifically allow for one resource to be mapped by several URLs. 
WebDAV allows for one resource to be mapped to multiple URL's because HTTP specifically allows for one resource to be mapped to multiple URL's. 
In particular, section 9.6 of RFC 2616: "A single resource MAY be identified by many different URIs. 
For example, an article might have a URI for identifying "the current version" which is separate from the URI identifying each particular version." 
Therefore the locking protocol (and the rest of WebDAV) must have well defined behavior in those cases where multiple URL's do identify the same resource. 
Let's keep it simple and assume that a WebDAV system only maps URLs to resources 1:1. 
That's fine, but it is good to keep the multiple mapping scenario in mind for when someone suggests a "simpler" model that does not handle the multiple mapping scenario. 
That means that when a collection containing null resources is 
moved or is renamed, all the locks in the collection disappear, and the null resources must be cleaned up. 
That seems contrary to what the users would like to see happen; that's the scenario that made me rethink the way this works. 
The loss of the locks is inherent in a "lock is on the URL" model. 
The reason the "lock is on the URL" model is superior to the "lock is on the resource" model can be seen by looking at the two cases for moving a locked resource. 
- If the client holding the lock does the move, it can easily lock the destination collection with a new depth lock, and then perform the move (the resources will be captured by the new depth lock). 
- If some other client not holding that lock does the move (if it is a shared lock, for example), there often is no good way for for the client to "find" the resource after it has been moved (since all the client has is a URL and a lock token). 
While we were debating this a while back, several vendors objected to the proposal that we require a server to allow a client to easily find a locked resource by using the lock token (PROPFIND Depth:Infinity on "/" is not considered a good way :-). 
Also, note that the current proposal for LOCK'ing an unmapped resource (i.e. creating a real resource there) would leave those empty resources in place to be captured by the depth lock at the destination. 
Cheers, Geoff 
Well, RFC 2518 Ch. 6 says: "The ability to lock a resource provides a mechanism for serializing access to that resource. 
Using a lock, an authoring client can provide a reasonable guarantuee that another principal will not modify a resource while it is being edited..." This gave me the impression that locks are on a resource and not on one particular URL of that resource. 
I agree that multiple URL and deep locks on collections provide some interesting challenges to define consistent behaviour. 
But I find it a little bit hard to give up the assumption locking resource == locking resource content + properties So, maybe I have misunderstood this thread? 
//Stefan 
From: Stefan Eissing [mailto:stefan.eissing@greenbytes.de] RFC 2518 Ch. 6 says: "The ability to lock a resource provides a mechanism for serializing access to that resource. 
Using a lock, an authoring client can provide a reasonable guarantuee that another principal will not modify a resource while it is being edited..." This gave me the impression that locks are on a resource and not on one particular URL of that resource. 
The purpose of a lock is serializing access to a resource, but that is not incompatible with saying "the lock is on a URI and controls access to the resource mapped to that URI". 
I agree that multiple URL and deep locks on collections provide some interesting challenges to define consistent behaviour. 
But I find it a little bit hard to give up the assumption locking resource == locking resource content + properties So, maybe I have misunderstood this thread? 
You just need to expand your equivalence as follows: locking resource == locking URL == locking resource mapped to that URL. Cheers, Geoff 
