As per my recent posts (sorry for the shotgun effect, I wanted to keep the threads separate), its been suggested that we can have test case A be yes and test case C be no. 
I just wanted to note that there is an interaction between this test case and rdfs:subPropertyOf. 
Consider: _:a dc:title "4th July" . 
_:b dc:date "4th July" . 
[I don't know DC well enough to know whether this is a realistic example, I suspect not so consider this just illustrative] All is reasonably well. 
With appropriate datatype range constraints one of these denotes a string and the other a date. 
Now add a common super property for all the dc properties: dc:property rdf:type rdf:Property . 
dc:title rdfs:subPropertyOf dc:property . 
dc:date rdfs:subPropertyOf dc:property . 
This now entails: _:a dc:property _:l . 
_:b dc:property _:l . 
I assume this is still monotonic, since I haven't actually retracted anything, though it sure feels like changing my mind to me. 
A more extreme form is to postulate the existence of a common super property of all properties, which we have talked about in the past. 
If there were such a thing and the answer to A is yes, then we'd have tidy literals anyway. 
At this point I think I need to hear Pat say, "relax". 
Brian 
This is an additional example of why a property alone cannot clarify whether two string-equal literals denote the same thing. 
This touches upon the "BOOM" examples I provided many months ago regarding the relationship between datatyping, rdfs:subPropertyOf, and query engine bindings. 
One cannot divorce a globally datatyped value from the original statement context within which it was expressed, because then, the proper context for correct interpretation is lost. 
Thus, while it is true that, given the above subproperty relations that a value of either dc:title or dc:date is also a valid value of dc:property, that does not mean that all literal values of dc:property that are string equal denote the same thing. 
Right. 
If we choose untidy literals, the answer to A cannot be yes. 
Thus: A B C D Tidy Y Y Y N Untidy N N N Y 
Relax. (yeah, I know you meant the *other* Pat ;-) Patrick 
My first reaction was, what's the problem?? Technically this is all consistent. 
But thinking about it more, I see that there is something odd about this. 
One would reason as follows: the *reason* why dc:property holds for both literals is different in the two cases, so even though its the same property, the literals aren't being treated the same (assuming that the literals 'mean' the same thing in the superproperty triples as they did in the corresponding subproperty triples), so the common-b-node inference is no more justified in the superproperty case than it was in the subproperty. 
Hmmm, yes, good point. 
Well, after the F2F discussion and subsequently, I think that this compromise idea (with literals being syntactically tidy but semantically untidy) isn't really worth the trouble it causes. 
If literals are going to be semantically untidy then lets have them be syntactically untidy as well, since that keeps everything coherent. 
I think we should stop trying to be clever, and just decide one way or the other: either literals just are string-ish things which denote themselves, or they are genuine names which can denote anything, depending on the datatyping applied to them; and in the latter case, then really should not be syntactically tidy, since different datatyping contexts have to be allowed to attach to distinct literal nodes. 
I myself would prefer the latter, and also to allow literals to be in the subject position, but I gather that this isn't acceptable; so I would vote that we stick to the other simple option and reject implication A. Pat IHMC(850)434 8903 home 40 South Alcaniz St.(850)202 4416 office phayes@ai.uwf.edu 
