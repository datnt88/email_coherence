Dan, would it break your mental model if the above N-triples-like syntax was modified to be: terms: constant (URIs w/fragids) string literals bnodes (existentially quantified variables) statement: term constant term. 
formula: statement* 
If we're talking about triples here where literals are acting as subjects, then we need to base the triples on node identity, right? 
I.e. (presuming nodes with identical uriref labels are "merged") statement = subject predicate object '.' subject = uriref | ( nodeID ':' literal ) | nodeID predicate = uriref object = subject | literal Note that only literal nodes that act as subjects must be specified for nodeID, otherwise, just use the literal. 
Eh? 
Of course, since statements are not themselves reified in 
NTriples, one can't qualify them ;-) Patrick 
...The other proposals (S, DC and oldX=URV) don't need this complication, however, since they can assume tidiness on literal nodes as well as urirefs. 
Can someone please point me to the most concise, prose definition of tidiness as it relates to the graph? 
Thanks, Patrick 
...The other proposals (S, DC and oldX=URV) don't need this complication, however, since they can assume tidiness on literal nodes as well as urirefs. 
Section 0.2, final paragraph. 
#g Graham Klyne MIMEsweeper Group Strategic Research http://www.mimesweeper.com 
...The other proposals (S, DC and oldX=URV) don't need this complication, however, since they can assume tidiness on literal nodes as well as urirefs. 
Sorry, local jargon. 
I invented the term in the MT document, by defining an RDF graph to be 'tidy' if had no duplicated names, so each uriref or literal occurs only on a single node. 
(At that time I was assuming (naively) a U-style treatment of literals. 
) Since then it has also been used to refer to the condition that triples are not duplicated in any graph, for example. 
The reason for having such a term is that forming the simple union of two graphs can produce a non-tidy graph, so one has to get explicit about the tidying process (ie the merging of nodes with the same label to create a tidy merged graph.) 
When we started taking literals more seriously, some ways of treating them (the P(++) ways) require that different occurrences of the same literal may have different meanings, so it is no longer appropriate 
to insist on tidiness for literal nodes. 
In fact, this is one way 
that the P(++) proposals (and I think the X, though I'm not sure) can be distinguished from the U/S/DC proposals, in that the latter will work with graphs that are tidy on literals, while the others will 
not. 
So this decision has consequences even for the graph syntax. 
Hope this helps. 
Pat IHMC(850)434 8903 home 40 South Alcaniz St.(850)202 4416 office phayes@ai.uwf.edu 
From: ext Pat Hayes [mailto:phayes@ai.uwf.edu] 
Sent: 15 November, 2001 20:57 Subject: RE: datatypes and MT (#rdfms-graph) 
...The other proposals (S, DC and oldX=URV) don't need this complication, however, since they can assume 
nodes as well as urirefs. 
That's what I thought it meant, and thus it is equivalent to the "level 1 merge compression" I outline in my X proposal. 
A tidy graph is an X level 1 graph. 
Absolutely. 
And in fact, this is what motivated the URV encoding of typed data literals, so that such values could "participate" in that tidying process, to *substantially* reduce graph real estate, and to make finite a number of potentially infinite levels of anonymous node based qualification. 
My X proposal shows an example of this in the section discussing URVs. 
I had never thought they were expected to participate in tidyness, since they clearly are ambiguous as to value. 
Did the original specs suggest they weren't? 
Is that where the "literals denote strings" view comes from? 
Correct. 
The X proposal expects that each literal occurence is represented by its own node. 
Only nodes with uriref labels are merged. 
Quite so. 
Very much. 
Thanks, Patrick 
