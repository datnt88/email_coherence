Another question, this time about unsupported datatypes. 
In the reference doc, it says: "For unsupported datatypes, lexically identical literals should be considered equal, whereas lexically different literals would not be 
known to be either equal or unequal. 
Unrecognized datatypes should be 
treated in the same way as unsupported datatypes." 
The first half of the sentence would suggest to treat a literal of unknown type as just a string. 
However, I am not entirely sure what is 
expected from a reasoner with respect to the behaviour of "would not be 
known to be either equal or unequal". 
Views? Cheers, G Gary Ng, PhD gary.ng@networkinference.com Senior Software Engineer Network Inference (Holdings) Ltd 
Unknown or unrecognised datatypes are treated as being the lexical form (a string) of some unknown datatype. 
It is obviously the case that, whatever the datatype, identical lexical forms map to the same element of the value space, and can thus be considered equal. 
For non-identical lexical forms, however, it *cannot* be assumed that they do not map to the same element of the value space and are thus unequal. 
E.g., the lexical forms "1.0" and "01.00" would map to the same value (and thus be considered equal) in some datatypes (e.g., decimal), but not in others (e.g., string). 
Ian 
From: Ian Horrocks Sent: 15 July 2003 18:02 Subject: Re: unsupported datatypes 
be 
is 
be 
Yes, I got that. 
But from a practical point of view of handling values from an unsupported datatype within a reasoning tool, this sounds like I can't even implement them as strings because since two different strings would be considered unequal. 
So the question is, how should I implement them? 
Consider the following: hasAValueOf rdf:datatype="someUnsupportedType" XYZ /hasAValueOf hasAValueOf rdf:datatype="someUnsupportedType" ABC /hasAValueOf by the definition, "XYZ" and "ABC" are neither equal nor unequal. 
So what should be the answer to the following question? 
Retrieve all instances of (complementOf(exists hasAValueOf XYZ)) Because we cannot *prove* that XYZ = or != to ABC, thus The answer would be empty. 
Am I correct? 
If I am correct, then this behaviour is the same as if XYZ and ABC are classes/instances. 
So really we can't implement values from unsupported datatypes as strings. 
Correct? 
G 
